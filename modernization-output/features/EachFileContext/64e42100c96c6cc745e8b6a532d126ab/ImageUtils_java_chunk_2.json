{
  "pageContent": "File Path: src/net/jforum/util/image/ImageUtils.java\n\n Original Content: public class ImageUtils\n{\n\tpublic static final int IMAGE_UNKNOWN = -1;\n\tpublic static final int IMAGE_JPEG = 0;\n\tpublic static final int IMAGE_PNG = 1;\n\tpublic static final int IMAGE_GIF = 2;\n\n\t/**\n\t * Resizes an image\n\t * \n\t * @param imgName The image name to resize. Must be the complet path to the file\n\t * @param type int\n\t * @param maxWidth The image's max width\n\t * @param maxHeight The image's max height\n\t * @return A resized <code>BufferedImage</code>\n\t */\n\tpublic static BufferedImage resizeImage(String imgName, int type, int maxWidth, int maxHeight)\n\t{\n\t\ttry {\n\t\t\treturn resizeImage(ImageIO.read(new File(imgName)), type, maxWidth, maxHeight);\n\t\t}\n\t\tcatch (IOException e) {\n\t\t\tthrow new ForumException(e);\n\t\t}\n\t}\n\n\t/**\n\t * Resizes an image.\n\t * \n\t * @param image\n\t *            The image to resize\n\t * @param maxWidth\n\t *            The image's max width\n\t * @param maxHeight\n\t *            The image's max height\n\t * @return A resized <code>BufferedImage</code>\n\t * @param type\n\t *            int\n\t */\n\tpublic static BufferedImage resizeImage(BufferedImage image, int type, int maxWidth, int maxHeight)\n\t{\n\t\tDimension largestDimension = new Dimension(maxWidth, maxHeight);\n\n\t\t// Original size\n\t\tint imageWidth = image.getWidth(null);\n\t\tint imageHeight = image.getHeight(null);\n\n\t\tfloat aspectRatio = (float) imageWidth / imageHeight;\n\n\t\tif (imageWidth > maxWidth || imageHeight > maxHeight) {\n\t\t\tif ((float) largestDimension.width / largestDimension.height > aspectRatio) {\n\t\t\t\tlargestDimension.width = (int) Math.ceil(largestDimension.height * aspectRatio);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlargestDimension.height = (int) Math.ceil(largestDimension.width / aspectRatio);\n\t\t\t}\n\n\t\t\timageWidth = largestDimension.width;\n\t\t\timageHeight = largestDimension.height;\n\t\t}\n\n\t\treturn createHeadlessSmoothBufferedImage(image, type, imageWidth, imageHeight);\n\t}\n\n\t/**\n\t * Saves an image to the disk.\n\t * \n\t * @param image  The image to save\n\t * @param toFileName The filename to use\n\t * @param type The image type. Use <code>ImageUtils.IMAGE_JPEG</code> to save as JPEG images,\n\t *  or <code>ImageUtils.IMAGE_PNG</code> to save as PNG.\n\t * @return <code>false</code> if no appropriate writer is found\n\t */\n\tpublic static boolean saveImage(BufferedImage image, String toFileName, int type)\n\t{\n\t\ttry {\n\t\t\treturn ImageIO.write(image, type == IMAGE_JPEG ? \"jpg\" : \"png\", new File(toFileName));\n\t\t}\n\t\tcatch (IOException e) {\n\t\t\tthrow new ForumException(e);\n\t\t}\n\t}\n\n\t/**\n\t * Compress and save an image to the disk. Currently this method only supports JPEG images.\n\t * \n\t * @param image The image to save\n\t * @param toFileName The filename to use\n\t * @param type The image type. Use <code>ImageUtils.IMAGE_JPEG</code> to save as JPEG images,\n\t * or <code>ImageUtils.IMAGE_PNG</code> to save as PNG.\n\t */\n\tpublic static void saveCompressedImage(BufferedImage image, String toFileName, int type)\n\t{\n\t\ttry {\n\t\t\tif (type == IMAGE_PNG) {\n\t\t\t\tthrow new UnsupportedOperationException(\"PNG compression not implemented\");\n\t\t\t}\n\n\t\t\tIterator iter = ImageIO.getImageWritersByFormatName(\"jpg\");\n\t\t\tImageWriter writer;\n\t\t\twriter = (ImageWriter) iter.next();\n\n\t\t\tImageOutputStream ios = ImageIO.createImageOutputStream(new File(toFileName));\n\t\t\twriter.setOutput(ios);\n\n\t\t\tImageWriteParam iwparam = new JPEGImageWriteParam(Locale.getDefault());\n\n\t\t\tiwparam.setCompressionMode(ImageWriteParam.MODE_EXPLICIT);\n\t\t\tiwparam.setCompressionQuality(0.7F);\n\n\t\t\twriter.write(null, new IIOImage(image, null, null), iwparam);\n\n\t\t\tios.flush();\n\t\t\twriter.dispose();\n\t\t\tios.close();\n\t\t}\n\t\tcatch (IOException e) {\n\t\t\tthrow new ForumException(e);\n\t\t}\n\t}\n\n\t/**\n\t * Creates a <code>BufferedImage</code> from an <code>Image</code>. This method can\n\t * function on a completely headless system. This especially includes Linux and Unix systems\n\t * that do not have the X11 libraries installed, which are required for the AWT subsystem to\n\t * operate. This method uses nearest neighbor approximation, so it's quite fast. Unfortunately,\n\t * the result is nowhere near as nice looking as the createHeadlessSmoothBufferedImage method.\n\t * \n\t * @param image  The image to convert\n\t * @param w The desired image width\n\t * @param h The desired image height\n\t * @return The converted image\n\t * @param type int\n\t */\n\tpublic static BufferedImage createHeadlessBufferedImage(BufferedImage image, int type, int width, int height)\n\t{\n\t\tif (type == ImageUtils.IMAGE_PNG && hasAlpha(image)) {\n\t\t\ttype = BufferedImage.TYPE_INT_ARGB;\n\t\t}\n\t\telse {\n\t\t\ttype = BufferedImage.TYPE_INT_RGB;\n\t\t}\n\n\t\tBufferedImage bi = new BufferedImage(width, height, type);\n\n\t\tfor (int y = 0; y < height; y++) {\n\t\t\tfor (int x = 0; x < width; x++) {\n\t\t\t\tbi.setRGB(x, y, image.getRGB(x * image.getWidth() / width, y * image.getHeight() / height));\n\t\t\t}\n\t\t}\n\n\t\treturn bi;\n\t}\n\n\t/**\n\t * Creates a <code>BufferedImage</code> from an <code>Image</code>. This method can\n\t * function on a completely headless system. This especially includes Linux and Unix systems\n\t * that do not have the X11 libraries installed, which are required for the AWT subsystem to\n\t * operate. The resulting image will be smoothly scaled using bilinear filtering.\n\t * \n\t * @param source The image to convert\n\t * @param w The desired image width\n\t * @param h The desired image height\n\t * @return The converted image\n\t * @param type  int\n\t */\n\tpublic static BufferedImage createHeadlessSmoothBufferedImage(BufferedImage source, int type, int width, int height)\n\t{\n\t\tif (type == ImageUtils.IMAGE_PNG && hasAlpha(source)) {\n\t\t\ttype = BufferedImage.TYPE_INT_ARGB;\n\t\t}\n\t\telse {\n\t\t\ttype = BufferedImage.TYPE_INT_RGB;\n\t\t}\n\n\t\tBufferedImage dest = new BufferedImage(width, height, type);\n\n\t\tint sourcex;\n\t\tint sourcey;\n\n\t\tdouble scalex = (double) width / source.getWidth();\n\t\tdouble scaley = (double) height / source.getHeight();\n\n\t\tint x1;\n\t\tint y1;\n\n\t\tdouble xdiff;\n\t\tdouble ydiff;\n\n\t\tint rgb;\n\t\tint rgb1;\n\t\tint rgb2;\n\n\t\tfor (int y = 0; y < height; y++) {\n\t\t\tsourcey = y * source.getHeight() / dest.getHeight();\n\t\t\tydiff = scale(y, scaley) - sourcey;\n\n\t\t\tfor (int x = 0; x < width; x++) {\n\t\t\t\tsourcex = x * source.getWidth() / dest.getWidth();\n\t\t\t\txdiff = scale(x, scalex) - sourcex;\n\n\t\t\t\tx1 = Math.min(source.getWidth() - 1, sourcex + 1);\n\t\t\t\ty1 = Math.min(source.getHeight() - 1, sourcey + 1);\n\n\t\t\t\trgb1 = getRGBInterpolation(source.getRGB(sourcex, sourcey), source.getRGB(x1, sourcey), xdiff);\n\t\t\t\trgb2 = getRGBInterpolation(source.getRGB(sourcex, y1), source.getRGB(x1, y1), xdiff);\n\n\t\t\t\trgb = getRGBInterpolation(rgb1, rgb2, ydiff);\n\n\t\t\t\tdest.setRGB(x, y, rgb);\n\t\t\t}\n\t\t}\n\n\t\treturn dest;\n\t}\n\n\tprivate static double scale(int point, double scale)\n\t{\n\t\treturn point / scale;\n\t}\n\n\tprivate static int getRGBInterpolation(int value1, int value2, double distance)\n\t{\n\t\tint alpha1 = (value1 & 0xFF000000) >>> 24;\n\t\tint red1 = (value1 & 0x00FF0000) >> 16;\n\t\tint green1 = (value1 & 0x0000FF00) >> 8;\n\t\tint blue1 = (value1 & 0x000000FF);\n\n\t\tint alpha2 = (value2 & 0xFF000000) >>> 24;\n\t\tint red2 = (value2 & 0x00FF0000) >> 16;\n\t\tint green2 = (value2 & 0x0000FF00) >> 8;\n\t\tint blue2 = (value2 & 0x000000FF);\n\n\t\tint rgb = ((int) (alpha1 * (1.0 - distance) + alpha2 * distance) << 24)\n\t\t\t| ((int) (red1 * (1.0 - distance) + red2 * distance) << 16)\n\t\t\t| ((int) (green1 * (1.0 - distance) + green2 * distance) << 8)\n\t\t\t| (int) (blue1 * (1.0 - distance) + blue2 * distance);\n\n\t\treturn rgb;\n\t}\n\n\t/**\n\t * Determines if the image has transparent pixels.\n\t * \n\t * @param image The image to check for transparent pixel.s\n\t * @return <code>true</code> of <code>false</code>, according to the result\n\t */\n\tpublic static boolean hasAlpha(Image image)\n\t{\n\t\ttry {\n\t\t\tPixelGrabber pg = new PixelGrabber(image, 0, 0, 1, 1, false);\n\t\t\tpg.grabPixels();\n\n\t\t\treturn pg.getColorModel().hasAlpha();\n\t\t}\n\t\tcatch (InterruptedException e) {\n\t\t\treturn false;\n\t\t}\n\t}\n}",
  "metadata": {
    "fileId": "ImageUtils_java_chunk_2",
    "fileName": "ImageUtils.java",
    "filePath": "src/net/jforum/util/image/ImageUtils.java"
  }
}