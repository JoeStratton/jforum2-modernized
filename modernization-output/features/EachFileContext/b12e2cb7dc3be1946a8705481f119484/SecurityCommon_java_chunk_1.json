{
  "pageContent": "File Path: src/net/jforum/dao/generic/security/SecurityCommon.java\n\n Original Content: /*\n * Copyright (c) JForum Team\n * All rights reserved.\n * \n * Redistribution and use in source and binary forms, \n * with or without modification, are permitted provided \n * that the following conditions are met:\n * \n * 1) Redistributions of source code must retain the above \n * copyright notice, this list of conditions and the \n * following  disclaimer.\n * 2)  Redistributions in binary form must reproduce the \n * above copyright notice, this list of conditions and \n * the following disclaimer in the documentation and/or \n * other materials provided with the distribution.\n * 3) Neither the name of \"Rafael Steil\" nor \n * the names of its contributors may be used to endorse \n * or promote products derived from this software without \n * specific prior written permission.\n * \n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT \n * HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY \n * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, \n * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF \n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR \n * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL \n * THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE \n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, \n * EXEMPLARY, OR CONSEQUENTIAL DAMAGES \n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF \n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, \n * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER \n * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER \n * IN CONTRACT, STRICT LIABILITY, OR TORT \n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN \n * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF \n * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE\n * \n * This file creation date: 19/03/2004 - 18:45:54\n * The JForum Project\n * http://www.jforum.net\n */\npackage net.jforum.dao.generic.security;\n\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\nimport java.util.Iterator;\n\nimport net.jforum.JForumExecutionContext;\nimport net.jforum.exceptions.DatabaseException;\nimport net.jforum.security.PermissionControl;\nimport net.jforum.security.Role;\nimport net.jforum.security.RoleCollection;\nimport net.jforum.security.RoleValue;\nimport net.jforum.security.RoleValueCollection;\nimport net.jforum.util.DbUtils;\nimport net.jforum.util.preferences.SystemGlobals;\n\nimport org.apache.commons.lang.StringUtils;\n\n/**\n * @author Rafael Steil\n * @version $Id: SecurityCommon.java,v 1.13 2007/08/16 13:07:34 rafaelsteil Exp $\n */\npublic class SecurityCommon\n{\n\t/**\n\t * Execute the <i>add role</i> thing. As the SQL statement to insert user and group roles are\n\t * diferent, they cannot be manipuled with a 'generic' statement, and is for this reason that\n\t * <code>addRole</code> method is marked abstract. <br>\n\t * The only job the <code>addRole</code> method should do is to get the correct SQL statement\n\t * for each case - user or group - and the repass it to this method, who then do the job for us.\n\t * \n\t * @param sql The SQL statement to be executed.\n\t * @param id The ID do insert. May be user's or group's id, depending of the situation ( the caller )\n\t * @param role The role name to insert\n\t * @param roleValues A <code>RoleValueCollection</code> collection containing the role values to\n\t * insert. If none is wanted, just pass null as argument.\n\t * @param supportAutoGeneratedKeys Set to <code>true</code> if <i>Statement.RETURN_GENERATED_KEYS</i> is supported\n\t * by the Driver, or <code>false</code> if not.\n\t * @param autoKeysQuery String\n\t */\n\tpublic static void executeAddRole(String sql, int id, Role role, RoleValueCollection roleValues,\n\t\t\tboolean supportAutoGeneratedKeys, String autoKeysQuery)\n\t{\n\t\tPreparedStatement p = null;\n\t\tResultSet rs = null;\n\t\t\n\t\ttry {\n\t\t\tif (supportAutoGeneratedKeys) {\n\t\t\t\tp = JForumExecutionContext.getConnection().prepareStatement(sql, Statement.RETURN_GENERATED_KEYS);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tp = JForumExecutionContext.getConnection().prepareStatement(sql);\n\t\t\t}\n\n\t\t\tp.setInt(1, id);\n\t\t\tp.setString(2, role.getName());\n\n\t\t\tp.executeUpdate();\n\n\t\t\tif (roleValues != null) {\n\t\t\t\tint roleId = -1;\n\n\t\t\t\tif (supportAutoGeneratedKeys) {\n\t\t\t\t\trs = p.getGeneratedKeys();\n\t\t\t\t\trs.next();\n\t\t\t\t\troleId = rs.getInt(1);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tp = JForumExecutionContext.getConnection().prepareStatement(autoKeysQuery);\n\t\t\t\t\trs = p.executeQuery();\n\t\t\t\t\tif (rs.next()) {\n\t\t\t\t\t\troleId = rs.getInt(1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trs.close();\n\t\t\t\trs = null;\n\t\t\t\tp.close();\n\t\t\t\tp = null;\n\n\t\t\t\tif (roleId == -1) {\n\t\t\t\t\tthrow new SQLException(\"Could not obtain the latest role id\");\n\t\t\t\t}\n\n\t\t\t\tp = JForumExecutionContext.getConnection().prepareStatement(\n\t\t\t\t\t\tSystemGlobals.getSql(\"PermissionControl.addRoleValues\"));\n\n\t\t\t\tfor (Iterator iter = roleValues.iterator(); iter.hasNext();) {\n\t\t\t\t\tRoleValue rv = (RoleValue) iter.next();\n\n\t\t\t\t\tp.setInt(1, roleId);\n\t\t\t\t\tp.setString(2, rv.getValue());\n\n\t\t\t\t\tp.executeUpdate();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow new DatabaseException(e);\n\t\t}\n\t\tfinally {\n\t\t\tDbUtils.close(rs, p);\n\t\t}\n\t}\n\n\t/**\n\t * See {@link PermissionControl#executeAddRole(String, int, String, RoleValueCollection)} for\n\t * explanation about this method. The working way is the same.\n\t * \n\t * @param rs The ResultSet containing the data to be fetched. This method does not\n\t * free the resultset after it finished using it, so it's responsability of the \n\t * caller to do such task.\n\t * @return A <code>RoleCollection</code> collection with the roles processed.\n\t */\n\tpublic static RoleCollection loadRoles(ResultSet rs)\n\t{\n\t\tRoleCollection rc = new RoleCollection();\n\n\t\ttry {\n\t\t\tRole r = null;\n\t\t\tString lastName = null;\n\n\t\t\twhile (rs.next()) {\n\t\t\t\tString currentName = rs.getString(\"name\");\n\t\t\t\t\n\t\t\t\tif (!currentName.equals(lastName)) {\n\t\t\t\t\tif (r != null) {\n\t\t\t\t\t\trc.add(r);\n\t\t\t\t\t}\n\n\t\t\t\t\tr = new Role();\n\t\t\t\t\tr.setName(rs.getString(\"name\"));\n\n\t\t\t\t\tlastName = currentName;\n\t\t\t\t}\n\n\t\t\t\tString roleValue = rs.getString(\"role_value\");\n\n\t\t\t\tif (!rs.wasNull() && StringUtils.isNotBlank(roleValue)) {\n\t\t\t\t\tr.getValues().add(new RoleValue(roleValue));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (r != null) {\n\t\t\t\trc.add(r);\n\t\t\t}\n\n\t\t\treturn rc;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow new DatabaseException(e);\n\t\t}\n\t}\n\t\n\tpublic static String groupIdAsString(int[] ids)\n\t{\n\t\tStringBuffer sb = new StringBuffer();\n\t\t\n\t\tfor (int i = 0; i < ids.length - 1; i++) {\n\t\t\tsb.append(ids[i]).append(',');\n\t\t}\n\t\t\n\t\tif (ids.length > 0) {\n\t\t\tsb.append(ids[ids.length - 1]);\t\t\t\n\t\t}\n\t\t\n\t\treturn sb.toString();\n\t}\n}",
  "metadata": {
    "fileId": "SecurityCommon_java_chunk_1",
    "fileName": "SecurityCommon.java",
    "filePath": "src/net/jforum/dao/generic/security/SecurityCommon.java"
  }
}