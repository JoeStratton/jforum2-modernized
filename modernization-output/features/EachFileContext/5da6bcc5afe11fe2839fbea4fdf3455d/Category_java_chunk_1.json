{
  "pageContent": "File Path: src/net/jforum/entities/Category.java\n\n Original Content: /*\n * Copyright (c) JForum Team\n * All rights reserved.\n * \n * Redistribution and use in source and binary forms, \n * with or without modification, are permitted provided \n * that the following conditions are met:\n * \n * 1) Redistributions of source code must retain the above \n * copyright notice, this list of conditions and the \n * following  disclaimer.\n * 2)  Redistributions in binary form must reproduce the \n * above copyright notice, this list of conditions and \n * the following disclaimer in the documentation and/or \n * other materials provided with the distribution.\n * 3) Neither the name of \"Rafael Steil\" nor \n * the names of its contributors may be used to endorse \n * or promote products derived from this software without \n * specific prior written permission.\n * \n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT \n * HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY \n * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, \n * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF \n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR \n * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL \n * THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE \n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, \n * EXEMPLARY, OR CONSEQUENTIAL DAMAGES \n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF \n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, \n * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER \n * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER \n * IN CONTRACT, STRICT LIABILITY, OR TORT \n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN \n * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF \n * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE\n * \n * This file creating date: Feb 17, 2003 / 10:47:29 PM\n * The JForum Project\n * http://www.jforum.net\n */\npackage net.jforum.entities;\n\nimport java.io.Serializable;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.TreeSet;\n\nimport net.jforum.SessionFacade;\nimport net.jforum.exceptions.ForumOrderChangedException;\nimport net.jforum.repository.SecurityRepository;\nimport net.jforum.security.PermissionControl;\nimport net.jforum.security.SecurityConstants;\nimport net.jforum.util.ForumOrderComparator;\n\n/**\n * Represents a category in the System.\n * Each category holds a reference to all its forums, which \n * can be retrieved by calling either @link #getForums(), \n * @link #getForum(int) and related methods. \n * \n * <br />\n * \n * This class also controls the access to its forums, so a call\n * to @link #getForums() will only return the forums accessible\n * to the user who make the call tho the method. \n * \n * @author Rafael Steil\n * @version $Id: Category.java,v 1.22 2007/08/18 07:03:20 andowson Exp $\n */\npublic class Category  implements Serializable\n{\n\tprivate int id;\n\tprivate int order;\n\tprivate boolean moderated;\n\tprivate String name;\n\tprivate Map forumsIdMap = new HashMap();\n\tprivate Set forums = new TreeSet(new ForumOrderComparator());\n\t\t\n\tpublic Category() {}\n\t\n\tpublic Category(int id) {\n\t\tthis.id = id;\n\t}\n\t\n\tpublic Category(String name, int id) {\n\t\tthis.name = name;\n\t\tthis.id = id;\n\t}\n\t\n\tpublic Category(Category c) {\n\t\tthis.name = c.getName();\n\t\tthis.id = c.getId();\n\t\tthis.order = c.getOrder();\n\t\tthis.moderated = c.isModerated();\n\t\t\n\t\tfor (Iterator iter = c.getForums().iterator(); iter.hasNext(); ) {\n\t\t\tthis.addForum(new Forum((Forum)iter.next()));\n\t\t}\n\t}\n\t\n\tpublic void setModerated(boolean status)\n\t{\n\t\tthis.moderated = status;\n\t}\n\t\n\tpublic boolean isModerated() \n\t{\n\t\treturn this.moderated;\n\t}\n\t\n\t/**\n\t * @return int\n\t */\n\tpublic int getId() {\n\t\treturn this.id;\n\t}\n\n\t/**\n\t * @return String\n\t */\n\tpublic String getName() {\n\t\treturn this.name;\n\t}\n\n\t/**\n\t * @return int\n\t */\n\tpublic int getOrder() {\n\t\treturn this.order;\n\t}\n\n\t/**\n\t * Sets the id.\n\t * @param id The id to set\n\t */\n\tpublic void setId(int id) {\n\t\tthis.id = id;\n\t}\n\n\t/**\n\t * Sets the name.\n\t * @param name The name to set\n\t */\n\tpublic void setName(String name) {\n\t\tthis.name = name;\n\t}\n\n\t/**\n\t * Sets the order.\n\t * @param order The order to set\n\t */\n\tpublic void setOrder(int order) {\n\t\tthis.order = order;\n\t}\n\t\n\t/**\n\t * Adds a forum to this category\n\t * \n\t * @param forum Forum\n\t */\n\tpublic void addForum(Forum forum) {\n\t\tthis.forumsIdMap.put(new Integer(forum.getId()), forum);\n\t\tthis.forums.add(forum);\n\t}\n\t\n\t/**\n\t * Reloads a forum.\n\t * The forum should already be in the cache and <b>SHOULD NOT</b>\n\t * have its order changed. If the forum's order was changed, \n\t * then you <b>MUST CALL</b> @link #changeForumOrder(Forum) <b>BEFORE</b>\n\t * calling this method.\n\t * \n\t * @param forum The forum to reload its information\n\t * @see #changeForumOrder(Forum)\n\t */\n\tpublic void reloadForum(Forum forum) {\n\t\tForum currentForum = this.getForum(forum.getId());\n\t\t\n\t\tif (forum.getOrder() != currentForum.getOrder()) {\n\t\t\tthrow new ForumOrderChangedException(\"Forum #\" + forum.getId() + \" cannot be reloaded, since its \"\n\t\t\t\t\t+ \"display order was changed. You must call Category#changeForumOrder(Forum)\"\n\t\t\t\t\t+ \"first\");\n\t\t}\n\t\t\n\t\tSet tmpSet = new TreeSet(new ForumOrderComparator());\n\t\ttmpSet.addAll(this.forums);\n\t\ttmpSet.remove(currentForum);\n\t\ttmpSet.add(forum);\n\t\tthis.forumsIdMap.put(new Integer(forum.getId()), forum);\n\t\t\n\t\tthis.forums = tmpSet;\n\t}\n\t\n\t/**\n\t * Changes a forum's display order. \n\t * This method changes the position of the\n\t * forum in the current display order of the\n\t * forum instance passed as argument, if applicable.\n\t * \n\t * @param forum The forum to change\n\t */\n\tpublic void changeForumOrder(Forum forum)\n\t{\n\t\tForum current = this.getForum(forum.getId());\n\t\tForum currentAtOrder = this.findByOrder(forum.getOrder());\n\t\t\n\t\tSet tmpSet = new TreeSet(new ForumOrderComparator());\n\t\ttmpSet.addAll(this.forums);\n\t\t\n\t\t// Remove the forum in the current order\n\t\t// where the changed forum will need to be\n\t\tif (currentAtOrder != null) {\n\t\t\ttmpSet.remove(currentAtOrder);\n\t\t}\n\t\t\n\t\ttmpSet.add(forum);\n\t\tthis.forumsIdMap.put(new Integer(forum.getId()), forum);\n\t\t\n\t\t// Remove the forum in the position occupied\n\t\t// by the changed forum before its modification,\n\t\t// so then we can add the another forum into \n\t\t// its position\n\t\tif (currentAtOrder != null) {\n\t\t\ttmpSet.remove(current);\n\t\t\tcurrentAtOrder.setOrder(current.getOrder());\n\t\t\ttmpSet.add(currentAtOrder);\n\n\t\t\tthis.forumsIdMap.put(new Integer(currentAtOrder.getId()), currentAtOrder);\n\t\t}\n\t\t\n\t\tthis.forums = tmpSet;\n\t}\n\t\n\tprivate Forum findByOrder(int order)\n\t{\n\t\tfor (Iterator iter = this.forums.iterator(); iter.hasNext(); ) {\n\t\t\tForum f = (Forum)iter.next();\n\t\t\tif (f.getOrder() == order) {\n\t\t\t\treturn f;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn null;\n\t}\n\t\n\t/**\n\t * Removes a forum from the list.\n\t * @param forumId int\n\t */\n\tpublic void removeForum(int forumId) {\n\t\tthis.forums.remove(this.getForum(forumId));\n\t\tthis.forumsIdMap.remove(new Integer(forumId));\n\t}\n\n\t/**\n\t * Gets a forum.\n\t * \n\t * @param userId The user's id who is trying to see the forum\n\t * @param forumId The id of the forum to get\n\t * @return The <code>Forum</code> instance if found, or <code>null</code>\n\t * otherwhise.\n\t * @see #getForum(int)\n\t */\n\tpublic Forum getForum(int userId, int forumId)\n\t{\n\t\tPermissionControl pc = SecurityRepository.get(userId);\n\t\tif (pc.canAccess(SecurityConstants.PERM_FORUM, Integer.toString(forumId))) {\n\t\t\treturn (Forum)this.forumsIdMap.get(new Integer(forumId));\n\t\t}\n\t\t\n\t\treturn null;\n\t}\n\n\t/**\n\t * Gets a forum.\n\t * \n\t * @param forumId The forum's id \n\t * @return The requested forum, if found, or <code>null</code> if\n\t * the forum does not exists or access to it is denied.\n\t * @see #getForum(int, int)\n\t */\n\tpublic Forum getForum(int forumId)\n\t{\n\t\treturn this.getForum(SessionFacade.getUserSession().getUserId(), forumId);\n\t}\n\n\t/**\n\t * Get all forums from this category.\n\t * \n\t * @return All forums, regardless it is accessible \n\t * to the user or not.\n\t */\n\tpublic Collection getForums()\n\t{\n\t\tif (this.forums.size() == 0) {\n\t\t\treturn this.forums;\n\t\t}\n\n\t\treturn this.getForums(SessionFacade.getUserSession().getUserId());\n\t}\n\n\t/**\n\t * Gets all forums from this category.\n\t * \n\t * @return The forums available to the user who make the call\n\t * @see #getForums()\n     * @param userId int\n\t */\n\tpublic Collection getForums(int userId) \n\t{\n\t\tPermissionControl pc = SecurityRepository.get(userId);\n\t\tList forums = new ArrayList();\n\n\t\tfor (Iterator iter = this.forums.iterator(); iter.hasNext(); ) {\n\t\t\tForum f = (Forum)iter.next();\n\t\t\tif (pc.canAccess(SecurityConstants.PERM_FORUM, Integer.toString(f.getId()))) {\n\t\t\t\tforums.add(f);\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn forums;\n\t}\n\n\t/** \n\t * @see java.lang.Object#hashCode()\n\t */\n\tpublic int hashCode() \n\t{\n\t\treturn this.id;\n\t}\n\n\t/** \n\t * @see java.lang.Object#equals(java.lang.Object)\n\t */\n\tpublic boolean equals(Object o) \n\t{\n\t\treturn ((o instanceof Category) && (((Category)o).getId() == this.id));\n\t}\n\t\n\t/** \n\t * @see java.lang.Object#toString()\n\t */\n\tpublic String toString() {\n\t\treturn \"[\" + this.name + \", id=\" + this.id + \", order=\" + this.order + \"]\"; \n\t}\n\n}",
  "metadata": {
    "fileId": "Category_java_chunk_1",
    "fileName": "Category.java",
    "filePath": "src/net/jforum/entities/Category.java"
  }
}