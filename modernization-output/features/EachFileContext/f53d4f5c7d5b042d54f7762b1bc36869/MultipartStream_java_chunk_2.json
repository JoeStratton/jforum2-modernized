{
  "pageContent": "File Path: src/net/jforum/util/legacy/commons/fileupload/MultipartStream.java\n\n Original Content: public class MultipartStream {\n\n    // ----------------------------------------------------- Manifest constants\n\n\n    /**\n     * The Carriage Return ASCII character value.\n     */\n    public static final byte CR = 0x0D;\n\n\n    /**\n     * The Line Feed ASCII character value.\n     */\n    public static final byte LF = 0x0A;\n\n\n    /**\n     * The dash (-) ASCII character value.\n     */\n    public static final byte DASH = 0x2D;\n\n\n    /**\n     * The maximum length of <code>header-part</code> that will be\n     * processed (10 kilobytes = 10240 bytes.).\n     */\n    public static final int HEADER_PART_SIZE_MAX = 10240;\n\n\n    /**\n     * The default length of the buffer used for processing a request.\n     */\n    protected static final int DEFAULT_BUFSIZE = 4096;\n\n\n    /**\n     * A byte sequence that marks the end of <code>header-part</code>\n     * (<code>CRLFCRLF</code>).\n     */\n    protected static final byte[] HEADER_SEPARATOR = {\n            CR, LF, CR, LF };\n\n\n    /**\n     * A byte sequence that that follows a delimiter that will be\n     * followed by an encapsulation (<code>CRLF</code>).\n     */\n    protected static final byte[] FIELD_SEPARATOR = {\n            CR, LF};\n\n\n    /**\n     * A byte sequence that that follows a delimiter of the last\n     * encapsulation in the stream (<code>--</code>).\n     */\n    protected static final byte[] STREAM_TERMINATOR = {\n            DASH, DASH};\n\n\n    // ----------------------------------------------------------- Data members\n\n\n    /**\n     * The input stream from which data is read.\n     */\n    private InputStream input;\n\n\n    /**\n     * The length of the boundary token plus the leading <code>CRLF--</code>.\n     */\n    private int boundaryLength;\n\n\n    /**\n     * The amount of data, in bytes, that must be kept in the buffer in order\n     * to detect delimiters reliably.\n     */\n    private int keepRegion;\n\n\n    /**\n     * The byte sequence that partitions the stream.\n     */\n    private byte[] boundary;\n\n\n    /**\n     * The length of the buffer used for processing the request.\n     */\n    private int bufSize;\n\n\n    /**\n     * The buffer used for processing the request.\n     */\n    private byte[] buffer;\n\n\n    /**\n     * The index of first valid character in the buffer.\n     * <br>\n     * 0 <= head < bufSize\n     */\n    private int head;\n\n\n    /**\n     * The index of last valid characer in the buffer + 1.\n     * <br>\n     * 0 <= tail <= bufSize\n     */\n    private int tail;\n\n\n    /**\n     * The content encoding to use when reading headers.\n     */\n    private String headerEncoding;\n\n\n    // ----------------------------------------------------------- Constructors\n\n\n    /**\n     * Default constructor.\n     *\n     * @see #MultipartStream(InputStream, byte[], int)\n     * @see #MultipartStream(InputStream, byte[])\n     *\n     */\n    public MultipartStream() {\n    }\n\n\n    /**\n     * <p> Constructs a <code>MultipartStream</code> with a custom size buffer.\n     *\n     * <p> Note that the buffer must be at least big enough to contain the\n     * boundary string, plus 4 characters for CR/LF and double dash, plus at\n     * least one byte of data.  Too small a buffer size setting will degrade\n     * performance.\n     *\n     * @param input    The <code>InputStream</code> to serve as a data source.\n     * @param boundary The token used for dividing the stream into\n     *                 <code>encapsulations</code>.\n     * @param bufSize  The size of the buffer to be used, in bytes.\n     *\n     *\n     * @see #MultipartStream()\n     * @see #MultipartStream(InputStream, byte[])\n     *\n     */\n    public MultipartStream(InputStream input,\n                           byte[] boundary,\n                           int bufSize) {\n        this.input = input;\n        this.bufSize = bufSize;\n        this.buffer = new byte[bufSize];\n\n        // We prepend CR/LF to the boundary to chop trailng CR/LF from\n        // body-data tokens.\n        this.boundary = new byte[boundary.length + 4];\n        this.boundaryLength = boundary.length + 4;\n        this.keepRegion = boundary.length + 3;\n        this.boundary[0] = CR;\n        this.boundary[1] = LF;\n        this.boundary[2] = DASH;\n        this.boundary[3] = DASH;\n        System.arraycopy(boundary, 0, this.boundary, 4, boundary.length);\n\n        head = 0;\n        tail = 0;\n    }\n\n\n    /**\n     * <p> Constructs a <code>MultipartStream</code> with a default size buffer.\n     *\n     * @param input    The <code>InputStream</code> to serve as a data source.\n     * @param boundary The token used for dividing the stream into\n     *                 <code>encapsulations</code>.\n     *\n     * @exception IOException when an error occurs.\n     *\n     * @see #MultipartStream()\n     * @see #MultipartStream(InputStream, byte[], int)\n     *\n     */\n    public MultipartStream(InputStream input,\n                           byte[] boundary)  {\n        this(input, boundary, DEFAULT_BUFSIZE);\n    }\n\n\n    // --------------------------------------------------------- Public methods\n\n\n    /**\n     * Retrieves the character encoding used when reading the headers of an\n     * individual part. When not specified, or <code>null</code>, the platform\n     * default encoding is used.\n\n     *\n     * @return The encoding used to read part headers.\n     */\n    public String getHeaderEncoding() {\n        return headerEncoding;\n    }\n\n\n    /**\n     * Specifies the character encoding to be used when reading the headers of\n     * individual parts. When not specified, or <code>null</code>, the platform\n     * default encoding is used.\n     *\n     * @param encoding The encoding used to read part headers.\n     */\n    public void setHeaderEncoding(String encoding) {\n        headerEncoding = encoding;\n    }\n\n\n    /**\n     * Reads a byte from the <code>buffer</code>, and refills it as\n     * necessary.\n     *\n     * @return The next byte from the input stream.\n     *\n     * @exception IOException if there is no more data available.\n     */\n    public byte readByte()\n        throws IOException {\n        // Buffer depleted ?\n        if (head == tail) {\n            head = 0;\n            // Refill.\n            tail = input.read(buffer, head, bufSize);\n            if (tail == -1) {\n                // No more data available.\n                throw new IOException(\"No more data is available\");\n            }\n        }\n        return buffer[head++];\n    }\n\n\n    /**\n     * Skips a <code>boundary</code> token, and checks whether more\n     * <code>encapsulations</code> are contained in the stream.\n     *\n     * @return <code>true</code> if there are more encapsulations in\n     *         this stream; <code>false</code> otherwise.\n     *\n     * @exception MalformedStreamException if the stream ends unexpecetedly or\n     *                                     fails to follow required syntax.\n     */\n    public boolean readBoundary()\n        throws MalformedStreamException {\n        byte[] marker = new byte[2];\n        boolean nextChunk = false;\n\n        head += boundaryLength;\n        try {\n            marker[0] = readByte();\n            if (marker[0] == LF) {\n                // Work around IE5 Mac bug with input type=image.\n                // Because the boundary delimiter, not including the trailing\n                // CRLF, must not appear within any file (RFC 2046, section\n                // 5.1.1), we know the missing CR is due to a buggy browser\n                // rather than a file containing something similar to a\n                // boundary.\n                return true;\n            }\n\n            marker[1] = readByte();\n            if (arrayequals(marker, STREAM_TERMINATOR, 2)) {\n                nextChunk = false;\n            } else if (arrayequals(marker, FIELD_SEPARATOR, 2)) {\n                nextChunk = true;\n            } else {\n                throw new MalformedStreamException(\n                        \"Unexpected characters follow a boundary\");\n            }\n        } catch (IOException e) {\n            throw new MalformedStreamException(\"Stream ended unexpectedly\");\n        }\n        return nextChunk;\n    }\n\n\n    /**\n     * <p>Changes the boundary token used for partitioning the stream.\n     *\n     * <p>This method allows single pass processing of nested multipart\n     * streams.\n     *\n     * <p>The boundary token of the nested stream is <code>required</code>\n     * to be of the same length as the boundary token in parent stream.\n     *\n     * <p>Restoring the parent stream boundary token after processing of a\n     * nested stream is left to the application.\n     *\n     * @param boundary The boundary to be used for parsing of the nested\n     *                 stream.\n     *\n     * @exception IllegalBoundaryException if the <code>boundary</code>\n     *                                     has a different length than the one\n     *                                     being currently parsed.\n     */\n    public void setBoundary(byte[] boundary)\n        throws IllegalBoundaryException {\n        if (boundary.length != boundaryLength - 4) {\n            throw new IllegalBoundaryException(\n                    \"The length of a boundary token can not be changed\");\n        }\n        System.arraycopy(boundary, 0, this.boundary, 4, boundary.length);\n    }",
  "metadata": {
    "fileId": "MultipartStream_java_chunk_2",
    "fileName": "MultipartStream.java",
    "filePath": "src/net/jforum/util/legacy/commons/fileupload/MultipartStream.java"
  }
}