{
  "pageContent": "File Path: src/net/jforum/util/legacy/commons/fileupload/ParameterParser.java\n\n Original Content: /*\n * Copyright 2001-2004 The Apache Software Foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage net.jforum.util.legacy.commons.fileupload;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**\n * A simple parser intended to parse sequences of name/value pairs.\n * Parameter values are exptected to be enclosed in quotes if they\n * contain unsafe characters, such as '=' characters or separators.\n * Parameter values are optional and can be omitted.\n *\n * <p>\n *  <code>param1 = value; param2 = \"anything goes; really\"; param3</code>\n * </p>\n *\n * @author <a href=\"mailto:oleg@ural.ru\">Oleg Kalnichevski</a>\n */\n\npublic class ParameterParser {\n    /**\n     * String to be parsed.\n     */\n    private char[] chars = null;\n\n    /**\n     * Current position in the string.\n     */\n    private int pos = 0;\n\n    /**\n     * Maximum position in the string.\n     */\n    private int len = 0;\n\n    /**\n     * Start of a token.\n     */\n    private int i1 = 0;\n\n    /**\n     * End of a token.\n     */\n    private int i2 = 0;\n\n    /**\n     * Whether names stored in the map should be converted to lower case.\n     */\n    private boolean lowerCaseNames = false;\n\n    /**\n     * Default ParameterParser constructor.\n     */\n    public ParameterParser() {\n        super();\n    }\n\n    /**\n     * Are there any characters left to parse?\n     *\n     * @return <tt>true</tt> if there are unparsed characters,\n     *         <tt>false</tt> otherwise.\n     */\n    private boolean hasChar() {\n        return this.pos < this.len;\n    }\n\n    /**\n     * A helper method to process the parsed token. This method removes\n     * leading and trailing blanks as well as enclosing quotation marks,\n     * when necessary.\n     *\n     * @param quoted <tt>true</tt> if quotation marks are expected,\n     *               <tt>false</tt> otherwise.\n     * @return the token\n     */\n    private String getToken(boolean quoted) {\n        // Trim leading white spaces\n        while ((i1 < i2) && (Character.isWhitespace(chars[i1]))) {\n            i1++;\n        }\n        // Trim trailing white spaces\n        while ((i2 > i1) && (Character.isWhitespace(chars[i2 - 1]))) {\n            i2--;\n        }\n        // Strip away quotation marks if necessary\n        if (quoted) {\n            if (((i2 - i1) >= 2)\n                && (chars[i1] == '\"')\n                && (chars[i2 - 1] == '\"')) {\n                i1++;\n                i2--;\n            }\n        }\n        String result = null;\n        if (i2 > i1) {\n            result = new String(chars, i1, i2 - i1);\n        }\n        return result;\n    }\n\n    /**\n     * Tests if the given character is present in the array of characters.\n     *\n     * @param ch the character to test for presense in the array of characters\n     * @param charray the array of characters to test against\n     *\n     * @return <tt>true</tt> if the character is present in the array of\n     *   characters, <tt>false</tt> otherwise.\n     */\n    private boolean isOneOf(char ch, final char[] charray) {\n        boolean result = false;\n        for (int i = 0; i < charray.length; i++) {\n            if (ch == charray[i]) {\n                result = true;\n                break;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Parses out a token until any of the given terminators\n     * is encountered.\n     *\n     * @param terminators the array of terminating characters. Any of these\n     * characters when encountered signify the end of the token\n     *\n     * @return the token\n     */\n    private String parseToken(final char[] terminators) {\n        char ch;\n        i1 = pos;\n        i2 = pos;\n        while (hasChar()) {\n            ch = chars[pos];\n            if (isOneOf(ch, terminators)) {\n                break;\n            }\n            i2++;\n            pos++;\n        }\n        return getToken(false);\n    }\n\n    /**\n     * Parses out a token until any of the given terminators\n     * is encountered outside the quotation marks.\n     *\n     * @param terminators the array of terminating characters. Any of these\n     * characters when encountered outside the quotation marks signify the end\n     * of the token\n     *\n     * @return the token\n     */\n    private String parseQuotedToken(final char[] terminators) {\n        char ch;\n        i1 = pos;\n        i2 = pos;\n        boolean quoted = false;\n        boolean charEscaped = false;\n        while (hasChar()) {\n            ch = chars[pos];\n            if (!quoted && isOneOf(ch, terminators)) {\n                break;\n            }\n            if (!charEscaped && ch == '\"') {\n                quoted = !quoted;\n            }\n            charEscaped = (!charEscaped && ch == '\\\\');\n            i2++;\n            pos++;\n\n        }\n        return getToken(true);\n    }\n\n    /**\n     * Returns <tt>true</tt> if parameter names are to be converted to lower\n     * case when name/value pairs are parsed.\n     *\n     * @return <tt>true</tt> if parameter names are to be\n     * converted to lower case when name/value pairs are parsed.\n     * Otherwise returns <tt>false</tt>\n     */\n    public boolean isLowerCaseNames() {\n        return this.lowerCaseNames;\n    }\n\n    /**\n     * Sets the flag if parameter names are to be converted to lower case when\n     * name/value pairs are parsed.\n     *\n     * @param b <tt>true</tt> if parameter names are to be\n     * converted to lower case when name/value pairs are parsed.\n     * <tt>false</tt> otherwise.\n     */\n    public void setLowerCaseNames(boolean b) {\n        this.lowerCaseNames = b;\n    }\n\n    /**\n     * Extracts a map of name/value pairs from the given string. Names are\n     * expected to be unique.\n     *\n     * @param str the string that contains a sequence of name/value pairs\n     * @param separator the name/value pairs separator\n     *\n     * @return a map of name/value pairs\n     */\n    public Map parse(final String str, char separator) {\n        if (str == null) {\n            return new HashMap();\n        }\n        return parse(str.toCharArray(), separator);\n    }\n\n    /**\n     * Extracts a map of name/value pairs from the given array of\n     * characters. Names are expected to be unique.\n     *\n     * @param chars the array of characters that contains a sequence of\n     * name/value pairs\n     * @param separator the name/value pairs separator\n     *\n     * @return a map of name/value pairs\n     */\n    public Map parse(final char[] chars, char separator) {\n        if (chars == null) {\n            return new HashMap();\n        }\n        return parse(chars, 0, chars.length, separator);\n    }\n\n    /**\n     * Extracts a map of name/value pairs from the given array of\n     * characters. Names are expected to be unique.\n     *\n     * @param chars the array of characters that contains a sequence of\n     * name/value pairs\n     * @param offset - the initial offset.\n     * @param length - the length.\n     * @param separator the name/value pairs separator\n     *\n     * @return a map of name/value pairs\n     */\n    public Map parse(\n        final char[] chars,\n        int offset,\n        int length,\n        char separator) {\n\n        if (chars == null) {\n            return new HashMap();\n        }\n        HashMap params = new HashMap();\n        this.chars = chars;\n        this.pos = offset;\n        this.len = length;\n\n        String paramName = null;\n        String paramValue = null;\n        while (hasChar()) {\n            paramName = parseToken(new char[] {\n                    '=', separator });\n            paramValue = null;\n            if (hasChar() && (chars[pos] == '=')) {\n                pos++; // skip '='\n                paramValue = parseQuotedToken(new char[] {\n                        separator });\n            }\n            if (hasChar() && (chars[pos] == separator)) {\n                pos++; // skip separator\n            }\n            if ((paramName != null) && (paramName.length() > 0)) {\n                if (this.lowerCaseNames) {\n                    paramName = paramName.toLowerCase();\n                }\n                params.put(paramName, paramValue);\n            }\n        }\n        return params;\n    }\n}",
  "metadata": {
    "fileId": "ParameterParser_java_chunk_1",
    "fileName": "ParameterParser.java",
    "filePath": "src/net/jforum/util/legacy/commons/fileupload/ParameterParser.java"
  }
}