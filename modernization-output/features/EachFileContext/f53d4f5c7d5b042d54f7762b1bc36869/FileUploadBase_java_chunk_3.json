{
  "pageContent": "File Path: src/net/jforum/util/legacy/commons/fileupload/FileUploadBase.java\n\n Original Content: if (requestSize == -1) {\n            throw new UnknownSizeException(\n                \"the request was rejected because its size is unknown\");\n        }\n\n        if (sizeMax >= 0 && requestSize > sizeMax) {\n            throw new SizeLimitExceededException(\n                \"the request was rejected because \"\n                + \"its size exceeds allowed range\");\n        }\n\n        try {\n            byte[] boundary = getBoundary(contentType);\n            if (boundary == null) {\n                throw new FileUploadException(\n                        \"the request was rejected because \"\n                        + \"no multipart boundary was found\");\n            }\n\n            InputStream input = ctx.getInputStream();\n\n            MultipartStream multi = new MultipartStream(input, boundary);\n            multi.setHeaderEncoding(headerEncoding);\n\n            boolean nextPart = multi.skipPreamble();\n            while (nextPart) {\n                Map headers = parseHeaders(multi.readHeaders());\n                String fieldName = getFieldName(headers);\n                if (fieldName != null) {\n                    String subContentType = getHeader(headers, CONTENT_TYPE);\n                    if (subContentType != null && subContentType\n                        .toLowerCase().startsWith(MULTIPART_MIXED)) {\n                        // Multiple files.\n                        byte[] subBoundary = getBoundary(subContentType);\n                        multi.setBoundary(subBoundary);\n                        boolean nextSubPart = multi.skipPreamble();\n                        while (nextSubPart) {\n                            headers = parseHeaders(multi.readHeaders());\n                            if (getFileName(headers) != null) {\n                                FileItem item =\n                                        createItem(headers, false);\n                                OutputStream os = item.getOutputStream();\n                                try {\n                                    multi.readBodyData(os);\n                                } finally {\n                                    os.close();\n                                }\n                                items.add(item);\n                            } else {\n                                // Ignore anything but files inside\n                                // multipart/mixed.\n                                multi.discardBodyData();\n                            }\n                            nextSubPart = multi.readBoundary();\n                        }\n                        multi.setBoundary(boundary);\n                    } else {\n                        FileItem item = createItem(headers,\n                                getFileName(headers) == null);\n                        OutputStream os = item.getOutputStream();\n                        try {\n                            multi.readBodyData(os);\n                        } finally {\n                            os.close();\n                        }\n                        items.add(item);\n                    }\n                } else {\n                    // Skip this part.\n                    multi.discardBodyData();\n                }\n                nextPart = multi.readBoundary();\n            }\n        } catch (IOException e) {\n            throw new FileUploadException(\n                \"Processing of \" + MULTIPART_FORM_DATA\n                    + \" request failed. \" + e.getMessage());\n        }\n\n        return items;\n    }\n\n\n    // ------------------------------------------------------ Protected methods\n\n\n    /**\n     * Retrieves the boundary from the <code>Content-type</code> header.\n     *\n     * @param contentType The value of the content type header from which to\n     *                    extract the boundary value.\n     *\n     * @return The boundary, as a byte array.\n     */\n    protected byte[] getBoundary(String contentType) {\n        ParameterParser parser = new ParameterParser();\n        parser.setLowerCaseNames(true);\n        // Parameter parser can handle null input\n        Map params = parser.parse(contentType, ';');\n        String boundaryStr = (String) params.get(\"boundary\");\n\n        if (boundaryStr == null) {\n            return null;\n        }\n        byte[] boundary;\n        try {\n            boundary = boundaryStr.getBytes(\"ISO-8859-1\");\n        } catch (UnsupportedEncodingException e) {\n            boundary = boundaryStr.getBytes();\n        }\n        return boundary;\n    }\n\n\n    /**\n     * Retrieves the file name from the <code>Content-disposition</code>\n     * header.\n     *\n     * @param headers A <code>Map</code> containing the HTTP request headers.\n     *\n     * @return The file name for the current <code>encapsulation</code>.\n     */\n    protected String getFileName(Map /* String, String */ headers) {\n        String fileName = null;\n        String cd = getHeader(headers, CONTENT_DISPOSITION);\n        if (cd.startsWith(FORM_DATA) || cd.startsWith(ATTACHMENT)) {\n            ParameterParser parser = new ParameterParser();\n            parser.setLowerCaseNames(true);\n            // Parameter parser can handle null input\n            Map params = parser.parse(cd, ';');\n            if (params.containsKey(\"filename\")) {\n                fileName = (String) params.get(\"filename\");\n                if (fileName != null) {\n                    fileName = fileName.trim();\n                } else {\n                    // Even if there is no value, the parameter is present, so\n                    // we return an empty file name rather than no file name.\n                    fileName = \"\";\n                }\n            }\n        }\n        return fileName;\n    }\n\n\n    /**\n     * Retrieves the field name from the <code>Content-disposition</code>\n     * header.\n     *\n     * @param headers A <code>Map</code> containing the HTTP request headers.\n     *\n     * @return The field name for the current <code>encapsulation</code>.\n     */\n    protected String getFieldName(Map /* String, String */ headers) {\n        String fieldName = null;\n        String cd = getHeader(headers, CONTENT_DISPOSITION);\n        if (cd != null && cd.startsWith(FORM_DATA)) {\n\n            ParameterParser parser = new ParameterParser();\n            parser.setLowerCaseNames(true);\n            // Parameter parser can handle null input\n            Map params = parser.parse(cd, ';');\n            fieldName = (String) params.get(\"name\");\n            if (fieldName != null) {\n                fieldName = fieldName.trim();\n            }\n        }\n        return fieldName;\n    }\n\n\n    /**\n     * Creates a new {@link FileItem} instance.\n     *\n     * @param headers       A <code>Map</code> containing the HTTP request\n     *                      headers.\n     * @param isFormField   Whether or not this item is a form field, as\n     *                      opposed to a file.\n     *\n     * @return A newly created <code>FileItem</code> instance.\n     *\n     * @exception FileUploadException if an error occurs.\n     */\n    protected FileItem createItem(Map headers,\n                                  boolean isFormField)  {\n        return getFileItemFactory().createItem(getFieldName(headers),\n                getHeader(headers, CONTENT_TYPE),\n                isFormField,\n                getFileName(headers));\n    }\n\n\n    /**\n     * <p> Parses the <code>header-part</code> and returns as key/value\n     * pairs.\n     *\n     * <p> If there are multiple headers of the same names, the name\n     * will map to a comma-separated list containing the values.\n     *\n     * @param headerPart The <code>header-part</code> of the current\n     *                   <code>encapsulation</code>.\n     *\n     * @return A <code>Map</code> containing the parsed HTTP request headers.\n     */\n    protected Map /* String, String */ parseHeaders(String headerPart) {\n        Map headers = new HashMap();\n        char[] buffer = new char[MAX_HEADER_SIZE];\n        boolean done = false;\n        int j = 0;\n        int i;\n        String header, headerName, headerValue;\n        try {\n            while (!done) {\n                i = 0;\n                // Copy a single line of characters into the buffer,\n                // omitting trailing CRLF.\n                while (i < 2\n                        || buffer[i - 2] != '\\r' || buffer[i - 1] != '\\n') {\n                    buffer[i++] = headerPart.charAt(j++);\n                }\n                header = new String(buffer, 0, i - 2);\n                if (header.equals(\"\")) {\n                    done = true;\n                } else {\n                    if (header.indexOf(':') == -1) {\n                        // This header line is malformed, skip it.\n                        continue;\n                    }\n                    headerName = header.substring(0, header.indexOf(':'))\n                        .trim().toLowerCase();\n                    headerValue =\n                        header.substring(header.indexOf(':') + 1).trim();\n                    if (getHeader(headers, headerName) != null) {\n                        // More that one heder of that name exists,\n                        // append to the list.\n                        headers.put(headerName,\n                                    getHeader(headers, headerName) + ','\n                                        + headerValue);\n                    } else {\n                        headers.put(headerName, headerValue);\n                    }\n                }\n            }\n        } catch (IndexOutOfBoundsException e) {\n            // Headers were malformed. continue with all that was\n            // parsed.\n        }\n        return headers;\n    }",
  "metadata": {
    "fileId": "FileUploadBase_java_chunk_3",
    "fileName": "FileUploadBase.java",
    "filePath": "src/net/jforum/util/legacy/commons/fileupload/FileUploadBase.java"
  }
}