{
  "pageContent": "File Path: src/net/jforum/util/legacy/commons/fileupload/MultipartStream.java\n\n Original Content: /**\n     * <p>Reads the <code>header-part</code> of the current\n     * <code>encapsulation</code>.\n     *\n     * <p>Headers are returned verbatim to the input stream, including the\n     * trailing <code>CRLF</code> marker. Parsing is left to the\n     * application.\n     *\n     * <p><strong>TODO</strong> allow limiting maximum header size to\n     * protect against abuse.\n     *\n     * @return The <code>header-part</code> of the current encapsulation.\n     *\n     * @exception MalformedStreamException if the stream ends unexpecetedly.\n     */\n    public String readHeaders()\n        throws MalformedStreamException {\n        int i = 0;\n        byte[] b = new byte[1];\n        // to support multi-byte characters\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        int sizeMax = HEADER_PART_SIZE_MAX;\n        int size = 0;\n        while (i < 4) {\n            try {\n                b[0] = readByte();\n            } catch (IOException e) {\n                throw new MalformedStreamException(\"Stream ended unexpectedly\");\n            }\n            size++;\n            if (b[0] == HEADER_SEPARATOR[i]) {\n                i++;\n            } else {\n                i = 0;\n            }\n            if (size <= sizeMax) {\n                baos.write(b[0]);\n            }\n        }\n\n        String headers = null;\n        if (headerEncoding != null) {\n            try {\n                headers = baos.toString(headerEncoding);\n            } catch (UnsupportedEncodingException e) {\n                // Fall back to platform default if specified encoding is not\n                // supported.\n                headers = baos.toString();\n            }\n        } else {\n            headers = baos.toString();\n        }\n\n        return headers;\n    }\n\n\n    /**\n     * <p>Reads <code>body-data</code> from the current\n     * <code>encapsulation</code> and writes its contents into the\n     * output <code>Stream</code>.\n     *\n     * <p>Arbitrary large amounts of data can be processed by this\n     * method using a constant size buffer. (see {@link\n     * #MultipartStream(InputStream,byte[],int) constructor}).\n     *\n     * @param output The <code>Stream</code> to write data into.\n     *\n     * @return the amount of data written.\n     *\n     * @exception MalformedStreamException if the stream ends unexpectedly.\n     * @exception IOException              if an i/o error occurs.\n     */\n    public int readBodyData(OutputStream output)\n        throws MalformedStreamException,\n               IOException {\n        boolean done = false;\n        int pad;\n        int pos;\n        int bytesRead;\n        int total = 0;\n        while (!done) {\n            // Is boundary token present somewere in the buffer?\n            pos = findSeparator();\n            if (pos != -1) {\n                // Write the rest of the data before the boundary.\n                output.write(buffer, head, pos - head);\n                total += pos - head;\n                head = pos;\n                done = true;\n            } else {\n                // Determine how much data should be kept in the\n                // buffer.\n                if (tail - head > keepRegion) {\n                    pad = keepRegion;\n                } else {\n                    pad = tail - head;\n                }\n                // Write out the data belonging to the body-data.\n                output.write(buffer, head, tail - head - pad);\n\n                // Move the data to the beginning of the buffer.\n                total += tail - head - pad;\n                System.arraycopy(buffer, tail - pad, buffer, 0, pad);\n\n                // Refill buffer with new data.\n                head = 0;\n                bytesRead = input.read(buffer, pad, bufSize - pad);\n\n                // [pprrrrrrr]\n                if (bytesRead != -1) {\n                    tail = pad + bytesRead;\n                } else {\n                    // The last pad amount is left in the buffer.\n                    // Boundary can't be in there so write out the\n                    // data you have and signal an error condition.\n                    output.write(buffer, 0, pad);\n                    output.flush();\n                    total += pad;\n                    throw new MalformedStreamException(\n                            \"Stream ended unexpectedly\");\n                }\n            }\n        }\n        output.flush();\n        return total;\n    }\n\n\n    /**\n     * <p> Reads <code>body-data</code> from the current\n     * <code>encapsulation</code> and discards it.\n     *\n     * <p>Use this method to skip encapsulations you don't need or don't\n     * understand.\n     *\n     * @return The amount of data discarded.\n     *\n     * @exception MalformedStreamException if the stream ends unexpectedly.\n     * @exception IOException              if an i/o error occurs.\n     */\n    public int discardBodyData()\n        throws MalformedStreamException,\n               IOException {\n        boolean done = false;\n        int pad;\n        int pos;\n        int bytesRead;\n        int total = 0;\n        while (!done) {\n            // Is boundary token present somewere in the buffer?\n            pos = findSeparator();\n            if (pos != -1) {\n                // Write the rest of the data before the boundary.\n                total += pos - head;\n                head = pos;\n                done = true;\n            } else {\n                // Determine how much data should be kept in the\n                // buffer.\n                if (tail - head > keepRegion) {\n                    pad = keepRegion;\n                } else {\n                    pad = tail - head;\n                }\n                total += tail - head - pad;\n\n                // Move the data to the beginning of the buffer.\n                System.arraycopy(buffer, tail - pad, buffer, 0, pad);\n\n                // Refill buffer with new data.\n                head = 0;\n                bytesRead = input.read(buffer, pad, bufSize - pad);\n\n                // [pprrrrrrr]\n                if (bytesRead != -1) {\n                    tail = pad + bytesRead;\n                } else {\n                    // The last pad amount is left in the buffer.\n                    // Boundary can't be in there so signal an error\n                    // condition.\n                    total += pad;\n                    throw new MalformedStreamException(\n                            \"Stream ended unexpectedly\");\n                }\n            }\n        }\n        return total;\n    }\n\n\n    /**\n     * Finds the beginning of the first <code>encapsulation</code>.\n     *\n     * @return <code>true</code> if an <code>encapsulation</code> was found in\n     *         the stream.\n     *\n     * @exception IOException if an i/o error occurs.\n     */\n    public boolean skipPreamble()\n        throws IOException {\n        // First delimiter may be not preceeded with a CRLF.\n        System.arraycopy(boundary, 2, boundary, 0, boundary.length - 2);\n        boundaryLength = boundary.length - 2;\n        try {\n            // Discard all data up to the delimiter.\n            discardBodyData();\n\n            // Read boundary - if succeded, the stream contains an\n            // encapsulation.\n            return readBoundary();\n        } catch (MalformedStreamException e) {\n            return false;\n        } finally {\n            // Restore delimiter.\n            System.arraycopy(boundary, 0, boundary, 2, boundary.length - 2);\n            boundaryLength = boundary.length;\n            boundary[0] = CR;\n            boundary[1] = LF;\n        }\n    }\n\n\n    /**\n     * Compares <code>count</code> first bytes in the arrays\n     * <code>a</code> and <code>b</code>.\n     *\n     * @param a     The first array to compare.\n     * @param b     The second array to compare.\n     * @param count How many bytes should be compared.\n     *\n     * @return <code>true</code> if <code>count</code> first bytes in arrays\n     *         <code>a</code> and <code>b</code> are equal.\n     */\n    public static boolean arrayequals(byte[] a,\n                                      byte[] b,\n                                      int count) {\n        for (int i = 0; i < count; i++) {\n            if (a[i] != b[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n\n    /**\n     * Searches for a byte of specified value in the <code>buffer</code>,\n     * starting at the specified <code>position</code>.\n     *\n     * @param value The value to find.\n     * @param pos   The starting position for searching.\n     *\n     * @return The position of byte found, counting from beginning of the\n     *         <code>buffer</code>, or <code>-1</code> if not found.\n     */\n    protected int findByte(byte value,\n                           int pos) {\n        for (int i = pos; i < tail; i++) {\n            if (buffer[i] == value) {\n                return i;\n            }\n        }\n\n        return -1;\n    }\n\n\n    /**\n     * Searches for the <code>boundary</code> in the <code>buffer</code>\n     * region delimited by <code>head</code> and <code>tail</code>.\n     *\n     * @return The position of the boundary found, counting from the\n     *         beginning of the <code>buffer</code>, or <code>-1</code> if\n     *         not found.\n     */\n    protected int findSeparator() {\n        int first;\n        int match = 0;\n        int maxpos = tail - boundaryLength;\n        for (first = head;\n             (first <= maxpos) && (match != boundaryLength);\n             first++) {\n            first = findByte(boundary[0], first);\n            if (first == -1 || (first > maxpos)) {\n                return -1;\n            }\n            for (match = 1; match < boundaryLength; match++) {\n                if (buffer[first + match] != boundary[match]) {\n                    break;\n                }\n            }\n        }\n        if (match == boundaryLength) {\n            return first - 1;\n        }\n        return -1;\n    }",
  "metadata": {
    "fileId": "MultipartStream_java_chunk_3",
    "fileName": "MultipartStream.java",
    "filePath": "src/net/jforum/util/legacy/commons/fileupload/MultipartStream.java"
  }
}