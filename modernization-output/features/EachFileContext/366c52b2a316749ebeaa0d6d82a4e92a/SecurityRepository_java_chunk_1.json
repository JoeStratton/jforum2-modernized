{
  "pageContent": "File Path: src/net/jforum/repository/SecurityRepository.java\n\n Original Content: /*\n * Copyright (c) JForum Team\n * All rights reserved.\n * \n * Redistribution and use in source and binary forms, \n * with or without modification, are permitted provided \n * that the following conditions are met:\n * \n * 1) Redistributions of source code must retain the above \n * copyright notice, this list of conditions and the \n * following  disclaimer.\n * 2)  Redistributions in binary form must reproduce the \n * above copyright notice, this list of conditions and \n * the following disclaimer in the documentation and/or \n * other materials provided with the distribution.\n * 3) Neither the name of \"Rafael Steil\" nor \n * the names of its contributors may be used to endorse \n * or promote products derived from this software without \n * specific prior written permission.\n * \n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT \n * HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY \n * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, \n * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF \n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR \n * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL \n * THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE \n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, \n * EXEMPLARY, OR CONSEQUENTIAL DAMAGES \n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF \n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, \n * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER \n * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER \n * IN CONTRACT, STRICT LIABILITY, OR TORT \n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN \n * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF \n * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE\n *\n * This file creation date: 18/11/2003 / 23:09:15\n * The JForum Project\n * http://www.jforum.net\n */\npackage net.jforum.repository;\n\nimport net.jforum.JForumExecutionContext;\nimport net.jforum.SessionFacade;\nimport net.jforum.cache.CacheEngine;\nimport net.jforum.cache.Cacheable;\nimport net.jforum.dao.DataAccessDriver;\nimport net.jforum.dao.GroupSecurityDAO;\nimport net.jforum.dao.UserDAO;\nimport net.jforum.entities.User;\nimport net.jforum.entities.UserSession;\nimport net.jforum.exceptions.SecurityLoadException;\nimport net.jforum.security.PermissionControl;\n\nimport org.apache.log4j.Logger;\n\n/**\n * @author Rafael Steil\n * @version $Id: SecurityRepository.java,v 1.25 2006/08/27 01:22:02 rafaelsteil Exp $\n */\npublic class SecurityRepository implements Cacheable\n{\n\tprivate static final Logger logger = Logger.getLogger(SecurityRepository.class);\n\tprivate static CacheEngine cache;\n\tprivate static final String FQN = \"security\";\n\n\t/**\n\t * @see net.jforum.cache.Cacheable#setCacheEngine(net.jforum.cache.CacheEngine)\n\t */\n\tpublic void setCacheEngine(CacheEngine engine)\n\t{\n\t\tcache = engine;\n\t}\n\n\t/***\n\t * Load user's roles. \n\t * \n\t * @param userId The user's id\n\t * @param force If <code>true</code>, forces a reload. If <code>false</code>, the call\n\t * will be ignored if the roles are already loaded.\n\t * \n\t * @see SecurityRepository#load(int)\n\t * @see SecurityRepository#load(User)\n\t * @see SecurityRepository#load(User, boolean)\n     * @return PermissionControl\n\t */\n\tpublic static PermissionControl load(int userId, boolean force)\n\t{\n\t\tif (force || cache.get(FQN, Integer.toString(userId)) == null) {\n\t\t\tUserDAO um = DataAccessDriver.getInstance().newUserDAO();\n\t\t\t\n\t\t\treturn SecurityRepository.load(um.selectById(userId), force);\n\t\t}\n\t\t\n\t\treturn SecurityRepository.get(userId);\n\t}\n\n\t/**\n\t * Load user's roles.\n\t * \n\t * @param userId The users's id\n\t * \n\t * @see SecurityRepository#load(int, boolean)\n\t * @see SecurityRepository#load(User)\n\t * @see SecurityRepository#load(User, boolean)\n     * @return PermissionControl\n\t */\n\tpublic static PermissionControl load(int userId)\n\t{\n\t\treturn SecurityRepository.load(userId, false);\n\t}\n\t\n\t/**\n\t * Load user's roles.\n\t * \n\t * @param user The <code>User</code> to load.\n\t * \n\t * @see SecurityRepository#load(int)\n\t * @see SecurityRepository#load(int, boolean), \n\t * @see SecurityRepository#load(User, boolean)\n     * @return  PermissionControl\n\t */\n\tpublic static PermissionControl load(User user)\n\t{\n\t\treturn SecurityRepository.load(user, false);\n\t}\n\n\t/**\n\t * Load user's roles.\n\t * \n\t * @param user The <code>User</code> to load\n\t * @param force If <code>true</code>, forces a reload. If <code>false</code>, the call\n\t * will be ignored if the roles are already loaded.\n\t * \n\t * @see SecurityRepository#load(int)\n\t * @see SecurityRepository#load(int, boolean)\n\t * @see SecurityRepository#load(User)\n     * @return PermissionControl\n\t */\n\tpublic static PermissionControl load(User user, boolean force)\n\t{\n\t\tString userId = Integer.toString(user.getId());\n\t\t\n\t\tif (force || cache.get(FQN, userId) == null) {\n\t\t\tPermissionControl pc = new PermissionControl();\n\t\t\t\n\t\t\t// load roles\n\t\t\tGroupSecurityDAO dao = DataAccessDriver.getInstance().newGroupSecurityDAO();\n\t\t\tpc.setRoles(dao.loadRolesByUserGroups(user));\n\t\t\t\n\t\t\tcache.add(FQN, userId, pc);\n\t\t\t\n\t\t\treturn pc;\n\t\t}\n\t\t\n\t\treturn SecurityRepository.get(user.getId());\n\t}\n\t\n\t/**\n\t * Check if the logged user has access to the role. \n\t * This method gets user's id from its session.\n\t * \n\t * @param roleName The role name to verity\n\t * @return <code>true</code> if the user has access to the role, <code>false</code> if access is denied\n\t * @throws SecurityLoadException if case of erros while trying\n\t * to load the roles\n\t * @see #canAccess(String, String)\n\t * @see #canAccess(int, String, String)\n\t */\n\tpublic static boolean canAccess(String roleName)\n\t{\n\t\treturn canAccess(roleName, null);\n\t}\n\t\n\tpublic static boolean canAccess(int userId, String roleName)\n\t{\n\t\treturn canAccess(userId, roleName, null);\n\t}\n\n\t/**\n\t * Check if the logged user has access to the role. \n\t * This method gets user's id from its session.\n\t * \n\t * @param roleName The role name to verify\n\t * @param value The value relacted to the role to verify for access\n\t * @return <code>true</code> if the user has access to the role, <code>false</code> if access is denied\n\t */\n\tpublic static boolean canAccess(String roleName, String value)\n\t{\n\t\tUserSession us = SessionFacade.getUserSession();\n\t\t\n\t\tif (us == null) {\n\t\t\tlogger.warn(\"Found null userSession. Going anonymous. Session id #\" \n\t\t\t\t+ JForumExecutionContext.getRequest().getSessionContext().getId());\n\t\t\tus = new UserSession();\n\t\t\tus.makeAnonymous();\n\t\t}\n\t\t\n\t\treturn canAccess(us.getUserId(), roleName, value);\n\t}\n\t\n\tpublic static boolean canAccess(int userId, String roleName, String value)\n\t{\n\t\tPermissionControl pc = SecurityRepository.get(userId);\n\t\t\n\t\tif (pc == null) {\n\t\t\tthrow new SecurityLoadException(\"Failed to load security roles for userId \" + userId + \" (null PermissionControl returned). \"\n\t\t\t\t+ \"roleName=\" + roleName + \", roleValue=\" + value);\n\t\t}\n\t\t\n\t\treturn (value != null ? pc.canAccess(roleName, value) : pc.canAccess(roleName));\n\t}\n\n\t/**\n\t * Gets the permssion schema of some specific user.\n\t * If the roles of the user aren't loaded yet, a call\n\t * to {@link #load(int)} will be made.\n\t * \n\t * @param userId The user's id to get the permissions\n\t * @return The <code>PermissionControl</code> instance related\n\t * to the user id passed as argument\n\t * @throws SecurityLoadException if case of erros while trying\n\t * to load the roles\n\t */\n\tpublic static PermissionControl get(int userId)\n\t{\n\t\tPermissionControl pc = (PermissionControl)cache.get(FQN, Integer.toString(userId));\n\t\t\n\t\tif (pc == null) {\n\t\t\ttry {\n\t\t\t\tpc = load(userId);\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\tthrow new SecurityLoadException(e);\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn pc;\n\t}\n\n\t/**\n\t * Adds a new permission control schema to the cache\n\t * \n\t * @param userId The user's id to associate with the schema\n\t * @param pc The <code>PermissionControl</code> instance to add\n\t */\n\tpublic static synchronized void add(int userId, PermissionControl pc)\n\t{\n\t\tcache.add(FQN, Integer.toString(userId), pc);\n\t}\n\t\n\t/**\n\t * Remove the cached roles from a specific user.\n\t * \n\t * @param userId The id of the user to remove from the cache\n\t */\n\tpublic static synchronized void remove(int userId)\n\t{\n\t\tcache.remove(FQN, Integer.toString(userId));\n\t}\n\t\n\t/**\n\t * Clear all cached security entries.\n\t */\n\tpublic static synchronized void clean()\n\t{\n\t\tcache.remove(FQN);\n\t}\n}",
  "metadata": {
    "fileId": "SecurityRepository_java_chunk_1",
    "fileName": "SecurityRepository.java",
    "filePath": "src/net/jforum/repository/SecurityRepository.java"
  }
}