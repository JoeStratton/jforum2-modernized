{
  "pageContent": "File Path: src/net/jforum/repository/TopicRepository.java\n\n Original Content: /*\n * Copyright (c) JForum Team\n * All rights reserved.\n * \n * Redistribution and use in source and binary forms, \n * with or without modification, are permitted provided \n * that the following conditions are met:\n * \n * 1) Redistributions of source code must retain the above \n * copyright notice, this list of conditions and the \n * following  disclaimer.\n * 2)  Redistributions in binary form must reproduce the \n * above copyright notice, this list of conditions and \n * the following disclaimer in the documentation and/or \n * other materials provided with the distribution.\n * 3) Neither the name of \"Rafael Steil\" nor \n * the names of its contributors may be used to endorse \n * or promote products derived from this software without \n * specific prior written permission.\n * \n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT \n * HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY \n * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, \n * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF \n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR \n * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL \n * THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE \n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, \n * EXEMPLARY, OR CONSEQUENTIAL DAMAGES \n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF \n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, \n * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER \n * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER \n * IN CONTRACT, STRICT LIABILITY, OR TORT \n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN \n * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF \n * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE\n * \n * This file creation date: 05/04/2004 - 20:11:44\n * The JForum Project\n * http://www.jforum.net\n */\npackage net.jforum.repository;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\n\nimport net.jforum.cache.CacheEngine;\nimport net.jforum.cache.Cacheable;\nimport net.jforum.dao.DataAccessDriver;\nimport net.jforum.dao.TopicDAO;\nimport net.jforum.entities.Topic;\nimport net.jforum.entities.TopicTypeComparator;\nimport net.jforum.util.preferences.ConfigKeys;\nimport net.jforum.util.preferences.SystemGlobals;\n\n/**\n * Repository for the last n topics for each forum.\n * \n * @author Rafael Steil\n * @author James Yong\n * @version $Id: TopicRepository.java,v 1.33 2007/09/05 04:00:27 rafaelsteil Exp $\n */\npublic class TopicRepository implements Cacheable\n{\n\tprivate static int maxItems = SystemGlobals.getIntValue(ConfigKeys.TOPICS_PER_PAGE);\n\t\n\tprivate static final String FQN = \"topics\";\n\tprivate static final String RECENT = \"recent\";\n\tprivate static final String HOTTEST = \"hottest\";\n\tprivate static final String FQN_FORUM = FQN + \"/byforum\";\n\tprivate static final String RELATION = \"relation\";\n\tprivate static final String FQN_LOADED = FQN + \"/loaded\";\n\tprivate static final Comparator TYPE_COMPARATOR = new TopicTypeComparator();\n\t\n\tprivate static CacheEngine cache;\n\t\n\t/**\n\t * @see net.jforum.cache.Cacheable#setCacheEngine(net.jforum.cache.CacheEngine)\n\t */\n\tpublic void setCacheEngine(CacheEngine engine)\n\t{\n\t\tcache = engine;\n\t}\n\t\n\tpublic static boolean isLoaded(int forumId)\n\t{\n\t\treturn \"1\".equals(cache.get(FQN_LOADED, Integer.toString(forumId)));\n\t}\n\n\t/**\n\t * Add topic to the FIFO stack\n\t * \n\t * @param topic The topic to add to stack\n\t */\n\tpublic synchronized static void pushTopic(Topic topic)\n\t{\n\t\tif (SystemGlobals.getBoolValue(ConfigKeys.TOPIC_CACHE_ENABLED)) {\n\t\t\tint limit = SystemGlobals.getIntValue(ConfigKeys.RECENT_TOPICS);\n\t\t\t\n\t\t\tLinkedList l = (LinkedList)cache.get(FQN, RECENT);\n\t\t\tif (l == null || l.size() == 0) {\n\t\t\t\tl = new LinkedList(loadMostRecentTopics());\n\t\t\t}\n\t\t\t\n\t\t\tl.remove(topic);\n\t\t\tl.addFirst(topic);\n\t\t\t\n\t\t\twhile (l.size() > limit) {\n\t\t\t\tl.removeLast();\n\t\t\t}\n\t\t\t\n\t\t\tcache.add(FQN, RECENT, l);\n\t\t}\n\t}\n\n\t/**\n\t * Get all cached recent topics. \n\t * \n\t */\t\n\tpublic static List getRecentTopics()\n\t{\n\t\tList l = (List)cache.get(FQN, RECENT);\n\t\t\n\t\tif (l == null || l.size() == 0\n\t\t\t|| !SystemGlobals.getBoolValue(ConfigKeys.TOPIC_CACHE_ENABLED)) {\n\t\t\tl = loadMostRecentTopics();\n\t\t}\n\t\t\n\t\treturn new ArrayList(l);\n\t}\t\n\n\t/**\n\t * Get all cached hottest topics.\n\t *\n\t */\n\tpublic static List getHottestTopics()\n\t{   \n\t    List l = (List)cache.get(FQN, HOTTEST);\n\t       \n\t    if (l == null || l.size() == 0\n\t        || !SystemGlobals.getBoolValue(ConfigKeys.TOPIC_CACHE_ENABLED)) {\n\t        l = loadHottestTopics();\n\t    }\n\t    \n\t    return new ArrayList(l);\n\t}\n\t\n\t/**\n\t * Add recent topics to the cache\n\t */\n\tpublic synchronized static List loadMostRecentTopics()\n\t{\n\t\tTopicDAO tm = DataAccessDriver.getInstance().newTopicDAO();\n\t\tint limit = SystemGlobals.getIntValue(ConfigKeys.RECENT_TOPICS);\n\t\t\n\t\tList l = tm.selectRecentTopics(limit);\n\t\tcache.add(FQN, RECENT, new LinkedList(l));\n\t\t\n\t\treturn l;\n\t}\n\n\t/**\n\t * Add hottest topics to the cache\n\t */\n\tpublic synchronized static List loadHottestTopics()\n\t{\n\t    TopicDAO tm = DataAccessDriver.getInstance().newTopicDAO();\n\t    int limit = SystemGlobals.getIntValue(ConfigKeys.HOTTEST_TOPICS);\n\t    \n\t    List l = tm.selectHottestTopics(limit);\n\t    cache.add(FQN, HOTTEST, new LinkedList(l));\n\t    \n\t    return l;\n\t}\n\t\n\t/**\n\t * Add topics to the cache\n\t * \n\t * @param forumId The forum id to which the topics are related\n\t * @param topics The topics to add\n\t */\n\tpublic static void addAll(int forumId, List topics)\n\t{\n\t\tif (SystemGlobals.getBoolValue(ConfigKeys.TOPIC_CACHE_ENABLED)) {\n\t\t\tsynchronized (FQN_FORUM) {\n\t\t\t\tcache.add(FQN_FORUM, Integer.toString(forumId), new LinkedList(topics));\n\t\t\t\t\n\t\t\t\tMap m = (Map)cache.get(FQN, RELATION);\n\t\t\t\t\n\t\t\t\tif (m == null) {\n\t\t\t\t\tm = new HashMap();\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tInteger fId = new Integer(forumId);\n\t\t\t\t\n\t\t\t\tfor (Iterator iter = topics.iterator(); iter.hasNext(); ) {\n\t\t\t\t\tTopic t = (Topic)iter.next();\n\t\t\t\t\t\n\t\t\t\t\tm.put(new Integer(t.getId()), fId);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tcache.add(FQN, RELATION, m);\n\t\t\t\tcache.add(FQN_LOADED, Integer.toString(forumId), \"1\");\n\t\t\t}\n\t\t}\n\t}\n\t\n\t/**\n\t * Clears the cache\n\t * \n\t * @param forumId The forum id to clear the cache\n\t */\n\tpublic static void clearCache(int forumId) \n\t{\n\t\tsynchronized (FQN_FORUM) {\n\t\t\tcache.add(FQN_FORUM, Integer.toString(forumId), new LinkedList());\n\t\t\tcache.remove(FQN, RELATION);\n\t\t}\n\t}\n\t\n\t/**\n\t * Adds a new topic to the cache\n\t * \n\t * @param topic The topic to add\n\t */\n\tpublic static void addTopic(Topic topic)\n\t{\n\t\tif (!SystemGlobals.getBoolValue(ConfigKeys.TOPIC_CACHE_ENABLED)) {\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tsynchronized (FQN_FORUM) {\n\t\t\tString forumId = Integer.toString(topic.getForumId());\n\t\t\tLinkedList list = (LinkedList)cache.get(FQN_FORUM, forumId);\n\t\t\t\n\t\t\tif (list == null) {\n\t\t\t\tlist = new LinkedList();\n\t\t\t\tlist.add(topic);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tboolean contains = list.contains(topic);\n\t\t\t\t\n\t\t\t\t// If the cache is full, remove the eldest element\n\t\t\t\tif (!contains && list.size() + 1 > maxItems) {\n\t\t\t\t\tlist.removeLast();\n\t\t\t\t}\n\t\t\t\telse if (contains) {\n\t\t\t\t\tlist.remove(topic);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tlist.add(topic);\n\t\t\t\t\n\t\t\t\tCollections.sort(list, TYPE_COMPARATOR);\n\t\t\t}\n\t\t\t\n\t\t\tcache.add(FQN_FORUM, forumId, list);\n\t\t\n\t\t\tMap m = (Map)cache.get(FQN, RELATION);\n\t\t\t\n\t\t\tif (m == null) {\n\t\t\t\tm = new HashMap();\n\t\t\t}\n\t\t\t\n\t\t\tm.put(new Integer(topic.getId()), new Integer(forumId));\n\t\t\t\n\t\t\tcache.add(FQN, RELATION, m);\n\t\t}\n\t}\n\t\n\t/**\n\t * Updates a cached topic\n\t * \n\t * @param topic The topic to update\n\t */\n\tpublic static void updateTopic(Topic topic)\n\t{\n\t\tif (SystemGlobals.getBoolValue(ConfigKeys.TOPIC_CACHE_ENABLED)) {\n\t\t\tsynchronized (FQN_FORUM) {\n\t\t\t\tString forumId = Integer.toString(topic.getForumId());\n\t\t\t\tList l = (List)cache.get(FQN_FORUM, forumId);\n\t\t\t\t\n\t\t\t\tif (l != null) {\n\t\t\t\t\tint index = l.indexOf(topic);\n\t\t\t\t\t\n\t\t\t\t\tif (index > -1) {\n\t\t\t\t\t\tl.set(index, topic);\n\t\t\t\t\t\tcache.add(FQN_FORUM, forumId, l);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t/**\n\t * Gets a cached topic.\n\t * \n\t * @param t The topic to try to get from the cache. The instance\n\t * passed as argument should have ae least the topicId and forumId set\n\t * @return The topic instance, if found, or <code>null</code> otherwise. \n\t */\n\tpublic static Topic getTopic(Topic t)\n\t{\n\t\tif (!SystemGlobals.getBoolValue(ConfigKeys.TOPIC_CACHE_ENABLED)) {\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\tif (t.getForumId() == 0) {\n\t\t\tMap m = (Map)cache.get(FQN, RELATION);\n\t\t\t\n\t\t\tif (m != null) {\n\t\t\t\tInteger forumId = (Integer)m.get(new Integer(t.getId()));\n\t\t\t\t\n\t\t\t\tif (forumId != null) {\n\t\t\t\t\tt.setForumId(forumId.intValue());\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (t.getForumId() == 0) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\t\n\t\tList l = (List)cache.get(FQN_FORUM, Integer.toString(t.getForumId()));\n\t\t\n\t\tint index = -1;\n\t\t\n\t\tif (l != null) {\n\t\t\tindex = l.indexOf(t);\n\t\t}\n\t\t\n\t\treturn (index == -1 ? null : (Topic)l.get(index));\n\t}\n\t\n\t/**\n\t * Checks if a topic is cached\n\t * \n\t * @param topic The topic to verify\n\t * @return <code>true</code> if the topic is cached, or <code>false</code> if not.\n\t */\n\tpublic static boolean isTopicCached(Topic topic)\n\t{\n\t\tif (!SystemGlobals.getBoolValue(ConfigKeys.TOPIC_CACHE_ENABLED)) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tString forumId = Integer.toString(topic.getForumId());\n\t\tList list = (List)cache.get(FQN_FORUM, forumId);\n\t\t\n\t\treturn list == null ? false : list.contains(topic);\n\t}\n\t\n\t/**\n\t * Get all cached topics related to a forum. \n\t * \n\t * @param forumid The forum id \n\t * @return <code>ArrayList</code> with the topics.\n\t */\n\tpublic static List getTopics(int forumid)\n\t{\n\t\tif (SystemGlobals.getBoolValue(ConfigKeys.TOPIC_CACHE_ENABLED)) {\n\t\t\tsynchronized (FQN_FORUM) {\n\t\t\t\tList returnList = (List)cache.get(FQN_FORUM, Integer.toString(forumid));\n\n\t\t\t\tif (returnList == null) {\n\t\t\t\t\treturn new ArrayList();\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\treturn new ArrayList(returnList);\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn new ArrayList();\n\t}\n}",
  "metadata": {
    "fileId": "TopicRepository_java_chunk_1",
    "fileName": "TopicRepository.java",
    "filePath": "src/net/jforum/repository/TopicRepository.java"
  }
}