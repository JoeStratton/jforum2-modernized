{
  "pageContent": "File Path: src/net/jforum/util/legacy/commons/fileupload/disk/DiskFileItem.java\n\n Original Content: /**\n     * Returns the contents of the file as a String, using the default\n     * character encoding.  This method uses {@link #get()} to retrieve the\n     * contents of the file.\n     *\n     * @return The contents of the file, as a string.\n     *\n     * @todo Consider making this method throw UnsupportedEncodingException.\n     */\n    public String getString() {\n        byte[] rawdata = get();\n        String charset = getCharSet();\n        if (charset == null) {\n            charset = DEFAULT_CHARSET;\n        }\n        try {\n            return new String(rawdata, charset);\n        } catch (UnsupportedEncodingException e) {\n            return new String(rawdata);\n        }\n    }\n\n\n    /**\n     * A convenience method to write an uploaded item to disk. The client code\n     * is not concerned with whether or not the item is stored in memory, or on\n     * disk in a temporary location. They just want to write the uploaded item\n     * to a file.\n     * <p>\n     * This implementation first attempts to rename the uploaded item to the\n     * specified destination file, if the item was originally written to disk.\n     * Otherwise, the data will be copied to the specified file.\n     * <p>\n     * This method is only guaranteed to work <em>once</em>, the first time it\n     * is invoked for a particular item. This is because, in the event that the\n     * method renames a temporary file, that file will no longer be available\n     * to copy or rename again at a later time.\n     *\n     * @param file The <code>File</code> into which the uploaded item should\n     *             be stored.\n     *\n     * @exception Exception if an error occurs.\n     */\n    public void write(File file) throws Exception {\n        if (isInMemory()) {\n            FileOutputStream fout = null;\n            try {\n                fout = new FileOutputStream(file);\n                fout.write(get());\n            } finally {\n                if (fout != null) {\n                    fout.close();\n                }\n            }\n        } else {\n            File outputFile = getStoreLocation();\n            if (outputFile != null) {\n                /*\n                 * The uploaded file is being stored on disk\n                 * in a temporary location so move it to the\n                 * desired file.\n                 */\n                if (!outputFile.renameTo(file)) {\n                    BufferedInputStream in = null;\n                    BufferedOutputStream out = null;\n                    try {\n                        in = new BufferedInputStream(\n                            new FileInputStream(outputFile));\n                        out = new BufferedOutputStream(\n                                new FileOutputStream(file));\n                        byte[] bytes = new byte[WRITE_BUFFER_SIZE];\n                        int s = 0;\n                        while ((s = in.read(bytes)) != -1) {\n                            out.write(bytes, 0, s);\n                        }\n                    } finally {\n                        if (in != null) {\n                            try {\n                                in.close();\n                            } catch (IOException e) {\n                                // ignore\n                            }\n                        }\n                        if (out != null) {\n                            try {\n                                out.close();\n                            } catch (IOException e) {\n                                // ignore\n                            }\n                        }\n                    }\n                }\n            } else {\n                /*\n                 * For whatever reason we cannot write the\n                 * file to disk.\n                 */\n                throw new FileUploadException(\n                    \"Cannot write uploaded file to disk!\");\n            }\n        }\n    }\n\n\n    /**\n     * Deletes the underlying storage for a file item, including deleting any\n     * associated temporary disk file. Although this storage will be deleted\n     * automatically when the <code>FileItem</code> instance is garbage\n     * collected, this method can be used to ensure that this is done at an\n     * earlier time, thus preserving system resources.\n     */\n    public void delete() {\n        cachedContent = null;\n        File outputFile = getStoreLocation();\n        if (outputFile != null && outputFile.exists()) {\n            outputFile.delete();\n        }\n    }\n\n\n    /**\n     * Returns the name of the field in the multipart form corresponding to\n     * this file item.\n     *\n     * @return The name of the form field.\n     *\n     * @see #setFieldName(java.lang.String)\n     *\n     */\n    public String getFieldName() {\n        return fieldName;\n    }\n\n\n    /**\n     * Sets the field name used to reference this file item.\n     *\n     * @param fieldName The name of the form field.\n     *\n     * @see #getFieldName()\n     *\n     */\n    public void setFieldName(String fieldName) {\n        this.fieldName = fieldName;\n    }\n\n\n    /**\n     * Determines whether or not a <code>FileItem</code> instance represents\n     * a simple form field.\n     *\n     * @return <code>true</code> if the instance represents a simple form\n     *         field; <code>false</code> if it represents an uploaded file.\n     *\n     * @see #setFormField(boolean)\n     *\n     */\n    public boolean isFormField() {\n        return isFormField;\n    }\n\n\n    /**\n     * Specifies whether or not a <code>FileItem</code> instance represents\n     * a simple form field.\n     *\n     * @param state <code>true</code> if the instance represents a simple form\n     *              field; <code>false</code> if it represents an uploaded file.\n     *\n     * @see #isFormField()\n     *\n     */\n    public void setFormField(boolean state) {\n        isFormField = state;\n    }\n\n\n    /**\n     * Returns an {@link java.io.OutputStream OutputStream} that can\n     * be used for storing the contents of the file.\n     *\n     * @return An {@link java.io.OutputStream OutputStream} that can be used\n     *         for storing the contensts of the file.\n     *\n     * @exception IOException if an error occurs.\n     */\n    public OutputStream getOutputStream()\n        throws IOException {\n        if (dfos == null) {\n            File outputFile = getTempFile();\n            dfos = new DeferredFileOutputStream(sizeThreshold, outputFile);\n        }\n        return dfos;\n    }\n\n\n    // --------------------------------------------------------- Public methods\n\n\n    /**\n     * Returns the {@link java.io.File} object for the <code>FileItem</code>'s\n     * data's temporary location on the disk. Note that for\n     * <code>FileItem</code>s that have their data stored in memory,\n     * this method will return <code>null</code>. When handling large\n     * files, you can use {@link java.io.File#renameTo(java.io.File)} to\n     * move the file to new location without copying the data, if the\n     * source and destination locations reside within the same logical\n     * volume.\n     *\n     * @return The data file, or <code>null</code> if the data is stored in\n     *         memory.\n     */\n    public File getStoreLocation() {\n        return dfos.getFile();\n    }\n\n\n    // ------------------------------------------------------ Protected methods\n\n\n    /**\n     * Removes the file contents from the temporary storage.\n     */\n    protected void finalize() {\n        File outputFile = dfos.getFile();\n\n        if (outputFile != null && outputFile.exists()) {\n            outputFile.delete();\n        }\n    }\n\n\n    /**\n     * Creates and returns a {@link java.io.File File} representing a uniquely\n     * named temporary file in the configured repository path. The lifetime of\n     * the file is tied to the lifetime of the <code>FileItem</code> instance;\n     * the file will be deleted when the instance is garbage collected.\n     *\n     * @return The {@link java.io.File File} to be used for temporary storage.\n     */\n    protected File getTempFile() {\n        File tempDir = repository;\n        if (tempDir == null) {\n            tempDir = new File(System.getProperty(\"java.io.tmpdir\"));\n        }\n\n        String fileName = \"upload_\" + getUniqueId() + \".tmp\";\n\n        File f = new File(tempDir, fileName);\n        FileCleaner.track(f, this);\n        return f;\n    }\n\n\n    // -------------------------------------------------------- Private methods\n\n\n    /**\n     * Returns an identifier that is unique within the class loader used to\n     * load this class, but does not have random-like apearance.\n     *\n     * @return A String with the non-random looking instance identifier.\n     */\n    private static String getUniqueId() {\n        int current;\n        synchronized (DiskFileItem.class) {\n            current = counter++;\n        }\n        String id = Integer.toString(current);\n\n        // If you manage to get more than 100 million of ids, you'll\n        // start getting ids longer than 8 characters.\n        if (current < 100000000) {\n            id = (\"00000000\" + id).substring(id.length());\n        }\n        return id;\n    }\n    \n    public String toString() {\n    \treturn \"name=\" + this.getName()\n\t\t\t+ \", StoreLocation=\" \n\t\t\t+ String.valueOf(this.getStoreLocation())\n\t\t\t+ \", size=\"\n\t\t\t+ this.getSize()\n\t\t\t+ \"bytes, \"\n\t\t\t+ \"isFormField=\" + isFormField()\n\t\t\t+ \", FieldName=\"\n\t\t\t+ this.getFieldName();\n    }\n\n}",
  "metadata": {
    "fileId": "DiskFileItem_java_chunk_3",
    "fileName": "DiskFileItem.java",
    "filePath": "src/net/jforum/util/legacy/commons/fileupload/disk/DiskFileItem.java"
  }
}