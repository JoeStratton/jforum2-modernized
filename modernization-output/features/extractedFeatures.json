[
  {
    "featureName": "InitializeConnectionPool",
    "description": "Initializes a database connection pool with configurable parameters.",
    "inputValues": [
      "driverClass-string-ConnectionConfig",
      "jdbcUrl-string-ConnectionConfig",
      "minPoolSize-number-ConnectionConfig",
      "maxPoolSize-number-ConnectionConfig",
      "idleConnectionTestPeriod-number-ConnectionConfig",
      "extraParams-string-ConnectionConfig"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the following configuration parameters:\n     a. driverClass (mandatory): Database driver class name\n     b. jdbcUrl (mandatory): Database connection URL\n     c. minPoolSize (mandatory): Minimum number of connections to maintain\n     d. maxPoolSize (mandatory): Maximum number of connections allowed\n     e. idleConnectionTestPeriod (mandatory): Time interval for testing idle connections\n     f. extraParams (optional): Additional configuration parameters as key-value pairs\n\n2. Data Validation:\n   - Validate driverClass:\n     a. Check if the value is not empty\n     b. Verify the driver class exists in the system\n     c. IF validation fails, THEN generate error message indicating invalid driver class\n   - Validate jdbcUrl:\n     a. Check if the value is not empty\n     b. Verify the URL format is valid for database connections\n     c. IF validation fails, THEN generate error message indicating invalid connection URL\n   - Validate minPoolSize:\n     a. Check if the value is a positive integer\n     b. Verify the value is less than or equal to maxPoolSize\n     c. IF validation fails, THEN generate error message indicating invalid minimum pool size\n   - Validate maxPoolSize:\n     a. Check if the value is a positive integer\n     b. Verify the value is greater than or equal to minPoolSize\n     c. IF validation fails, THEN generate error message indicating invalid maximum pool size\n   - Validate idleConnectionTestPeriod:\n     a. Check if the value is a non-negative integer\n     b. IF validation fails, THEN generate error message indicating invalid test period\n   - Validate extraParams (if provided):\n     a. Check if the format follows the pattern of \"key=value;key=value\"\n     b. IF validation fails, THEN generate error message indicating invalid extra parameters format\n\n3. Business Rule Processing:\n   - Check system resources:\n     a. Verify the system has sufficient memory for the requested pool size\n     b. IF memory is insufficient, THEN adjust maxPoolSize to a safe default value\n   - Verify database accessibility:\n     a. Check if the database server is reachable\n     b. IF database server is unreachable, THEN generate appropriate error message\n   - Determine appropriate pool settings based on system load:\n     a. IF system is under high load, THEN recommend optimal pool settings\n     b. IF minPoolSize is too low for expected traffic, THEN log a warning\n\n4. Core Operation Execution:\n   - Initialize the connection pool:\n     a. Create a new connection pool instance\n     b. Apply the basic configuration parameters (driverClass, jdbcUrl, minPoolSize, maxPoolSize, idleConnectionTestPeriod)\n     c. IF initialization fails, THEN generate detailed error message and abort\n   - Process extra parameters (if provided):\n     a. Parse the extraParams string by splitting on semicolons\n     b. FOR EACH parameter pair:\n        i. Split the pair on equals sign to get key and value\n        ii. Determine the appropriate data type for the value\n        iii. Apply the parameter to the connection pool\n        iv. IF parameter application fails, THEN log warning and continue\n   - Verify pool initialization:\n     a. Test connection acquisition from the pool\n     b. IF test connection fails, THEN generate error message and attempt recovery\n     c. Release test connection back to the pool\n\n5. Response Generation:\n   - IF pool initialization is successful:\n     a. Generate success response with pool statistics\n     b. Include current pool size, available connections, and configuration summary\n     c. Provide methods for connection acquisition and release\n   - IF pool initialization fails:\n     a. Generate detailed error response\n     b. Include specific error conditions encountered\n     c. Provide troubleshooting suggestions based on error type\n     d. Include support contact information",
    "databaseEntities": [],
    "validationRules": [
      "Driver class must not be empty and must exist in the system",
      "JDBC URL must not be empty and must be in valid format",
      "Minimum pool size must be a positive integer",
      "Maximum pool size must be a positive integer and greater than or equal to minimum pool size",
      "Idle connection test period must be a non-negative integer",
      "Extra parameters must follow the format 'key=value;key=value' if provided"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "ConnectionConfig": {
        "type": "object",
        "properties": {
          "driverClass": {
            "type": "string",
            "description": "Database driver class name"
          },
          "jdbcUrl": {
            "type": "string",
            "description": "Database connection URL"
          },
          "minPoolSize": {
            "type": "number",
            "description": "Minimum number of connections to maintain"
          },
          "maxPoolSize": {
            "type": "number",
            "description": "Maximum number of connections allowed"
          },
          "idleConnectionTestPeriod": {
            "type": "number",
            "description": "Time interval for testing idle connections"
          },
          "extraParams": {
            "type": "string",
            "description": "Additional configuration parameters as key-value pairs"
          }
        },
        "required": [
          "driverClass",
          "jdbcUrl",
          "minPoolSize",
          "maxPoolSize",
          "idleConnectionTestPeriod"
        ]
      }
    }
  },
  {
    "featureName": "GetDatabaseConnection",
    "description": "Provides database connections from the connection pool.",
    "inputValues": [],
    "businessLogic": "1. Input Collection:\n   - No explicit input parameters required\n   - System configuration values are used internally:\n     - Database connection driver\n     - Database connection string\n     - These values are retrieved from system configuration\n\n2. Data Validation:\n   - Validate system configuration:\n     - Check if database connection driver is properly configured\n     - Verify database connection string is valid and properly formatted\n     - Ensure all required database parameters are available\n   - IF any configuration validation fails THEN:\n     - Generate appropriate error message\n     - Mark database status as unavailable\n     - Return error response with configuration issue details\n\n3. Business Rule Processing:\n   - Check system state:\n     - Verify if database driver class can be loaded\n     - Check if database is already marked as available or unavailable\n     - Determine if a test connection can be established\n   - Apply connection rules:\n     - Determine if connection pooling is enabled or disabled\n     - Check if system is in initialization phase or normal operation\n     - Verify if database is in a state to accept connections\n\n4. Core Operation Execution:\n   - Acquire database connection:\n     - Request new connection directly from database driver\n     - Use system-configured connection string to establish connection\n     - Apply any connection-specific configurations\n     - Set appropriate timeout values if configured\n   - IF connection acquisition fails THEN:\n     - Log detailed error information\n     - Mark database as unavailable\n     - Prepare failure response with diagnostic information\n     - Throw appropriate exception with error details\n   - Test connection validity:\n     - Perform basic validation of the connection\n     - Verify connection is responsive\n     - Release test connection if in initialization phase\n\n5. Response Generation:\n   - For successful connection:\n     - Return valid database connection to requestor\n     - Update system state to indicate database is available\n   - For failed connection:\n     - Include detailed error information\n     - Mark system state to indicate database is unavailable\n     - Provide error details in the exception\n   - Connection release handling:\n     - Properly close the connection when released\n     - Handle null connections gracefully during release\n     - Ensure all resources are properly closed",
    "databaseEntities": [],
    "validationRules": [
      "Database driver must be properly configured in system globals",
      "Database connection string must be valid and properly formatted",
      "Database driver class must be loadable",
      "Test connection must be successful during initialization",
      "Connection must be properly released after use",
      "Null connections should be handled gracefully during release"
    ],
    "dbSeedingOperations": [],
    "schema": {}
  },
  {
    "featureName": "ReleaseConnection",
    "description": "Returns database connections to the pool after use.",
    "inputValues": [
      "connection-object-Connection"
    ],
    "businessLogic": "1. Input Collection:\n   - Receive database connection object (mandatory)\n   - System determines if connection is valid for release\n\n2. Data Validation:\n   - Check if connection object is null\n     * IF connection is null THEN\n       - Skip release process\n       - Exit feature without error\n     * ELSE\n       - Proceed to connection release process\n   - Verify connection is in a state that can be released\n     * Check connection is not already closed\n     * Ensure connection belongs to the managed pool\n\n3. Business Rule Processing:\n   - Determine if connection needs special handling before release\n     * Check for any uncommitted transactions\n     * Verify no statements are still open on this connection\n   - Prepare connection for return to pool\n     * Reset any connection-specific settings to default values\n     * Clear any connection warnings\n\n4. Core Operation Execution:\n   - Release the database connection back to the connection pool\n     * Return the physical connection to the pool manager\n     * Update internal pool statistics\n     * Mark the logical connection as closed\n   - Handle any exceptions during release process\n     * Log exception details\n     * Ensure resources are properly cleaned up even if errors occur\n     * Suppress and contain exceptions to prevent propagation\n\n5. Response Generation:\n   - No explicit response needed for successful operation\n   - For any errors during release:\n     * Log detailed error information\n     * Include connection identifier in error logs\n     * Provide diagnostic information for troubleshooting\n     * Contain errors within the release process to maintain system stability",
    "databaseEntities": [],
    "validationRules": [
      "Connection object must be properly initialized before release",
      "Connection must belong to the managed connection pool",
      "System must handle null connections gracefully",
      "Exceptions during connection release must be contained and not propagated"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Connection": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "Unique identifier for the connection"
          },
          "status": {
            "type": "string",
            "description": "Current status of the connection (active, idle, closed)"
          },
          "creationTime": {
            "type": "number",
            "description": "Timestamp when connection was created"
          },
          "poolIdentifier": {
            "type": "string",
            "description": "Identifier of the pool this connection belongs to"
          }
        }
      }
    }
  },
  {
    "featureName": "ReleaseAllConnections",
    "description": "Destroys the connection pool and releases all database connections.",
    "inputValues": [],
    "businessLogic": "1. Input Collection:\n   - No user inputs required\n   - System will use existing connection pool configuration\n\n2. Data Validation:\n   - Verify connection pool exists\n     - IF connection pool is null THEN\n       - Generate error: \"Connection pool not initialized\"\n       - Exit process\n     - END IF\n\n3. Business Rule Processing:\n   - Check system state for active operations\n     - IF critical database operations are in progress THEN\n       - Generate warning: \"Active operations detected\"\n       - Request confirmation to proceed\n       - IF confirmation denied THEN\n         - Exit process\n       - END IF\n     - END IF\n   - Verify administrator privileges\n     - IF current user does not have administrator privileges THEN\n       - Generate error: \"Insufficient permissions to release connections\"\n       - Exit process\n     - END IF\n\n4. Core Operation Execution:\n   - Log connection pool statistics before shutdown\n     - Record current active connections count\n     - Record idle connections count\n     - Record uptime statistics\n   - Initiate connection pool shutdown sequence\n     - Mark pool as shutting down to prevent new connections\n     - Wait for in-use connections to complete (with timeout)\n     - Release all idle connections\n     - Destroy connection pool resources\n     - Clear internal references to connection objects\n   - Update system state\n     - Mark database connection status as disconnected\n     - Update system availability indicators\n\n5. Response Generation:\n   - IF shutdown completed successfully THEN\n     - Generate success response: \"All database connections successfully released\"\n     - Include statistics summary of released connections\n   - ELSE\n     - Generate error response with details of failed shutdown\n     - Include troubleshooting information\n     - Provide recovery steps for administrators\n   - END IF",
    "databaseEntities": [],
    "validationRules": [
      "Connection pool must be initialized before release",
      "User must have administrator privileges to release connections",
      "System should warn if active operations are in progress"
    ],
    "dbSeedingOperations": [],
    "schema": {}
  },
  {
    "featureName": "ConfigurePoolParameters",
    "description": "Applies custom configuration parameters to the connection pool.",
    "inputValues": [
      "extraParams-string-ConnectionPool",
      "poolConfiguration-object-PoolConfig"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the following inputs:\n     - extraParams (string): Semi-colon separated list of key-value pairs in format \"property=value;property2=value2\"\n     - poolConfiguration (object): Object containing predefined pool configuration settings\n     - System configuration values (system-generated): Retrieved from system configuration store\n   \n2. Data Validation:\n   - Validate extraParams format:\n     - IF extraParams is provided THEN\n       - Verify it follows the pattern of \"property=value;property2=value2\"\n       - Ensure each property name is non-empty\n       - Ensure each property has a corresponding value\n     - END IF\n   - Validate poolConfiguration object:\n     - Verify minimum pool size is a positive integer\n     - Verify maximum pool size is greater than or equal to minimum pool size\n     - Verify connection test period is a non-negative integer\n     - IF any validation fails THEN\n       - Generate appropriate error message\n       - Abort configuration process\n     - END IF\n\n3. Business Rule Processing:\n   - Check system state:\n     - Verify connection pool is in a configurable state\n     - Ensure database driver is available\n     - Validate connection string format\n   - Process configuration constraints:\n     - Ensure minimum pool size does not exceed system-defined threshold\n     - Ensure maximum pool size does not exceed system-defined threshold\n     - Verify idle connection test period is within acceptable range\n     - IF any constraint is violated THEN\n       - Log warning or error based on severity\n       - Apply default or adjusted values as appropriate\n     - END IF\n\n4. Core Operation Execution:\n   - Initialize connection pool with base configuration:\n     - Set database driver class\n     - Configure connection URL\n     - Set minimum and maximum pool sizes\n     - Set idle connection test period\n   - Process extra parameters:\n     - IF extraParams is provided and valid THEN\n       - Split parameter string by semicolon delimiter\n       - FOR EACH parameter pair:\n         - Split into key and value\n         - IF key and value are properly formatted THEN\n           - Determine appropriate data type for the parameter\n           - Convert value to appropriate type (string, integer, boolean)\n           - Apply parameter to connection pool configuration\n         - ELSE\n           - Log warning about skipping malformed parameter\n           - Continue to next parameter\n         - END IF\n       - END FOR\n     - END IF\n   - Finalize pool configuration:\n     - Apply any remaining system defaults not explicitly set\n     - Initialize connection pool with complete configuration\n     - Test connection to verify configuration success\n\n5. Response Generation:\n   - IF configuration process completes successfully THEN\n     - Return success status\n     - Include summary of applied configuration parameters\n     - Include connection pool statistics (current size, available connections)\n   - ELSE\n     - Return error status\n     - Include detailed error information\n     - Provide troubleshooting suggestions\n     - Include system support contact information\n   - END IF",
    "databaseEntities": [],
    "validationRules": [
      "Extra parameters must follow the format 'property=value;property2=value2'",
      "Property names must be non-empty strings",
      "Minimum pool size must be a positive integer",
      "Maximum pool size must be greater than or equal to minimum pool size",
      "Idle connection test period must be a non-negative integer",
      "Database driver must be available in the system",
      "Connection string must be properly formatted"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "PoolConfig": {
        "type": "object",
        "properties": {
          "minPoolSize": {
            "type": "integer",
            "description": "Minimum number of connections to maintain in the pool"
          },
          "maxPoolSize": {
            "type": "integer",
            "description": "Maximum number of connections allowed in the pool"
          },
          "idleConnectionTestPeriod": {
            "type": "integer",
            "description": "Period in seconds between tests of idle connections"
          },
          "driverClass": {
            "type": "string",
            "description": "Database driver class name"
          },
          "jdbcUrl": {
            "type": "string",
            "description": "Database connection URL"
          }
        },
        "required": [
          "minPoolSize",
          "maxPoolSize",
          "idleConnectionTestPeriod",
          "driverClass",
          "jdbcUrl"
        ]
      }
    }
  },
  {
    "featureName": "ProcessRequest",
    "description": "Processes HTTP requests by invoking the appropriate action method based on request parameters.",
    "inputValues": [
      "request-object-RequestContext",
      "response-object-ResponseContext",
      "context-object-SimpleHash"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the request object containing user action and parameters\n   - Collect the response object for sending output back to the user\n   - Collect the context object containing data for template rendering\n   - System identifies the requested action from the request parameters\n\n2. Data Validation:\n   - Validate that the request object is properly initialized\n     * Check if request contains a valid action parameter\n     * Verify that action parameter follows naming conventions\n   - Validate that the response object is properly initialized\n     * Ensure response can be written to\n   - Validate that the context object is properly initialized\n     * Verify context can store template variables\n   - IF any validation fails, THEN prepare appropriate error message\n\n3. Business Rule Processing:\n   - Check if the action should be ignored based on system state\n     * IF ignoreAction flag is set to true, THEN skip action method invocation\n   - Determine if the user has permission to execute the requested action\n     * Verify user authentication status if required\n     * Check user authorization for the specific action\n   - Verify that the system is in a valid state to process the request\n     * Check if the system is in maintenance mode\n     * Verify that required services are available\n\n4. Core Operation Execution:\n   - IF not ignoring action, THEN:\n     * Attempt to find a method matching the requested action name\n     * IF method exists, THEN:\n       - Invoke the method with no parameters\n       - Capture any results or state changes\n     * IF method does not exist, THEN:\n       - Fall back to the default list() method\n       - Log that a fallback occurred\n   - Check if a redirect has been set during processing\n     * IF redirect exists, THEN set template to empty\n   - Check if a custom template has been specified\n     * IF custom template attribute exists in request, THEN use it\n   - Check if custom content flag is set\n     * IF custom content is enabled, THEN skip template processing\n\n5. Response Generation:\n   - IF no template name is set after processing, THEN:\n     * Generate an error indicating missing template configuration\n   - IF template name is set, THEN:\n     * Load the template from the configured template directory\n     * Apply the context data to the template\n     * Generate the final rendered output\n   - Return the processed template for rendering\n   - IF any errors occurred during processing:\n     * Generate appropriate error messages\n     * Set error status in response\n     * Provide troubleshooting information when applicable",
    "databaseEntities": [],
    "validationRules": [
      "Request object must not be null",
      "Response object must not be null",
      "Context object must not be null",
      "Action name must be a valid method name",
      "Template name must be defined before rendering"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "RequestContext": {
        "type": "object",
        "properties": {
          "action": {
            "type": "string",
            "description": "The name of the action to be executed"
          },
          "parameters": {
            "type": "object",
            "description": "Collection of request parameters"
          },
          "attributes": {
            "type": "object",
            "description": "Collection of request attributes"
          }
        }
      },
      "ResponseContext": {
        "type": "object",
        "properties": {
          "contentType": {
            "type": "string",
            "description": "The content type of the response"
          },
          "status": {
            "type": "number",
            "description": "The HTTP status code"
          }
        }
      },
      "SimpleHash": {
        "type": "object",
        "properties": {
          "variables": {
            "type": "object",
            "description": "Collection of template variables"
          }
        }
      }
    }
  },
  {
    "featureName": "RenderTemplate",
    "description": "Renders the appropriate template view after processing the request action.",
    "inputValues": [
      "requestContext-object-RequestContext",
      "responseContext-object-ResponseContext",
      "templateContext-object-SimpleHash",
      "action-string-Action"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect RequestContext object containing request parameters and attributes\n   - Collect ResponseContext object for managing response data\n   - Collect SimpleHash context object for template data\n   - Collect action name as string\n   - System will use templateName (initially null) to track selected template\n\n2. Data Validation:\n   - Validate RequestContext is not null\n     * IF RequestContext is null THEN generate error message \"Request context cannot be null\"\n   - Validate ResponseContext is not null\n     * IF ResponseContext is null THEN generate error message \"Response context cannot be null\"\n   - Validate SimpleHash context is not null\n     * IF SimpleHash context is null THEN generate error message \"Template context cannot be null\"\n   - Validate action string is properly formatted\n     * IF action is null THEN use default action \"list\"\n     * IF action contains invalid characters THEN generate error message \"Invalid action name format\"\n\n3. Business Rule Processing:\n   - Check if action should be ignored\n     * IF ignoreAction flag is true THEN skip action processing\n   - Determine if action method exists\n     * IF action method exists in current class THEN prepare to invoke it\n     * IF action method does not exist THEN prepare to use default list method\n   - Check for custom content flag\n     * IF custom content flag is set THEN prepare to skip template rendering\n   - Check for redirect flag\n     * IF redirect flag is set THEN prepare to use empty template\n\n4. Core Operation Execution:\n   - Store request, response and context objects in class fields\n   - IF not ignoring action THEN:\n     * TRY to invoke the method matching the action name\n     * IF method not found THEN invoke the list() method\n     * IF any exception occurs during invocation THEN handle the exception appropriately\n   - Determine template name:\n     * IF redirect is requested THEN set template to empty template\n     * ELSE IF request has template attribute THEN use that template\n     * ELSE use template name set during action processing\n   - IF custom content flag is set THEN:\n     * Skip template rendering\n     * Return null template\n   - IF template name is still null THEN:\n     * Generate template not found error\n   - Load the template from the template configuration:\n     * Combine template directory path with template name\n     * Load template from the template engine\n     * IF template loading fails THEN generate appropriate error\n\n5. Response Generation:\n   - Return the loaded template object for rendering\n   - IF template loading successful THEN provide template to view renderer\n   - IF template loading failed THEN provide error details\n   - IF redirect requested THEN handle redirect instead of template rendering\n   - IF custom content requested THEN return null to allow custom handling",
    "databaseEntities": [],
    "validationRules": [
      "Request context must not be null",
      "Response context must not be null",
      "Template context must not be null",
      "Action name must be a valid method name",
      "Template name must be defined before rendering",
      "Template must exist in the template directory"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "RequestContext": {
        "type": "object",
        "properties": {
          "action": {
            "type": "string",
            "description": "The action to be performed"
          },
          "attributes": {
            "type": "object",
            "description": "Collection of request attributes"
          }
        }
      },
      "ResponseContext": {
        "type": "object",
        "properties": {
          "contentType": {
            "type": "string",
            "description": "Content type of the response"
          }
        }
      },
      "SimpleHash": {
        "type": "object",
        "description": "Template data context containing variables for rendering"
      }
    }
  },
  {
    "featureName": "StartSystemGlobals",
    "description": "Initializes system configuration by loading properties from configuration files.",
    "inputValues": [
      "appPath-string-SystemConfig"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect application root path (appPath) as a string\n   - System will use this path to locate configuration files\n   - The appPath is mandatory and must be a valid directory path\n\n2. Data Validation:\n   - Validate appPath exists and is accessible\n     a. Check if the directory exists\n     b. Verify read permissions for the directory\n     c. IF validation fails, THEN generate appropriate error message\n   - Validate required configuration files exist\n     a. Check for main configuration file in the expected location\n     b. IF main configuration file is missing, THEN generate error message\n\n3. Business Rule Processing:\n   - Determine configuration loading sequence\n     a. Identify primary configuration file location\n     b. Identify database-specific configuration file\n     c. Check for existence of installation-specific configuration\n   - Prepare configuration environment\n     a. Initialize global configuration container\n     b. Set application path in the configuration\n\n4. Core Operation Execution:\n   - Load primary configuration file\n     a. Read all key-value pairs from main configuration file\n     b. Store configuration values in memory\n     c. IF file reading fails, THEN log error and terminate process\n   - Load database-specific configuration\n     a. Retrieve database driver configuration path from primary settings\n     b. Load additional configuration values from database-specific file\n     c. Merge with existing configuration values\n   - Load installation-specific configuration (if available)\n     a. Check if installation configuration file exists\n     b. IF exists, THEN load and merge its values with existing configuration\n     c. Override any duplicate settings with installation-specific values\n   - Initialize system with loaded configuration\n     a. Apply all configuration settings to the system\n     b. Make configuration values available system-wide\n\n5. Response Generation:\n   - Confirm successful configuration loading\n     a. Verify all required configuration values are present\n     b. Log successful initialization with configuration summary\n     c. Return success status\n   - Handle configuration errors\n     a. Generate detailed error messages for any configuration issues\n     b. Log configuration failures with specific reasons\n     c. Provide troubleshooting information",
    "databaseEntities": [],
    "validationRules": [
      "Application path must be a valid directory",
      "Application path must have read permissions",
      "Main configuration file must exist at the specified location",
      "Configuration files must be properly formatted",
      "Required configuration keys must be present in the loaded files"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "SystemConfig": {
        "type": "object",
        "properties": {
          "appPath": {
            "type": "string",
            "description": "The application root directory path"
          }
        },
        "required": [
          "appPath"
        ]
      }
    }
  },
  {
    "featureName": "LoadModulesMapping",
    "description": "Loads module mappings from properties file to configure system modules.",
    "inputValues": [
      "baseConfigDir-string-ConfigDirectory"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the base configuration directory path (baseConfigDir) as a string\n   - This directory must contain the modulesMapping.properties file\n   - The baseConfigDir is mandatory and must be a valid directory path\n\n2. Data Validation:\n   - Validate that baseConfigDir is not null or empty\n     * IF baseConfigDir is null or empty THEN generate error message \"Configuration directory path cannot be empty\"\n   - Validate that baseConfigDir exists and is a directory\n     * IF baseConfigDir does not exist THEN generate error message \"Configuration directory does not exist\"\n     * IF baseConfigDir is not a directory THEN generate error message \"Path is not a valid directory\"\n   - Validate that modulesMapping.properties file exists in the baseConfigDir\n     * IF modulesMapping.properties does not exist THEN generate error message \"Module mapping file not found in configuration directory\"\n\n3. Business Rule Processing:\n   - Check file access permissions\n     * Verify read permissions for the modulesMapping.properties file\n     * IF file is not readable THEN generate error message \"Cannot read module mapping file due to permission issues\"\n   - Check file format validity\n     * Ensure the file is a valid properties file\n     * IF file format is invalid THEN generate error message \"Module mapping file has invalid format\"\n\n4. Core Operation Execution:\n   - Create a new Properties object to store module mappings\n   - Open file input stream to the modulesMapping.properties file\n     * IF file cannot be opened THEN generate error message \"Failed to open module mapping file\"\n   - Load properties from the file input stream\n     * IF properties cannot be loaded THEN generate error message \"Failed to load module mappings from file\"\n   - Close the file input stream\n     * Ensure the stream is closed even if an exception occurs\n   - Store loaded properties in memory for system use\n     * Maintain the key-value pairs for module name to class mappings\n\n5. Response Generation:\n   - Return the loaded Properties object containing all module mappings\n     * The Properties object contains key-value pairs where keys are module identifiers and values are implementation class names\n   - In case of errors:\n     * Return appropriate error message indicating the nature of the failure\n     * Include suggestions for resolving common issues\n   - Log the successful loading of module mappings\n     * Include the number of modules loaded",
    "databaseEntities": [],
    "validationRules": [
      "Base configuration directory path must not be empty",
      "Base configuration directory must exist",
      "Module mapping file must exist in the specified directory",
      "Module mapping file must be readable",
      "Module mapping file must be a valid properties file"
    ],
    "dbSeedingOperations": [],
    "schema": {}
  },
  {
    "featureName": "CreateLoginAuthenticator",
    "description": "Creates an instance of the configured login authenticator for user authentication.",
    "inputValues": [
      "authenticatorClassName-string-LoginAuthenticator"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect authenticatorClassName (string, mandatory) - The fully qualified class name of the login authenticator to instantiate\n   - System will retrieve configuration from system globals\n\n2. Data Validation:\n   - Validate authenticatorClassName:\n     a. Check if authenticatorClassName is not null or empty\n     b. Verify the authenticatorClassName follows proper class naming convention\n     c. If validation fails, prepare appropriate error message\n\n3. Business Rule Processing:\n   - Verify system state:\n     a. Check if system configuration is properly initialized\n     b. Ensure the system has proper access to class loading mechanisms\n     c. Verify the authenticator configuration exists in the system\n\n4. Core Operation Execution:\n   - Load the authenticator class:\n     a. Use class loading mechanism to find the specified authenticator class\n     b. IF class is not found, generate appropriate error with class name details\n     c. Verify the loaded class implements the required LoginAuthenticator interface\n   - Create authenticator instance:\n     a. Instantiate a new object of the authenticator class\n     b. IF instantiation fails, generate appropriate error with details\n     c. Store the created authenticator instance in the system for future authentication requests\n   - Initialize the authenticator:\n     a. IF the authenticator requires initialization, call its initialization method\n     b. Pass any required system configuration to the authenticator\n     c. Verify the authenticator is properly initialized and ready for use\n\n5. Response Generation:\n   - Success response:\n     a. Return confirmation that the authenticator was successfully created\n     b. Include the type of authenticator that was created\n   - Error response:\n     a. For class not found errors, provide details about the missing class\n     b. For instantiation errors, provide details about why instantiation failed\n     c. For initialization errors, provide details about the initialization failure\n     d. Include suggestions for resolving the error",
    "databaseEntities": [
      "jforum_users",
      "jforum_groups",
      "jforum_user_groups"
    ],
    "validationRules": [
      "Authenticator class name must not be empty",
      "Authenticator class must implement the LoginAuthenticator interface",
      "Authenticator class must have a public no-argument constructor",
      "Authenticator class must be accessible from the application's classpath"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "LoginAuthenticator": {
        "type": "object",
        "properties": {
          "className": {
            "type": "string",
            "description": "The fully qualified class name of the login authenticator"
          },
          "instance": {
            "type": "object",
            "description": "The instantiated authenticator object"
          }
        },
        "required": [
          "className"
        ]
      }
    }
  },
  {
    "featureName": "LoadUrlPatterns",
    "description": "Loads URL patterns from configuration file for request routing.",
    "inputValues": [
      "configFilePath-string-ConfigFile"
    ],
    "businessLogic": "1. Input Collection\n   - Collect the configuration file path (configFilePath) as a string\n   - System will use default path if not explicitly provided\n   - Configuration file must be in properties format\n\n2. Data Validation\n   - Validate configuration file path\n     - Check if file exists at the specified location\n     - Verify file has proper read permissions\n     - Confirm file has the correct format (.properties)\n   - IF file does not exist\n     - Generate appropriate error message\n     - Log error details\n     - Terminate process\n   - IF file exists but cannot be read\n     - Generate permission error message\n     - Log access error details\n     - Terminate process\n\n3. Business Rule Processing\n   - Check system readiness for URL pattern loading\n     - Verify system initialization is complete\n     - Ensure no conflicting operations are in progress\n   - Prepare resources for file reading operation\n     - Initialize property container for patterns\n     - Set up file input stream\n   - Validate file structure\n     - Check if file contains valid key-value pairs\n     - Verify pattern format compliance\n\n4. Core Operation Execution\n   - Open file input stream to the configuration file\n   - Load all properties from the file into memory\n   - FOR each key-value pair in the properties file\n     - Extract the pattern key (URL identifier)\n     - Extract the pattern value (URL pattern)\n     - Add the pattern to the URL pattern collection\n     - Log successful addition of pattern\n   - Close file input stream properly\n   - Handle any exceptions during file processing\n     - Log detailed error information\n     - Convert to appropriate system exception\n     - Ensure resources are properly released\n\n5. Response Generation\n   - Compile summary of loaded patterns\n     - Count of successfully loaded patterns\n     - List of any patterns that could not be loaded\n   - Log completion of URL pattern loading process\n   - Return success status or throw exception if process failed\n   - Notify dependent components about pattern updates",
    "databaseEntities": [],
    "validationRules": [
      "Configuration file must exist at the specified path",
      "Configuration file must be readable",
      "Configuration file must contain valid key-value pairs",
      "URL patterns must follow the system's pattern format",
      "Each URL pattern must have a unique identifier key"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "ConfigFile": {
        "type": "object",
        "properties": {
          "path": {
            "type": "string",
            "description": "Path to the URL patterns configuration file"
          },
          "format": {
            "type": "string",
            "description": "Format of the configuration file (properties)",
            "default": "properties"
          }
        },
        "required": [
          "path"
        ]
      }
    }
  },
  {
    "featureName": "ListenForChanges",
    "description": "Sets up file monitoring for configuration files to detect and apply changes.",
    "inputValues": [
      "configFiles-object-ConfigurationFiles",
      "fileChangesDelay-number-SystemSetting"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect configFiles (object): List of configuration files to monitor\n     - Required properties: filePath (string), fileType (string)\n     - Optional properties: priority (number)\n   - Collect fileChangesDelay (number): Time interval in milliseconds between file checks\n     - System may provide default value if not specified\n     - Must be a positive integer\n\n2. Data Validation:\n   - Validate fileChangesDelay:\n     - IF fileChangesDelay is not a number, THEN return error \"File changes delay must be a number\"\n     - IF fileChangesDelay <= 0, THEN disable file monitoring and exit process\n     - IF fileChangesDelay < minimumAllowedDelay, THEN set to minimumAllowedDelay and log warning\n   - Validate configFiles:\n     - FOR EACH file in configFiles:\n       - Check if file exists\n       - IF file does not exist, THEN log warning but continue process\n       - Verify file has read permissions\n       - IF file lacks read permissions, THEN log error and skip this file\n\n3. Business Rule Processing:\n   - Determine appropriate file listeners based on file types:\n     - FOR EACH file in configFiles:\n       - IF file is a query file (SQL), THEN assign QueryFileListener\n       - IF file is a system properties file, THEN assign SystemPropertiesListener\n       - IF file is a custom configuration file, THEN assign appropriate custom listener\n   - Check system resources:\n     - Verify system has sufficient resources for file monitoring\n     - IF resources are insufficient, THEN log warning and adjust monitoring frequency\n\n4. Core Operation Execution:\n   - Initialize file monitoring system:\n     - Create file monitor instance if not already created\n     - Configure monitoring parameters based on system capabilities\n   - Register file listeners:\n     - FOR EACH file in configFiles:\n       - Register appropriate listener for the file\n       - Set monitoring interval to fileChangesDelay\n       - Initialize baseline file state (timestamp, checksum)\n   - Start monitoring process:\n     - Activate all registered file monitors\n     - Log successful activation of monitoring for each file\n   - Set up notification system:\n     - Configure how changes will be reported\n     - Define actions to take when changes are detected\n\n5. Response Generation:\n   - Return monitoring status:\n     - List of successfully monitored files\n     - List of files that couldn't be monitored (with reasons)\n     - Current monitoring interval\n   - Provide management interface details:\n     - How to manually trigger reloads\n     - How to temporarily disable monitoring\n     - How to adjust monitoring parameters",
    "databaseEntities": [],
    "validationRules": [
      "File changes delay must be greater than zero to enable monitoring",
      "Configuration files must exist and be readable",
      "Each file type must have an appropriate listener assigned",
      "System must have sufficient resources for file monitoring"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "ConfigurationFiles": {
        "type": "array",
        "items": {
          "type": "object",
          "properties": {
            "filePath": {
              "type": "string",
              "description": "Path to the configuration file"
            },
            "fileType": {
              "type": "string",
              "description": "Type of configuration file (SQL, properties, etc.)"
            },
            "priority": {
              "type": "number",
              "description": "Priority level for processing changes (optional)"
            }
          },
          "required": [
            "filePath",
            "fileType"
          ]
        }
      },
      "SystemSetting": {
        "type": "object",
        "properties": {
          "value": {
            "type": "number",
            "description": "Value of the system setting"
          },
          "unit": {
            "type": "string",
            "description": "Unit of measurement for the setting"
          }
        },
        "required": [
          "value"
        ]
      }
    }
  },
  {
    "featureName": "LoadDaoImplementation",
    "description": "Loads and initializes the configured data access driver implementation.",
    "inputValues": [
      "driverClassName-string-DataAccessDriver"
    ],
    "businessLogic": "1. Input Collection:\n   - Retrieve the driver class name from the system configuration\n   - The driver class name is a mandatory system-generated value\n\n2. Data Validation:\n   - Validate that the driver class name is not empty\n     * IF driver class name is empty or null THEN\n       - Generate error message: \"DAO driver class name is not specified\"\n       - Terminate the process\n     * END IF\n   - Verify that the specified driver class exists in the system\n     * IF driver class does not exist THEN\n       - Generate error message: \"Specified DAO driver class could not be found\"\n       - Terminate the process\n     * END IF\n\n3. Business Rule Processing:\n   - Verify that the driver class implements the required DataAccessDriver interface\n     * IF driver class does not implement DataAccessDriver interface THEN\n       - Generate error message: \"The specified class does not implement the required DataAccessDriver interface\"\n       - Terminate the process\n     * END IF\n   - Check if any existing driver implementation is already loaded\n     * IF existing driver implementation is loaded THEN\n       - Prepare for replacement of the current implementation\n     * END IF\n\n4. Core Operation Execution:\n   - Load the driver class using the class name\n     * Create a new instance of the driver class\n     * IF instance creation fails THEN\n       - Generate error message: \"Failed to instantiate the DAO driver implementation\"\n       - Log detailed error information\n       - Terminate the process\n     * END IF\n   - Initialize the data access driver with the newly created instance\n     * Register the driver instance as the active data access implementation\n     * IF initialization fails THEN\n       - Generate error message: \"Failed to initialize the DAO driver implementation\"\n       - Log detailed error information\n       - Revert to previous implementation if available\n       - Terminate the process\n     * END IF\n   - Log successful driver initialization\n\n5. Response Generation:\n   - On Success:\n     * Return confirmation that the DAO implementation has been successfully loaded\n     * Include the name of the loaded driver class\n   - On Failure:\n     * Return detailed error information\n     * Include suggestions for troubleshooting",
    "databaseEntities": [
      "jforum_users",
      "jforum_groups",
      "jforum_categories",
      "jforum_forums",
      "jforum_topics",
      "jforum_posts",
      "jforum_posts_text",
      "jforum_attachments",
      "jforum_privmsgs",
      "jforum_privmsgs_text",
      "jforum_moderator_groups",
      "jforum_user_groups",
      "jforum_sessions",
      "jforum_smilies",
      "jforum_words",
      "jforum_karma",
      "jforum_bookmarks",
      "jforum_quota_limit",
      "jforum_extension_groups"
    ],
    "validationRules": [
      "Driver class name must not be empty",
      "Driver class must exist in the system",
      "Driver class must implement the DataAccessDriver interface",
      "Driver instance must be successfully created",
      "Driver initialization must complete without errors"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "DataAccessDriver": {
        "type": "object",
        "properties": {
          "className": {
            "type": "string",
            "description": "The fully qualified class name of the data access driver implementation"
          }
        },
        "required": [
          "className"
        ]
      }
    }
  },
  {
    "featureName": "StartCacheEngine",
    "description": "Initializes the caching system and associates cacheable objects.",
    "inputValues": [
      "cacheImplementation-string-CacheEngine",
      "cacheableObjects-string-CacheableList"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect cacheImplementation (string): The fully qualified class name of the cache engine to use\n   - Collect cacheableObjects (string): Comma-separated list of fully qualified class names of objects that can be cached\n   - Both inputs are mandatory and must be non-empty\n\n2. Data Validation:\n   - Validate cacheImplementation:\n     a. Check if the value is not null or empty\n     b. Verify the string represents a valid class name format\n     c. If validation fails, generate appropriate error message\n   - Validate cacheableObjects:\n     a. Check if the value is not null or empty\n     b. Verify the string contains valid class name formats separated by commas\n     c. If validation fails, generate appropriate error message\n\n3. Business Rule Processing:\n   - Check system readiness:\n     a. Verify the system environment is ready for cache initialization\n     b. Ensure no existing cache engine is currently running\n     c. If conditions are not met, prepare appropriate error message\n\n4. Core Operation Execution:\n   - Initialize Cache Engine:\n     a. Log information about the cache implementation being used\n     b. Create an instance of the specified cache implementation class\n     c. Initialize the cache engine instance\n     d. IF initialization fails, prepare error message and stop execution\n   - Associate Cacheable Objects:\n     a. Split the cacheableObjects string into an array of individual class names\n     b. FOR each class name in the array:\n        i. Log information about creating an instance of the class\n        ii. Create an instance of the specified class\n        iii. IF the instance implements Cacheable interface:\n             - Associate the cache engine with the cacheable object\n        iv. ELSE:\n             - Log an error that the object does not implement the required interface\n             - Continue to the next object\n     c. IF any critical errors occur during association, prepare error message\n\n5. Response Generation:\n   - Success Response:\n     a. Generate confirmation that cache engine has been successfully initialized\n     b. Include details about the cache implementation used\n     c. Include count of successfully associated cacheable objects\n   - Error Response:\n     a. Provide detailed error information if initialization failed\n     b. Include specific error messages for each failed validation or operation\n     c. Suggest possible solutions or next steps",
    "databaseEntities": [],
    "validationRules": [
      "Cache implementation class name must not be empty",
      "Cache implementation class must be a valid and accessible class",
      "Cacheable objects list must not be empty",
      "Each cacheable object must implement the Cacheable interface",
      "No existing cache engine should be running before initialization"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "CacheEngine": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "description": "Name of the cache engine implementation"
          },
          "status": {
            "type": "string",
            "enum": [
              "initialized",
              "stopped",
              "error"
            ],
            "description": "Current status of the cache engine"
          }
        }
      },
      "CacheableObject": {
        "type": "object",
        "properties": {
          "className": {
            "type": "string",
            "description": "Fully qualified class name of the cacheable object"
          },
          "status": {
            "type": "string",
            "enum": [
              "associated",
              "error"
            ],
            "description": "Association status with cache engine"
          },
          "errorMessage": {
            "type": "string",
            "description": "Error message if association failed"
          }
        }
      }
    }
  },
  {
    "featureName": "StopCacheEngine",
    "description": "Gracefully stops the cache engine when system is shutting down.",
    "inputValues": [],
    "businessLogic": "1. Input Collection:\n   - No user inputs required as this is a system-initiated process\n   - System-generated input: Current cache engine instance\n\n2. Data Validation:\n   - Check if cache engine exists\n     - IF cache engine instance is null THEN\n       - Skip the operation as there is nothing to stop\n       - Log appropriate message indicating no cache engine is running\n     - ELSE\n       - Proceed to cache engine shutdown\n\n3. Business Rule Processing:\n   - Verify system state is in shutdown mode\n   - Check for any pending cache operations\n     - IF critical operations are in progress THEN\n       - Wait for completion or set timeout\n     - ELSE\n       - Proceed immediately\n\n4. Core Operation Execution:\n   - Notify cache engine to prepare for shutdown\n     - Release any exclusive locks\n     - Complete any pending write operations\n     - Flush any unsaved data to persistent storage if applicable\n   - Execute cache engine stop procedure\n     - Release all allocated resources\n     - Close any open connections or files\n     - Clear memory allocations\n   - Set cache engine reference to inactive state\n\n5. Response Generation:\n   - Log successful shutdown of cache engine\n   - IF shutdown encounters errors THEN\n     - Log error details\n     - Attempt emergency shutdown if possible\n     - Provide system administrators with diagnostic information\n   - ELSE\n     - Log successful completion of cache engine shutdown",
    "databaseEntities": [],
    "validationRules": [
      "Cache engine instance must exist before attempting to stop it",
      "System must be in a valid state for cache shutdown",
      "All critical cache operations must be completed or safely terminated"
    ],
    "dbSeedingOperations": [],
    "schema": {}
  },
  {
    "featureName": "StartSearchIndexer",
    "description": "Initializes the search indexing system for content searching.",
    "inputValues": [
      "searchConfiguration-object-SearchConfig"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect search configuration settings:\n     1.1. Retrieve search indexer implementation class name\n     1.2. Determine index storage location\n     1.3. Identify content types to be indexed\n     1.4. Collect indexing frequency parameters\n     1.5. Gather search field weights and relevance settings\n\n2. Data Validation:\n   - Validate search configuration parameters:\n     2.1. Verify search implementation class exists\n        IF implementation class not found THEN\n          Generate error message: \"Search implementation class not found\"\n          Exit process\n        END IF\n     2.2. Confirm index storage location is valid and accessible\n        IF storage location is invalid or inaccessible THEN\n          Generate error message: \"Invalid or inaccessible index storage location\"\n          Exit process\n        END IF\n     2.3. Validate content types for indexing\n        IF no content types specified THEN\n          Generate warning: \"No content types specified for indexing\"\n        END IF\n     2.4. Check indexing frequency parameters\n        IF frequency parameters are invalid THEN\n          Set to default values\n          Generate warning: \"Using default indexing frequency parameters\"\n        END IF\n\n3. Business Rule Processing:\n   - Verify system readiness for search indexing:\n     3.1. Check if system has sufficient resources for indexing\n        IF insufficient memory available THEN\n          Generate error message: \"Insufficient system resources for search indexing\"\n          Exit process\n        END IF\n     3.2. Verify database connectivity for content retrieval\n        IF database connection fails THEN\n          Generate error message: \"Database connection required for indexing is unavailable\"\n          Exit process\n        END IF\n     3.3. Check for existing index\n        IF existing index found THEN\n          Determine if reindexing is required\n        END IF\n\n4. Core Operation Execution:\n   - Initialize search indexing system:\n     4.1. Create search indexer instance\n        Create instance of specified search implementation class\n        IF instance creation fails THEN\n          Generate error message: \"Failed to create search indexer instance\"\n          Exit process\n        END IF\n     4.2. Configure indexer with provided settings\n        Apply storage location settings\n        Set content type filters\n        Configure relevance and weighting parameters\n     4.3. Initialize index structures\n        Create or open index storage\n        Initialize document processors\n        Set up field analyzers\n     4.4. Register content listeners\n        Register listeners for each content type to be indexed\n        Set up event triggers for content changes\n     4.5. Schedule background indexing tasks\n        Create scheduled tasks based on frequency parameters\n        Initialize task executor\n\n5. Response Generation:\n   - Provide indexer initialization status:\n     5.1. Generate success response\n        Include indexer status information\n        Report number of indexed documents if applicable\n        Provide estimated completion time for initial indexing\n     5.2. For errors, provide detailed error information\n        Include specific error condition\n        Suggest troubleshooting steps\n        Provide reference to documentation",
    "databaseEntities": [
      "jforum_posts",
      "jforum_posts_text",
      "jforum_topics",
      "jforum_forums",
      "jforum_categories"
    ],
    "validationRules": [
      "Search implementation class must exist and be accessible",
      "Index storage location must be valid and accessible",
      "At least one content type must be specified for indexing",
      "Indexing frequency parameters must be valid numeric values",
      "System must have sufficient resources for indexing operations",
      "Database connection must be available for content retrieval"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "SearchConfig": {
        "type": "object",
        "properties": {
          "implementationClass": {
            "type": "string",
            "description": "Fully qualified class name of the search implementation"
          },
          "storageLocation": {
            "type": "string",
            "description": "Path to the index storage location"
          },
          "contentTypes": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Types of content to be indexed"
          },
          "indexingFrequency": {
            "type": "object",
            "properties": {
              "initialDelay": {
                "type": "number",
                "description": "Initial delay before starting indexing"
              },
              "periodicInterval": {
                "type": "number",
                "description": "Interval between periodic indexing operations"
              }
            }
          },
          "relevanceSettings": {
            "type": "object",
            "properties": {
              "fieldWeights": {
                "type": "object",
                "description": "Weight values for different content fields"
              },
              "boostFactors": {
                "type": "object",
                "description": "Boost factors for specific content types"
              }
            }
          }
        },
        "required": [
          "implementationClass",
          "storageLocation",
          "contentTypes"
        ]
      }
    }
  },
  {
    "featureName": "StartSummaryJob",
    "description": "Initializes scheduled job for sending post summary emails to users.",
    "inputValues": [
      "summaryFrequency-string-ScheduleConfig",
      "summaryTimeOfDay-string-ScheduleConfig",
      "summaryEnabled-boolean-ScheduleConfig",
      "summaryRecipients-object-RecipientConfig",
      "cronExpression-string-ScheduleConfig",
      "quartzConfigFile-string-SystemConfig"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the following configuration parameters:\n     1.1. summaryFrequency (mandatory): Frequency for sending summary emails (daily, weekly, monthly)\n     1.2. summaryTimeOfDay (mandatory): Time of day to send the summary (HH:MM format)\n     1.3. summaryEnabled (mandatory): Flag indicating if summary job should be active\n     1.4. summaryRecipientConfig (mandatory): Configuration for determining which users receive summaries\n     1.5. cronExpression (optional): Custom scheduling expression for advanced timing control\n     1.6. quartzConfigFile (optional): Path to scheduler configuration file\n   - System will use default values if specific parameters are not provided\n\n2. Data Validation:\n   2.1. Validate summaryFrequency:\n      - MUST be one of the allowed values: \"daily\", \"weekly\", or \"monthly\"\n      - IF invalid, set to default \"daily\" and log warning\n   2.2. Validate summaryTimeOfDay:\n      - MUST follow HH:MM format (24-hour)\n      - Hours MUST be between 00-23\n      - Minutes MUST be between 00-59\n      - IF invalid, set to default \"00:00\" and log warning\n   2.3. Validate summaryEnabled:\n      - MUST be boolean type\n      - IF not specified, default to false\n   2.4. Validate summaryRecipientConfig:\n      - MUST contain valid selection criteria for users\n      - MUST specify at least one recipient group or selection method\n      - IF invalid, use system default (all active users) and log warning\n   2.5. Validate cronExpression (if provided):\n      - MUST follow proper cron expression format\n      - MUST represent a valid schedule\n      - IF invalid, log error and use standard schedule based on frequency/time\n   2.6. Validate quartzConfigFile (if provided):\n      - MUST be a valid file path\n      - File MUST exist and be readable\n      - IF invalid, use system default configuration file\n\n3. Business Rule Processing:\n   3.1. Check system readiness:\n      - Verify email functionality is properly configured\n      - Verify database connection is available\n      - Verify scheduler framework is available\n      - IF any check fails, log error and abort job initialization\n   3.2. Check for existing summary job:\n      - IF job already exists:\n        - Determine if reconfiguration is needed\n        - IF reconfiguration needed, stop existing job\n        - ELSE exit with success status\n   3.3. Verify user notification preferences are accessible\n      - Ensure user preference tables are available\n      - IF not available, log warning and continue with default settings\n   3.4. Check for job scheduling conflicts:\n      - Verify the requested schedule doesn't conflict with other critical system jobs\n      - IF conflict detected, adjust timing slightly and log warning\n\n4. Core Operation Execution:\n   4.1. Create summary job scheduler:\n      - Initialize scheduler component using configuration file\n      - Configure scheduler with provided frequency and time parameters\n      - IF custom cronExpression provided, use it instead of standard schedule\n      - Set up error handling and retry mechanisms\n   4.2. Register summary job with the system:\n      - Create job definition with all required parameters\n      - Associate job with the scheduler\n      - Configure job to use the recipient configuration\n      - Assign unique identifier to the job\n   4.3. Activate the scheduler:\n      - IF summaryEnabled is true:\n        - Start the scheduler immediately\n        - Schedule first execution based on configuration\n        - Log successful activation with next execution time\n      - ELSE:\n        - Register the job but keep it in inactive state\n        - Log that job is registered but inactive\n   4.4. Store configuration:\n      - Save all job configuration to persistent storage\n      - Ensure configuration survives system restarts\n      - Record last start time and status\n\n5. Response Generation:\n   5.1. Generate success response:\n      - Include job identifier\n      - Include first scheduled execution time\n      - Include summary of configuration parameters\n      - Include status (active/inactive)\n   5.2. Handle potential errors:\n      - For configuration errors: return specific validation messages\n      - For system errors: return appropriate error code and message\n      - Include troubleshooting information when needed\n      - Provide suggestions for resolving configuration issues\n   5.3. Log job initialization:\n      - Record detailed information about job configuration\n      - Log success or failure status\n      - Include performance metrics of initialization process",
    "databaseEntities": [
      "jforum_users",
      "jforum_topics",
      "jforum_posts",
      "jforum_posts_text",
      "jforum_forums",
      "jforum_sessions"
    ],
    "validationRules": [
      "Summary frequency must be one of: daily, weekly, or monthly",
      "Summary time must be in valid HH:MM format (24-hour)",
      "Summary enabled flag must be a boolean value",
      "Summary recipient configuration must specify at least one valid selection method",
      "Email functionality must be properly configured before enabling summary job",
      "Database connection must be available to initialize the job",
      "Cron expression must follow valid format if provided",
      "Scheduler configuration file must exist and be readable if specified",
      "Summary job must not already be running when starting a new instance",
      "System must have sufficient resources to run the scheduled job"
    ],
    "dbSeedingOperations": [
      "Insert default summary job configuration if not present",
      "Create default scheduler entry in system configuration table"
    ],
    "schema": {
      "RecipientConfig": {
        "type": "object",
        "properties": {
          "userGroups": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "List of user groups to receive summaries"
          },
          "activityThreshold": {
            "type": "object",
            "properties": {
              "minDays": {
                "type": "number",
                "description": "Minimum days of user activity to qualify for summary"
              },
              "maxDays": {
                "type": "number",
                "description": "Maximum days of user inactivity to still receive summary"
              }
            }
          },
          "includeAllUsers": {
            "type": "boolean",
            "description": "Flag to include all active users regardless of other criteria"
          },
          "excludedUsers": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "List of users explicitly excluded from receiving summaries"
          }
        }
      },
      "ScheduleConfig": {
        "type": "object",
        "properties": {
          "frequency": {
            "type": "string",
            "enum": [
              "daily",
              "weekly",
              "monthly"
            ],
            "description": "How often the summary should be sent"
          },
          "timeOfDay": {
            "type": "string",
            "pattern": "^([01]?[0-9]|2[0-3]):[0-5][0-9]$",
            "description": "Time of day to send in HH:MM format"
          },
          "enabled": {
            "type": "boolean",
            "description": "Whether the summary job is active"
          },
          "cronExpression": {
            "type": "string",
            "description": "Custom cron expression for advanced scheduling"
          }
        }
      }
    }
  },
  {
    "featureName": "StartPop3Integration",
    "description": "Initializes POP3 email integration service for the forum.",
    "inputValues": [
      "configurationSettings-object-Pop3Config"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect POP3 configuration settings from system configuration:\n     - POP3 server address (mandatory)\n     - Port number (mandatory, default: 110)\n     - Username (mandatory)\n     - Password (mandatory)\n     - Connection security type (optional, default: none)\n     - Check interval in minutes (mandatory, default: 15)\n     - Destination forum for email posts (mandatory)\n     - Email processing rules (optional)\n\n2. Data Validation:\n   - Validate POP3 server configuration:\n     - VERIFY server address is not empty and has valid format\n     - VERIFY port number is a positive integer between 1-65535\n     - VERIFY username is not empty\n     - VERIFY password is not empty\n     - VERIFY connection security type is one of: none, SSL, TLS\n     - VERIFY check interval is a positive integer\n     - VERIFY destination forum exists in the system\n   - IF any validation fails THEN:\n     - Generate appropriate error message\n     - Log validation failure details\n     - Abort integration startup\n\n3. Business Rule Processing:\n   - Check system prerequisites:\n     - VERIFY POP3 integration is enabled in system settings\n     - VERIFY required libraries are available\n     - VERIFY system has appropriate permissions to create scheduled tasks\n   - Check for existing POP3 integration:\n     - IF POP3 job is already running THEN:\n       - Stop existing job\n       - Log that service is being restarted\n     - ELSE:\n       - Log that service is being started for the first time\n\n4. Core Operation Execution:\n   - Initialize POP3 job scheduler:\n     - Create new scheduler instance\n     - Configure job parameters based on validated inputs\n     - Set execution interval based on check interval setting\n     - Register email processing handlers\n     - Configure error handling and retry mechanisms\n   - Start the POP3 job:\n     - Initialize connection to mail server\n     - Schedule first execution based on configuration\n     - Register job with system scheduler\n   - Configure monitoring and reporting:\n     - Set up logging for POP3 activities\n     - Configure notification settings for critical errors\n\n5. Response Generation:\n   - IF integration started successfully THEN:\n     - Log successful initialization message\n     - Return success status with job details\n     - Include next scheduled execution time\n   - ELSE:\n     - Log detailed error information\n     - Return failure status with specific error details\n     - Include troubleshooting suggestions",
    "databaseEntities": [
      "jforum_users",
      "jforum_forums",
      "jforum_topics",
      "jforum_posts",
      "jforum_posts_text"
    ],
    "validationRules": [
      "POP3 server address must be a valid hostname or IP address",
      "POP3 port must be a valid port number between 1-65535",
      "Username must not be empty",
      "Password must not be empty",
      "Check interval must be a positive integer",
      "Destination forum must exist in the system",
      "POP3 integration must be enabled in system settings"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Pop3Config": {
        "type": "object",
        "properties": {
          "serverAddress": {
            "type": "string",
            "description": "POP3 server hostname or IP address"
          },
          "port": {
            "type": "number",
            "description": "POP3 server port number"
          },
          "username": {
            "type": "string",
            "description": "Authentication username for POP3 server"
          },
          "password": {
            "type": "string",
            "description": "Authentication password for POP3 server"
          },
          "securityType": {
            "type": "string",
            "enum": [
              "none",
              "SSL",
              "TLS"
            ],
            "description": "Connection security type"
          },
          "checkInterval": {
            "type": "number",
            "description": "Interval in minutes between email checks"
          },
          "destinationForum": {
            "type": "number",
            "description": "Forum ID where emails will be posted"
          },
          "processingRules": {
            "type": "object",
            "description": "Rules for processing incoming emails"
          }
        },
        "required": [
          "serverAddress",
          "port",
          "username",
          "password",
          "checkInterval",
          "destinationForum"
        ]
      }
    }
  },
  {
    "featureName": "PrepareTemplateContext",
    "description": "Sets up common variables used by templates with forum configuration and user context.",
    "inputValues": [
      "context-object-SimpleHash",
      "jforumContext-object-ForumContext"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect template context object (SimpleHash)\n   - Collect forum context object (ForumContext)\n   - Retrieve current request from JForumExecutionContext\n\n2. Data Validation:\n   - Verify context object is not null\n     - IF context is null THEN return error message indicating missing template context\n   - Verify forum context object is not null\n     - IF forum context is null THEN return error message indicating missing forum context\n\n3. Business Rule Processing:\n   - Check system permissions for current user\n     - Verify if karma feature is enabled for current user\n     - Verify if bookmarks feature is enabled for current user\n     - Verify if moderation log access is permitted for current user\n   - Retrieve system configuration values\n     - Get date/time format configuration\n     - Get authentication settings (auto login enabled, SSO type)\n     - Get template directory name\n     - Get file extension configuration\n     - Get version information\n     - Get forum title and page metadata\n     - Get encoding settings\n\n4. Core Operation Execution:\n   - Populate context with permission-based variables\n     - Add karma permission status to context\n     - Add bookmarks permission status to context\n     - Add moderation log access permission to context\n   - Populate context with system configuration variables\n     - Add date/time format to context\n     - Add auto login status to context\n     - Add SSO status to context\n     - Add template name to context\n     - Add file extension to context\n     - Add version information to context\n     - Add forum title and page title to context\n     - Add meta keywords and description to context\n     - Add encoding information to context\n   - Populate context with request-based variables\n     - Add context path to context\n     - Add server name to context\n     - Add server port to context\n   - Populate context with additional utility objects\n     - Add internationalization instance to context\n     - Add forum link and homepage link to context\n     - Add forum context object to context\n     - Add current timestamp to context\n\n5. Response Generation:\n   - Return populated context object with all required template variables\n   - No explicit response is needed as the context object is modified in-place",
    "databaseEntities": [
      "jforum_users",
      "jforum_sessions"
    ],
    "validationRules": [
      "Template context object must not be null",
      "Forum context object must not be null",
      "System configuration values must be accessible",
      "User permissions must be properly verified"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "SimpleHash": {
        "type": "object",
        "description": "Template context container that stores key-value pairs for template rendering",
        "properties": {
          "put": {
            "type": "function",
            "description": "Adds a key-value pair to the context"
          }
        }
      },
      "ForumContext": {
        "type": "object",
        "description": "Contains forum-specific context information for the current request"
      }
    }
  },
  {
    "featureName": "CheckAutoLogin",
    "description": "Verifies user credentials for automatic login using cookies and database validation.",
    "inputValues": [
      "userSession-object-UserSession",
      "cookies-object-CookieCollection"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the UserSession object for the current user\n   - Retrieve system cookie configuration settings\n      - Cookie name for user data\n      - Cookie name for user hash\n      - Cookie name for auto login flag\n   - Retrieve cookies from the user's request\n      - User ID cookie\n      - User hash cookie\n      - Auto login preference cookie\n\n2. Data Validation:\n   - Validate cookie existence\n      - Check if user ID cookie exists\n      - Check if user hash cookie exists\n      - Check if auto login cookie exists\n   - IF any required cookie is missing THEN\n      - Mark session as anonymous\n      - Return false (auto login not possible)\n   - Validate cookie values\n      - Verify user ID is not anonymous user ID\n      - Verify auto login value is set to \"1\"\n      - Verify user hash is not empty\n\n3. Business Rule Processing:\n   - IF user ID represents anonymous user THEN\n      - Mark session as anonymous\n      - Return false (auto login not possible)\n   - IF auto login preference is not enabled THEN\n      - Mark session as anonymous\n      - Return false (auto login not possible)\n   - Extract user ID from cookie\n   - Extract user hash from cookie\n   - Retrieve user authentication hash from database using user ID\n   - IF user hash from database is empty or null THEN\n      - Mark session as anonymous\n      - Return false (invalid user credentials)\n   - Generate security hash from stored user hash using encryption\n   - IF generated security hash does not match cookie hash THEN\n      - Make user session anonymous\n      - Return false (hash verification failed)\n\n4. Core Operation Execution:\n   - Set user ID in the session\n   - Retrieve complete user data from database using user ID\n   - IF user not found OR user ID mismatch OR user is deleted THEN\n      - Make user session anonymous\n      - Return false (user validation failed)\n   - Configure user session with user data\n      - Copy user data to session\n      - Check if user already has an active session\n      - IF existing session found THEN\n         - Store existing session data to database\n         - Retrieve user session data\n         - Remove old session\n      - ELSE\n         - Retrieve user session data from database\n      - IF no previous session data found THEN\n         - Set last visit time to current time\n      - ELSE\n         - Update last visit time based on previous session\n      - Set auto login flag to true in session\n      - Mark session as logged in\n      - Load user language preferences\n   - Return true (auto login successful)\n\n5. Response Generation:\n   - Return boolean result indicating success or failure of auto login\n   - IF successful THEN\n      - User session contains authenticated user information\n      - System recognizes user as logged in\n   - IF failed THEN\n      - User remains in anonymous state\n      - Standard login will be required",
    "databaseEntities": [
      "jforum_users",
      "jforum_sessions"
    ],
    "validationRules": [
      "User ID cookie must exist for auto login",
      "User hash cookie must exist for auto login",
      "Auto login cookie must exist and be set to '1'",
      "User ID must not be the anonymous user ID",
      "User hash from database must match the encrypted hash in cookie",
      "User must exist in the database",
      "User must not be marked as deleted"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "UserSession": {
        "type": "object",
        "properties": {
          "userId": {
            "type": "number",
            "description": "The ID of the user"
          },
          "sessionId": {
            "type": "string",
            "description": "The session identifier"
          },
          "ip": {
            "type": "string",
            "description": "The IP address of the user"
          },
          "lastVisit": {
            "type": "date",
            "description": "The date of the user's last visit"
          },
          "startTime": {
            "type": "date",
            "description": "The start time of the session"
          },
          "sessionTime": {
            "type": "number",
            "description": "The duration of the session"
          },
          "autoLogin": {
            "type": "boolean",
            "description": "Flag indicating if auto login is enabled"
          },
          "makeAnonymous": {
            "type": "function",
            "description": "Method to reset the session to anonymous state"
          }
        }
      },
      "CookieCollection": {
        "type": "object",
        "properties": {
          "userData": {
            "type": "string",
            "description": "Cookie containing user identification data"
          },
          "userHash": {
            "type": "string",
            "description": "Cookie containing user authentication hash"
          },
          "autoLogin": {
            "type": "string",
            "description": "Cookie indicating auto login preference"
          }
        }
      }
    }
  },
  {
    "featureName": "ConfigureUserSession",
    "description": "Sets up user session with preferences and authentication details after successful login.",
    "inputValues": [
      "userSession-object-UserSession",
      "user-object-User"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect UserSession object containing current session information\n   - Collect User object containing authenticated user details\n   - System will use current date/time for session timestamps\n\n2. Data Validation:\n   - Validate UserSession object is not null\n      * IF UserSession is null THEN generate error message\n   - Validate User object is not null\n      * IF User is null THEN generate error message\n   - Verify User ID is valid\n      * IF User ID is invalid or zero THEN generate error message\n   - Check if User account is active\n      * IF User is marked as deleted THEN reject session configuration\n\n3. Business Rule Processing:\n   - Transfer User data to UserSession\n      * Copy user ID, username, and other profile information\n      * Set authentication status to logged in\n   - Check for existing session information\n      * IF user already has an active session THEN\n         > Retrieve existing session data\n         > Store current session data to database\n         > Remove old session information\n   - Determine last visit timestamp\n      * IF previous session exists THEN\n         > Calculate last visit time based on previous session start time and duration\n      * ELSE\n         > Set last visit time to current system time\n   - Set auto-login flag to true\n   - Mark session as authenticated\n\n4. Core Operation Execution:\n   - Update user's session with profile preferences\n   - Load user's language preference\n   - Set session start time\n   - Associate user permissions with session\n   - Store updated session in session repository\n   - Update last activity timestamp\n\n5. Response Generation:\n   - Return configured UserSession object\n   - Include authentication status\n   - Include user preferences\n   - Include permission settings\n   - Include timestamp information",
    "databaseEntities": [
      "jforum_users",
      "jforum_sessions",
      "jforum_user_groups"
    ],
    "validationRules": [
      "UserSession object must not be null",
      "User object must not be null",
      "User ID must be valid and greater than zero",
      "User account must not be marked as deleted"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "UserSession": {
        "userId": "number",
        "username": "string",
        "lastVisit": "date",
        "startTime": "date",
        "sessionTime": "number",
        "sessionId": "string",
        "ip": "string",
        "isLogged": "boolean",
        "autoLogin": "boolean"
      },
      "User": {
        "id": "number",
        "username": "string",
        "password": "string",
        "email": "string",
        "lang": "string",
        "isDeleted": "boolean"
      }
    }
  },
  {
    "featureName": "CheckSSO",
    "description": "Authenticates users via Single Sign-On implementation and creates accounts if needed.",
    "inputValues": [
      "request-object-RequestContext",
      "userSession-object-UserSession"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the user session object containing current session information\n   - Collect the HTTP request object containing SSO authentication data\n   - System configuration settings for SSO implementation class\n   - System configuration settings for email and password attributes\n\n2. Data Validation:\n   - Validate SSO implementation class is properly configured\n     * IF SSO implementation class is not found or invalid THEN\n       * Throw configuration error\n       * Log error details\n       * End process\n   - Validate request object contains necessary authentication data\n     * IF request is null THEN\n       * Throw invalid request error\n       * End process\n\n3. Business Rule Processing:\n   - Instantiate the configured SSO implementation class\n   - Attempt to authenticate the user through SSO implementation\n     * Pass the request object to the SSO authenticator\n     * Retrieve username from SSO authenticator\n   - Verify authentication result\n     * IF username is null or empty THEN\n       * Mark user session as anonymous\n       * End authentication process\n     * ELSE\n       * Continue to user verification\n\n4. Core Operation Execution:\n   - Check if authenticated user exists in the system\n     * IF user does not exist THEN\n       * Retrieve email from session context using configured attribute name\n         * IF email is not found THEN\n           * Use default email from system configuration\n       * Retrieve password from session context using configured attribute name\n         * IF password is not found THEN\n           * Use default password from system configuration\n       * Register new user with retrieved username, password, and email\n         * Create user record in database\n         * Assign default user groups and permissions\n     * ELSE\n       * Retrieve existing user information\n   - Configure user session with authenticated user data\n     * Copy user data to session\n     * Check if user has an existing session\n       * IF existing session found THEN\n         * Store existing session data\n         * Remove old session\n         * Set last visit time based on previous session\n       * ELSE\n         * Set last visit time to current time\n     * Mark session as authenticated\n     * Set auto-login flag\n     * Load user's language preferences\n\n5. Response Generation:\n   - Return configured user session with authentication status\n   - IF authentication successful THEN\n     * Session contains user information and permissions\n     * User is marked as logged in\n   - ELSE\n     * Session is marked as anonymous\n     * Basic session data is maintained",
    "databaseEntities": [
      "jforum_users",
      "jforum_user_groups",
      "jforum_sessions"
    ],
    "validationRules": [
      "SSO implementation class must be properly configured",
      "Request object must contain valid authentication data",
      "Username must be provided by SSO implementation for successful authentication",
      "User email must be available from session or default configuration",
      "User password must be available from session or default configuration"
    ],
    "dbSeedingOperations": [
      "Default system configuration values for SSO implementation class",
      "Default system configuration values for email and password attributes",
      "Default email address for new SSO users",
      "Default password for new SSO users"
    ],
    "schema": {
      "RequestContext": {
        "properties": {
          "sessionContext": {
            "type": "object",
            "description": "Session context containing attributes and session ID"
          },
          "remoteAddr": {
            "type": "string",
            "description": "IP address of the client"
          },
          "cookies": {
            "type": "array",
            "description": "HTTP cookies from the request"
          }
        }
      },
      "UserSession": {
        "properties": {
          "userId": {
            "type": "integer",
            "description": "User ID of the authenticated user"
          },
          "username": {
            "type": "string",
            "description": "Username of the authenticated user"
          },
          "lastVisit": {
            "type": "date",
            "description": "Date and time of the user's last visit"
          },
          "sessionId": {
            "type": "string",
            "description": "Unique session identifier"
          },
          "ip": {
            "type": "string",
            "description": "IP address associated with the session"
          },
          "isAnonymous": {
            "type": "boolean",
            "description": "Flag indicating if the session is anonymous"
          },
          "autoLogin": {
            "type": "boolean",
            "description": "Flag indicating if auto-login is enabled"
          }
        }
      }
    }
  },
  {
    "featureName": "RefreshSession",
    "description": "Updates user session data including last visit time and authentication status.",
    "inputValues": [
      "userSession-object-UserSession",
      "request-object-RequestContext"
    ],
    "businessLogic": "1. Input Collection:\n   - Retrieve the current user session\n   - Obtain the request context\n   - Determine authentication type from system configuration\n\n2. Data Validation:\n   - Check if user session exists\n     - IF user session is null THEN create a new session\n     - IF user session exists THEN validate according to authentication type\n   - Verify session ID validity\n   - Check IP address information\n\n3. Business Rule Processing:\n   - IF session is new:\n     - Register basic session information\n     - Set session ID from request context\n     - Record user's IP address\n     - Mark session as not logged in\n     - Check if current request is from a bot\n       - IF not a bot THEN proceed with authentication checks\n   - IF using standard authentication:\n     - Check if auto-login is enabled in system configuration\n       - IF auto-login enabled THEN attempt auto-login using cookies\n       - IF auto-login disabled THEN make session anonymous\n   - IF using SSO authentication:\n     - Validate user through SSO implementation\n     - IF SSO validation fails THEN make session anonymous\n     - IF SSO validation succeeds THEN configure user session with user data\n   - IF existing session with SSO authentication:\n     - Verify if the SSO session is still valid\n     - IF SSO session invalid THEN remove current session and restart refresh process\n     - IF SSO session valid THEN continue\n\n4. Core Operation Execution:\n   - For new authenticated sessions:\n     - Configure user data in session\n     - Check for existing session data for this user\n     - IF user has existing session:\n       - Store previous session data to database\n       - Retrieve user session data\n       - Remove old session\n     - ELSE:\n       - Attempt to retrieve previous session data from database\n     - Update last visit timestamp:\n       - IF no previous session found THEN set last visit to current time\n       - IF previous session found THEN calculate last visit based on previous session data\n     - Mark session as auto-login if applicable\n     - Mark session as logged in\n     - Load user's language preference\n   - For existing sessions:\n     - Update session timestamp to record activity\n\n5. Response Generation:\n   - Return updated user session\n   - No explicit response needed as session state is maintained in the system",
    "databaseEntities": [
      "jforum_users",
      "jforum_sessions"
    ],
    "validationRules": [
      "Session must have a valid session ID",
      "User authentication must be verified before session is marked as logged in",
      "SSO sessions must be validated on each refresh",
      "Last visit time must be updated based on session history",
      "IP address must be recorded for new sessions",
      "Bot requests should be identified and handled appropriately"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "UserSession": {
        "type": "object",
        "properties": {
          "userId": {
            "type": "integer"
          },
          "sessionId": {
            "type": "string"
          },
          "ip": {
            "type": "string"
          },
          "lastVisit": {
            "type": "date"
          },
          "startTime": {
            "type": "date"
          },
          "sessionTime": {
            "type": "integer"
          },
          "autoLogin": {
            "type": "boolean"
          }
        }
      },
      "RequestContext": {
        "type": "object",
        "properties": {
          "sessionContext": {
            "type": "object"
          },
          "remoteAddr": {
            "type": "string"
          },
          "cookies": {
            "type": "array"
          },
          "contextPath": {
            "type": "string"
          },
          "serverName": {
            "type": "string"
          },
          "serverPort": {
            "type": "integer"
          }
        }
      }
    }
  },
  {
    "featureName": "AddCookie",
    "description": "Adds or updates a cookie in the current response.",
    "inputValues": [
      "name-string-Cookie",
      "value-string-Cookie"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the cookie name (string) to be added or updated\n     - The cookie name is mandatory\n     - No default value is provided\n   - Collect the cookie value (string) to be stored\n     - The cookie value is optional\n     - If not provided, an empty string will be used\n\n2. Data Validation:\n   - Validate cookie name:\n     2.1. Check if cookie name is not null\n     2.2. Check if cookie name is not empty\n     2.3. If validation fails, abort the operation\n   - Validate cookie value:\n     2.4. No specific validation for value as null is handled in processing\n\n3. Business Rule Processing:\n   - Verify response context availability:\n     3.1. Check if the current response context is accessible\n     3.2. If response context is not available, abort the operation\n   - Determine cookie expiration:\n     3.3. IF cookie value is null, THEN\n          3.3.1. Set cookie max age to 0 (expire immediately)\n          3.3.2. Set cookie value to empty string\n     3.4. ELSE\n          3.4.1. Set cookie max age to 3600 * 24 * 365 (one year in seconds)\n\n4. Core Operation Execution:\n   - Create cookie object:\n     4.1. Create a new cookie with the provided name and value\n     4.2. Set the cookie's max age based on the determination in step 3\n     4.3. Set the cookie's path to root (\"/\")\n   - Add cookie to response:\n     4.4. Add the created cookie to the current response\n     4.5. If adding to response fails, abort the operation\n\n5. Response Generation:\n   - No explicit response is generated\n   - The cookie is added to the HTTP response\n   - The operation completes silently\n   - No confirmation or error message is returned to the caller",
    "databaseEntities": [],
    "validationRules": [
      "Cookie name must not be null",
      "Cookie name must not be empty",
      "Response context must be available"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Cookie": {
        "name": "string",
        "value": "string",
        "maxAge": "number",
        "path": "string"
      }
    }
  },
  {
    "featureName": "AddCookie",
    "description": "Creates or updates a cookie with specified name, value and expiration settings.",
    "inputValues": [
      "name-string-Cookie",
      "value-string-Cookie",
      "maxAge-number-Cookie",
      "path-string-Cookie"
    ],
    "businessLogic": "1. Input Collection\n   - Collect the following inputs:\n     a. name (string, mandatory): The unique identifier for the cookie\n     b. value (string, mandatory): The data to be stored in the cookie\n     c. maxAge (number, optional): Duration in seconds for cookie validity\n     d. path (string, optional): The path on the server where cookie is valid\n\n2. Data Validation\n   - Validate cookie name:\n     a. Verify name is not null or empty\n     b. Check that name follows valid cookie name format (no special characters, spaces)\n     c. Generate error if validation fails: \"Cookie name is required and must be valid\"\n   - Validate cookie value:\n     a. Check if value is provided (can be empty string but must not be null)\n     b. IF value is null, set maxAge to 0 and value to empty string (indicating cookie deletion)\n     c. Generate error if validation fails: \"Cookie value cannot be null\"\n   - Validate maxAge:\n     a. IF maxAge is not provided, use system default (typically 1 year or 3600 * 24 * 365 seconds)\n     b. IF maxAge is provided, ensure it is a valid number\n     c. IF maxAge is negative, treat as session cookie (expires when browser closes)\n     d. IF maxAge is 0, mark cookie for immediate deletion\n     e. Generate error if validation fails: \"Cookie max age must be a valid number\"\n   - Validate path:\n     a. IF path is provided, ensure it starts with a forward slash\n     b. IF path is not provided, use default path \"/\"\n     c. Generate error if validation fails: \"Cookie path must start with a forward slash\"\n\n3. Business Rule Processing\n   - Check system cookie settings:\n     a. Verify if cookies are enabled in the system configuration\n     b. IF cookies are disabled, log warning and exit process\n   - Check cookie size limitations:\n     a. Ensure combined name and value don't exceed maximum allowed size\n     b. IF size exceeds limit, generate error: \"Cookie size exceeds maximum allowed limit\"\n   - Handle special cookie expiration cases:\n     a. IF value is null, set maxAge to 0 to delete the cookie\n     b. IF maxAge is negative, create session cookie (no explicit expiration)\n\n4. Core Operation Execution\n   - Create or update cookie:\n     a. Create a new cookie object with name and value\n     b. Set cookie expiration time based on maxAge parameter or system default\n     c. Set cookie path to specified path or default path \"/\"\n     d. IF secure flag is required by system settings, mark cookie as secure\n     e. IF HTTP-only flag is required by system settings, mark cookie as HTTP-only\n   - Add cookie to response:\n     a. Add the cookie to the outgoing HTTP response\n     b. IF cookie addition fails, log error and notify caller\n   - Handle existing cookies:\n     a. IF a cookie with the same name already exists, it will be replaced\n     b. Ensure proper update of all cookie properties\n\n5. Response Generation\n   - Generate success response:\n     a. Return confirmation that cookie was successfully created/updated\n     b. Include cookie details (name, expiration, path) in response\n   - Generate error response (if applicable):\n     a. Return specific error message explaining the failure\n     b. Include suggestions for resolving the issue",
    "databaseEntities": [
      "jforum_sessions"
    ],
    "validationRules": [
      "Cookie name must not be null or empty",
      "Cookie name must follow valid format",
      "Cookie value must not be null",
      "If maxAge is provided, it must be a valid number",
      "If path is provided, it must start with a forward slash",
      "If value is null, cookie will be marked for deletion"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Cookie": {
        "name": "string",
        "value": "string",
        "maxAge": "number",
        "path": "string",
        "secure": "boolean",
        "httpOnly": "boolean"
      }
    }
  },
  {
    "featureName": "InitializeDatabaseConnection",
    "description": "Initializes a direct database connection using connection parameters from system configuration.",
    "inputValues": [
      "connectionDriver-string-Configuration",
      "connectionString-string-Configuration"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect connectionDriver from system configuration\n   - Collect connectionString from system configuration\n   - Both inputs are mandatory and system-generated from configuration settings\n\n2. Data Validation:\n   - Validate connectionDriver:\n     a. Check if connectionDriver is not null or empty\n     b. Verify connectionDriver class name follows proper naming convention\n     c. Generate error message if validation fails: \"Invalid or missing database driver\"\n   - Validate connectionString:\n     a. Check if connectionString is not null or empty\n     b. Verify connectionString follows proper format for database connection\n     c. Generate error message if validation fails: \"Invalid or missing connection string\"\n\n3. Business Rule Processing:\n   - Verify system environment:\n     a. Check if required database driver is available in the system\n     b. Verify system has proper permissions to load the driver class\n     c. IF driver is unavailable THEN\n        i. Log error condition\n        ii. Prepare for failure response\n     d. IF permissions are insufficient THEN\n        i. Log security constraint violation\n        ii. Prepare for failure response\n\n4. Core Operation Execution:\n   - Load database driver:\n     a. Attempt to load the database driver class using connectionDriver\n     b. IF driver loading fails THEN\n        i. Log initialization failure\n        ii. Prepare error response with driver loading details\n        iii. Mark database as unavailable\n   - Test connection:\n     a. Attempt to establish a test connection using connectionString\n     b. IF connection attempt fails THEN\n        i. Log connection failure with specific error details\n        ii. Prepare error response with connection failure information\n        iii. Mark database as unavailable\n     c. IF connection succeeds THEN\n        i. Release the test connection immediately\n        ii. Mark database as available\n\n5. Response Generation:\n   - Success response:\n     a. Generate confirmation that database connection initialization succeeded\n     b. Include status information about the connection\n     c. Provide reference to the initialized connection service\n   - Error response:\n     a. Include specific error details from failed operation\n     b. Provide troubleshooting information\n     c. Include suggestions for resolving the issue",
    "databaseEntities": [],
    "validationRules": [
      "Database driver name must not be empty",
      "Database driver class must be available in the system",
      "Connection string must not be empty",
      "Connection string must be properly formatted",
      "System must have permissions to load the driver class",
      "Database must be accessible using the provided connection string"
    ],
    "dbSeedingOperations": [],
    "schema": {}
  },
  {
    "featureName": "HandleSessionDestruction",
    "description": "Manages user session termination by storing session data and removing the session.",
    "inputValues": [
      "sessionId-string-Session"
    ],
    "businessLogic": "1. Input Collection:\n   - Retrieve sessionId (string, mandatory) from the terminating session\n   - System will automatically trigger this process when a session is being destroyed\n\n2. Data Validation:\n   - Validate sessionId existence\n     - IF sessionId is null or empty THEN\n       - Log warning message about invalid session\n       - Exit process without further action\n     - END IF\n   - Verify session is valid and can be processed\n     - IF session cannot be retrieved using sessionId THEN\n       - Log warning about non-existent session\n       - Exit process without further action\n     - END IF\n\n3. Business Rule Processing:\n   - Check if session contains user-related data\n     - IF session contains no user data THEN\n       - Skip data storage step\n       - Proceed directly to session removal\n     - END IF\n   - Determine if session data needs persistence\n     - IF user was authenticated THEN\n       - Mark session for data storage\n     - ELSE\n       - Skip data storage step\n     - END IF\n\n4. Core Operation Execution:\n   - Store session data\n     - Attempt to persist relevant session information\n     - IF storage operation fails THEN\n       - Log warning with error details\n       - Continue to session removal despite failure\n     - END IF\n   - Remove session\n     - Remove session from active sessions registry\n     - Release all resources associated with the session\n     - Update user online status if applicable\n\n5. Response Generation:\n   - No direct response to end user as this is a system process\n   - System logging\n     - Log successful session termination\n     - Include session duration in log if available\n     - Record any errors encountered during process",
    "databaseEntities": [
      "jforum_sessions",
      "jforum_users"
    ],
    "validationRules": [
      "Session ID must not be null or empty",
      "Session must exist in the system before processing",
      "Session data must be properly stored before removal if user was authenticated"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Session": {
        "type": "object",
        "properties": {
          "sessionId": {
            "type": "string",
            "description": "Unique identifier for the user session"
          },
          "userId": {
            "type": "number",
            "description": "ID of the user associated with this session"
          },
          "creationTime": {
            "type": "date",
            "description": "When the session was created"
          },
          "lastAccessTime": {
            "type": "date",
            "description": "When the session was last accessed"
          },
          "isAuthenticated": {
            "type": "boolean",
            "description": "Whether the session belongs to an authenticated user"
          }
        },
        "required": [
          "sessionId"
        ]
      }
    }
  },
  {
    "featureName": "StartDatabase",
    "description": "Initializes the database connection and verifies connectivity.",
    "inputValues": [
      "configSettings-object-DatabaseConfig"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect database configuration settings (configSettings-object-DatabaseConfig)\n     - Connection string parameters (required)\n     - Authentication credentials (required)\n     - Connection pool settings (optional)\n     - Timeout settings (optional, system default if not provided)\n\n2. Data Validation:\n   - Validate database configuration parameters\n     - Check if connection string is properly formatted\n     - Verify credentials are provided and properly formatted\n     - Validate that pool settings are within acceptable ranges\n     - Ensure timeout values are positive numbers\n   - IF any validation fails THEN\n     - Generate appropriate validation error message\n     - Halt initialization process\n     - Return error status with details\n\n3. Business Rule Processing:\n   - Check system readiness for database operations\n     - Verify system has sufficient resources for database connection\n     - Check if required system libraries are available\n     - Ensure no conflicting database processes are running\n   - IF system is not ready THEN\n     - Log detailed diagnostics information\n     - Generate appropriate error message\n     - Return error status with system state information\n\n4. Core Operation Execution:\n   - Initialize database connection implementation\n     - Create database connection instance\n     - Apply configuration settings to connection\n     - Initialize connection pools if configured\n   - Establish test connection to verify connectivity\n     - Open connection to database\n     - Execute simple validation query\n     - Release connection back to pool\n   - IF connection fails THEN\n     - Attempt connection retry with exponential backoff (up to 3 attempts)\n     - IF all retries fail THEN\n       - Release all allocated resources\n       - Log detailed connection failure information\n       - Return error status with connectivity details\n\n5. Response Generation:\n   - IF connection successful THEN\n     - Log successful database initialization\n     - Record connection statistics (connection time, pool status)\n     - Return success status with connection details\n   - ELSE\n     - Return detailed error information\n     - Include troubleshooting suggestions\n     - Provide support contact information",
    "databaseEntities": [
      "jforum_users",
      "jforum_groups",
      "jforum_categories",
      "jforum_forums",
      "jforum_topics",
      "jforum_posts",
      "jforum_posts_text",
      "jforum_attachments",
      "jforum_privmsgs",
      "jforum_privmsgs_text",
      "jforum_moderator_groups",
      "jforum_user_groups",
      "jforum_sessions",
      "jforum_smilies",
      "jforum_words",
      "jforum_karma",
      "jforum_bookmarks",
      "jforum_quota_limit",
      "jforum_extension_groups"
    ],
    "validationRules": [
      "Database configuration must contain valid connection parameters",
      "Database credentials must be properly formatted and non-empty",
      "Connection pool settings must be within acceptable ranges",
      "System must have sufficient resources for database operations",
      "Database must be accessible from the current network environment",
      "Database version must be compatible with the application"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "DatabaseConfig": {
        "connectionString": "string",
        "username": "string",
        "password": "string",
        "poolMinSize": "number",
        "poolMaxSize": "number",
        "connectionTimeout": "number",
        "idleTimeout": "number",
        "retryAttempts": "number"
      }
    }
  },
  {
    "featureName": "StartForumRepository",
    "description": "Initializes the cache control system for forums and categories.",
    "inputValues": [
      "forumDAO-object-ForumDAO",
      "categoryDAO-object-CategoryDAO",
      "configDAO-object-ConfigDAO"
    ],
    "businessLogic": "1. Input Collection:\n   - Obtain data access objects required for initialization:\n     1.1. ForumDAO: Required for accessing forum data\n     1.2. CategoryDAO: Required for accessing category data\n     1.3. ConfigDAO: Required for accessing system configuration data\n   - All inputs are system-generated and mandatory for repository initialization\n\n2. Data Validation:\n   - Validate data access objects availability:\n     2.1. Verify ForumDAO instance is not null\n        IF ForumDAO is null THEN\n          Generate error message: \"Forum data access object not available\"\n          Abort initialization process\n        END IF\n     2.2. Verify CategoryDAO instance is not null\n        IF CategoryDAO is null THEN\n          Generate error message: \"Category data access object not available\"\n          Abort initialization process\n        END IF\n     2.3. Verify ConfigDAO instance is not null\n        IF ConfigDAO is null THEN\n          Generate error message: \"Configuration data access object not available\"\n          Abort initialization process\n        END IF\n\n3. Business Rule Processing:\n   - Verify system readiness for repository initialization:\n     3.1. Check if database connection is established\n        IF database connection is not available THEN\n          Log error: \"Database connection not established\"\n          Abort initialization process\n        END IF\n     3.2. Verify required database tables exist\n        IF required tables are missing THEN\n          Log error: \"Required database tables not found\"\n          Abort initialization process\n        END IF\n     3.3. Check if repository is already initialized\n        IF repository is already initialized (cache contains LOADED flag) THEN\n          Log warning: \"Repository already initialized\"\n          Skip initialization process\n          Return success status\n        END IF\n\n4. Core Operation Execution:\n   - Initialize the forum repository cache:\n     4.1. Create a new ForumRepository instance\n     4.2. Load categories data from CategoryDAO\n        IF category data retrieval fails THEN\n          Log error: \"Failed to retrieve category data\"\n          Throw repository startup exception\n        END IF\n     4.3. Load forums data from ForumDAO\n        IF forum data retrieval fails THEN\n          Log error: \"Failed to retrieve forum data\"\n          Throw repository startup exception\n        END IF\n     4.4. Load system configuration from ConfigDAO\n        4.4.1. Retrieve most users ever online count\n        IF configuration retrieval fails THEN\n          Log error: \"Failed to retrieve configuration settings\"\n          Throw repository startup exception\n        END IF\n     4.5. Load user information statistics\n        4.5.1. Retrieve total user count\n        4.5.2. Retrieve last registered user information\n     4.6. Initialize message counter if not already present\n        IF total messages counter is null THEN\n          Add total messages counter to cache with initial value of 0\n        END IF\n     4.7. Mark repository as loaded in cache\n        4.7.1. Add LOADED flag to cache\n\n5. Response Generation:\n   - Finalize repository initialization:\n     5.1. If initialization completes successfully\n        5.1.1. Log success message: \"Forum repository successfully initialized\"\n        5.1.2. Return success status\n     5.2. If initialization fails at any point\n        5.2.1. Log detailed error information\n        5.2.2. Throw repository startup exception with error details\n        5.2.3. Include troubleshooting information in error message",
    "databaseEntities": [
      "jforum_categories",
      "jforum_forums",
      "jforum_users"
    ],
    "validationRules": [
      "ForumDAO instance must be available",
      "CategoryDAO instance must be available",
      "ConfigDAO instance must be available",
      "Database connection must be established",
      "Required database tables must exist",
      "Repository must not be already initialized"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "ForumDAO": {
        "type": "object",
        "description": "Data access object for forum operations"
      },
      "CategoryDAO": {
        "type": "object",
        "description": "Data access object for category operations"
      },
      "ConfigDAO": {
        "type": "object",
        "description": "Data access object for configuration settings"
      }
    }
  },
  {
    "featureName": "ProcessInstallRequest",
    "description": "Processes installation requests by executing appropriate module commands based on request parameters.",
    "inputValues": [
      "request-object-InstallRequest",
      "response-object-InstallResponse",
      "moduleType-string-Module",
      "actionType-string-Action",
      "contextPath-string-Path"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the installation request parameters:\n     1.1. Retrieve the module name (mandatory) from the request\n     1.2. Retrieve the action name (mandatory) from the request\n     1.3. Retrieve the context path (mandatory) from the system\n     1.4. Retrieve the character encoding (mandatory) from system configuration\n     1.5. Retrieve the servlet extension (mandatory) from system configuration\n\n2. Data Validation:\n   - Validate the installation request parameters:\n     2.1. Check if the system is already installed\n        2.1.1. IF system is already installed THEN\n              - Prepare redirect to the main application page\n              - Set appropriate redirect flag\n              - Skip further processing\n        2.1.2. ELSE continue with installation process\n     2.2. Validate module name\n        2.2.1. Check if module name is not empty\n        2.2.2. Check if module name exists in the modules repository\n        2.2.3. IF module is invalid THEN prepare error response\n     2.3. Validate action name\n        2.3.1. Check if action name is not empty\n        2.3.2. Check if action is valid for the selected module\n        2.3.3. IF action is invalid THEN prepare error response\n\n3. Business Rule Processing:\n   - Process installation business rules:\n     3.1. Check system state for installation eligibility\n        3.1.1. Verify if required configuration files exist\n        3.1.2. Check if database connection parameters are valid\n        3.1.3. Verify file system permissions for installation\n     3.2. Prepare execution context\n        3.2.1. Create forum context with request and response objects\n        3.2.2. Set character encoding for request and response\n        3.2.3. Initialize template context with system parameters\n        3.2.4. Add context path, server name, template name to context\n        3.2.5. Add server port, encoding, and extension to context\n        3.2.6. Add internationalization support to context\n        3.2.7. Add version information to context\n\n4. Core Operation Execution:\n   - Execute the installation process:\n     4.1. Retrieve the module class from the modules repository\n     4.2. IF module class is found THEN\n        4.2.1. Instantiate the command class for the module\n        4.2.2. Process the command with request, response and context\n        4.2.3. Retrieve the resulting template\n        4.2.4. IF no redirect is set THEN\n              - Set content type with proper encoding\n              - Process template with context\n              - Write output to response\n              - Flush output buffer\n        4.2.5. ELSE prepare for redirect after completion\n     4.3. IF module class is not found THEN\n        4.3.1. Prepare error response indicating invalid module\n     4.4. IF any exception occurs during processing THEN\n        4.4.1. Set content type with proper encoding\n        4.4.2. Handle exception data with appropriate writer\n        4.4.3. Write error information to response\n\n5. Response Generation:\n   - Generate appropriate response:\n     5.1. Check if redirect flag is set\n        5.1.1. IF redirect is required THEN\n              - Encode the redirect URL\n              - Send redirect response to client\n        5.1.2. ELSE ensure response is properly completed\n     5.2. Finalize execution context\n        5.2.1. Clean up any resources\n        5.2.2. Complete the request-response cycle",
    "databaseEntities": [
      "jforum_users",
      "jforum_groups",
      "jforum_categories",
      "jforum_forums",
      "jforum_topics",
      "jforum_posts",
      "jforum_posts_text",
      "jforum_attachments",
      "jforum_privmsgs",
      "jforum_privmsgs_text",
      "jforum_moderator_groups",
      "jforum_user_groups",
      "jforum_sessions",
      "jforum_smilies",
      "jforum_words",
      "jforum_karma",
      "jforum_bookmarks",
      "jforum_quota_limit",
      "jforum_extension_groups"
    ],
    "validationRules": [
      "System must not be already installed",
      "Module name must not be empty",
      "Module name must exist in the modules repository",
      "Action name must not be empty",
      "Action must be valid for the selected module",
      "Required configuration files must exist",
      "Database connection parameters must be valid",
      "File system must have appropriate permissions for installation"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "InstallRequest": {
        "module": "string",
        "action": "string",
        "contextPath": "string",
        "serverName": "string",
        "serverPort": "number",
        "characterEncoding": "string"
      },
      "InstallResponse": {
        "outputStream": "object",
        "contentType": "string",
        "redirectURL": "string"
      }
    }
  },
  {
    "featureName": "RedirectToForumsList",
    "description": "Redirects users to the forums list page when the system is already installed.",
    "inputValues": [
      "request-object-HttpRequest",
      "response-object-HttpResponse"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect request object with user session information\n   - Collect response object for redirection handling\n   - System-generated installation status flag\n\n2. Data Validation:\n   - Validate request object is properly initialized\n     * Check if request contains required context path\n     * Verify request encoding is properly set\n   - Validate response object is properly initialized\n     * Ensure response can handle redirects\n     * Verify response encoding is properly set\n   - Validate system installation status\n     * Check if system installation flag is accessible\n     * Verify the flag contains a valid boolean value\n\n3. Business Rule Processing:\n   - Check system installation status\n     * IF system is already installed (installation flag is TRUE)\n       THEN prepare for redirection to forums list\n     * IF system is not installed (installation flag is FALSE)\n       THEN allow normal installation process to continue\n   - Determine appropriate destination URL\n     * Construct forums list URL using context path and appropriate extension\n     * Format URL according to system configuration\n\n4. Core Operation Execution:\n   - Handle installed system scenario\n     * IF system is installed\n       THEN set redirection target to forums list URL\n       AND prepare system for redirect operation\n     * IF system is not installed\n       THEN continue with normal installation flow\n       AND prepare system to display installation interface\n   - Prepare execution context\n     * Set appropriate flags for subsequent processing\n     * Store redirection information if applicable\n\n5. Response Generation:\n   - Process redirection if required\n     * IF redirection is set\n       THEN encode redirection URL for security\n       AND send redirect instruction to client\n     * IF no redirection is needed\n       THEN continue with normal response processing\n   - Complete request handling\n     * Ensure all resources are properly released\n     * Finalize execution context",
    "databaseEntities": [
      "jforum_users",
      "jforum_forums",
      "jforum_categories"
    ],
    "validationRules": [
      "System installation status must be a valid boolean value",
      "Request context path must be available for URL construction",
      "System must have valid configuration for servlet extension"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "HttpRequest": {
        "properties": {
          "contextPath": {
            "type": "string",
            "description": "Base path of the application"
          },
          "module": {
            "type": "string",
            "description": "Requested module name"
          },
          "action": {
            "type": "string",
            "description": "Requested action name"
          }
        }
      },
      "HttpResponse": {
        "properties": {
          "outputStream": {
            "type": "object",
            "description": "Stream for writing response data"
          },
          "redirectCapability": {
            "type": "boolean",
            "description": "Ability to perform redirects"
          }
        }
      }
    }
  },
  {
    "featureName": "RenderInstallationTemplate",
    "description": "Renders installation templates with context data for the installation process.",
    "inputValues": [
      "request-object-RequestContext",
      "response-object-ResponseContext",
      "templateContext-object-TemplateContext"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the request object containing user input and parameters\n   - Collect the response object for output generation\n   - Collect the template context for rendering data\n   - Determine the requested module and action from the request\n   - Extract character encoding settings from system configuration\n   \n2. Data Validation:\n   - Validate that the system is not already installed\n     * IF system is already installed THEN\n       - Set redirect to the forums list page\n       - Skip template rendering process\n     * ELSE continue with installation template rendering\n   - Validate that the requested module exists in the modules repository\n     * IF module not found THEN\n       - Generate appropriate error response\n       - Log the invalid module request\n   - Validate character encoding is properly set\n     * IF encoding is invalid or not set THEN\n       - Use default encoding\n\n3. Business Rule Processing:\n   - Create forum context with required parameters:\n     * Context path from request\n     * Servlet extension from system configuration\n     * Request and response objects\n     * Set installation mode flag\n   - Prepare template context with system information:\n     * Add context path value\n     * Add server name from request\n     * Add template name (default)\n     * Add server port from request\n     * Add internationalization instance\n     * Add character encoding\n     * Add servlet extension\n     * Add forum context object\n     * Add system version information\n   - Determine the appropriate module class based on the requested module\n\n4. Core Operation Execution:\n   - Initialize output writer with proper character encoding\n   - Execute the command process:\n     * Instantiate the module class\n     * Process the request through the command object\n     * Obtain the template to be rendered\n     * IF redirect is set during processing THEN\n       - Skip template rendering\n     * ELSE\n       - Set content type header with proper encoding\n       - Process the template with the context data\n       - Write the processed template to the output stream\n       - Flush the output buffer\n   - Handle any exceptions during processing:\n     * Create exception writer\n     * Format exception details\n     * Write exception information to output\n\n5. Response Generation:\n   - Check if a redirect was requested during processing\n     * IF redirect is set THEN\n       - Encode the redirect URL\n       - Send redirect response to client\n     * ELSE\n       - Ensure all output has been written and flushed\n   - Finalize execution context\n   - Release any resources used during processing",
    "databaseEntities": [],
    "validationRules": [
      "System must not be already installed",
      "Requested module must exist in the modules repository",
      "Character encoding must be properly set",
      "Template context must contain all required system information",
      "Output writer must use the correct character encoding"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "RequestContext": {
        "properties": {
          "module": {
            "type": "string",
            "description": "The requested module name"
          },
          "action": {
            "type": "string",
            "description": "The requested action within the module"
          },
          "contextPath": {
            "type": "string",
            "description": "The context path of the application"
          },
          "characterEncoding": {
            "type": "string",
            "description": "The character encoding for the request"
          }
        }
      },
      "ResponseContext": {
        "properties": {
          "outputStream": {
            "type": "object",
            "description": "The output stream for writing response data"
          },
          "contentType": {
            "type": "string",
            "description": "The content type of the response"
          }
        }
      },
      "TemplateContext": {
        "properties": {
          "contextPath": {
            "type": "string",
            "description": "The context path of the application"
          },
          "serverName": {
            "type": "string",
            "description": "The server name"
          },
          "templateName": {
            "type": "string",
            "description": "The template name to use"
          },
          "serverPort": {
            "type": "string",
            "description": "The server port"
          },
          "encoding": {
            "type": "string",
            "description": "The character encoding"
          },
          "extension": {
            "type": "string",
            "description": "The servlet extension"
          },
          "version": {
            "type": "string",
            "description": "The system version"
          },
          "moduleName": {
            "type": "string",
            "description": "The requested module name"
          },
          "action": {
            "type": "string",
            "description": "The requested action"
          }
        }
      }
    }
  },
  {
    "featureName": "HandleInstallationExceptions",
    "description": "Handles and displays exceptions that occur during the installation process.",
    "inputValues": [
      "exception-object-Exception",
      "request-object-Request",
      "response-object-Response"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the exception object that was thrown during installation\n     - Exception details including message, stack trace, and cause\n     - This is system-generated during error conditions\n   - Collect request information\n     - User context data\n     - Current module and action being executed\n     - Request parameters\n     - This is provided by the system context\n   - Collect response information\n     - Output stream for writing the error response\n     - Response encoding settings\n     - This is provided by the system context\n\n2. Data Validation:\n   - Validate exception object\n     - IF exception is NULL THEN\n       - Create a generic system exception with message \"Unknown error occurred\"\n     - END IF\n   - Validate output stream availability\n     - IF output stream is not available THEN\n       - Attempt to create a new output stream from the response object\n       - IF creation fails THEN\n         - Log critical error to system logs\n         - Return with system error code\n       - END IF\n     - END IF\n   - Validate character encoding\n     - IF encoding is not specified THEN\n       - Use system default encoding\n     - END IF\n\n3. Business Rule Processing:\n   - Determine exception severity level\n     - IF exception is critical (affects core functionality) THEN\n       - Set severity level to \"Critical\"\n     - ELSE IF exception affects functionality but system can continue THEN\n       - Set severity level to \"Warning\"\n     - ELSE\n       - Set severity level to \"Information\"\n     - END IF\n   - Determine appropriate display format\n     - IF in development mode THEN\n       - Include detailed technical information\n     - ELSE\n       - Use user-friendly error messages\n     - END IF\n   - Check if installation can continue\n     - IF exception is recoverable THEN\n       - Set continuation flag to true\n     - ELSE\n       - Set continuation flag to false\n     - END IF\n\n4. Core Operation Execution:\n   - Format exception information\n     - Extract exception message\n     - Format stack trace for display\n     - Include cause if available\n   - Create error response content\n     - Generate HTML error page with appropriate styling\n     - Include exception details based on display format\n     - Add navigation options based on continuation flag\n   - Write error information to output stream\n     - Set appropriate content type and encoding\n     - Write formatted error content to output stream\n     - Flush output stream to ensure delivery\n   - Update system state\n     - Record exception in system logs\n     - Update installation status if necessary\n\n5. Response Generation:\n   - Finalize error response\n     - Add any additional headers required\n     - Set appropriate HTTP status code\n   - Provide recovery options\n     - IF continuation flag is true THEN\n       - Include option to retry the operation\n       - Include option to skip the failed step if possible\n     - ELSE\n       - Include option to restart installation\n       - Include links to support resources\n     - END IF\n   - Complete response\n     - Close output stream if necessary\n     - Signal completion of exception handling",
    "databaseEntities": [],
    "validationRules": [
      "Exception object must contain valid error information",
      "Output stream must be available for writing error information",
      "Character encoding must be valid",
      "Error response must include appropriate user guidance based on error severity"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Exception": {
        "message": "string",
        "stackTrace": "string",
        "cause": "object"
      },
      "Request": {
        "module": "string",
        "action": "string",
        "parameters": "object",
        "contextPath": "string"
      },
      "Response": {
        "outputStream": "object",
        "encoding": "string",
        "contentType": "string"
      }
    }
  },
  {
    "featureName": "InitializeForumSystem",
    "description": "Initializes the forum system including database connection and repository loading.",
    "inputValues": [
      "servletConfig-object-ServletConfig",
      "servletContext-object-ServletContext"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect ServletConfig object (mandatory)\n   - Collect ServletContext object (mandatory)\n   - System configuration parameters (system-generated)\n   - Database connection parameters (system-generated)\n\n2. Data Validation:\n   - Validate ServletConfig is not null\n     * IF ServletConfig is null THEN generate error message \"ServletConfig cannot be null\"\n   - Validate ServletContext is not null\n     * IF ServletContext is null THEN generate error message \"ServletContext cannot be null\"\n   - Validate system configuration files exist\n     * IF configuration files not found THEN generate error message \"System configuration files not found\"\n   - Validate database connection parameters\n     * IF database parameters invalid THEN generate error message \"Invalid database configuration\"\n\n3. Business Rule Processing:\n   - Check if application is already initialized\n     * IF application already initialized THEN skip initialization and return success\n   - Verify file system permissions for configuration and data directories\n     * IF permissions insufficient THEN generate error message \"Insufficient file system permissions\"\n   - Verify database server availability\n     * IF database server unavailable THEN generate error message \"Database server unavailable\"\n   - Check system resource availability (memory, disk space)\n     * IF resources insufficient THEN generate warning message \"System resources may be insufficient\"\n\n4. Core Operation Execution:\n   - Initialize base application settings\n     * Load system global configuration values\n     * Set up encoding parameters\n     * Initialize template engine\n   - Start database connection\n     * Establish connection to database server\n     * Set connection properties (auto-commit, transaction support)\n     * Apply database-specific workarounds if needed\n     * IF connection fails THEN mark database as down and log error\n   - Load forum repositories\n     * Initialize forum repository structures\n     * Load ranking data into memory\n     * Load smilies repository\n     * Load banlist information\n     * Load security repository\n     * Load modules repository\n   - Initialize execution context\n     * Create forum context container\n     * Set up request/response handling framework\n     * Initialize session management\n   - Register shutdown procedures\n     * Set up resource cleanup handlers\n     * Register connection pool shutdown\n     * Register cache engine termination\n\n5. Response Generation:\n   - Generate initialization status report\n     * Include database connection status\n     * Include repository loading results\n     * Include any warnings or non-critical issues\n   - IF initialization successful THEN\n     * Return success status with system readiness information\n     * Log successful initialization with timestamp\n   - ELSE\n     * Return detailed error information\n     * Log initialization failure with specific error conditions\n     * Provide recovery suggestions",
    "databaseEntities": [
      "jforum_users",
      "jforum_groups",
      "jforum_categories",
      "jforum_forums",
      "jforum_topics",
      "jforum_posts",
      "jforum_posts_text",
      "jforum_attachments",
      "jforum_privmsgs",
      "jforum_privmsgs_text",
      "jforum_moderator_groups",
      "jforum_user_groups",
      "jforum_sessions",
      "jforum_smilies",
      "jforum_words",
      "jforum_karma",
      "jforum_bookmarks",
      "jforum_quota_limit",
      "jforum_extension_groups"
    ],
    "validationRules": [
      "ServletConfig must not be null",
      "ServletContext must not be null",
      "System configuration files must exist and be readable",
      "Database connection parameters must be valid",
      "Database server must be available",
      "File system permissions must be sufficient for data directories",
      "System must have adequate resources (memory, disk space)",
      "All required repositories must load successfully"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "ServletConfig": {
        "type": "object",
        "properties": {
          "servletName": {
            "type": "string",
            "description": "Name of the servlet"
          },
          "servletContext": {
            "type": "object",
            "description": "Context in which the servlet operates"
          },
          "initParameters": {
            "type": "object",
            "description": "Initialization parameters for the servlet"
          }
        }
      },
      "ServletContext": {
        "type": "object",
        "properties": {
          "contextPath": {
            "type": "string",
            "description": "Path prefix for the application"
          },
          "attributes": {
            "type": "object",
            "description": "Context attributes"
          },
          "initParameters": {
            "type": "object",
            "description": "Context initialization parameters"
          }
        }
      }
    }
  },
  {
    "featureName": "ProcessForumRequest",
    "description": "Processes HTTP requests by routing to appropriate module controllers with security checks.",
    "inputValues": [
      "request-object-HttpRequest",
      "response-object-HttpResponse"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the HTTP request object with all parameters, headers, and session data\n   - Collect the HTTP response object for output generation\n   - Extract module name from the request URL\n   - Extract action name from the request URL\n   - Retrieve user session information from the request\n   - Determine client IP address from the request\n\n2. Data Validation:\n   - Validate that the request contains a valid module name\n     * IF module name is missing or empty, prepare a 404 error response\n     * IF module name is provided, verify it exists in the modules repository\n   - Validate user authentication status\n     * Check if user session exists\n     * Determine if user is logged in\n   - Validate IP address against ban list\n     * Check if the requesting IP address is in the system ban list\n     * IF IP is banned, redirect to banned page or send 403 Forbidden based on system configuration\n\n3. Business Rule Processing:\n   - Initialize execution context\n     * Create a new forum context with request and response information\n     * Set up template context with common variables\n   - Process security requirements\n     * Load security permissions for the current user\n     * Verify user has access to the requested module and action\n   - Check database connectivity\n     * Verify database connection is active\n     * IF database is not available, attempt to reconnect\n\n4. Core Operation Execution:\n   - Resolve module controller\n     * Look up the appropriate controller class for the requested module\n     * Instantiate the controller class\n   - Process the request\n     * Pass request and response objects to the controller\n     * Execute the requested action on the controller\n     * Generate response template\n   - Handle content generation\n     * IF redirect is requested, store redirect URL\n     * ELSE IF custom content is specified, use controller-generated content\n     * ELSE process template with context data\n   - Manage transaction state\n     * Commit database transaction if successful\n     * Enable rollback if exceptions occur\n\n5. Response Generation:\n   - Set appropriate content type headers\n     * Use default encoding or controller-specified encoding\n   - Generate response output\n     * IF redirect is requested, send redirect response\n     * ELSE IF binary content, write directly to output stream\n     * ELSE write processed template to response writer\n   - Handle error conditions\n     * Format appropriate error messages\n     * Set correct HTTP status codes\n   - Finalize response\n     * Close output streams\n     * Complete database transactions\n     * Clean up resources",
    "databaseEntities": [
      "jforum_users",
      "jforum_groups",
      "jforum_sessions",
      "jforum_banlist"
    ],
    "validationRules": [
      "Module name must exist in the modules repository",
      "User must have permission to access the requested module and action",
      "User IP address must not be in the ban list",
      "Database connection must be available",
      "Content type must be properly set before sending response"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "HttpRequest": {
        "type": "object",
        "properties": {
          "module": {
            "type": "string",
            "description": "The requested module name"
          },
          "action": {
            "type": "string",
            "description": "The requested action within the module"
          },
          "parameters": {
            "type": "object",
            "description": "Collection of request parameters"
          },
          "remoteAddr": {
            "type": "string",
            "description": "IP address of the client"
          },
          "contextPath": {
            "type": "string",
            "description": "Base path of the application"
          },
          "session": {
            "type": "object",
            "description": "User session information"
          }
        }
      },
      "HttpResponse": {
        "type": "object",
        "properties": {
          "outputStream": {
            "type": "object",
            "description": "Stream for writing response data"
          },
          "contentType": {
            "type": "string",
            "description": "MIME type of the response content"
          },
          "encoding": {
            "type": "string",
            "description": "Character encoding of the response"
          }
        }
      }
    }
  },
  {
    "featureName": "EnforceBanRules",
    "description": "Checks if user IP is banned and redirects to banned page or sends 403 error.",
    "inputValues": [
      "remoteAddress-string-User",
      "userId-number-User"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect remote IP address (mandatory)\n   - Retrieve user ID from current session (system-generated)\n\n2. Data Validation:\n   - Validate IP address format\n     * Ensure IP address is in valid IPv4 or IPv6 format\n     * Verify IP address is not empty\n     * If invalid, log error and proceed with default handling\n   - Validate user ID\n     * Ensure user ID is a positive integer\n     * If invalid, use anonymous user ID (typically 0 or -1)\n\n3. Business Rule Processing:\n   - Check system ban enforcement settings\n     * Verify if ban system is enabled in system configuration\n     * Determine ban response type (redirect vs error code) from configuration\n   - Create ban check object\n     * Populate with collected user ID\n     * Populate with validated IP address\n   - Query ban repository\n     * Check if IP address matches any banned IP patterns\n     * Check if user ID is explicitly banned\n     * IF either condition is true, THEN mark user as banned\n\n4. Core Operation Execution:\n   - IF user should be banned THEN\n     * Check ban response configuration setting\n     * IF system is configured to send HTTP 403 error THEN\n       - Set response status to 403 (Forbidden)\n       - End request processing\n     * ELSE\n       - Change module context to \"forums\"\n       - Set action context to \"banned\"\n       - Prepare banned page template\n   - ELSE\n     * Allow normal request processing to continue\n     * Maintain original module and action contexts\n\n5. Response Generation:\n   - For banned users with 403 response:\n     * Return HTTP 403 Forbidden status code\n     * No additional content required\n   - For banned users with redirect response:\n     * Set appropriate template variables for banned page\n     * Return banned page content with explanation\n   - For non-banned users:\n     * Continue normal request processing\n     * No special response handling needed",
    "databaseEntities": [
      "jforum_users",
      "jforum_sessions"
    ],
    "validationRules": [
      "IP address must be in valid format",
      "User ID must be a positive integer if provided",
      "Ban check must be performed before processing any forum action",
      "System must honor the configured ban response type"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "BanEntry": {
        "type": "object",
        "properties": {
          "userId": {
            "type": "number",
            "description": "ID of the banned user"
          },
          "ip": {
            "type": "string",
            "description": "IP address or pattern that is banned"
          },
          "active": {
            "type": "boolean",
            "description": "Whether this ban is currently active"
          }
        }
      }
    }
  },
  {
    "featureName": "RenderForumContent",
    "description": "Renders forum content using templates and handles response encoding.",
    "inputValues": [
      "request-object-RequestContext",
      "response-object-ResponseContext",
      "templateContext-object-TemplateContext",
      "moduleClass-string-ModuleClass",
      "encoding-string-Encoding"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the following inputs:\n     a. request (RequestContext): Contains user request data including module and action information\n     b. response (ResponseContext): Used for sending the rendered content back to the user\n     c. templateContext (TemplateContext): Contains template variables and context data\n     d. moduleClass (String): The class name of the module to be executed\n     e. encoding (String): Character encoding to be used for the response\n\n2. Data Validation:\n   - Validate request object:\n     a. Check if request is not null\n     b. Verify that module information is available\n     c. Ensure action information is present\n   - Validate response object:\n     a. Verify response is not null and can be written to\n   - Validate moduleClass:\n     a. Check if moduleClass is not null or empty\n     b. Verify that the moduleClass exists in the system\n   - Validate encoding:\n     a. Ensure encoding is a valid character encoding\n     b. If encoding is not specified, use system default encoding\n\n3. Business Rule Processing:\n   - Check user session status:\n     a. Verify if user is logged in\n     b. Load security permissions for the current user\n   - Check IP ban status:\n     a. Retrieve user's IP address\n     b. Check if the IP is in the ban list\n     c. IF IP is banned THEN\n        i. Change module to display ban message\n        ii. IF system is configured to send forbidden status THEN\n            - Set response to forbidden status\n            - Skip further processing\n   - Prepare template context:\n     a. Add module name to context\n     b. Add action name to context\n     c. Add user language to context\n     d. Add user session information to context\n     e. Add request and response objects to context\n\n4. Core Operation Execution:\n   - Retrieve command instance:\n     a. Load the module class using reflection\n     b. Create a new instance of the command\n   - Process the command:\n     a. Execute the command with the request, response, and context\n     b. Retrieve the resulting template\n   - Check for redirect:\n     a. IF redirect is specified THEN\n        i. Store redirect URL for later processing\n        ii. Skip content rendering\n     b. ELSE continue with content rendering\n   - Render content:\n     a. Determine content type:\n        i. IF custom content type is specified THEN use it\n        ii. ELSE use \"text/html\" with specified encoding\n     b. Set content type on response\n     c. IF not custom content THEN\n        i. Create output writer with proper encoding\n        ii. Process template with context\n        iii. Flush output buffer\n\n5. Response Generation:\n   - Finalize response:\n     a. Close output writer if open\n     b. Check for pending redirect:\n        i. IF redirect URL exists THEN\n           - IF encoding is disabled THEN send redirect without encoding\n           - ELSE send redirect with proper URL encoding\n     c. Complete execution context:\n        i. Release any resources\n        ii. Finalize database operations\n   - Handle exceptions:\n     a. IF any exception occurs during processing THEN\n        i. Enable transaction rollback\n        ii. Set content type for error response\n        iii. Write exception details to output\n        iv. Complete execution context",
    "databaseEntities": [
      "jforum_users",
      "jforum_groups",
      "jforum_categories",
      "jforum_forums",
      "jforum_topics",
      "jforum_posts",
      "jforum_sessions",
      "jforum_banlist"
    ],
    "validationRules": [
      "Request object must not be null",
      "Response object must not be null",
      "Module class must exist in the system",
      "Encoding must be a valid character encoding",
      "User IP must be checked against ban list before rendering content",
      "Content type must be set before writing response",
      "Template must be processed with proper context data"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "RequestContext": {
        "type": "object",
        "properties": {
          "module": {
            "type": "string",
            "description": "The requested module name"
          },
          "action": {
            "type": "string",
            "description": "The requested action name"
          },
          "contextPath": {
            "type": "string",
            "description": "The application context path"
          },
          "remoteAddr": {
            "type": "string",
            "description": "The remote IP address"
          }
        }
      },
      "ResponseContext": {
        "type": "object",
        "properties": {
          "outputStream": {
            "type": "object",
            "description": "The output stream for writing response"
          },
          "contentType": {
            "type": "string",
            "description": "The content type of the response"
          }
        }
      },
      "TemplateContext": {
        "type": "object",
        "properties": {
          "variables": {
            "type": "object",
            "description": "Template variables for rendering"
          }
        }
      }
    }
  },
  {
    "featureName": "ManageForumShutdown",
    "description": "Handles graceful shutdown of forum resources including database connections.",
    "inputValues": [
      "shutdownRequest-object-ShutdownRequest"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect shutdownRequest object containing:\n     - requestSource (mandatory): identifies the source initiating the shutdown\n     - shutdownReason (optional): reason for the shutdown\n     - immediateShutdown (mandatory): boolean flag indicating if shutdown should be immediate\n     - notifyUsers (optional): boolean flag indicating if users should be notified\n     - systemGeneratedTimestamp (system-generated): timestamp when shutdown was initiated\n\n2. Data Validation:\n   - Validate shutdownRequest object:\n     - Verify requestSource is not empty and is a valid source\n     - If shutdownReason is provided, ensure it's not exceeding maximum allowed length\n     - Verify immediateShutdown is a valid boolean value\n     - If notifyUsers is true, ensure system is in a state where notifications can be sent\n     - Error message should be generated for each invalid field\n\n3. Business Rule Processing:\n   - Verify system state allows for shutdown:\n     - Check if any critical operations are in progress\n     - Verify administrator privileges for the shutdown request\n     - Check if minimum uptime requirements have been met\n     - Ensure no data backup or maintenance tasks are currently running\n\n4. Core Operation Execution:\n   - Prepare for shutdown:\n     - IF notifyUsers is true, THEN prepare shutdown notification for active users\n     - Log the shutdown event with reason and timestamp\n   - Execute resource cleanup:\n     - Stop accepting new user connections\n     - Wait for existing requests to complete (unless immediateShutdown is true)\n     - Release all database connections:\n       - Call database implementation's connection release method\n       - Verify all connections are properly closed\n       - Log any connection closure failures\n     - Stop cache engine:\n       - Flush any pending cache writes to persistent storage\n       - Release cache resources\n       - Log cache shutdown status\n   - Handle component shutdown:\n     - Shutdown each forum component in proper sequence\n     - For each component:\n       - Attempt graceful shutdown\n       - Log component shutdown status\n       - IF component fails to shutdown AND immediateShutdown is false, THEN retry shutdown\n       - IF retry fails, log error but continue with next component\n   - Finalize shutdown:\n     - Record final system state\n     - Update shutdown status in system records\n     - Release remaining system resources\n\n5. Response Generation:\n   - Generate shutdown completion response:\n     - Include timestamp of completed shutdown\n     - List of successfully closed resources\n     - List of any resources that failed to close properly\n     - Recommendations for system restart if applicable\n     - IF any critical errors occurred during shutdown, include detailed error information\n     - Support contact information for shutdown-related issues",
    "databaseEntities": [
      "jforum_sessions",
      "jforum_users",
      "jforum_posts",
      "jforum_topics",
      "jforum_forums"
    ],
    "validationRules": [
      "Shutdown request must come from an authenticated administrator",
      "All active database transactions must be completed or rolled back before shutdown",
      "Cache engine must be properly stopped to prevent data loss",
      "All database connections must be properly released",
      "System must log all shutdown steps for audit purposes"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "ShutdownRequest": {
        "type": "object",
        "properties": {
          "requestSource": {
            "type": "string",
            "description": "Source initiating the shutdown"
          },
          "shutdownReason": {
            "type": "string",
            "description": "Reason for the shutdown"
          },
          "immediateShutdown": {
            "type": "boolean",
            "description": "Flag indicating if shutdown should be immediate"
          },
          "notifyUsers": {
            "type": "boolean",
            "description": "Flag indicating if users should be notified"
          },
          "systemGeneratedTimestamp": {
            "type": "string",
            "format": "date-time",
            "description": "Timestamp when shutdown was initiated"
          }
        },
        "required": [
          "requestSource",
          "immediateShutdown"
        ]
      }
    }
  },
  {
    "featureName": "StartApplication",
    "description": "Initializes the application by loading configurations and starting required services.",
    "inputValues": [
      "applicationPath-string-System",
      "configurationSettings-object-ConfigurationSettings"
    ],
    "businessLogic": "1. Input Collection:\n   - applicationPath (string, mandatory): The root path of the application\n   - configurationSettings (object, mandatory): Configuration parameters for the application\n     - developmentMode (boolean, optional): Flag indicating if the application should run in development mode, defaults to false\n     - templatePaths (array, optional): List of paths for template loading\n     - configurationFiles (array, mandatory): List of configuration files to load\n\n2. Data Validation:\n   - Validate applicationPath:\n     - Check if applicationPath is not empty\n     - Verify the path exists and is accessible\n     - IF path does not exist or is not accessible THEN\n       - Generate error message: \"Invalid application path provided\"\n       - Terminate startup process\n   - Validate configurationSettings:\n     - Check if required configuration files are specified\n     - Verify all specified file paths exist\n     - IF any required configuration file is missing THEN\n       - Generate error message: \"Missing required configuration file(s)\"\n       - Terminate startup process\n\n3. Business Rule Processing:\n   - Initialize logging system:\n     - Load logging configuration from specified path\n     - Configure logging levels based on development mode\n     - IF logging initialization fails THEN\n       - Generate error message: \"Failed to initialize logging system\"\n       - Terminate startup process\n   - Load system configuration:\n     - Load default configuration values\n     - Load database query definitions\n     - Load driver-specific query definitions\n     - Load additional configuration files if specified\n     - IF configuration loading fails THEN\n       - Generate error message: \"Failed to load system configuration\"\n       - Terminate startup process\n   - Verify system requirements:\n     - Check for required directories and create if missing\n     - Verify write permissions on necessary directories\n     - IF system requirements not met THEN\n       - Generate error message: \"System requirements not met\"\n       - Log specific missing requirements\n       - Terminate startup process\n\n4. Core Operation Execution:\n   - Initialize template engine:\n     - Configure template update delay based on development mode\n     - Set up default template loader with application template path\n     - IF additional template paths specified THEN\n       - Set up multi-template loader with all specified paths\n     - ELSE\n       - Use only default template loader\n     - IF template engine initialization fails THEN\n       - Generate error message: \"Failed to initialize template engine\"\n       - Terminate startup process\n   - Load modules and components:\n     - Initialize module repository\n     - Load URL patterns for routing\n     - Load internationalization resources\n     - Load template mappings\n     - Load text formatting handlers\n     - IF any component fails to load THEN\n       - Generate error message: \"Failed to load required component: [component name]\"\n       - Terminate startup process\n   - Initialize services:\n     - Create authentication service\n     - Load data access implementation\n     - Configure change listeners\n     - Start search indexing service\n     - Start scheduled jobs\n     - Start caching engine\n     - IF any service fails to start THEN\n       - Generate error message: \"Failed to start required service: [service name]\"\n       - Attempt to shut down any started services\n       - Terminate startup process\n\n5. Response Generation:\n   - Create application context:\n     - Store initialized components in application context\n     - Set application state to \"running\"\n   - Generate startup summary:\n     - Record application startup time\n     - Log successful initialization message\n     - Include information about running mode (development/production)\n     - List initialized services and components\n   - IF any warnings occurred during startup THEN\n     - Log warning messages with appropriate severity\n     - Include recommendations for resolving warnings\n   - Return startup status:\n     - Success indicator\n     - Startup timestamp\n     - Application version information\n     - Environment information",
    "databaseEntities": [
      "jforum_users",
      "jforum_groups",
      "jforum_categories",
      "jforum_forums",
      "jforum_topics",
      "jforum_posts",
      "jforum_posts_text",
      "jforum_attachments",
      "jforum_privmsgs",
      "jforum_privmsgs_text",
      "jforum_moderator_groups",
      "jforum_user_groups",
      "jforum_sessions",
      "jforum_smilies",
      "jforum_words",
      "jforum_karma",
      "jforum_bookmarks",
      "jforum_quota_limit",
      "jforum_extension_groups"
    ],
    "validationRules": [
      "Application path must exist and be accessible",
      "Required configuration files must be specified and exist",
      "Template directories must exist and be accessible",
      "System must have appropriate permissions to write to required directories",
      "Required services must initialize successfully",
      "Configuration values must contain all required parameters"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "ConfigurationSettings": {
        "type": "object",
        "properties": {
          "developmentMode": {
            "type": "boolean",
            "description": "Flag indicating if the application should run in development mode"
          },
          "templatePaths": {
            "type": "array",
            "items": {
              "type": "string",
              "description": "Path to template directory"
            },
            "description": "List of paths for template loading"
          },
          "configurationFiles": {
            "type": "array",
            "items": {
              "type": "string",
              "description": "Path to configuration file"
            },
            "description": "List of configuration files to load"
          }
        },
        "required": [
          "configurationFiles"
        ]
      }
    }
  },
  {
    "featureName": "InitializeServlet",
    "description": "Sets up the forum servlet environment including template engine configuration and module loading.",
    "inputValues": [
      "servletConfig-object-ServletConfig",
      "applicationPath-string-System",
      "developmentMode-boolean-System"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect ServletConfig object (mandatory)\n   - Extract application path from servlet context (system-generated)\n   - Determine development mode from initialization parameters (default: false)\n\n2. Data Validation:\n   - Validate ServletConfig is not null\n     * IF ServletConfig is null THEN generate initialization error\n     * Error message: \"ServletConfig cannot be null\"\n   - Validate application path exists and is accessible\n     * IF application path does not exist THEN generate initialization error\n     * Error message: \"Invalid application path\"\n   - Validate development mode parameter format\n     * IF development mode parameter is present but not a valid boolean THEN use default value\n\n3. Business Rule Processing:\n   - Verify system configuration files existence\n     * Check for configuration directory\n     * Check for template directory\n     * Check for logging configuration file\n     * IF any required configuration file is missing THEN generate initialization error\n   - Verify template directory structure\n     * Check for default templates folder\n     * Check for extra templates folder if configured\n     * IF template directories are invalid THEN generate initialization error\n\n4. Core Operation Execution:\n   - Initialize logging system\n     * Configure logging system using configuration file\n     * Set appropriate logging levels based on development mode\n   - Load system configuration\n     * Load default system settings\n     * Load database query definitions\n     * Load additional configuration files\n   - Initialize template engine\n     * Create template configuration\n     * Set template update delay based on development mode\n     * Configure number format settings\n     * Set system startup time\n   - Configure template loaders\n     * Create default template loader\n     * IF extra template path is configured THEN create multi-template loader\n     * ELSE use default template loader only\n   - Initialize system components\n     * Load URL patterns for request handling\n     * Initialize internationalization system\n     * Load template mappings\n     * Initialize text formatting system\n     * Configure authentication mechanism\n     * Load data access components\n     * Start background services\n   - Store template configuration in execution context\n\n5. Response Generation:\n   - Log initialization status\n     * IF initialization successful THEN log success message with configuration details\n     * IF initialization failed THEN log detailed error information\n   - Set initialization status flag\n     * Mark servlet as properly initialized if all steps completed successfully\n     * Store initialization timestamp\n   - Prepare system for request handling\n     * Register servlet in the servlet context\n     * Make initialization status available to dependent components",
    "databaseEntities": [
      "jforum_users",
      "jforum_groups",
      "jforum_categories",
      "jforum_forums",
      "jforum_topics",
      "jforum_posts"
    ],
    "validationRules": [
      "ServletConfig must not be null",
      "Application path must exist and be accessible",
      "Development mode parameter must be a valid boolean value",
      "Configuration directory must exist",
      "Template directory must exist",
      "Logging configuration file must exist and be valid",
      "Database query files must exist and be valid"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "ServletConfig": {
        "type": "object",
        "properties": {
          "servletContext": {
            "type": "object",
            "description": "Context in which the servlet operates"
          },
          "initParameters": {
            "type": "object",
            "description": "Initialization parameters for the servlet"
          }
        }
      }
    }
  },
  {
    "featureName": "LoadConfigurationComponents",
    "description": "Loads URL patterns, internationalization resources, templates and BBCode handlers for the application.",
    "inputValues": [
      "applicationPath-string-System",
      "configDirectory-string-System",
      "templateMappingPath-string-System"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect applicationPath (mandatory): The root path of the application\n   - Collect configDirectory (mandatory): Directory containing configuration files\n   - Collect templateMappingPath (mandatory): Path to template mapping configuration\n   - System will determine if running in debug mode (system-generated)\n\n2. Data Validation:\n   - Validate applicationPath:\n     a. Check if path exists\n     b. Verify read permissions on the path\n     c. IF path does not exist or is not readable THEN\n        i. Generate error message \"Invalid application path\"\n        ii. Abort loading process\n   - Validate configDirectory:\n     a. Check if directory exists within application path\n     b. Verify read permissions on the directory\n     c. IF directory does not exist or is not readable THEN\n        i. Generate error message \"Configuration directory not found or not accessible\"\n        ii. Abort loading process\n   - Validate templateMappingPath:\n     a. Check if file exists\n     b. Verify read permissions on the file\n     c. IF file does not exist or is not readable THEN\n        i. Generate error message \"Template mapping file not found or not accessible\"\n        ii. Abort loading process\n\n3. Business Rule Processing:\n   - Check system state:\n     a. Verify if configuration components are not already loaded\n     b. IF components are already loaded THEN\n        i. Determine if reload is necessary based on timestamps\n        ii. IF reload not necessary THEN skip loading\n   - Check dependencies:\n     a. Verify that system globals are initialized\n     b. Verify that cache engine is running\n     c. IF any dependency check fails THEN\n        i. Generate appropriate error message\n        ii. Abort loading process\n\n4. Core Operation Execution:\n   - Load URL patterns:\n     a. Read URL pattern configuration files from config directory\n     b. Parse pattern definitions\n     c. Register patterns in the system repository\n     d. IF any pattern fails to load THEN\n        i. Log warning message\n        ii. Continue with next pattern\n   - Load internationalization resources:\n     a. Determine current locale setting\n     b. Load language resource files for the locale\n     c. Parse language key-value pairs\n     d. Register translations in the system repository\n     e. IF any resource fails to load THEN\n        i. Log warning message\n        ii. Continue with next resource\n   - Load templates:\n     a. Read template mapping file\n     b. Parse template definitions\n     c. Register templates in the system repository\n     d. IF any template fails to load THEN\n        i. Log warning message\n        ii. Continue with next template\n   - Load BBCode handlers:\n     a. Initialize BBCode parser\n     b. Parse BBCode definitions\n     c. Register BBCode collection in the system repository\n     d. IF any BBCode definition fails to parse THEN\n        i. Log warning message\n        ii. Continue with next definition\n\n5. Response Generation:\n   - Generate success response:\n     a. Create summary of loaded components\n     b. Include counts of loaded URL patterns, language resources, templates, and BBCode handlers\n     c. Include timestamp of completion\n   - IF any component failed to load completely THEN\n     a. Include warning message in response\n     b. List specific components that failed to load\n   - IF critical failure occurred THEN\n     a. Generate error response with detailed message\n     b. Include troubleshooting information",
    "databaseEntities": [],
    "validationRules": [
      "Application path must exist and be readable",
      "Configuration directory must exist and be readable",
      "Template mapping file must exist and be readable",
      "URL patterns must follow the defined format",
      "Language resource files must exist for the configured locale",
      "Template definitions must reference existing template files",
      "BBCode definitions must follow the correct syntax"
    ],
    "dbSeedingOperations": [],
    "schema": {}
  },
  {
    "featureName": "GetExecutionContext",
    "description": "Retrieves the current thread's execution context for forum operations.",
    "inputValues": [],
    "businessLogic": "1. Input Collection:\n   - No explicit user inputs required\n   - System will use the current thread context\n\n2. Data Validation:\n   - Check if execution context exists in the current thread\n     - IF context does not exist, system must create a new context\n     - IF context exists, system must retrieve the existing context\n\n3. Business Rule Processing:\n   - Verify thread local storage accessibility\n     - IF thread local storage is inaccessible, prepare appropriate error response\n   - Check execution context state\n     - IF execution context is in an inconsistent state, prepare error information\n\n4. Core Operation Execution:\n   - Retrieve execution context from thread local storage\n     - IF no context exists in current thread:\n       - Create new execution context instance\n       - Store new context in thread local storage\n     - ELSE:\n       - Return existing execution context\n   - Ensure context contains all required components:\n     - Database connection information\n     - Forum context data\n     - Template context\n     - Response/request information\n     - Content type settings\n     - Redirect information\n\n5. Response Generation:\n   - Return complete execution context object containing:\n     - Current database connection\n     - Forum context\n     - Template context\n     - Redirect information\n     - Content type settings\n     - Custom content flags\n     - Transaction state information",
    "databaseEntities": [],
    "validationRules": [
      "Execution context must be thread-specific",
      "Context must contain valid forum context if available",
      "Context must maintain database connection state"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "ExecutionContext": {
        "type": "object",
        "properties": {
          "connection": {
            "type": "object",
            "description": "Database connection for the current thread"
          },
          "forumContext": {
            "type": "object",
            "description": "Context containing forum-specific information"
          },
          "templateContext": {
            "type": "object",
            "description": "Template rendering context"
          },
          "redirectTo": {
            "type": "string",
            "description": "URL to redirect to, if applicable"
          },
          "contentType": {
            "type": "string",
            "description": "Content type for the current response"
          },
          "isCustomContent": {
            "type": "boolean",
            "description": "Flag indicating if response has custom content"
          },
          "enableRollback": {
            "type": "boolean",
            "description": "Flag indicating if transaction should be rolled back"
          }
        }
      }
    }
  },
  {
    "featureName": "ManageDatabaseConnection",
    "description": "Handles database connection lifecycle including transactions and rollbacks.",
    "inputValues": [
      "connection-object-Connection",
      "forumContext-object-ForumContext",
      "enableRollback-boolean-System"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect database connection object (mandatory)\n   - Collect forum context information (mandatory)\n   - Determine transaction behavior settings (mandatory)\n   - Determine content type settings (optional)\n   - Determine redirect information (optional)\n\n2. Data Validation:\n   - Validate connection object:\n     * Check if connection is null\n     * Verify connection is valid and open\n   - Validate forum context:\n     * Ensure request context is available\n     * Ensure response context is available\n   - Validate transaction settings:\n     * Confirm transaction mode is properly configured\n     * Verify auto-commit settings match system configuration\n\n3. Business Rule Processing:\n   - Initialize execution context:\n     * Create thread-local storage for context data\n     * Set up template context for rendering\n   - Configure connection properties:\n     * Set auto-commit based on system transaction settings\n     * Associate connection with current thread context\n   - Prepare response parameters:\n     * Set content type if specified\n     * Configure redirect information if needed\n\n4. Core Operation Execution:\n   - Connection Management:\n     * Store connection in thread-local context\n     * Configure connection based on system settings\n     * Make connection available to application components\n   - Transaction Control:\n     * IF transaction support is enabled THEN\n       > Manage transaction boundaries\n       > Support explicit rollback requests\n       > Handle commit/rollback operations\n     * ELSE\n       > Use auto-commit mode\n   - Context Lifecycle Management:\n     * Maintain execution context throughout request\n     * Support context retrieval operations\n     * Enable custom content handling when needed\n\n5. Response Generation:\n   - Connection Cleanup:\n     * IF connection exists THEN\n       > IF using transactions THEN\n         * IF rollback requested THEN\n           - Execute rollback operation\n         * ELSE\n           - Commit transaction\n       > Release connection back to pool\n     * Clear thread-local storage\n   - Response Finalization:\n     * Apply content type settings\n     * Process any redirect instructions\n     * Handle authentication requirements if needed",
    "databaseEntities": [],
    "validationRules": [
      "Connection must be valid before operations",
      "Auto-commit setting must match system configuration",
      "Thread context must be properly initialized",
      "Connection must be released after use",
      "Transactions must be either committed or rolled back",
      "Thread-local storage must be cleared after request completion"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Connection": {
        "type": "object",
        "properties": {
          "autoCommit": {
            "type": "boolean",
            "description": "Controls whether transactions are automatically committed"
          }
        }
      },
      "ForumContext": {
        "type": "object",
        "properties": {
          "request": {
            "type": "object",
            "description": "Request context containing HTTP request information"
          },
          "response": {
            "type": "object",
            "description": "Response context for HTTP response handling"
          }
        }
      }
    }
  },
  {
    "featureName": "HandleRedirection",
    "description": "Sets and retrieves URL redirection information for forum navigation.",
    "inputValues": [
      "redirectUrl-string-Navigation",
      "contentType-string-Response",
      "customContent-boolean-Response"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect redirectUrl (string): The URL to redirect to\n   - Collect contentType (string): The content type for the response\n   - Collect customContent (boolean): Flag indicating if custom content is being used\n   - System will use current execution context if available\n\n2. Data Validation:\n   - Validate redirectUrl:\n     2.1. Check if redirectUrl is not null when setting a redirection\n     2.2. Verify redirectUrl follows valid URL format\n     2.3. Return error if validation fails\n   - Validate contentType:\n     2.4. Check if contentType is a recognized MIME type\n     2.5. Return error if validation fails\n   - Validate execution context:\n     2.6. Verify that a forum execution context exists\n     2.7. If no context exists, create a new context\n     2.8. Return error if context cannot be established\n\n3. Business Rule Processing:\n   - Check execution context state:\n     3.1. Verify the current thread has an active execution context\n     3.2. IF no context exists, create a new execution context\n     3.3. Store the context in thread-local storage\n   - Process redirection settings:\n     3.4. IF redirectUrl is provided, store it in the execution context\n     3.5. IF contentType is provided, store it in the execution context\n     3.6. IF customContent flag is provided, update the custom content setting\n\n4. Core Operation Execution:\n   - Set redirection information:\n     4.1. Store the redirectUrl in the current execution context\n     4.2. Update the content type if specified\n     4.3. Update custom content flag if specified\n   - Retrieve redirection information:\n     4.4. Access the current execution context\n     4.5. Retrieve the stored redirectUrl\n     4.6. Retrieve the content type setting\n     4.7. Retrieve the custom content flag\n   - Handle special redirection cases:\n     4.8. IF basic authentication is requested, add appropriate headers\n     4.9. Set response status code to 401 (Unauthorized) if needed\n     4.10. Enable custom content handling for special responses\n\n5. Response Generation:\n   - For redirection setting:\n     5.1. Return confirmation that redirection has been set\n     5.2. Include the set URL in the confirmation\n   - For redirection retrieval:\n     5.3. Return the current redirection URL\n     5.4. Include content type information\n     5.5. Include custom content flag status\n   - For authentication requests:\n     5.6. Return authentication challenge response\n     5.7. Include appropriate authentication headers",
    "databaseEntities": [
      "jforum_sessions"
    ],
    "validationRules": [
      "Redirection URL must be properly formatted",
      "Content type must be a valid MIME type",
      "An execution context must exist or be created",
      "Custom content flag must be a boolean value"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Navigation": {
        "type": "object",
        "properties": {
          "redirectUrl": {
            "type": "string",
            "description": "URL to redirect the user to"
          }
        }
      },
      "Response": {
        "type": "object",
        "properties": {
          "contentType": {
            "type": "string",
            "description": "MIME type for the response"
          },
          "customContent": {
            "type": "boolean",
            "description": "Flag indicating if custom content is being used"
          }
        }
      }
    }
  },
  {
    "featureName": "ManageContentType",
    "description": "Controls HTTP response content type settings for different forum outputs.",
    "inputValues": [
      "contentType-string-ResponseSettings",
      "isCustomContent-boolean-ResponseSettings",
      "enableRollback-boolean-TransactionSettings"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the following inputs:\n     a. contentType (string, mandatory): The MIME type to set for the HTTP response\n     b. isCustomContent (boolean, optional): Flag to indicate if response contains custom/binary content\n     c. enableRollback (boolean, optional): Flag to control transaction behavior\n\n2. Data Validation:\n   - Validate contentType input:\n     a. IF contentType is null or empty THEN\n        i. Generate error message: \"Content type must be specified\"\n     b. ELSE\n        i. Verify contentType follows valid MIME type format\n        ii. IF invalid format THEN generate error: \"Invalid content type format\"\n   - Validate isCustomContent input:\n     a. IF isCustomContent is null THEN\n        i. Set default value to false\n   - Validate enableRollback input:\n     a. IF enableRollback is null THEN\n        i. Set default value to false\n\n3. Business Rule Processing:\n   - Check current system state:\n     a. Verify execution context exists\n        i. IF execution context does not exist THEN\n           1. Create new execution context\n           2. Set it as current context\n   - Check content type compatibility:\n     a. IF isCustomContent is true THEN\n        i. Verify contentType is appropriate for binary data\n        ii. IF incompatible THEN generate warning: \"Content type may be incompatible with binary data\"\n   - Check transaction state:\n     a. IF enableRollback is true THEN\n        i. Verify database connection supports transactions\n        ii. IF transactions not supported THEN generate warning: \"Rollback requested but transactions not supported\"\n\n4. Core Operation Execution:\n   - Set content type in execution context:\n     a. Store contentType value in current execution context\n   - Configure custom content flag:\n     a. Set isCustomContent flag in current execution context\n   - Configure transaction behavior:\n     a. IF enableRollback is true THEN\n        i. Mark current transaction for rollback\n   - Apply content type to HTTP response:\n     a. Get current response object from execution context\n     b. Set content type on response object\n     c. IF operation fails THEN\n        i. Log error: \"Failed to set content type on response\"\n        ii. Generate appropriate error response\n\n5. Response Generation:\n   - For successful operation:\n     a. Return success status\n     b. Include confirmation that content type was set\n     c. Include current content type value\n   - For failed operation:\n     a. Return error status\n     b. Include specific error message\n     c. Include guidance for resolving the issue\n     d. Log detailed error information for system administrators",
    "databaseEntities": [],
    "validationRules": [
      "Content type must not be empty",
      "Content type must follow valid MIME type format",
      "Custom content flag must be a boolean value",
      "Rollback flag must be a boolean value"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "ResponseSettings": {
        "type": "object",
        "properties": {
          "contentType": {
            "type": "string",
            "description": "MIME type for the HTTP response"
          },
          "isCustomContent": {
            "type": "boolean",
            "description": "Flag indicating if response contains custom/binary content"
          }
        }
      },
      "TransactionSettings": {
        "type": "object",
        "properties": {
          "enableRollback": {
            "type": "boolean",
            "description": "Flag to control transaction behavior"
          }
        }
      }
    }
  },
  {
    "featureName": "RequestBasicAuthentication",
    "description": "Triggers HTTP basic authentication for securing forum access.",
    "inputValues": [],
    "businessLogic": "1. Input Collection:\n   - No explicit user inputs required\n   - System-generated authentication request\n\n2. Data Validation:\n   - No input validation required as this is a system-initiated process\n\n3. Business Rule Processing:\n   - Verify current user authentication status\n     3.1. Check if user is already authenticated\n     3.2. IF user is authenticated, THEN skip authentication request\n     3.3. IF user is not authenticated, THEN proceed with authentication request\n   - Determine if the requested resource requires authentication\n     3.4. Check access control rules for the requested resource\n     3.5. IF resource does not require authentication, THEN skip authentication request\n     3.6. IF resource requires authentication, THEN proceed with authentication request\n\n4. Core Operation Execution:\n   - Prepare authentication challenge\n     4.1. Create authentication header with realm information\n     4.2. Set realm name to \"JForum\"\n   - Send authentication challenge to user\n     4.3. Set HTTP response status code to 401 (Unauthorized)\n     4.4. Add WWW-Authenticate header to the response\n     4.5. Mark the response as containing custom content\n   - Handle potential errors\n     4.6. IF error occurs while sending the authentication challenge\n          4.6.1. Log the error details\n          4.6.2. Convert to appropriate system exception\n\n5. Response Generation:\n   - Authentication challenge response\n     5.1. Browser receives 401 status code with WWW-Authenticate header\n     5.2. Browser displays authentication dialog to the user\n     5.3. User enters credentials or cancels the authentication\n   - Post-authentication handling\n     5.4. IF user provides credentials\n          5.4.1. System will receive credentials in a subsequent request\n          5.4.2. Credentials will be validated in a separate process\n     5.5. IF user cancels authentication\n          5.5.1. User will not gain access to the protected resource",
    "databaseEntities": [
      "jforum_users",
      "jforum_sessions"
    ],
    "validationRules": [
      "Authentication challenge must include the realm name",
      "HTTP response status must be set to 401 (Unauthorized)",
      "Custom content flag must be enabled to prevent default error pages"
    ],
    "dbSeedingOperations": [],
    "schema": {}
  },
  {
    "featureName": "AddUserSession",
    "description": "Registers a new user session with appropriate tracking for logged-in or anonymous users.",
    "inputValues": [
      "userSession-object-UserSession",
      "connection-object-Connection",
      "checked-boolean-System"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect UserSession object with user information\n     - userId (number): Identifier of the user\n     - username (string): Name of the user\n     - sessionId (string): Unique identifier for the session\n     - lastVisit (date): Timestamp of the last visit\n     - startTime (date): Timestamp when the session started\n     - ip (string): IP address of the user\n     - isBot (boolean): Flag indicating if the user is a bot\n     - sessionTime (number): Duration of the session in milliseconds\n   - Collect database connection object\n     - connection (object): Database connection for persistence\n     - If null, system will handle accordingly based on implementation\n   - Collect checked flag (optional)\n     - checked (boolean): Flag to bypass existing session check\n     - Default value is false if not provided\n\n2. Data Validation:\n   - Validate UserSession object\n     - Ensure UserSession object is not null\n     - Verify sessionId is not null or empty\n     - Validate userId is a valid number\n     - Ensure startTime is a valid date\n   - Validate connection object if database persistence is required\n     - If connection is required but null, prepare appropriate error\n   - Validate session data integrity\n     - Ensure startTime is not in the future\n     - Verify IP address format is valid\n\n3. Business Rule Processing:\n   - Determine user type based on userId\n     - IF userId equals system-defined anonymous user ID THEN\n       - Mark as anonymous user\n     - ELSE\n       - Mark as logged-in user\n   - Check for existing sessions\n     - IF checked flag is false THEN\n       - Query database for existing session with same userId\n       - IF existing session found THEN\n         - Skip adding new session and return\n   - Check for bot detection\n     - IF isBot flag is true THEN\n       - Skip user counting operations\n     - ELSE\n       - Proceed with user counting\n\n4. Core Operation Execution:\n   - Prepare UserSession object for storage\n     - Ensure all required fields are populated\n     - Format startTime as database timestamp\n   - IF existing session check is bypassed OR no existing session found THEN\n     - Execute database insert operation\n       - Store sessionId, userId, and startTime in database\n       - Handle any database errors that may occur\n   - Process user type specific operations\n     - IF user is logged in (not anonymous) THEN\n       - Update user's last activity timestamp\n       - Associate session with user account\n     - ELSE IF user is anonymous THEN\n       - Track anonymous session separately if needed\n   - Update session statistics\n     - Increment active session counters\n     - Update online users list\n\n5. Response Generation:\n   - Return success status\n     - Indicate successful session registration\n   - Provide session information\n     - Include sessionId for reference\n     - Include session creation timestamp\n   - Handle potential errors\n     - Return appropriate error messages for validation failures\n     - Include guidance for resolving persistence issues\n     - Throw DatabaseException for SQL errors",
    "databaseEntities": [
      "jforum_sessions",
      "jforum_users"
    ],
    "validationRules": [
      "UserSession object must not be null",
      "SessionId must not be null or empty",
      "User must be properly identified as either anonymous or logged-in",
      "Bot requests should be identified and handled appropriately",
      "Connection object must be valid if database persistence is required",
      "StartTime must be a valid date",
      "Database operations must handle SQL exceptions properly"
    ],
    "dbSeedingOperations": [
      "Ensure system has a valid anonymous user ID configured",
      "Ensure jforum_sessions table exists with proper schema"
    ],
    "schema": {
      "UserSession": {
        "userId": "number",
        "username": "string",
        "sessionId": "string",
        "lastVisit": "date",
        "startTime": "date",
        "sessionTime": "number",
        "ip": "string",
        "isBot": "boolean"
      },
      "Connection": {
        "status": "string",
        "autoCommit": "boolean"
      }
    }
  },
  {
    "featureName": "ManageSessionAttributes",
    "description": "Adds, retrieves, and removes attributes from the user's session.",
    "inputValues": [
      "name-string-SessionAttribute",
      "value-object-AttributeValue",
      "operation-string-OperationType"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the following inputs:\n     a. name (string, mandatory): The attribute name to identify the session attribute\n     b. value (object, mandatory for setAttribute operation): The attribute value to store\n     c. operation (string, mandatory): The operation to perform (setAttribute, getAttribute, removeAttribute, getAttributeNames, getId, invalidate)\n\n2. Data Validation:\n   - Validate the attribute name:\n     a. IF name is null or empty THEN\n        - Return error: \"Attribute name cannot be empty\"\n     b. IF name contains invalid characters THEN\n        - Return error: \"Attribute name contains invalid characters\"\n   - Validate the operation type:\n     a. IF operation is not one of (setAttribute, getAttribute, removeAttribute, getAttributeNames, getId, invalidate) THEN\n        - Return error: \"Invalid operation type specified\"\n   - Validate the attribute value for setAttribute operation:\n     a. IF operation is setAttribute AND value is null THEN\n        - Return warning: \"Setting null value for attribute\"\n\n3. Business Rule Processing:\n   - Verify session availability:\n     a. IF current user session is not available THEN\n        - Return error: \"No active session found\"\n   - Check session capacity:\n     a. IF operation is setAttribute AND session attribute count exceeds maximum limit THEN\n        - Return error: \"Session attribute limit exceeded\"\n   - Verify attribute access permissions:\n     a. IF attribute name starts with reserved prefix THEN\n        - Verify user has administrative privileges\n        - IF user lacks administrative privileges THEN\n           - Return error: \"Insufficient permissions to modify system attributes\"\n   - Verify session state for operations:\n     a. IF session has been invalidated THEN\n        - Return error: \"Cannot perform operations on an invalidated session\"\n\n4. Core Operation Execution:\n   - Process the requested operation:\n     a. IF operation is setAttribute THEN\n        - Store the attribute name and value in the current session\n        - Record the attribute modification in the session history\n     b. IF operation is getAttribute THEN\n        - Retrieve the attribute value from the current session using the provided name\n        - IF attribute does not exist THEN\n           - Return null or appropriate default value\n     c. IF operation is removeAttribute THEN\n        - Remove the attribute from the current session\n        - Record the attribute removal in the session history\n     d. IF operation is getAttributeNames THEN\n        - Retrieve the enumeration of all attribute names in the current session\n     e. IF operation is getId THEN\n        - Retrieve the unique identifier for the current session\n     f. IF operation is invalidate THEN\n        - Invalidate the current session, removing all attributes\n        - Record the session invalidation event\n   - Update session timestamp:\n     a. Update the last accessed timestamp for the session\n\n5. Response Generation:\n   - Generate appropriate response based on operation:\n     a. IF operation was setAttribute THEN\n        - Return success confirmation: \"Attribute [name] has been set successfully\"\n     b. IF operation was getAttribute THEN\n        - Return the retrieved attribute value or null if not found\n     c. IF operation was removeAttribute THEN\n        - Return success confirmation: \"Attribute [name] has been removed successfully\"\n     d. IF operation was getAttributeNames THEN\n        - Return enumeration of all attribute names in the session\n     e. IF operation was getId THEN\n        - Return the unique session identifier\n     f. IF operation was invalidate THEN\n        - Return confirmation: \"Session has been invalidated successfully\"\n   - Include operation metadata:\n     a. Include timestamp of operation\n     b. Include session identifier (masked for security)\n     c. Include remaining session lifetime",
    "databaseEntities": [
      "jforum_sessions"
    ],
    "validationRules": [
      "Attribute name must not be empty",
      "Operation type must be one of: setAttribute, getAttribute, removeAttribute, getAttributeNames, getId, invalidate",
      "User must have an active session",
      "User must have appropriate permissions for system attributes",
      "Session must not exceed maximum attribute count",
      "Session must not be invalidated for attribute operations"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "AttributeValue": {
        "type": "object",
        "properties": {
          "value": {
            "type": [
              "string",
              "number",
              "boolean",
              "object",
              "null"
            ],
            "description": "The actual value of the attribute"
          },
          "expirationTime": {
            "type": [
              "number",
              "null"
            ],
            "description": "Optional expiration time for the attribute"
          },
          "isTransient": {
            "type": "boolean",
            "description": "Flag indicating if the attribute should persist across sessions"
          }
        }
      },
      "OperationType": {
        "type": "string",
        "enum": [
          "setAttribute",
          "getAttribute",
          "removeAttribute",
          "getAttributeNames",
          "getId",
          "invalidate"
        ],
        "description": "The type of operation to perform on the session"
      }
    }
  },
  {
    "featureName": "RemoveUserSession",
    "description": "Removes a user session from the system and updates relevant counters.",
    "inputValues": [
      "sessionId-string-Session"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the sessionId (string) of the session to be removed\n   - System will use this sessionId to identify the session to remove\n\n2. Data Validation:\n   - Validate that sessionId is not null or empty\n     - IF sessionId is null or empty THEN\n       - Return an error message indicating that a valid session ID is required\n     - END IF\n   - Verify that the cache system is available\n     - IF cache system is not available THEN\n       - Log a warning message about null cache instance\n       - Return an error indicating the system is temporarily unavailable\n     - END IF\n\n3. Business Rule Processing:\n   - Check if the session exists in the system\n     - Retrieve the user session information using the provided sessionId\n     - IF session does not exist THEN\n       - Log that no session was found for the given sessionId\n       - Return a message indicating the session was not found\n     - END IF\n   - Determine the user type (logged in or anonymous) associated with the session\n     - Retrieve the userId from the session\n     - Compare userId with the system's anonymous user ID value\n\n4. Core Operation Execution:\n   - Acquire a synchronization lock to prevent concurrent modifications\n   - Remove the session from the logged sessions collection if applicable\n     - IF session exists in logged sessions THEN\n       - Remove the session from logged sessions collection\n     - END IF\n   - Remove any user ID mappings associated with this session\n     - IF user ID mapping exists THEN\n       - Remove the mapping between user ID and session ID\n     - END IF\n   - Update the appropriate user counter\n     - IF user is a logged-in user THEN\n       - Decrease the logged users count by 1\n     - ELSE IF user is an anonymous user THEN\n       - Decrease the anonymous users count by 1\n     - END IF\n   - Remove the main session entry from the system\n   - Release the synchronization lock\n\n5. Response Generation:\n   - Generate a success response\n     - Include confirmation that the session was successfully removed\n     - Include the session ID that was removed\n     - Include the updated counts of logged and anonymous users\n   - IF any errors occurred during the process THEN\n     - Generate an error response with appropriate error details\n     - Include guidance on how to retry the operation if applicable\n   - END IF",
    "databaseEntities": [
      "jforum_sessions"
    ],
    "validationRules": [
      "Session ID must not be null or empty",
      "Cache system must be available",
      "Session must exist in the system to be removed"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Session": {
        "sessionId": "string",
        "userId": "number",
        "username": "string",
        "lastVisit": "date",
        "isLogged": "boolean"
      }
    }
  },
  {
    "featureName": "GetSessionInformation",
    "description": "Retrieves information about all sessions, logged sessions, and session counts.",
    "inputValues": [],
    "businessLogic": "1. Input Collection:\n   - No user inputs required for this feature\n   - System will use current session context for data retrieval\n\n2. Data Validation:\n   - Verify cache system is initialized and available\n   - IF cache is null THEN\n     2.1. Log warning message\n     2.2. Return appropriate error response\n   - END IF\n\n3. Business Rule Processing:\n   - Verify session data access permissions\n   - Check if current user has administrative privileges to view session data\n   - IF user does not have required permissions THEN\n     3.1. Generate access denied response\n     3.2. Log unauthorized access attempt\n     3.3. Return error response\n   - END IF\n\n4. Core Operation Execution:\n   - Retrieve session information:\n     4.1. Acquire synchronization lock on session data to ensure thread safety\n     4.2. Collect all active sessions from the cache system\n     4.3. Collect all logged-in user sessions from the cache system\n     4.4. Calculate session counts:\n       4.4.1. Retrieve logged user count from cache\n       4.4.2. Retrieve anonymous user count from cache\n       4.4.3. Calculate total user count (sum of logged and anonymous users)\n     4.5. Release synchronization lock\n   - Process session data for presentation:\n     4.6. Filter out system sessions if applicable\n     4.7. Sort sessions based on predefined criteria (e.g., login time, username)\n     4.8. Format session data for display\n\n5. Response Generation:\n   - Prepare response with session information:\n     5.1. Include total number of active sessions\n     5.2. Include breakdown of logged vs. anonymous users\n     5.3. Include detailed list of all sessions with relevant attributes\n     5.4. Include detailed list of logged sessions with relevant attributes\n   - Format response according to display requirements\n   - Return complete session information package",
    "databaseEntities": [
      "jforum_sessions",
      "jforum_users"
    ],
    "validationRules": [
      "Cache system must be initialized before retrieving session information",
      "User must have appropriate permissions to view session data",
      "Session counts must accurately reflect the number of active sessions",
      "Session data must be protected with proper synchronization"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Session": {
        "type": "object",
        "properties": {
          "sessionId": {
            "type": "string",
            "description": "Unique identifier for the session"
          },
          "userId": {
            "type": "integer",
            "description": "User identifier associated with the session"
          },
          "username": {
            "type": "string",
            "description": "Username of the logged-in user"
          },
          "isLogged": {
            "type": "boolean",
            "description": "Indicates if the session belongs to a logged-in user"
          },
          "lastVisit": {
            "type": "date",
            "description": "Timestamp of the last activity in the session"
          },
          "isBot": {
            "type": "boolean",
            "description": "Indicates if the session belongs to a web crawler or bot"
          }
        }
      },
      "SessionSummary": {
        "type": "object",
        "properties": {
          "totalSessions": {
            "type": "integer",
            "description": "Total number of active sessions"
          },
          "loggedUsers": {
            "type": "integer",
            "description": "Number of logged-in users"
          },
          "anonymousUsers": {
            "type": "integer",
            "description": "Number of anonymous users"
          },
          "allSessions": {
            "type": "array",
            "items": {
              "$ref": "#/Session"
            },
            "description": "List of all active sessions"
          },
          "loggedSessions": {
            "type": "array",
            "items": {
              "$ref": "#/Session"
            },
            "description": "List of sessions for logged-in users"
          }
        }
      }
    }
  },
  {
    "featureName": "CheckUserSessionStatus",
    "description": "Verifies if a user is in session by username or ID and checks login status.",
    "inputValues": [
      "username-string-User",
      "userId-number-User",
      "sessionId-string-Session"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect one of the following inputs:\n     - username (string): The username to check in session\n     - userId (number): The user ID to check in session\n     - sessionId (string): The session ID to retrieve user information\n   - Note: At least one of these inputs must be provided\n   - System will use current session ID if none is provided\n\n2. Data Validation:\n   - IF username is provided:\n     - Verify username is not empty\n     - Verify username format is valid (alphanumeric with allowed special characters)\n   - IF userId is provided:\n     - Verify userId is a positive integer\n     - Verify userId is not the anonymous user ID\n   - IF sessionId is provided:\n     - Verify sessionId is not empty\n     - Verify sessionId follows the expected format\n   - IF no input is provided:\n     - Use current user's session ID\n     - Verify current session exists\n\n3. Business Rule Processing:\n   - Check if cache system is initialized and available\n     - IF cache is not available:\n       - Log warning message\n       - Return appropriate error response\n   - Determine which verification method to use based on provided inputs:\n     - IF username is provided:\n       - Use username-based verification\n     - ELSE IF userId is provided:\n       - Use userId-based verification\n     - ELSE:\n       - Use sessionId-based verification\n\n4. Core Operation Execution:\n   - IF using username-based verification:\n     - Retrieve all active sessions from cache\n     - Iterate through each session:\n       - Skip anonymous users\n       - Compare username with each session's username\n       - IF match found:\n         - Store matching session ID\n         - Break iteration\n   - IF using userId-based verification:\n     - Directly query the user ID index in cache\n     - Retrieve associated session ID if exists\n   - IF using sessionId-based verification:\n     - Retrieve user session object from cache using session ID\n     - Extract user information from session object\n   - Check login status:\n     - Verify if session has logged attribute set to \"1\"\n     - Determine if user is anonymous by comparing with system anonymous ID\n\n5. Response Generation:\n   - Prepare session status response with:\n     - isInSession (boolean): Whether user is found in any active session\n     - sessionId (string): The session ID if user is in session, null otherwise\n     - isLoggedIn (boolean): Whether user is authenticated (not anonymous)\n     - lastActivityTime (date): Timestamp of last user activity if available\n     - username (string): Username associated with the session if available\n     - userId (number): User ID associated with the session if available\n   - IF verification failed due to system error:\n     - Include appropriate error message\n     - Include error code for client handling",
    "databaseEntities": [
      "jforum_users",
      "jforum_sessions"
    ],
    "validationRules": [
      "At least one of username, userId, or sessionId must be provided",
      "Username must not be empty when provided",
      "UserId must be a positive integer when provided",
      "UserId must not be the anonymous user ID when verifying login status",
      "SessionId must not be empty when provided",
      "Cache system must be initialized before checking session status"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "User": {
        "type": "object",
        "properties": {
          "userId": {
            "type": "number",
            "description": "Unique identifier for the user"
          },
          "username": {
            "type": "string",
            "description": "User's login name"
          }
        }
      },
      "Session": {
        "type": "object",
        "properties": {
          "sessionId": {
            "type": "string",
            "description": "Unique identifier for the session"
          },
          "userId": {
            "type": "number",
            "description": "User ID associated with this session"
          },
          "username": {
            "type": "string",
            "description": "Username associated with this session"
          },
          "isLogged": {
            "type": "boolean",
            "description": "Whether the user is logged in"
          },
          "lastActivity": {
            "type": "date",
            "description": "Timestamp of the last user activity"
          }
        }
      }
    }
  },
  {
    "featureName": "ManageLoginState",
    "description": "Controls the logged-in state of user sessions with login/logout functionality.",
    "inputValues": [
      "sessionId-string-Session",
      "userId-number-User",
      "username-string-User",
      "userSession-object-UserSession"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect sessionId (string, mandatory)\n   - Collect userId (number, mandatory)\n   - Collect username (string, mandatory)\n   - Collect userSession object (object, mandatory)\n   - System generates session tracking data\n\n2. Data Validation:\n   - Validate sessionId:\n     a. Check if sessionId is not null or empty\n     b. Verify sessionId format is valid\n     c. Return error if validation fails\n   - Validate userId:\n     a. Verify userId is a positive integer\n     b. Check if userId exists in the system\n     c. Return error if validation fails\n   - Validate username:\n     a. Verify username is not null or empty\n     b. Check if username exists and matches userId\n     c. Return error if validation fails\n\n3. Business Rule Processing:\n   - Check system state:\n     a. Verify if cache system is initialized\n     b. Ensure session tracking is enabled\n     c. Return error if system is not ready\n   - Verify session constraints:\n     a. Check if maximum session limit is reached\n     b. Verify if user is allowed to login based on account status\n     c. Return error if constraints are violated\n\n4. Core Operation Execution:\n   - Login Operation:\n     a. Create new user session if not exists\n     b. Associate sessionId with userId\n     c. Mark session as logged in\n     d. Update logged users count\n     e. Store session in cache\n     f. IF login fails, rollback any partial changes\n   - Logout Operation:\n     a. Retrieve user session using sessionId\n     b. Mark session as logged out\n     c. Remove user from logged users list\n     d. Update logged users count\n     e. Maintain session as anonymous or remove completely\n     f. IF logout fails, ensure consistent system state\n   - Session Management:\n     a. Track active sessions\n     b. Monitor session timeouts\n     c. Clean up expired sessions\n     d. Maintain accurate counts of logged vs. anonymous users\n\n5. Response Generation:\n   - Success Response:\n     a. Return session status (logged in/out)\n     b. Include session identifier\n     c. Provide session expiration information\n   - Error Response:\n     a. Return specific error code and message\n     b. Include troubleshooting information\n     c. Log detailed error for system administrators",
    "databaseEntities": [
      "jforum_users",
      "jforum_sessions",
      "jforum_user_groups"
    ],
    "validationRules": [
      "Session ID must not be empty",
      "User ID must be a positive integer",
      "Username must not be empty",
      "User must exist in the system",
      "Session must be valid and not expired",
      "Anonymous users must have the system-defined anonymous ID",
      "Each user can have only one active session"
    ],
    "dbSeedingOperations": [
      "Initialize anonymous user ID in system configuration",
      "Set up default session timeout values"
    ],
    "schema": {
      "UserSession": {
        "sessionId": "string",
        "userId": "number",
        "username": "string",
        "lastVisit": "date",
        "startTime": "date",
        "isLogged": "boolean",
        "isAnonymous": "boolean"
      }
    }
  },
  {
    "featureName": "TrackTopicReadTimes",
    "description": "Manages tracking information about when topics were last read by users.",
    "inputValues": [
      "userId-number-User",
      "topicId-number-Topic",
      "readTime-date-ReadTime"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect userId (number, mandatory) - The identifier of the user\n   - Collect topicId (number, mandatory) - The identifier of the topic being read\n   - Collect readTime (date, system-generated, default: current timestamp) - The time when the topic was read\n\n2. Data Validation:\n   - Validate userId:\n      * Verify userId is a positive integer\n      * Verify userId exists in the system\n      * IF userId is invalid THEN return error message \"Invalid user identifier\"\n   - Validate topicId:\n      * Verify topicId is a positive integer\n      * Verify topicId exists in the system\n      * IF topicId is invalid THEN return error message \"Invalid topic identifier\"\n   - Validate readTime:\n      * Verify readTime is a valid date format\n      * Verify readTime is not in the future\n      * IF readTime is invalid THEN use current system time instead\n\n3. Business Rule Processing:\n   - Check user session status:\n      * Verify user has an active session\n      * IF user session is not found THEN return error message \"User must be in an active session\"\n   - Check user access permissions:\n      * Verify user has permission to access the specified topic\n      * IF user lacks permission THEN return error message \"User does not have permission to access this topic\"\n   - Retrieve existing topic read times:\n      * Get the user's topic read time tracking map from the session\n      * IF tracking map does not exist THEN create a new empty tracking map\n\n4. Core Operation Execution:\n   - Update topic read time:\n      * Add or update the entry in the tracking map with topicId as key and readTime as value\n      * IF the topic already exists in the tracking map THEN:\n         > Compare the existing timestamp with the new readTime\n         > Only update if the new readTime is more recent\n   - Update forum-level read tracking (optional):\n      * Determine the forum that contains the topic\n      * Update the forum's last read time if necessary\n      * Store this information in the forum-level tracking map\n   - Persist tracking information:\n      * Store the updated tracking map in the user's session\n      * Ensure the tracking information persists across page views\n\n5. Response Generation:\n   - Success response:\n      * Return confirmation that the topic read time was updated\n      * Include the topicId and timestamp in the response\n   - Error response:\n      * Return appropriate error message based on validation failures\n      * Include guidance on how to resolve the issue",
    "databaseEntities": [
      "jforum_users",
      "jforum_topics",
      "jforum_sessions",
      "jforum_forums"
    ],
    "validationRules": [
      "User ID must be a valid positive integer",
      "Topic ID must be a valid positive integer",
      "User must have an active session",
      "User must have permission to access the topic",
      "Read time must not be in the future"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "ReadTimeTracking": {
        "type": "object",
        "properties": {
          "userId": {
            "type": "number",
            "description": "The identifier of the user"
          },
          "topicId": {
            "type": "number",
            "description": "The identifier of the topic being read"
          },
          "readTime": {
            "type": "string",
            "format": "date-time",
            "description": "The timestamp when the topic was last read"
          }
        },
        "required": [
          "userId",
          "topicId",
          "readTime"
        ]
      }
    }
  },
  {
    "featureName": "ClearSessions",
    "description": "Clears all session data and resets session counters.",
    "inputValues": [],
    "businessLogic": "1. Input Collection:\n   - No user inputs required for this operation\n   - System will use current cache state as input\n\n2. Data Validation:\n   - Verify cache system is properly initialized\n     - IF cache system is null THEN\n       - Log warning message\n       - Abort operation\n       - Return appropriate error message\n     - END IF\n\n3. Business Rule Processing:\n   - Check if session clearing operation is permitted\n     - Verify user has appropriate permissions to clear sessions\n     - IF user lacks required permissions THEN\n       - Deny operation\n       - Log unauthorized attempt\n       - Return permission denied message\n     - END IF\n   - Determine impact of session clearing\n     - Calculate number of active sessions to be cleared\n     - Determine number of logged-in users to be affected\n     - Prepare system notification if needed\n\n4. Core Operation Execution:\n   - Acquire synchronization lock on session data\n     - Ensure no concurrent modifications during clearing process\n   - Clear all session data\n     - Remove all entries from main session storage\n     - Reset logged user count to zero\n     - Reset anonymous user count to zero\n   - Clear logged sessions data\n     - Remove all entries from logged sessions storage\n   - Clear user ID mappings\n     - Remove all user ID to session mappings\n   - Release synchronization lock\n   - Log session clearing event with timestamp and initiator information\n\n5. Response Generation:\n   - Generate success response\n     - Include total number of sessions cleared\n     - Include breakdown of logged vs. anonymous sessions cleared\n     - Include timestamp of operation completion\n   - IF any errors occurred during clearing process THEN\n     - Generate error response with details\n     - Include specific error conditions encountered\n     - Provide troubleshooting information\n   - END IF",
    "databaseEntities": [
      "jforum_sessions"
    ],
    "validationRules": [
      "Cache system must be initialized before clearing sessions",
      "User must have appropriate permissions to clear sessions",
      "Session clearing operation must be atomic to prevent inconsistent state"
    ],
    "dbSeedingOperations": [],
    "schema": {}
  },
  {
    "featureName": "StoreSessionData",
    "description": "Persists user session information to the database with connection management.",
    "inputValues": [
      "sessionId-string-Session",
      "userSession-object-UserSession"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect sessionId (mandatory string) that uniquely identifies the user session\n   - System retrieves the associated UserSession object using the sessionId\n   - Connection object will be managed internally by the system\n\n2. Data Validation:\n   - Validate sessionId format and existence\n     a. IF sessionId is empty or null THEN\n        - Return error: \"Session ID cannot be empty\"\n     b. IF sessionId format is invalid THEN\n        - Return error: \"Invalid session ID format\"\n   - Validate UserSession retrieval\n     a. Attempt to retrieve UserSession using sessionId\n     b. IF UserSession not found THEN\n        - Log warning: \"No session found for the provided ID\"\n        - Exit process without error (no action needed)\n\n3. Business Rule Processing:\n   - Check if user is anonymous\n     a. Retrieve anonymous user ID from system configuration\n     b. Compare current user ID with anonymous user ID\n     c. IF user is anonymous THEN\n        - Skip database update (anonymous sessions are not persisted)\n   - Verify database connection availability\n     a. IF connection cannot be established THEN\n        - Log error: \"Unable to establish database connection\"\n        - Return error: \"Database connection failed\"\n\n4. Core Operation Execution:\n   - Establish database connection\n     a. Request connection from connection manager\n     b. IF connection acquisition fails THEN\n        - Log error: \"Failed to acquire database connection\"\n        - Return error: \"Database connection error\"\n   - Persist session data\n     a. IF user is not anonymous THEN\n        - Update user session data in database\n        - Remove user security information from security repository\n     b. IF database operation fails THEN\n        - Log warning with error details\n        - Continue process (non-critical failure)\n   - Release database connection\n     a. Return connection to connection pool\n     b. IF connection release fails THEN\n        - Log warning: \"Error while releasing database connection\"\n        - Continue process (non-critical failure)\n\n5. Response Generation:\n   - For successful operation:\n     a. No specific response needed (void operation)\n     b. Session data successfully stored in database\n   - For failed operation:\n     a. Log appropriate error messages for troubleshooting\n     b. No exception propagation to calling code (errors handled internally)",
    "databaseEntities": [
      "jforum_sessions"
    ],
    "validationRules": [
      "Session ID must not be empty",
      "User session must exist for the provided session ID",
      "Database connection must be available",
      "Anonymous user sessions are not persisted to database"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "UserSession": {
        "type": "object",
        "properties": {
          "userId": {
            "type": "number",
            "description": "Unique identifier for the user"
          },
          "sessionId": {
            "type": "string",
            "description": "Unique identifier for the session"
          },
          "sessionData": {
            "type": "object",
            "description": "Various session-related information"
          }
        },
        "required": [
          "userId",
          "sessionId"
        ]
      }
    }
  },
  {
    "featureName": "StoreSessionDataWithConnection",
    "description": "Persists user session information using a provided database connection.",
    "inputValues": [
      "sessionId-string-Session",
      "connection-object-DatabaseConnection"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect sessionId (mandatory): unique identifier for the user session\n   - Obtain database connection (mandatory): connection object for database operations\n   - System will use these inputs to persist session data\n\n2. Data Validation:\n   - Validate sessionId:\n     a. Check if sessionId is not null or empty\n     b. Verify sessionId format follows system requirements\n     c. IF validation fails, THEN generate appropriate error message\n   - Validate database connection:\n     a. Verify connection object is valid and active\n     b. Check if connection has proper access rights\n     c. IF connection is invalid, THEN generate connection error\n\n3. Business Rule Processing:\n   - Retrieve user session:\n     a. Locate user session data using the provided sessionId\n     b. IF session not found, THEN terminate process and log warning\n     c. IF session exists, THEN proceed with data persistence\n   - Check user type:\n     a. Determine if session belongs to an anonymous user\n     b. IF user is anonymous, THEN skip database update\n     c. IF user is registered, THEN proceed with update operation\n\n4. Core Operation Execution:\n   - Persist session data:\n     a. For non-anonymous users:\n        i. Update user session record in database using provided connection\n        ii. IF update fails, THEN log error details and handle exception\n        iii. IF update succeeds, THEN proceed to security cleanup\n     b. Security cleanup:\n        i. Remove user security information from security repository\n        ii. This ensures fresh security data will be loaded on next access\n   - Handle exceptions:\n     a. Capture any errors during persistence operation\n     b. Log appropriate warning messages with error details\n     c. Ensure process continues gracefully despite errors\n\n5. Response Generation:\n   - Success case:\n     a. No explicit response needed for successful operation\n     b. System continues normal operation\n   - Error case:\n     a. Log appropriate warning messages\n     b. Include error details for troubleshooting\n     c. Allow system to continue despite non-critical errors",
    "databaseEntities": [
      "jforum_sessions",
      "jforum_users"
    ],
    "validationRules": [
      "Session ID must not be empty",
      "Database connection must be valid and active",
      "User session must exist for the given session ID",
      "Only non-anonymous user sessions should be persisted to database"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "DatabaseConnection": {
        "type": "object",
        "properties": {
          "status": {
            "type": "string",
            "description": "Current status of the database connection"
          },
          "accessRights": {
            "type": "object",
            "description": "Access permissions for database operations"
          }
        },
        "required": [
          "status",
          "accessRights"
        ]
      },
      "Session": {
        "type": "object",
        "properties": {
          "sessionId": {
            "type": "string",
            "description": "Unique identifier for the user session"
          },
          "userId": {
            "type": "integer",
            "description": "ID of the user associated with this session"
          },
          "lastVisit": {
            "type": "date",
            "description": "Timestamp of the user's last activity"
          },
          "isAnonymous": {
            "type": "boolean",
            "description": "Flag indicating if this is an anonymous user session"
          }
        },
        "required": [
          "sessionId",
          "userId",
          "lastVisit",
          "isAnonymous"
        ]
      }
    }
  },
  {
    "featureName": "ReleaseDatabaseConnection",
    "description": "Closes and releases a database connection when it's no longer needed.",
    "inputValues": [
      "connection-object-DatabaseConnection"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the database connection object that needs to be released\n     1.1. Verify the connection object is provided\n     1.2. Check if the connection is of the expected type\n     1.3. Determine if the connection is in an active state\n\n2. Data Validation:\n   - Validate the connection object before attempting to release it\n     2.1. Check if the connection object is null\n        IF connection is null THEN\n          Skip the release process and return\n        END IF\n     2.2. Verify the connection is not already closed\n        IF connection status indicates it's already closed THEN\n          Log information that connection is already closed\n          Skip further processing\n        END IF\n\n3. Business Rule Processing:\n   - Apply business rules related to connection management\n     3.1. Check if there are any pending transactions on the connection\n        IF pending transactions exist THEN\n          Determine whether to commit or rollback based on system configuration\n          Log appropriate warning about releasing connection with pending work\n        END IF\n     3.2. Verify system state allows for connection release\n        IF system is in shutdown mode THEN\n          Use expedited release process\n        END IF\n\n4. Core Operation Execution:\n   - Execute the connection release operation\n     4.1. Attempt to close the database connection\n        TRY\n          Invoke close operation on the connection\n          Mark connection as successfully closed\n        CATCH any exceptions during close operation\n          Log the exception details\n          Record failed closure attempt\n        END TRY\n     4.2. Clean up any associated resources\n        Release any statement objects associated with the connection\n        Clear any connection-specific caches\n     4.3. Update connection tracking if applicable\n        Decrement active connection counter\n        Update connection usage statistics\n\n5. Response Generation:\n   - Generate appropriate response based on the release operation outcome\n     5.1. IF connection was successfully released THEN\n          Return success status\n          Include connection release timestamp\n     5.2. IF connection release failed THEN\n          Return error status\n          Include failure reason\n          Provide recovery suggestions\n     5.3. Generate any required notifications\n        IF connection pool is approaching capacity limits THEN\n          Generate system alert for administrators\n        END IF",
    "databaseEntities": [],
    "validationRules": [
      "Connection object must not be null before attempting to close it",
      "Connection must be in an active state to be released",
      "Any exceptions during connection release must be properly handled",
      "Connection must be marked as closed after successful release"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "DatabaseConnection": {
        "type": "object",
        "properties": {
          "connectionId": {
            "type": "string",
            "description": "Unique identifier for the database connection"
          },
          "status": {
            "type": "string",
            "description": "Current status of the connection (active, closed, etc.)"
          },
          "creationTime": {
            "type": "date",
            "description": "When the connection was created"
          },
          "lastAccessTime": {
            "type": "date",
            "description": "When the connection was last accessed"
          }
        },
        "required": [
          "connectionId",
          "status"
        ]
      }
    }
  },
  {
    "featureName": "ProcessUrlPattern",
    "description": "Processes URL patterns by splitting and storing variables for forum navigation.",
    "inputValues": [
      "name-string-UrlPattern",
      "value-string-UrlPattern"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the pattern name (string, mandatory)\n   - Collect the pattern value (string, mandatory)\n   - System will generate vars array and size attributes\n\n2. Data Validation:\n   - Validate pattern name:\n     * Must not be null or empty\n     * Should follow the format 'moduleName.actionName.numberOfParameters'\n   - Validate pattern value:\n     * Can be empty for patterns with no variables\n     * Should contain comma-separated variable names when variables exist\n   - Generate appropriate error messages for invalid inputs\n\n3. Business Rule Processing:\n   - Verify the pattern name follows the expected format\n   - Check that the pattern value format is valid for parsing\n   - Ensure the pattern can be properly processed\n\n4. Core Operation Execution:\n   - Split the pattern value by comma delimiter\n   - Create a new array to store the variables\n   - Determine the pattern size:\n     * IF the first element is empty or only whitespace, THEN size is 0\n     * ELSE size equals the number of elements after splitting\n   - FOR each variable in the pattern:\n     * Trim whitespace from the variable name\n     * Store the trimmed variable in the vars array\n   - Store the processed pattern information (name, value, size, vars)\n\n5. Response Generation:\n   - Return success status when pattern is successfully processed\n   - Provide access to the pattern name, size, and variables array\n   - IF processing fails, return appropriate error information\n   - Include the pattern details in the response for verification",
    "databaseEntities": [],
    "validationRules": [
      "Pattern name must not be null or empty",
      "Pattern value must be properly formatted for parsing",
      "Variable names must be trimmed of whitespace"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "UrlPattern": {
        "name": "string",
        "value": "string",
        "size": "number",
        "vars": "array"
      }
    }
  },
  {
    "featureName": "GetUrlPatternComponents",
    "description": "Retrieves pattern name, variables, and size for URL routing in the forum system.",
    "inputValues": [
      "patternName-string-UrlPattern",
      "patternValue-string-UrlPattern"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the following inputs:\n     - patternName (string, mandatory): The name identifier for the URL pattern\n     - patternValue (string, mandatory): The comma-separated list of variables in the pattern\n   - System will use these inputs to create a URL pattern object\n\n2. Data Validation:\n   - Validate patternName:\n     - IF patternName is empty or null THEN\n       - Generate error message: \"Pattern name cannot be empty\"\n     - IF patternName does not follow the format \"module.action.paramCount\" THEN\n       - Generate error message: \"Pattern name must follow format: module.action.paramCount\"\n   - Validate patternValue:\n     - No specific format validation required as empty values are allowed\n     - patternValue should be a comma-separated list of variable names\n\n3. Business Rule Processing:\n   - Verify pattern name uniqueness:\n     - IF pattern with the same name already exists in the system THEN\n       - Generate warning: \"Pattern with this name already exists and will be overwritten\"\n   - Check pattern consistency:\n     - IF patternName ends with a number (paramCount) THEN\n       - The number should match the actual number of parameters in patternValue\n       - IF mismatch detected THEN\n         - Generate warning: \"Parameter count in name does not match actual parameters\"\n\n4. Core Operation Execution:\n   - Process the pattern value:\n     - Split the patternValue by comma separator\n     - Create an array to store the variables\n     - Calculate the pattern size:\n       - IF the first element is empty or only contains whitespace THEN\n         - Set size to 0\n       - ELSE\n         - Set size to the number of elements after splitting\n     - For each element in the split array:\n       - Trim whitespace from the element\n       - Store the trimmed element in the variables array\n   - Create the URL pattern object with:\n     - The provided pattern name\n     - The processed variables array\n     - The calculated pattern size\n\n5. Response Generation:\n   - Return the URL pattern components:\n     - Pattern name: The original name provided\n     - Pattern variables: Array of variable names extracted from the pattern value\n     - Pattern size: The number of variables in the pattern\n   - IF any warnings were generated during processing THEN\n     - Include warnings in the response\n   - IF any errors were encountered THEN\n     - Return error details and status",
    "databaseEntities": [],
    "validationRules": [
      "Pattern name must not be empty",
      "Pattern name should follow the format 'module.action.paramCount'",
      "Pattern value must be properly formatted as comma-separated values",
      "Parameter count in name should match actual parameters in value"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "UrlPattern": {
        "properties": {
          "name": {
            "type": "string",
            "description": "The name identifier for the URL pattern"
          },
          "value": {
            "type": "string",
            "description": "The comma-separated list of variables in the pattern"
          },
          "size": {
            "type": "integer",
            "description": "The number of variables in the pattern"
          },
          "vars": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Array of variable names extracted from the pattern value"
          }
        },
        "required": [
          "name",
          "value"
        ]
      }
    }
  },
  {
    "featureName": "FindUrlPattern",
    "description": "Retrieves a URL pattern by its name from the patterns collection.",
    "inputValues": [
      "name-string-UrlPattern"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the required input field:\n     a. name (string, mandatory): The identifier of the URL pattern to find\n     b. No default values are provided\n     c. No system-generated fields are required\n\n2. Data Validation:\n   - Validate the input field:\n     a. Validate that name is not null\n        i. IF name is null THEN\n           - Generate error message: \"Pattern name cannot be null\"\n           - Return error response\n        ii. END IF\n     b. Validate that name is not empty\n        i. IF name is empty string THEN\n           - Generate error message: \"Pattern name cannot be empty\"\n           - Return error response\n        ii. END IF\n\n3. Business Rule Processing:\n   - Verify system state:\n     a. Check if the patterns collection is initialized\n        i. IF patterns collection is not initialized THEN\n           - Generate error message: \"Patterns collection is not initialized\"\n           - Return error response\n        ii. END IF\n\n4. Core Operation Execution:\n   - Search for the pattern:\n     a. Look up the pattern in the collection using the provided name as key\n     b. Retrieve the UrlPattern object associated with the name\n     c. IF no pattern is found with the given name THEN\n        i. Set result to null\n     d. ELSE\n        i. Set result to the found UrlPattern object\n     e. END IF\n\n5. Response Generation:\n   - Generate appropriate response:\n     a. IF result is not null THEN\n        i. Return success response containing the found UrlPattern object\n           - Include pattern name\n           - Include pattern value\n     b. ELSE\n        i. Return null or appropriate indication that no pattern was found\n     c. END IF",
    "databaseEntities": [],
    "validationRules": [
      "Pattern name must not be null",
      "Pattern name must not be empty",
      "Patterns collection must be initialized before searching"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "UrlPattern": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "description": "The identifier of the URL pattern"
          },
          "value": {
            "type": "string",
            "description": "The actual pattern value"
          }
        },
        "required": [
          "name",
          "value"
        ]
      }
    }
  },
  {
    "featureName": "AddUrlPattern",
    "description": "Adds a new URL pattern with name and value to the patterns collection.",
    "inputValues": [
      "name-string-UrlPattern",
      "value-string-UrlPattern"
    ],
    "businessLogic": "1. Input Collection\n   1.1. Collect the following inputs:\n       - name (string, mandatory): The unique identifier for the URL pattern\n       - value (string, mandatory): The pattern value to be associated with the name\n   1.2. No default values are provided for these fields\n   1.3. Both fields must be provided by the user\n\n2. Data Validation\n   2.1. Validate the name input:\n       2.1.1. Check IF name is not null\n       2.1.2. Check IF name is not an empty string\n       2.1.3. IF any validation fails, prepare error message \"Pattern name cannot be empty\"\n   2.2. Validate the value input:\n       2.2.1. Check IF value is not null\n       2.2.2. Check IF value is not an empty string\n       2.2.3. IF any validation fails, prepare error message \"Pattern value cannot be empty\"\n   2.3. Check for duplicate pattern names:\n       2.3.1. Check IF a pattern with the same name already exists in the collection\n       2.3.2. IF duplicate found, prepare error message \"A pattern with this name already exists\"\n\n3. Business Rule Processing\n   3.1. Verify system state:\n       3.1.1. Check IF the patterns collection is initialized\n       3.1.2. IF not initialized, prepare error message \"Pattern collection is not ready\"\n   3.2. Verify pattern name format:\n       3.2.1. Check IF the pattern name follows naming conventions (alphanumeric with no special characters except underscores)\n       3.2.2. IF format is invalid, prepare error message \"Pattern name contains invalid characters\"\n   3.3. Verify pattern value format:\n       3.3.1. Check IF the pattern value is in a valid format\n       3.3.2. IF format is invalid, prepare error message \"Pattern value is in an invalid format\"\n\n4. Core Operation Execution\n   4.1. Create a new URL pattern object:\n       4.1.1. Initialize a new pattern object with the provided name and value\n   4.2. Add the pattern to the collection:\n       4.2.1. Store the pattern in the collection using the name as the key\n       4.2.2. IF storage operation fails, prepare error message \"Failed to add pattern to collection\"\n       4.2.3. Set up rollback procedure to remove the pattern if subsequent operations fail\n\n5. Response Generation\n   5.1. For successful addition:\n       5.1.1. Prepare success message indicating the pattern was added successfully\n       5.1.2. Include the name and value of the added pattern in the response\n   5.2. For failed addition:\n       5.2.1. Include specific error message from the validation or processing steps\n       5.2.2. Provide guidance on how to correct the issue\n   5.3. Return the appropriate response to the caller",
    "databaseEntities": [],
    "validationRules": [
      "Pattern name must not be empty",
      "Pattern value must not be empty",
      "Pattern name must be unique in the collection",
      "Pattern name should follow naming conventions",
      "Pattern value must be in a valid format"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "UrlPattern": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "description": "The unique identifier for the URL pattern"
          },
          "value": {
            "type": "string",
            "description": "The pattern value associated with the name"
          }
        },
        "required": [
          "name",
          "value"
        ]
      }
    }
  },
  {
    "featureName": "BuildMessageId",
    "description": "Creates a unique message identifier for forum posts with post, topic, and forum information.",
    "inputValues": [
      "postId-number-Post",
      "topicId-number-Topic",
      "forumId-number-Forum",
      "topic-object-Topic"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the following inputs:\n     a. postId (number, mandatory): The unique identifier of the post\n     b. topicId (number, mandatory): The unique identifier of the topic\n     c. forumId (number, mandatory): The unique identifier of the forum\n     d. topic (object, optional): Complete Topic object containing firstPostId, id, and forumId\n\n2. Data Validation:\n   - Validate postId:\n     a. Check if postId is provided and is a positive integer\n     b. IF postId is missing or invalid, THEN generate appropriate error message\n   - Validate topicId:\n     a. Check if topicId is provided and is a positive integer\n     b. IF topicId is missing or invalid, THEN generate appropriate error message\n   - Validate forumId:\n     a. Check if forumId is provided and is a positive integer\n     b. IF forumId is missing or invalid, THEN generate appropriate error message\n   - IF topic object is provided:\n     a. Verify topic contains firstPostId property\n     b. Verify topic contains id property\n     c. Verify topic contains forumId property\n     d. IF any required topic properties are missing, THEN generate appropriate error message\n\n3. Business Rule Processing:\n   - Determine the message identifier type:\n     a. IF all individual parameters (postId, topicId, forumId) are provided, THEN prepare to build standard message ID\n     b. IF topic object is provided, THEN prepare to build in-reply-to message ID\n     c. IF parsing an existing message ID, THEN prepare to extract topic ID\n   - Generate system values:\n     a. Create timestamp using current system time\n     b. Generate random number for uniqueness\n\n4. Core Operation Execution:\n   - For standard message ID creation:\n     a. Combine postId, topicId, forumId, timestamp, and random number in specific format\n     b. Format as \"<postId.topicId.forumId.timestamp+randomNumber@jforum>\"\n   - For in-reply-to message ID creation:\n     a. Extract firstPostId, id, and forumId from topic object\n     b. Format as \"<firstPostId.id.forumId.timestamp+randomNumber@jforum>\"\n   - For message ID parsing:\n     a. Apply pattern matching to extract components from message ID string\n     b. Extract topicId component from the matched pattern\n     c. Convert extracted topicId to integer value\n     d. IF conversion fails, THEN set topicId to default value\n\n5. Response Generation:\n   - For message ID creation:\n     a. Return the fully formatted message ID string\n     b. Ensure angle brackets are properly included\n   - For message ID parsing:\n     a. Return the extracted topicId value\n     b. Include status information about the parsing operation",
    "databaseEntities": [
      "jforum_topics",
      "jforum_posts",
      "jforum_forums"
    ],
    "validationRules": [
      "Post ID must be a positive integer",
      "Topic ID must be a positive integer",
      "Forum ID must be a positive integer",
      "Topic object must contain firstPostId, id, and forumId properties when used for in-reply-to headers"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Topic": {
        "type": "object",
        "properties": {
          "id": {
            "type": "number",
            "description": "Unique identifier for the topic"
          },
          "firstPostId": {
            "type": "number",
            "description": "ID of the first post in the topic"
          },
          "forumId": {
            "type": "number",
            "description": "ID of the forum containing this topic"
          }
        },
        "required": [
          "id",
          "firstPostId",
          "forumId"
        ]
      }
    }
  },
  {
    "featureName": "BuildInReplyTo",
    "description": "Generates an In-Reply-To header for forum post replies based on topic information.",
    "inputValues": [
      "topic-object-Topic"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect Topic object with the following required attributes:\n     * firstPostId (number): The ID of the first post in the topic\n     * id (number): The ID of the topic\n     * forumId (number): The ID of the forum containing the topic\n   - All fields are mandatory for proper header generation\n\n2. Data Validation:\n   - Validate Topic object existence\n     * IF Topic is null or undefined THEN\n       - Return error: \"Topic information is required\"\n     * END IF\n   - Validate Topic attributes\n     * IF Topic.firstPostId is missing or not a positive integer THEN\n       - Return error: \"Valid first post ID is required\"\n     * END IF\n     * IF Topic.id is missing or not a positive integer THEN\n       - Return error: \"Valid topic ID is required\"\n     * END IF\n     * IF Topic.forumId is missing or not a positive integer THEN\n       - Return error: \"Valid forum ID is required\"\n     * END IF\n\n3. Business Rule Processing:\n   - Check system configuration for header format requirements\n     * Verify header format pattern is configured correctly\n     * Ensure domain name for message ID is properly set\n   - Determine if additional metadata should be included in the header\n     * Check if timestamp inclusion is enabled\n     * Check if randomization is enabled for uniqueness\n\n4. Core Operation Execution:\n   - Construct the In-Reply-To header string\n     * Start with opening angle bracket '<'\n     * Append the first post ID from the topic\n     * Append separator '.'\n     * Append the topic ID\n     * Append separator '.'\n     * Append the forum ID\n     * Append separator '.'\n     * Generate and append a unique timestamp\n     * Generate and append a random number for additional uniqueness\n     * Append '@' followed by the system domain identifier\n     * End with closing angle bracket '>'\n   - Format the complete header according to email standards\n\n5. Response Generation:\n   - Return the fully constructed In-Reply-To header string\n   - Include metadata about the header generation process\n     * Source topic information\n     * Generation timestamp\n     * Format version used\n   - Provide usage instructions for the header in email communications",
    "databaseEntities": [
      "jforum_topics",
      "jforum_posts",
      "jforum_forums"
    ],
    "validationRules": [
      "Topic object must not be null",
      "First post ID must be a positive integer",
      "Topic ID must be a positive integer",
      "Forum ID must be a positive integer",
      "Generated header must follow the format '<firstPostId.topicId.forumId.timestamp.randomNumber@domain>'"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Topic": {
        "type": "object",
        "properties": {
          "firstPostId": {
            "type": "number",
            "description": "ID of the first post in the topic"
          },
          "id": {
            "type": "number",
            "description": "ID of the topic"
          },
          "forumId": {
            "type": "number",
            "description": "ID of the forum containing the topic"
          }
        },
        "required": [
          "firstPostId",
          "id",
          "forumId"
        ]
      }
    }
  },
  {
    "featureName": "ParseMessageId",
    "description": "Extracts topic ID from message headers using regex pattern matching.",
    "inputValues": [
      "header-string-MessageHeader"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the message header string (mandatory)\n   - The header should be in the format '<postId.topicId.forumId.randomNumber@host>'\n   - No default values are provided\n\n2. Data Validation:\n   - Check if the header string is not null\n     - IF header is null THEN\n       - Return a MessageId object with default values\n     - END IF\n   - Validate that the header follows the expected format\n     - The format should match the pattern '<postId.topicId.forumId.randomNumber@host>'\n     - No specific error messages are generated for invalid formats\n\n3. Business Rule Processing:\n   - Prepare the regular expression pattern for extracting components\n     - Pattern should match '<(.*?)\\.(.*?)\\.(.*?)\\.(.*?)@.*>'\n     - This pattern captures four groups separated by periods\n   - Apply the pattern to the header string\n   - Check if the pattern matches the header\n     - IF pattern does not match THEN\n       - Return a MessageId object with default values\n     - END IF\n\n4. Core Operation Execution:\n   - Extract the second component (topicId) from the matched pattern\n   - Convert the extracted string to an integer\n     - IF conversion fails THEN\n       - Silently handle the exception\n       - Keep the default topicId value (0)\n     - END IF\n   - Store the extracted topicId in the MessageId object\n\n5. Response Generation:\n   - Return the MessageId object containing the extracted topicId\n   - No specific error responses are generated\n   - The caller can retrieve the topicId using the getTopicId() method",
    "databaseEntities": [
      "jforum_topics"
    ],
    "validationRules": [
      "Message header must follow the pattern '<postId.topicId.forumId.randomNumber@host>'",
      "Topic ID must be a valid integer value"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "MessageId": {
        "type": "object",
        "properties": {
          "topicId": {
            "type": "integer",
            "description": "The extracted topic ID from the message header"
          }
        }
      }
    }
  },
  {
    "featureName": "OpenPOPConnection",
    "description": "Establishes a connection to a POP3 mail server with optional SSL support.",
    "inputValues": [
      "mailIntegration-object-MailIntegration"
    ],
    "businessLogic": "1. Input Collection:\n   1.1. Collect the MailIntegration object containing:\n       - popHost (mandatory): Server hostname\n       - popPort (mandatory): Server port number\n       - popUsername (mandatory): Username for authentication\n       - popPassword (mandatory): Password for authentication\n       - isSSL (mandatory): Boolean flag indicating whether to use SSL\n\n2. Data Validation:\n   2.1. Validate MailIntegration object:\n       - Check if mailIntegration object is not null\n       - Verify popHost is not empty and has valid hostname format\n       - Ensure popPort is a positive integer within valid port range (1-65535)\n       - Confirm popUsername is not empty\n       - Verify popPassword is provided\n       - Validate isSSL is a boolean value\n   2.2. If any validation fails:\n       - Generate appropriate error message\n       - Abort connection process\n\n3. Business Rule Processing:\n   3.1. Check system state:\n       - Verify no existing connection is active\n       - If connection exists, close it before proceeding\n   3.2. Determine connection protocol:\n       - IF isSSL is TRUE, THEN use secure protocol (pop3s)\n       - ELSE use standard protocol (pop3)\n\n4. Core Operation Execution:\n   4.1. Establish mail session:\n       - Create new mail session with default properties\n   4.2. Connect to mail server:\n       - Initialize store using appropriate protocol (pop3 or pop3s)\n       - Connect to server using provided credentials (host, port, username, password)\n       - IF connection fails, THEN generate connection error\n   4.3. Access mail folder:\n       - Attempt to open the INBOX folder in READ_WRITE mode\n       - IF folder cannot be accessed, THEN generate folder access error\n\n5. Response Generation:\n   5.1. Success response:\n       - Return confirmation that connection has been established\n       - Make connection available for subsequent mail operations\n   5.2. Error response:\n       - Provide detailed error information if connection failed\n       - Include troubleshooting suggestions based on error type",
    "databaseEntities": [],
    "validationRules": [
      "MailIntegration object must not be null",
      "POP host must be a valid hostname or IP address",
      "POP port must be a valid port number (1-65535)",
      "POP username must not be empty",
      "POP password must not be empty",
      "SSL flag must be a boolean value"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "MailIntegration": {
        "type": "object",
        "properties": {
          "popHost": {
            "type": "string",
            "description": "POP3 server hostname or IP address"
          },
          "popPort": {
            "type": "number",
            "description": "POP3 server port number"
          },
          "popUsername": {
            "type": "string",
            "description": "Username for POP3 authentication"
          },
          "popPassword": {
            "type": "string",
            "description": "Password for POP3 authentication"
          },
          "isSSL": {
            "type": "boolean",
            "description": "Flag indicating whether to use SSL for connection"
          }
        },
        "required": [
          "popHost",
          "popPort",
          "popUsername",
          "popPassword",
          "isSSL"
        ]
      }
    }
  },
  {
    "featureName": "ListMailMessages",
    "description": "Retrieves all available messages from the POP3 server inbox.",
    "inputValues": [
      "mailIntegration-object-MailIntegration"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect MailIntegration object containing:\n     a. POP3 server host address (mandatory)\n     b. POP3 server port number (mandatory)\n     c. Username for authentication (mandatory)\n     d. Password for authentication (mandatory)\n     e. SSL connection flag (mandatory)\n\n2. Data Validation:\n   - Validate MailIntegration object:\n     a. Verify POP3 host is not empty\n     b. Verify port number is valid (positive integer)\n     c. Verify username is not empty\n     d. Verify password is not empty\n     e. Verify SSL flag is properly set (boolean value)\n   - IF any validation fails, THEN:\n     a. Generate appropriate error message\n     b. Terminate the operation\n\n3. Business Rule Processing:\n   - Check system state:\n     a. Verify the mail integration feature is enabled in system settings\n     b. Verify network connectivity is available\n   - Check resource availability:\n     a. Verify the system has permission to access network resources\n     b. Verify the system can establish external connections\n   - IF any checks fail, THEN:\n     a. Log the specific failure reason\n     b. Generate appropriate error message\n     c. Terminate the operation\n\n4. Core Operation Execution:\n   - Establish connection to mail server:\n     a. Create mail session\n     b. Determine protocol based on SSL setting (POP3 or POP3S)\n     c. Connect to server using provided credentials\n     d. Open INBOX folder in read-write mode\n     e. IF connection fails, THEN:\n        i. Log connection failure details\n        ii. Generate connection error message\n        iii. Terminate the operation\n   - Retrieve messages:\n     a. Request all messages from the INBOX folder\n     b. Store messages in memory for processing\n     c. IF message retrieval fails, THEN:\n        i. Log retrieval failure details\n        ii. Close any open connections\n        iii. Generate retrieval error message\n        iv. Terminate the operation\n\n5. Response Generation:\n   - Success response:\n     a. Return the complete list of retrieved messages\n     b. Include message count in the response\n     c. Include message metadata (sender, subject, date) for each message\n   - Error response:\n     a. Include specific error code\n     b. Include descriptive error message\n     c. Include troubleshooting suggestions when applicable",
    "databaseEntities": [],
    "validationRules": [
      "MailIntegration object must not be null",
      "POP3 host must be a valid server address",
      "POP3 port must be a valid port number",
      "Username must not be empty",
      "Password must not be empty",
      "SSL flag must be a boolean value"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "MailIntegration": {
        "type": "object",
        "properties": {
          "popHost": {
            "type": "string",
            "description": "POP3 server hostname"
          },
          "popPort": {
            "type": "number",
            "description": "POP3 server port number"
          },
          "popUsername": {
            "type": "string",
            "description": "Username for POP3 authentication"
          },
          "popPassword": {
            "type": "string",
            "description": "Password for POP3 authentication"
          },
          "isSSL": {
            "type": "boolean",
            "description": "Flag indicating whether to use SSL connection"
          }
        },
        "required": [
          "popHost",
          "popPort",
          "popUsername",
          "popPassword",
          "isSSL"
        ]
      }
    }
  },
  {
    "featureName": "ClosePOPConnection",
    "description": "Closes an active connection to a POP email server.",
    "inputValues": [],
    "businessLogic": "1. Input Collection:\n   - No explicit inputs required for this operation\n   - System will use the current connection state information\n   - Connection must be previously established via openConnection method\n\n2. Data Validation:\n   - Validate connection state:\n     a. Verify the connection is in an active state\n        - IF connection is not active THEN\n          - Generate error: \"Cannot close an inactive connection\"\n          - Exit process\n     b. Verify the folder object is valid\n        - IF folder is null THEN\n          - Log warning: \"Attempting to close connection with null folder\"\n     c. Verify the store object is valid\n        - IF store is null THEN\n          - Log warning: \"Attempting to close connection with null store\"\n\n3. Business Rule Processing:\n   - Check if any pending operations need to be completed before closing\n     a. IF there are unsaved changes THEN\n        - Determine if changes should be committed or discarded\n        - IF changes should be committed THEN\n          - Process pending changes\n        - ELSE\n          - Discard pending changes\n   - Verify system resources can be properly released\n     a. Check if any locks are held on the connection\n        - IF locks exist THEN\n          - Attempt to release locks\n          - IF locks cannot be released THEN\n            - Log warning: \"Closing connection with active locks\"\n\n4. Core Operation Execution:\n   - Release message resources\n     a. IF messages have been retrieved THEN\n        - Release message references\n        - Clear message cache\n   - Close the folder connection\n     a. IF folder is not null THEN\n        - Attempt to close the folder\n        - Handle any errors during folder closure\n          - IF error occurs THEN\n            - Log error: \"Error closing folder: [error details]\"\n   - Close the store connection\n     a. IF store is not null THEN\n        - Attempt to close the store\n        - Handle any errors during store closure\n          - IF error occurs THEN\n            - Log error: \"Error closing store: [error details]\"\n   - Release any system resources associated with the connection\n     a. Clear any cached credentials\n     b. Release network resources\n\n5. Response Generation:\n   - Generate appropriate response\n     a. IF all operations completed successfully THEN\n        - Return success status: \"Connection closed successfully\"\n     b. IF any errors occurred THEN\n        - Return error status with details\n        - Include information about partial completion if applicable",
    "databaseEntities": [
      "MailIntegration"
    ],
    "validationRules": [
      "Connection must be in active state before closing",
      "Store object must be valid",
      "Folder object must be valid"
    ],
    "dbSeedingOperations": [],
    "schema": {}
  },
  {
    "featureName": "StartPOP3IntegrationJob",
    "description": "Initializes and schedules a POP3 mail integration job using a scheduler based on system configuration.",
    "inputValues": [
      "isEnabled-boolean-SystemConfiguration",
      "cronExpression-string-SchedulerConfiguration",
      "configFilePath-string-SystemConfiguration"
    ],
    "businessLogic": "1. Input Collection:\n   1.1. Collect system configuration parameters:\n       1.1.1. isEnabled: Boolean flag indicating if POP3 integration is enabled (mandatory)\n       1.1.2. cronExpression: String containing the scheduling pattern (mandatory)\n       1.1.3. configFilePath: String path to the scheduler configuration file (mandatory)\n\n2. Data Validation:\n   2.1. Validate isEnabled parameter:\n       2.1.1. IF isEnabled is null THEN return error \"POP3 integration enabled flag must be specified\"\n   2.2. Validate cronExpression parameter:\n       2.2.1. IF cronExpression is empty or null THEN return error \"Cron expression must be specified\"\n       2.2.2. IF cronExpression format is invalid THEN return error \"Invalid cron expression format\"\n   2.3. Validate configFilePath parameter:\n       2.3.1. IF configFilePath is empty or null THEN return error \"Configuration file path must be specified\"\n       2.3.2. IF configuration file does not exist THEN return error \"Configuration file not found\"\n\n3. Business Rule Processing:\n   3.1. Check if job is already running:\n       3.1.1. IF job is already started THEN skip further processing and return success\n   3.2. Check if POP3 integration is enabled:\n       3.2.1. IF isEnabled is false THEN skip job creation and return success\n\n4. Core Operation Execution:\n   4.1. Initialize the scheduler:\n       4.1.1. Load scheduler configuration from the specified configuration file\n       4.1.2. Create a new scheduler instance\n       4.1.3. IF scheduler initialization fails THEN return error \"Failed to initialize scheduler\"\n   4.2. Create job details:\n       4.2.1. Define job name as \"POP3Listener\"\n       4.2.2. Define job group as \"pop3Integration\"\n       4.2.3. Associate job with the mail listener class\n   4.3. Create trigger for the job:\n       4.3.1. Create a new trigger with the provided cron expression\n       4.3.2. Set trigger name to match the job name\n       4.3.3. Set trigger group to \"pop3Integration\"\n       4.3.4. IF trigger creation fails due to invalid cron expression THEN return error \"Invalid cron expression format\"\n   4.4. Schedule the job:\n       4.4.1. Associate the job details with the trigger\n       4.4.2. Add the job to the scheduler\n       4.4.3. IF job scheduling fails THEN return error \"Failed to schedule POP3 integration job\"\n   4.5. Start the scheduler:\n       4.5.1. Activate the scheduler to begin job execution\n       4.5.2. IF scheduler fails to start THEN return error \"Failed to start scheduler\"\n   4.6. Mark job as started:\n       4.6.1. Update system state to indicate POP3 integration job is running\n\n5. Response Generation:\n   5.1. Generate success response:\n       5.1.1. IF job was already running THEN return message \"POP3 integration job is already running\"\n       5.1.2. IF job was disabled THEN return message \"POP3 integration is disabled in system configuration\"\n       5.1.3. IF job was successfully started THEN return message \"POP3 integration job started successfully with schedule: [cronExpression]\"\n   5.2. Generate error response:\n       5.2.1. Include specific error message from failed operation\n       5.2.2. Include suggestion for resolving the issue\n       5.2.3. Log detailed error information for system administrators",
    "databaseEntities": [],
    "validationRules": [
      "POP3 integration enabled flag must be a boolean value",
      "Cron expression must be a valid scheduling pattern",
      "Configuration file path must point to an existing file",
      "Job must not be already running when attempting to start it",
      "Scheduler must be properly initialized before job creation"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "SystemConfiguration": {
        "type": "object",
        "properties": {
          "isEnabled": {
            "type": "boolean",
            "description": "Flag indicating if POP3 integration is enabled"
          },
          "configFilePath": {
            "type": "string",
            "description": "Path to the scheduler configuration file"
          }
        }
      },
      "SchedulerConfiguration": {
        "type": "object",
        "properties": {
          "cronExpression": {
            "type": "string",
            "description": "Cron expression defining the job execution schedule"
          }
        }
      }
    }
  },
  {
    "featureName": "ProcessMailIntegration",
    "description": "Processes emails from POP servers and integrates them into the forum system.",
    "inputValues": [
      "mailIntegration-object-MailIntegration"
    ],
    "businessLogic": "1. Input Collection\n   1.1. Retrieve all mail integration configurations from the system\n       1.1.1. Each configuration contains server details, authentication credentials, and forum mapping information\n       1.1.2. System-generated configurations are loaded automatically\n       1.1.3. No manual input is required during execution\n\n2. Data Validation\n   2.1. Validate each mail integration configuration\n       2.1.1. Verify server address is properly formatted\n       2.1.2. Confirm port number is valid\n       2.1.3. Ensure username and password are not empty\n       2.1.4. Validate that target forum for messages exists\n       2.1.5. IF any validation fails, log error and skip the current configuration\n\n3. Business Rule Processing\n   3.1. Check system state for mail processing\n       3.1.1. Verify if mail processing is already in progress\n       3.1.2. IF processing is already active, exit without performing operations\n       3.1.3. Set processing state flag to active\n   3.2. Prepare resources for mail processing\n       3.2.1. Initialize mail connector component\n       3.2.2. Initialize message parser component\n       3.2.3. Initialize post action component for forum integration\n\n4. Core Operation Execution\n   4.1. Process each mail integration configuration\n       4.1.1. FOR each mail integration configuration:\n           4.1.1.1. Configure connector with current mail integration settings\n           4.1.1.2. Open connection to mail server\n           4.1.1.3. Retrieve all unprocessed messages\n           4.1.1.4. Parse each message to extract content, subject, sender information\n           4.1.1.5. Convert parsed messages to forum post format\n           4.1.1.6. Create new forum posts based on message content\n           4.1.1.7. Link posts to appropriate topics based on subject lines\n           4.1.1.8. Associate posts with user accounts based on sender information\n           4.1.1.9. Close connection to mail server\n       4.1.2. IF any errors occur during processing:\n           4.1.2.1. Log detailed error information\n           4.1.2.2. Ensure connection is properly closed\n           4.1.2.3. Continue with next configuration\n\n5. Response Generation\n   5.1. Generate processing summary\n       5.1.1. Count of processed mail configurations\n       5.1.2. Number of messages successfully imported\n       5.1.3. Number of messages that failed processing\n   5.2. Update system state\n       5.2.1. Set processing state flag to inactive\n       5.2.2. Log completion of mail integration process\n   5.3. Error handling\n       5.3.1. Ensure all resources are properly released even if errors occur\n       5.3.2. Provide detailed logs for troubleshooting",
    "databaseEntities": [
      "jforum_users",
      "jforum_topics",
      "jforum_posts",
      "jforum_posts_text",
      "jforum_forums"
    ],
    "validationRules": [
      "Mail server connection details must be valid and complete",
      "Mail integration must be mapped to an existing forum",
      "Only one mail processing job can run at a time",
      "Each email must have a valid sender that can be mapped to a forum user",
      "Email content must not be empty",
      "Connection to mail server must be properly closed after processing"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "MailIntegration": {
        "type": "object",
        "properties": {
          "serverId": {
            "type": "number",
            "description": "Unique identifier for the mail server configuration"
          },
          "serverAddress": {
            "type": "string",
            "description": "POP server address"
          },
          "serverPort": {
            "type": "number",
            "description": "POP server port"
          },
          "username": {
            "type": "string",
            "description": "Username for authentication"
          },
          "password": {
            "type": "string",
            "description": "Password for authentication"
          },
          "targetForumId": {
            "type": "number",
            "description": "Forum ID where messages will be posted"
          },
          "enabled": {
            "type": "boolean",
            "description": "Whether this mail integration is active"
          }
        },
        "required": [
          "serverId",
          "serverAddress",
          "serverPort",
          "username",
          "password",
          "targetForumId",
          "enabled"
        ]
      }
    }
  },
  {
    "featureName": "ExtractEmailMessage",
    "description": "Extracts and processes email message content from POP3 messages including headers, body, and metadata.",
    "inputValues": [
      "message-object-Message"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect Message object containing raw email data\n   - System will extract the following components:\n     * Subject line\n     * Message content\n     * Sender information\n     * Reply-to address\n     * References header\n     * In-Reply-To header\n     * Content type\n     * List email address\n     * Send date\n     * All headers\n\n2. Data Validation:\n   - Validate Message object is not null\n     * IF Message object is null THEN return error indicating invalid input\n   - Validate Message can be accessed\n     * IF Message cannot be accessed THEN handle exception and return appropriate error\n   - Validate required message components\n     * Check that subject can be retrieved\n     * Check that content can be accessed\n     * Check that sender information is available\n     * IF any critical component is inaccessible THEN log specific validation error\n\n3. Business Rule Processing:\n   - Determine message content type\n     * IF content is multipart THEN identify primary content part\n     * IF content type is text/html or text/plain THEN prepare for text extraction\n     * IF content type is unsupported THEN note limitation in processing\n   - Process special headers\n     * Check for In-Reply-To header to establish message threading\n     * Check for References header to maintain conversation context\n     * Store all headers in accessible format for later reference\n   - Handle reply address determination\n     * IF specific reply-to address exists THEN use it\n     * ELSE use sender address as reply-to address\n\n4. Core Operation Execution:\n   - Extract message metadata\n     * Extract subject line\n     * Extract sender address\n     * Extract recipient address\n     * Extract sent date\n     * Extract reply-to address\n   - Process message headers\n     * Iterate through all headers\n     * Store headers in structured format\n     * Identify and specially handle In-Reply-To and References headers\n   - Extract message content\n     * IF message is multipart THEN select appropriate part for content extraction\n     * Open input stream to message content\n     * Read content in chunks to handle large messages efficiently\n     * Convert content to string representation\n     * Close all resources properly to prevent leaks\n   - Handle any exceptions during extraction\n     * Catch and properly handle I/O exceptions\n     * Catch and properly handle messaging exceptions\n     * Ensure resources are released even if exceptions occur\n\n5. Response Generation:\n   - Assemble extracted message components into structured format\n     * Combine all extracted metadata and content\n     * Format data for consistent access\n   - Provide complete message representation\n     * Include all extracted fields in consistent format\n     * Make all message components accessible through standard interface\n   - Return fully processed message object\n     * Ensure all components are properly extracted and formatted\n     * Provide access methods for all message components",
    "databaseEntities": [
      "jforum_posts",
      "jforum_posts_text",
      "jforum_topics",
      "jforum_users"
    ],
    "validationRules": [
      "Message object must not be null",
      "Message content must be accessible",
      "Sender information must be available",
      "Resources must be properly closed after extraction",
      "Content type must be properly identified",
      "Message headers must be properly extracted and stored"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Message": {
        "type": "object",
        "properties": {
          "subject": {
            "type": "string",
            "description": "Email subject line"
          },
          "content": {
            "type": "object",
            "description": "Raw message content"
          },
          "from": {
            "type": "array",
            "description": "Sender address information"
          },
          "replyTo": {
            "type": "array",
            "description": "Reply-to address information"
          },
          "recipients": {
            "type": "array",
            "description": "Message recipients"
          },
          "sentDate": {
            "type": "object",
            "description": "Date when message was sent"
          },
          "contentType": {
            "type": "string",
            "description": "MIME content type of message"
          },
          "headers": {
            "type": "object",
            "description": "Collection of message headers"
          }
        }
      }
    }
  },
  {
    "featureName": "ParseMultipartMessage",
    "description": "Parses multipart email messages to extract text content from different parts.",
    "inputValues": [
      "message-object-EmailMessage"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the email message object with all its components\n   - Required fields include:\n     * Subject (string)\n     * Content (object)\n     * Content Type (string)\n     * From addresses (array)\n     * Recipients (array)\n     * Reply-To addresses (array)\n     * Sent Date (date)\n     * Headers (map/dictionary)\n\n2. Data Validation:\n   - Validate message object existence\n     * IF message is null or empty THEN\n       > Return error indicating invalid message\n     * END IF\n   - Validate required message components\n     * IF subject is null THEN\n       > Set subject to empty string\n     * END IF\n     * IF content is null THEN\n       > Return error indicating empty message content\n     * END IF\n     * IF sender information is missing THEN\n       > Return error indicating missing sender information\n     * END IF\n\n3. Business Rule Processing:\n   - Determine message content type\n     * Extract content type from message headers\n     * IF content type contains \"multipart\" THEN\n       > Flag message as multipart message\n     * ELSE\n       > Flag message as single part message\n     * END IF\n   - Process message headers\n     * Extract all headers into a structured collection\n     * Specifically identify important headers:\n       > In-Reply-To\n       > References\n       > List-related headers\n   - Determine reply chain information\n     * IF In-Reply-To header exists THEN\n       > Extract message reference identifier\n     * END IF\n     * IF References header exists THEN\n       > Extract thread reference information\n     * END IF\n\n4. Core Operation Execution:\n   - Extract basic message metadata\n     * Subject from message subject field\n     * Sender from From address field\n     * List email from recipient field\n     * Send date from message date field\n     * Reply-To from Reply-To field or fallback to sender if not present\n   - Process message content based on type\n     * IF message is multipart THEN\n       > Identify the first body part\n       > Determine content type of first body part\n     * ELSE\n       > Use main message content directly\n     * END IF\n   - Extract text content from appropriate part\n     * IF content type is text/plain or text/html THEN\n       > Open input stream to message part\n       > Read content stream into buffer\n       > Convert stream to string representation\n       > Close all resources properly\n     * END IF\n   - Organize extracted data\n     * Combine metadata and content into structured message object\n     * Include all extracted headers\n     * Include all reference information\n\n5. Response Generation:\n   - Create structured message object with:\n     * Subject\n     * Sender information\n     * Reply-To address\n     * References information\n     * In-Reply-To information\n     * Content type\n     * Message text content\n     * Send date\n     * All headers\n   - Return complete parsed message object\n   - IF any errors occurred during processing THEN\n     > Return error information with details about the failure point\n   - END IF",
    "databaseEntities": [
      "jforum_posts",
      "jforum_posts_text",
      "jforum_privmsgs",
      "jforum_privmsgs_text"
    ],
    "validationRules": [
      "Message object must not be null",
      "Message content must be accessible",
      "Sender information must be present",
      "Content type must be identified",
      "Message text must be extracted if content is text/plain or text/html"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "EmailMessage": {
        "type": "object",
        "properties": {
          "subject": {
            "type": "string",
            "description": "Email subject line"
          },
          "content": {
            "type": "object",
            "description": "Raw message content"
          },
          "contentType": {
            "type": "string",
            "description": "MIME content type of the message"
          },
          "from": {
            "type": "array",
            "description": "Sender addresses"
          },
          "recipients": {
            "type": "array",
            "description": "Recipient addresses"
          },
          "replyTo": {
            "type": "array",
            "description": "Reply-To addresses"
          },
          "sentDate": {
            "type": "date",
            "description": "Date when message was sent"
          },
          "headers": {
            "type": "object",
            "description": "Map of all message headers"
          }
        },
        "required": [
          "content",
          "from",
          "recipients"
        ]
      }
    }
  },
  {
    "featureName": "ExtractEmailMetadata",
    "description": "Extracts and processes email metadata including subject, sender, reply-to, references, and dates from incoming messages.",
    "inputValues": [
      "emailMessage-object-Message"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the email message object containing all raw email data\n   - System will process the following metadata fields:\n     * Subject line\n     * Sender address\n     * Reply-to address\n     * References header\n     * In-Reply-To header\n     * Content type\n     * Recipient address\n     * Send date\n     * All email headers\n     * Message content\n\n2. Data Validation:\n   - Validate email message object\n     * Verify the message object is not null\n     * Check that the message contains required minimum fields (subject, sender)\n     * Validate that content can be accessed\n   - Validate email addresses format\n     * Ensure sender address follows standard email format\n     * Verify reply-to address format if present\n   - Validate date information\n     * Ensure send date is a valid date format\n     * Verify date is not in the future\n\n3. Business Rule Processing:\n   - Process email headers\n     * Extract all headers into a structured collection\n     * Identify and flag special headers (References, In-Reply-To)\n     * Map header names to their values\n   - Handle reply chain information\n     * IF In-Reply-To header exists, extract message reference ID\n     * IF References header exists, extract conversation thread history\n   - Process addressing information\n     * Extract primary sender address\n     * IF reply-to field exists, use as primary response address\n     * ELSE use sender address as reply-to address\n     * Extract list email address from recipients\n\n4. Core Operation Execution:\n   - Extract message content\n     * Determine message format (plain text, HTML, multipart)\n     * IF message is multipart, extract first part as primary content\n     * Process content based on content type\n       * FOR text/plain: Extract raw text\n       * FOR text/html: Extract HTML content\n     * Handle character encoding appropriately\n     * Buffer content into memory with appropriate size handling\n   - Organize metadata structure\n     * Compile all extracted metadata into structured format\n     * Associate headers with their corresponding values\n     * Link reply chain information with message content\n\n5. Response Generation:\n   - Prepare metadata result\n     * Assemble complete metadata object with all extracted fields\n     * Include subject, sender, reply-to, references, dates, content\n     * Format headers in accessible structure\n   - Handle extraction errors\n     * IF any extraction process fails, provide error information\n     * Include partial metadata if some fields were successfully extracted\n     * Provide guidance on missing or malformed fields\n   - Return complete metadata package\n     * Deliver structured metadata for further processing\n     * Include original message reference for traceability",
    "databaseEntities": [
      "jforum_posts",
      "jforum_posts_text",
      "jforum_topics",
      "jforum_users"
    ],
    "validationRules": [
      "Email message object must not be null",
      "Sender address must be a valid email format",
      "Reply-to address must be a valid email format if present",
      "Send date must be a valid date",
      "Content type must be recognized (text/plain, text/html, etc.)",
      "Message content must be extractable"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Message": {
        "type": "object",
        "properties": {
          "subject": {
            "type": "string",
            "description": "Email subject line"
          },
          "from": {
            "type": "array",
            "description": "Sender addresses"
          },
          "replyTo": {
            "type": "array",
            "description": "Reply-to addresses"
          },
          "recipients": {
            "type": "array",
            "description": "Message recipients"
          },
          "sentDate": {
            "type": "date",
            "description": "Date when message was sent"
          },
          "headers": {
            "type": "object",
            "description": "Collection of all message headers"
          },
          "content": {
            "type": "object",
            "description": "Message content object"
          },
          "contentType": {
            "type": "string",
            "description": "MIME type of message content"
          }
        }
      }
    }
  },
  {
    "featureName": "ParsePOPMessages",
    "description": "Parses email messages from a POP connector and stores them in a retrievable list.",
    "inputValues": [
      "connector-object-POPConnector"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the POPConnector object which contains connection to the email server\n   - The connector must be properly initialized and connected to the mail server\n   - No additional user inputs are required as this is a system operation\n\n2. Data Validation:\n   - Validate POPConnector object:\n      * Verify the connector is not null\n      * Verify the connector has an active connection to the mail server\n      * IF connector validation fails, THEN generate appropriate error message and terminate process\n\n3. Business Rule Processing:\n   - Check system readiness:\n      * Verify system has sufficient memory to process incoming messages\n      * Verify storage capacity for message list\n      * IF system resources are insufficient, THEN log warning and continue with limited processing\n\n4. Core Operation Execution:\n   - Initialize an empty message collection to store processed messages\n   - Request list of messages from the connector:\n      * Call the connector's listMessages method to retrieve all available messages\n      * IF message retrieval fails, THEN log error and return empty list\n   - Process each message in the retrieved collection:\n      * FOR each message in the connector's message list:\n         > Create a new message object to store the parsed message\n         > Extract message content and metadata\n         > Add the processed message to the message collection\n         > Log successful message processing\n      * END FOR\n   - Finalize message processing:\n      * Verify all messages were processed correctly\n      * Log summary of processing results\n\n5. Response Generation:\n   - Return the collection of processed messages\n   - IF no messages were processed, THEN return empty collection\n   - Include count of successfully processed messages in log\n   - Include any processing warnings or errors in log",
    "databaseEntities": [],
    "validationRules": [
      "POPConnector must be properly initialized",
      "POPConnector must have an active connection to the mail server",
      "System must have sufficient resources to process messages"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "POPConnector": {
        "type": "object",
        "properties": {
          "connection": {
            "type": "object",
            "description": "Connection to the mail server"
          },
          "listMessages": {
            "type": "function",
            "description": "Method to retrieve messages from the mail server"
          }
        },
        "required": [
          "connection",
          "listMessages"
        ]
      }
    }
  },
  {
    "featureName": "GetParsedMessages",
    "description": "Retrieves the list of parsed POP email messages.",
    "inputValues": [
      "connector-object-POPConnector"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect POPConnector object which contains connection details to the email server\n   - The connector must be properly initialized and connected to the email server\n\n2. Data Validation:\n   - Validate that the POPConnector object is not null\n   - Verify the connector has an active connection to the email server\n   - IF connector is null or not connected THEN\n     - Generate appropriate error message\n     - Exit process\n   - END IF\n\n3. Business Rule Processing:\n   - Verify the system has sufficient permissions to access the mailbox\n   - Check if the connection has timeout constraints\n   - Ensure the system can handle the potential volume of messages\n   - IF any business rule fails THEN\n     - Log the specific failure reason\n     - Generate appropriate error message\n     - Exit process\n   - END IF\n\n4. Core Operation Execution:\n   - Initialize an empty list to store parsed messages\n   - Request the list of raw messages from the connector\n   - FOR each raw message in the retrieved list:\n     - Create a new parsed message object\n     - Extract message metadata (sender, recipient, subject, date)\n     - Extract message content (body, attachments if any)\n     - Add the parsed message to the messages list\n     - Log the successful retrieval of the message\n   - END FOR\n   - IF any error occurs during message parsing THEN\n     - Log the error details\n     - Continue with the next message\n   - END IF\n\n5. Response Generation:\n   - Return the complete list of successfully parsed messages\n   - Include count of successfully parsed messages\n   - Include count of messages that failed parsing (if any)\n   - IF no messages were found or parsed THEN\n     - Return empty list with appropriate status\n   - END IF",
    "databaseEntities": [
      "jforum_posts",
      "jforum_posts_text",
      "jforum_privmsgs",
      "jforum_privmsgs_text"
    ],
    "validationRules": [
      "POPConnector must be properly initialized",
      "Connection to email server must be active",
      "System must have sufficient permissions to access the mailbox"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "POPConnector": {
        "type": "object",
        "properties": {
          "connection": {
            "type": "object",
            "description": "Connection details to the POP email server"
          },
          "listMessages": {
            "type": "function",
            "description": "Method that returns array of raw email messages"
          }
        },
        "required": [
          "connection",
          "listMessages"
        ]
      },
      "POPMessage": {
        "type": "object",
        "properties": {
          "sender": {
            "type": "string",
            "description": "Email address of the sender"
          },
          "recipient": {
            "type": "string",
            "description": "Email address of the recipient"
          },
          "subject": {
            "type": "string",
            "description": "Subject line of the email"
          },
          "content": {
            "type": "string",
            "description": "Body content of the email"
          },
          "date": {
            "type": "date",
            "description": "Date when the email was sent"
          }
        },
        "required": [
          "sender",
          "subject",
          "content",
          "date"
        ]
      }
    }
  },
  {
    "featureName": "InsertMessagesFromPOP",
    "description": "Processes email messages from POP server and posts them to forum topics.",
    "inputValues": [
      "popMessages-object-POPMessageCollection",
      "senderEmail-string-User",
      "listEmail-string-Forum",
      "subject-string-Message",
      "messageBody-string-Message",
      "inReplyTo-string-Message"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect POP message collection containing multiple email messages\n   - For each message, extract:\n     - Sender email address (mandatory)\n     - List/destination email address (mandatory)\n     - Subject line (mandatory)\n     - Message body content (mandatory)\n     - In-Reply-To header (optional)\n     - Message identifiers (system-generated)\n\n2. Data Validation:\n   - Validate sender email format\n     - Must be a properly formatted email address\n     - Error message if format is invalid: \"Invalid sender email format\"\n   - Validate list email format\n     - Must be a properly formatted email address\n     - Error message if format is invalid: \"Invalid list email format\"\n   - Validate subject line\n     - Must not be empty\n     - Error message if empty: \"Subject line cannot be empty\"\n   - Validate message body\n     - Must not be empty\n     - Error message if empty: \"Message body cannot be empty\"\n\n3. Business Rule Processing:\n   - For each message in the collection:\n     - Check if sender email exists in the system\n       - IF sender email not found in user database\n         - Log warning message\n         - Skip processing this message\n         - Continue to next message\n     - Check if list email is associated with a forum\n       - IF list email not associated with any forum\n         - Log error message\n         - Skip processing this message\n         - Continue to next message\n     - Determine if message is a reply to existing topic\n       - IF In-Reply-To header exists\n         - Extract topic ID from message identifier\n       - ELSE\n         - Mark as new topic\n\n4. Core Operation Execution:\n   - For each valid message:\n     - Create system session for the sender user\n       - Generate unique session ID\n       - Set user permissions and preferences\n     - Prepare message data\n       - Set forum ID based on list email\n       - Set topic type as normal\n       - Set message subject and body\n       - Apply user formatting preferences (BBCode, HTML, smilies)\n     - Post message to forum\n       - IF message is a reply (has topic ID)\n         - Add as reply to existing topic\n       - ELSE\n         - Create as new topic\n     - Clean up session data after posting\n\n5. Response Generation:\n   - For successful message processing:\n     - Log successful posting information\n     - Include forum ID and topic ID in log\n   - For failed message processing:\n     - Log detailed error information\n     - Include reason for failure\n   - Generate final processing summary\n     - Total messages received\n     - Number of messages successfully processed\n     - Number of messages failed",
    "databaseEntities": [
      "jforum_users",
      "jforum_forums",
      "jforum_topics",
      "jforum_posts",
      "jforum_posts_text",
      "jforum_sessions"
    ],
    "validationRules": [
      "Sender email must exist in the user database",
      "List email must be associated with a forum",
      "Subject line must not be empty",
      "Message body must not be empty",
      "User must have permission to post in the target forum"
    ],
    "dbSeedingOperations": [
      "Forums must have email addresses configured for receiving messages",
      "Users must have email addresses that match their forum accounts"
    ],
    "schema": {
      "POPMessageCollection": {
        "type": "array",
        "items": {
          "type": "object",
          "properties": {
            "sender": {
              "type": "string",
              "description": "Email address of the sender"
            },
            "listEmail": {
              "type": "string",
              "description": "Email address of the forum/list"
            },
            "subject": {
              "type": "string",
              "description": "Subject line of the message"
            },
            "message": {
              "type": "string",
              "description": "Body content of the message"
            },
            "inReplyTo": {
              "type": "string",
              "description": "Message identifier this message is replying to"
            }
          },
          "required": [
            "sender",
            "listEmail",
            "subject",
            "message"
          ]
        }
      }
    }
  },
  {
    "featureName": "InsertForumPostFromEmail",
    "description": "Creates forum posts from email content with proper user attribution.",
    "inputValues": [
      "senderEmail-string-User",
      "subject-string-Post",
      "messageContent-string-Post",
      "listEmail-string-Forum",
      "inReplyTo-string-Message"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the following inputs:\n     a. senderEmail (mandatory): Email address of the sender\n     b. subject (mandatory): Subject line of the email\n     c. messageContent (mandatory): Body content of the email\n     d. listEmail (mandatory): Target forum email address\n     e. inReplyTo (optional): Reference to previous message if this is a reply\n\n2. Data Validation:\n   - Validate sender email:\n     a. Check if email format is valid\n     b. Verify email exists in the system\n     c. IF email is invalid or not found, log warning and abort processing\n   - Validate forum email address:\n     a. Check if the listEmail corresponds to a valid forum\n     b. IF no matching forum is found, abort processing\n   - Validate message content:\n     a. Ensure subject is not empty\n     b. Ensure message body is not empty\n     c. IF either is empty, abort processing\n\n3. Business Rule Processing:\n   - User authentication and authorization:\n     a. Find user account associated with sender email\n     b. Verify user has permission to post in the target forum\n     c. IF user not found or lacks permission, log warning and abort processing\n   - Determine post context:\n     a. IF inReplyTo reference exists, extract topic ID from reference\n     b. Verify topic exists and is open for replies\n     c. IF topic not found or closed, treat as new topic instead\n\n4. Core Operation Execution:\n   - Session preparation:\n     a. Create temporary user session for the email sender\n     b. Set appropriate user preferences (BBCode, HTML, smilies settings)\n   - Forum identification:\n     a. Determine target forum ID based on listEmail\n   - Post creation:\n     a. IF inReplyTo contains valid topic reference, create reply to existing topic\n     b. ELSE create new topic with the email subject as topic title\n     c. Use email message body as post content\n     d. Apply user's formatting preferences to the content\n     e. Associate post with the sender's user account\n     f. Record post creation timestamp\n   - Cleanup:\n     a. Remove temporary user session\n     b. Release any system resources\n\n5. Response Generation:\n   - Success handling:\n     a. Log successful post creation with forum ID and topic ID\n     b. Record message processing completion\n   - Error handling:\n     a. Log detailed error information for failed processing attempts\n     b. Include sender email and reason for failure\n     c. Ensure partial processing doesn't leave inconsistent data",
    "databaseEntities": [
      "jforum_users",
      "jforum_forums",
      "jforum_topics",
      "jforum_posts",
      "jforum_posts_text",
      "jforum_sessions"
    ],
    "validationRules": [
      "Sender email must exist in the system",
      "Sender email must be associated with a valid user account",
      "Forum email address must correspond to an existing forum",
      "Email subject must not be empty",
      "Email message content must not be empty",
      "If replying to a topic, the topic must exist and be open for replies",
      "User must have permission to post in the target forum"
    ],
    "dbSeedingOperations": [
      "Ensure at least one forum has an email address configured",
      "Ensure user accounts have email addresses that match potential senders"
    ],
    "schema": {
      "User": {
        "id": "number",
        "email": "string",
        "username": "string",
        "isBbCodeEnabled": "boolean",
        "isHtmlEnabled": "boolean",
        "isSmiliesEnabled": "boolean"
      },
      "Forum": {
        "id": "number",
        "name": "string",
        "email": "string"
      },
      "Topic": {
        "id": "number",
        "forumId": "number",
        "title": "string",
        "type": "number"
      },
      "Post": {
        "topicId": "number",
        "userId": "number",
        "subject": "string",
        "text": "string",
        "bbCodeEnabled": "boolean",
        "htmlEnabled": "boolean",
        "smiliesEnabled": "boolean"
      },
      "Message": {
        "topicId": "number",
        "messageId": "string"
      }
    }
  },
  {
    "featureName": "DiscoverForumIdFromEmail",
    "description": "Maps email addresses to corresponding forum IDs for message routing.",
    "inputValues": [
      "listEmail-string-Forum",
      "sender-string-User"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect listEmail (string): The forum's email address to search for (mandatory)\n   - Collect sender (string): The email address of the message sender (mandatory)\n\n2. Data Validation:\n   - Validate listEmail:\n     2.1. Check if listEmail is not null or empty\n     2.2. Verify listEmail follows valid email format\n     2.3. If validation fails, generate appropriate error message\n   - Validate sender:\n     2.4. Check if sender is not null or empty\n     2.5. Verify sender follows valid email format\n     2.6. If validation fails, generate appropriate error message\n\n3. Business Rule Processing:\n   - Check system configuration:\n     3.1. Verify email-to-forum mapping feature is enabled\n     3.2. IF email-to-forum mapping is disabled, THEN return error message\n   - Verify sender authorization:\n     3.3. Check if sender email exists in the user database\n     3.4. IF sender not found, THEN log warning and return error message\n     3.5. Check if sender has permission to post to forums\n     3.6. IF sender lacks permission, THEN return error message\n\n4. Core Operation Execution:\n   - Forum ID discovery:\n     4.1. Search forum database for records matching the listEmail\n     4.2. IF matching forum found:\n        4.2.1. Retrieve forum ID associated with listEmail\n        4.2.2. Verify forum is active and accepting posts\n        4.2.3. IF forum is inactive, THEN return error message\n     4.3. IF no matching forum found:\n        4.3.1. Log the failed mapping attempt\n        4.3.2. Return default forum ID if configured, otherwise return error\n   - User verification:\n     4.4. Retrieve user information based on sender email\n     4.5. Verify user has permission to post in the identified forum\n     4.6. IF user lacks permission, THEN return error message\n\n5. Response Generation:\n   - Success response:\n     5.1. Return the discovered forum ID\n     5.2. Include forum name and category information\n     5.3. Include posting guidelines if available\n   - Error response:\n     5.4. Return appropriate error code\n     5.5. Include descriptive error message\n     5.6. Provide troubleshooting information when applicable",
    "databaseEntities": [
      "jforum_users",
      "jforum_forums",
      "jforum_user_groups",
      "jforum_groups"
    ],
    "validationRules": [
      "List email must be a valid email format",
      "List email must exist in the forum database",
      "Sender email must be a valid email format",
      "Sender email must belong to a registered user",
      "User must have permission to post to the identified forum",
      "Forum must be active and accepting posts"
    ],
    "dbSeedingOperations": [
      "Ensure forums have email addresses configured",
      "Ensure user permissions are properly set up"
    ],
    "schema": {
      "Forum": {
        "id": "number",
        "name": "string",
        "description": "string",
        "email": "string",
        "isActive": "boolean"
      },
      "User": {
        "id": "number",
        "email": "string",
        "username": "string",
        "permissions": "object"
      }
    }
  },
  {
    "featureName": "ExtractTopicRelationships",
    "description": "Identifies reply relationships between emails to maintain conversation threads.",
    "inputValues": [
      "message-object-POPMessage",
      "sender-string-User",
      "inReplyTo-string-MessageHeader",
      "subject-string-MessageSubject",
      "listEmail-string-ForumEmail"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect incoming email message (message-object-POPMessage)\n     - Message content (body text)\n     - Message subject line\n     - Sender email address\n     - Message headers including In-Reply-To\n     - List/forum email address (recipient)\n   - System will determine if this is a new conversation or reply to existing thread\n\n2. Data Validation:\n   - Validate sender email address\n     - Must be properly formatted email address\n     - Must belong to a registered user in the system\n     - Error: If sender not found, log warning and skip processing\n   - Validate message content\n     - Must not be empty\n     - Must comply with forum posting rules\n   - Validate subject line\n     - Must not be empty\n     - Remove any unnecessary prefixes (Re:, Fwd:, etc.) for processing\n   - Validate recipient forum email\n     - Must match a configured forum email address\n     - Error: If no matching forum found, reject message\n\n3. Business Rule Processing:\n   - Determine message relationship\n     - IF In-Reply-To header exists THEN\n       - Extract message identifier from header\n       - Parse identifier to determine original topic ID\n       - Verify topic exists in the system\n       - IF topic found THEN\n         - Mark message as reply to existing topic\n       - ELSE\n         - Mark as new topic (relationship not established)\n     - ELSE\n       - Mark as new topic\n   - Check user permissions\n     - Verify user has permission to post in the target forum\n     - Verify user has permission to reply if message is a reply\n   - Apply user preferences\n     - Check if BBCode is enabled for user\n     - Check if HTML is enabled for user\n     - Check if smilies are enabled for user\n\n4. Core Operation Execution:\n   - Prepare message parameters\n     - Set forum ID based on recipient email address\n     - Set topic type (normal)\n     - Set message subject and body\n     - IF message is a reply THEN\n       - Associate with existing topic ID\n     - ELSE\n       - Create as new topic\n     - Apply user formatting preferences\n   - Create session context for processing\n     - Generate unique session ID\n     - Set user session attributes\n   - Execute message posting operation\n     - Insert message into appropriate topic\n     - Update topic last post information\n     - Update forum statistics\n   - Clean up session resources\n     - Remove temporary session\n\n5. Response Generation:\n   - Log successful message processing\n     - Record topic ID and post ID\n     - Record processing time\n   - Handle any processing errors\n     - Log detailed error information\n     - Skip to next message if batch processing\n   - Generate system notification if configured\n     - Notify moderators of new post if required\n     - Send confirmation to sender if enabled",
    "databaseEntities": [
      "jforum_users",
      "jforum_forums",
      "jforum_topics",
      "jforum_posts",
      "jforum_posts_text",
      "jforum_sessions"
    ],
    "validationRules": [
      "Sender email must belong to a registered user",
      "Message content must not be empty",
      "Subject line must not be empty",
      "Recipient forum email must match a configured forum",
      "User must have permission to post in the target forum",
      "If replying, the original topic must exist"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "POPMessage": {
        "type": "object",
        "properties": {
          "sender": {
            "type": "string",
            "description": "Email address of the sender"
          },
          "subject": {
            "type": "string",
            "description": "Subject line of the email"
          },
          "message": {
            "type": "string",
            "description": "Body content of the email"
          },
          "inReplyTo": {
            "type": "string",
            "description": "Message ID this email is replying to"
          },
          "listEmail": {
            "type": "string",
            "description": "Email address of the forum this message was sent to"
          }
        },
        "required": [
          "sender",
          "subject",
          "message",
          "listEmail"
        ]
      }
    }
  },
  {
    "featureName": "ValidateApiKey",
    "description": "Authenticates REST API requests by validating the provided API key against stored credentials.",
    "inputValues": [
      "apiKey-string-ApiCredential"
    ],
    "businessLogic": "1. Input Collection\n   - Collect the API key (string) from the request\n   - The API key is mandatory and must be provided in the request\n   - No default values are applicable\n\n2. Data Validation\n   - Validate API key format\n     - Check if the API key is not null or empty\n     - Verify the API key follows the expected format (alphanumeric string)\n     - IF validation fails, THEN prepare error message indicating invalid API key format\n\n3. Business Rule Processing\n   - Verify system readiness for API key validation\n     - Check if the credential storage system is accessible\n     - IF credential storage is not accessible, THEN prepare system unavailable error\n\n4. Core Operation Execution\n   - Retrieve stored API credentials\n     - Access the credential storage to find matching API key\n     - Compare the provided API key with stored credentials\n     - IF a match is found, THEN mark authentication as successful\n     - IF no match is found, THEN mark authentication as failed\n\n5. Response Generation\n   - Generate authentication result\n     - IF authentication is successful\n       - Return success indicator (true)\n       - Allow the API request to proceed\n     - IF authentication fails\n       - Return failure indicator (false)\n       - Include appropriate authentication failure message\n       - Deny access to the requested API functionality",
    "databaseEntities": [
      "jforum_users",
      "jforum_api_credentials"
    ],
    "validationRules": [
      "API key must not be null or empty",
      "API key must match a valid credential in the system",
      "API key must be in the correct format"
    ],
    "dbSeedingOperations": [
      "Ensure at least one valid API key exists in the credential storage system"
    ],
    "schema": {
      "ApiCredential": {
        "apiKey": "string",
        "isActive": "boolean",
        "createdDate": "date",
        "expiryDate": "date",
        "permissions": "string"
      }
    }
  },
  {
    "featureName": "ListUsers",
    "description": "Retrieves a list of all users in the system with pagination and filtering options.",
    "inputValues": [
      "start-number-Pagination",
      "usersPerPage-number-Pagination",
      "username-string-SearchFilter",
      "group_id-number-GroupFilter"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect pagination parameters:\n     a. start - Starting position for pagination (optional, defaults to 1)\n     b. usersPerPage - Number of users to display per page (system-configured value)\n   - Collect filter parameters:\n     a. username - Search string for filtering users by name (optional)\n     b. group_id - Group identifier for filtering users by group (optional)\n\n2. Data Validation:\n   - Validate pagination parameters:\n     a. Check if start is a positive integer\n     b. IF start is invalid, THEN use default value of 1\n     c. Retrieve system-configured value for usersPerPage\n   - Validate filter parameters:\n     a. IF username is provided, THEN ensure it's properly formatted\n     b. IF group_id is provided, THEN ensure it's a valid integer\n     c. IF group_id equals 0, THEN treat as no group filter\n\n3. Business Rule Processing:\n   - Determine the appropriate query type:\n     a. IF username is provided and not empty, THEN prepare for name-based search\n     b. ELSE IF group_id is provided and not zero, THEN prepare for group-based search\n     c. ELSE prepare for standard paginated list\n   - Calculate pagination values:\n     a. Determine total number of users based on query type\n     b. Calculate total pages based on usersPerPage\n     c. Validate that requested page is within range\n\n4. Core Operation Execution:\n   - Execute the appropriate query based on type:\n     a. IF performing name-based search:\n        i. Retrieve users matching the provided username pattern\n     b. ELSE IF performing group-based search:\n        i. Retrieve users belonging to the specified group\n        ii. Apply pagination to the results\n     c. ELSE:\n        i. Retrieve all users with pagination\n   - Prepare additional context data:\n     a. Retrieve group information for group selection\n     b. Format pagination information\n     c. Prepare any search parameters for display\n\n5. Response Generation:\n   - Success response:\n     a. Format the list of retrieved users\n     b. Include pagination information (current page, total pages)\n     c. Include search/filter parameters if applicable\n     d. Include group information for filtering options\n     e. Return the complete response to the user\n   - Error response:\n     a. Format any errors that occurred during processing\n     b. Include appropriate error messages\n     c. Return the error information to the user",
    "databaseEntities": [
      "jforum_users",
      "jforum_groups",
      "jforum_user_groups"
    ],
    "validationRules": [
      "Pagination start parameter must be a positive integer",
      "Users per page must follow system configuration",
      "Group ID must be a valid integer if provided",
      "User must have administrative permissions to view user list"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "User": {
        "id": "number",
        "username": "string",
        "email": "string",
        "registrationDate": "date",
        "active": "boolean",
        "groups": "array"
      },
      "Group": {
        "id": "number",
        "name": "string",
        "description": "string"
      }
    }
  },
  {
    "featureName": "CreateUser",
    "description": "Creates a new user with username, email and password with validation checks.",
    "inputValues": [
      "username-string-User",
      "email-string-User",
      "password-string-User",
      "activationKey-string-User"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the following required inputs:\n     a. username (string, mandatory): User's login name\n     b. email (string, mandatory): User's email address\n     c. password (string, mandatory): User's account password\n     d. activationKey (string, optional): Key for account activation, system-generated if not provided\n\n2. Data Validation:\n   a. Username Validation:\n      - Verify username is provided and not empty\n      - IF username is empty THEN\n        - Return error message indicating username is required\n        - Terminate process\n      - END IF\n      - Verify username length is within acceptable range (minimum 3 characters, maximum 25 characters)\n      - IF username length is invalid THEN\n        - Return error message indicating username length requirements\n        - Terminate process\n      - END IF\n      - Verify username contains only allowed characters (alphanumeric and underscores)\n      - IF username contains invalid characters THEN\n        - Return error message indicating allowed character set\n        - Terminate process\n      - END IF\n   \n   b. Email Validation:\n      - Verify email is provided and not empty\n      - IF email is empty THEN\n        - Return error message indicating email is required\n        - Terminate process\n      - END IF\n      - Verify email follows valid format (contains @ and proper domain structure)\n      - IF email format is invalid THEN\n        - Return error message indicating proper email format\n        - Terminate process\n      - END IF\n   \n   c. Password Validation:\n      - Verify password is provided and not empty\n      - IF password is empty THEN\n        - Return error message indicating password is required\n        - Terminate process\n      - END IF\n      - Verify password meets minimum complexity requirements (length, character types)\n      - IF password complexity is insufficient THEN\n        - Return error message indicating password requirements\n        - Terminate process\n      - END IF\n\n3. Business Rule Processing:\n   a. Username Uniqueness Check:\n      - Check if the username already exists in the system\n      - IF username already exists THEN\n        - Return error message indicating username is already taken\n        - Terminate process\n      - END IF\n   \n   b. Email Uniqueness Check:\n      - Check if the email already exists in the system\n      - IF email already exists THEN\n        - Return error message indicating email is already registered\n        - Terminate process\n      - END IF\n   \n   c. Activation Key Generation:\n      - IF activationKey is not provided THEN\n        - Generate a unique activation key for the user\n      - END IF\n\n4. Core Operation Execution:\n   a. User Record Creation:\n      - Create a new user record with the following information:\n        - Username\n        - Password (securely stored)\n        - Email\n        - Registration date (current timestamp)\n        - Activation key\n        - Default settings for user preferences\n      - IF record creation fails THEN\n        - Return error message indicating system error\n        - Terminate process\n      - END IF\n   \n   b. Group Assignment:\n      - Assign the user to the default user group\n      - IF group assignment fails THEN\n        - Delete the created user record\n        - Return error message indicating system error\n        - Terminate process\n      - END IF\n\n5. Response Generation:\n   a. Success Response:\n      - Generate success response containing:\n        - User ID of the newly created user\n        - Username\n        - Email\n        - Registration date\n        - Activation status (typically requiring activation)\n        - Message indicating successful account creation\n   \n   b. Error Response (if applicable):\n      - Generate error response containing:\n        - Error message describing the issue\n        - Error code or type\n        - Guidance on how to resolve the issue",
    "databaseEntities": [
      "jforum_users",
      "jforum_user_groups"
    ],
    "validationRules": [
      "Username must not be empty",
      "Username must be between 3 and 25 characters",
      "Username must contain only alphanumeric characters and underscores",
      "Username must be unique in the system",
      "Email must not be empty",
      "Email must follow valid format",
      "Email must be unique in the system",
      "Password must not be empty",
      "Password must meet minimum complexity requirements"
    ],
    "dbSeedingOperations": [
      "Default user group must exist in jforum_groups table"
    ],
    "schema": {
      "User": {
        "type": "object",
        "properties": {
          "id": {
            "type": "integer",
            "description": "Unique identifier for the user"
          },
          "username": {
            "type": "string",
            "description": "User's login name"
          },
          "password": {
            "type": "string",
            "description": "User's account password"
          },
          "email": {
            "type": "string",
            "description": "User's email address"
          },
          "registrationDate": {
            "type": "date",
            "description": "Date when user registered"
          },
          "activationKey": {
            "type": "string",
            "description": "Key for account activation"
          },
          "active": {
            "type": "integer",
            "description": "Indicates if the user account is active"
          }
        },
        "required": [
          "username",
          "password",
          "email"
        ]
      }
    }
  },
  {
    "featureName": "AuthenticateApiRequest",
    "description": "Validates API requests using API key authentication.",
    "inputValues": [
      "api_key-string-Authentication"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect API key from the request\n     1.1. Extract the 'api_key' parameter from the incoming request\n     1.2. Mark 'api_key' as mandatory input\n     1.3. No default value is provided for API key\n\n2. Data Validation:\n   - Validate the API key parameter\n     2.1. Check if the API key parameter exists in the request\n     2.2. Verify the API key is not empty or only whitespace\n     2.3. IF API key is missing or empty THEN\n          2.3.1. Generate an authentication error message\n          2.3.2. Halt further processing\n     2.4. Format validation is not required as API keys can have various formats\n\n3. Business Rule Processing:\n   - Validate the API key against authorized keys\n     3.1. Retrieve the list of valid API keys from the system\n     3.2. Compare the provided API key with the stored valid keys\n     3.3. IF the API key does not match any valid key THEN\n          3.3.1. Generate an invalid authentication error message\n          3.3.2. Log the failed authentication attempt with request details\n          3.3.3. Halt further processing\n     3.4. IF the API key is valid but expired THEN\n          3.4.1. Generate an expired key error message\n          3.4.2. Log the expired key usage attempt\n          3.4.3. Halt further processing\n\n4. Core Operation Execution:\n   - Process successful authentication\n     4.1. Identify the API key owner/account\n     4.2. Record the successful authentication in system logs\n     4.3. Set the authentication context for the current request\n     4.4. Allow the request to proceed to the requested operation\n     4.5. IF any errors occur during authentication context setup THEN\n          4.5.1. Generate a system error message\n          4.5.2. Log the error details\n          4.5.3. Halt further processing\n\n5. Response Generation:\n   - No direct response is generated for authentication\n     5.1. IF authentication is successful THEN\n          5.1.1. Allow the request to continue to the requested operation\n     5.2. IF authentication fails THEN\n          5.2.1. Return an authentication error response\n          5.2.2. Include appropriate error code and message\n          5.2.3. Do not expose sensitive information about the authentication system",
    "databaseEntities": [
      "jforum_users"
    ],
    "validationRules": [
      "API key must not be empty",
      "API key must match a valid key in the system",
      "API key must not be expired",
      "Authentication must be performed before accessing API operations"
    ],
    "dbSeedingOperations": [
      "Initial valid API keys must be created in the system"
    ],
    "schema": {
      "Authentication": {
        "type": "object",
        "properties": {
          "api_key": {
            "type": "string",
            "description": "Unique key used to authenticate API requests"
          }
        },
        "required": [
          "api_key"
        ]
      }
    }
  },
  {
    "featureName": "InitializeCache",
    "description": "Initializes the cache engine system.",
    "inputValues": [
      "cacheConfiguration-object-CacheConfiguration"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect cacheConfiguration (mandatory) containing:\n     a. Cache type/provider information\n     b. Cache size limits\n     c. Expiration policies\n     d. Persistence settings\n     e. Cache properties file path\n\n2. Data Validation:\n   - Validate cacheConfiguration:\n     a. Verify cache type is supported by the system\n     b. Ensure cache size limits are within acceptable ranges\n     c. Validate that expiration policies have valid time units\n     d. Check persistence settings for compatibility with system\n     e. Verify cache properties file exists and is accessible\n   - IF any validation fails THEN:\n     a. Generate appropriate error message\n     b. Halt initialization process\n     c. Return error status\n\n3. Business Rule Processing:\n   - Check system resources:\n     a. Verify sufficient memory is available for cache allocation\n     b. Check disk space if persistence is enabled\n     c. Verify system permissions for cache operations\n   - Check for existing cache instances:\n     a. IF cache is already initialized THEN:\n        i. Determine if reinitialization is allowed\n        ii. If allowed, prepare for stopping existing cache\n        iii. If not allowed, return appropriate status\n   - Verify logging system is available for cache operations\n\n4. Core Operation Execution:\n   - Prepare cache environment:\n     a. Create necessary directories for cache storage if persistence enabled\n     b. Initialize internal data structures\n     c. Set up monitoring mechanisms\n   - Initialize the cache engine:\n     a. Load cache configuration from properties file\n     b. Create cache manager instance\n     c. Allocate required memory\n     d. Set up cache regions based on configuration\n     e. Configure expiration policies\n     f. Initialize notification mechanisms\n   - Register cache with system:\n     a. Make cache available to other components\n     b. Set up management interfaces\n   - IF any step fails during initialization THEN:\n     a. Release any allocated resources\n     b. Log detailed error information\n     c. Return failure status with exception details\n\n5. Response Generation:\n   - On successful initialization:\n     a. Generate initialization statistics (memory allocated, regions created)\n     b. Return success status with cache instance information\n     c. Include cache capabilities information\n     d. Log successful initialization\n   - On failure:\n     a. Provide detailed error information\n     b. Include troubleshooting suggestions\n     c. Suggest alternative configurations if appropriate\n     d. Log initialization failure with error details",
    "databaseEntities": [],
    "validationRules": [
      "Cache configuration must be provided",
      "Cache type must be supported by the system",
      "Cache size limits must be within acceptable ranges",
      "Expiration policies must have valid time units",
      "System must have sufficient resources for cache allocation",
      "Cache properties file must exist and be accessible",
      "Cache manager must be successfully created"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "CacheConfiguration": {
        "type": "object",
        "properties": {
          "cacheType": {
            "type": "string",
            "description": "The type of cache to initialize"
          },
          "sizeLimit": {
            "type": "object",
            "properties": {
              "maxEntries": {
                "type": "number",
                "description": "Maximum number of entries allowed in cache"
              },
              "maxMemoryMB": {
                "type": "number",
                "description": "Maximum memory allocation in megabytes"
              }
            }
          },
          "expirationPolicy": {
            "type": "object",
            "properties": {
              "defaultTTL": {
                "type": "number",
                "description": "Default time-to-live for cache entries in seconds"
              },
              "idleTime": {
                "type": "number",
                "description": "Maximum idle time before entry expiration in seconds"
              }
            }
          },
          "persistenceSettings": {
            "type": "object",
            "properties": {
              "enabled": {
                "type": "boolean",
                "description": "Whether cache persistence is enabled"
              },
              "storageLocation": {
                "type": "string",
                "description": "Location for persistent cache storage"
              }
            }
          },
          "propertiesFilePath": {
            "type": "string",
            "description": "Path to the cache configuration properties file"
          }
        },
        "required": [
          "cacheType"
        ]
      }
    }
  },
  {
    "featureName": "StopCache",
    "description": "Stops the cache engine system and releases associated resources.",
    "inputValues": [],
    "businessLogic": "1. Input Collection:\n   - No user inputs required for this operation\n   - System-generated context information will be used\n\n2. Data Validation:\n   - Verify cache engine is currently in active state\n     - IF cache engine is not initialized or already stopped THEN\n       - Generate appropriate notification\n       - Exit process without further action\n     - END IF\n\n3. Business Rule Processing:\n   - Check for pending operations\n     - IF critical write operations are in progress THEN\n       - Queue stop request until operations complete\n       - Set timeout for pending operations\n     - END IF\n   - Verify system state allows for cache shutdown\n     - IF system is in maintenance mode THEN\n       - Proceed with immediate shutdown\n     - ELSE\n       - Check for active user sessions\n       - IF active sessions exist THEN\n         - Log active session count\n       - END IF\n     - END IF\n\n4. Core Operation Execution:\n   - Prepare for cache shutdown\n     - Reject new cache requests\n     - Set cache system state to \"shutting down\"\n   - Flush modified data\n     - IF unsaved cache data exists THEN\n       - Write modified cache entries to persistent storage\n     - END IF\n   - Release resources\n     - Clear all cached objects\n     - Release memory allocations\n     - Close any open file handles or connections\n   - Update system status\n     - Set cache system state to \"stopped\"\n     - Update last shutdown timestamp\n\n5. Response Generation:\n   - Generate shutdown completion notification\n     - Include timestamp of shutdown\n     - Include statistics (cache hit ratio, uptime)\n   - Log cache shutdown event\n     - Record shutdown reason\n     - Record shutdown completion status",
    "databaseEntities": [],
    "validationRules": [
      "Cache engine must be in active state before stopping",
      "All critical write operations must complete before full shutdown",
      "System resources must be properly released during shutdown"
    ],
    "dbSeedingOperations": [],
    "schema": {}
  },
  {
    "featureName": "AddCacheItem",
    "description": "Adds a new object to the cache with a specified key.",
    "inputValues": [
      "key-string-CacheKey",
      "value-object-CacheValue",
      "fqn-string-FullyQualifiedName"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the following inputs:\n     a. key (string, mandatory): Unique identifier for the cache item\n     b. value (object, mandatory): The object to be cached\n     c. fqn (string, optional): Fully qualified name for the cache hierarchy, defaults to system default if not provided\n\n2. Data Validation:\n   - Validate key:\n     a. IF key is null or empty THEN\n        i. Generate error message: \"Cache key cannot be empty\"\n        ii. Abort operation\n     b. Check key format according to system requirements\n\n   - Validate value:\n     a. IF value is null THEN\n        i. Generate error message: \"Cache value cannot be null\"\n        ii. Abort operation\n     b. Verify value is serializable\n        i. IF value is not serializable THEN\n           1. Generate error message: \"Cache value must be serializable\"\n           2. Abort operation\n\n   - Validate fqn:\n     a. IF fqn is null THEN\n        i. Set fqn to default system value\n     b. Check fqn format according to system requirements\n\n3. Business Rule Processing:\n   - Check cache state:\n     a. IF cache system is not initialized THEN\n        i. Generate error message: \"Cache system not initialized\"\n        ii. Abort operation\n\n   - Check cache existence:\n     a. IF cache with specified fqn does not exist THEN\n        i. Create new cache with the specified fqn\n        ii. Log cache creation event\n\n   - Check cache capacity:\n     a. IF cache is at maximum capacity THEN\n        i. Apply eviction policy to make room for new item\n        ii. Log eviction event\n\n   - Check for existing items:\n     a. IF item with same key already exists in the specified fqn THEN\n        i. Prepare to overwrite existing item\n        ii. Log overwrite event\n\n4. Core Operation Execution:\n   - Prepare cache element:\n     a. Create a new cache element with the key and value\n     b. Apply any required metadata to the element\n\n   - Determine storage method based on inputs:\n     a. IF both fqn and key are provided THEN\n        i. Retrieve or create cache for the fqn\n        ii. Store element in the cache using the key\n     b. IF only key is provided THEN\n        i. Store element directly in default cache using key\n\n   - Handle storage operation:\n     a. Apply any required transformations to the value\n     b. Execute the storage operation\n     c. IF storage operation fails THEN\n        i. Generate error message: \"Failed to add item to cache\"\n        ii. Abort operation and rollback any partial changes\n\n   - Update cache metadata:\n     a. Update item count\n     b. Update memory usage metrics if applicable\n     c. Record timestamp of operation if needed\n     d. Log successful cache addition if debug logging is enabled\n\n5. Response Generation:\n   - For successful operation:\n     a. Generate success response indicating item was added to cache\n     b. Include key and fqn (if used) in response for reference\n     c. Include cache statistics in response if requested\n\n   - For failed operation:\n     a. Generate detailed error response\n     b. Include specific error code and message\n     c. Provide troubleshooting information if available",
    "databaseEntities": [],
    "validationRules": [
      "Cache key must not be empty",
      "Cache value must not be null",
      "Cache value must be serializable",
      "Cache system must be initialized before adding items",
      "Cache must have available capacity or apply eviction policy"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "CacheValue": {
        "type": "object",
        "description": "Any serializable object that needs to be stored in the cache",
        "properties": {
          "content": {
            "type": "object",
            "description": "The actual content to be cached"
          }
        }
      },
      "CacheKey": {
        "type": "string",
        "description": "Unique identifier used to retrieve the cached item"
      },
      "FullyQualifiedName": {
        "type": "string",
        "description": "Namespace identifier for organizing cache items in hierarchical structure"
      }
    }
  },
  {
    "featureName": "AddCacheItemWithFqn",
    "description": "Adds a new object to the cache with a fully qualified name and key.",
    "inputValues": [
      "fqn-string-CacheNode",
      "key-string-CacheKey",
      "value-object-CacheValue"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the following inputs:\n     1.1. fqn (string, mandatory): The fully qualified name representing the cache node location\n     1.2. key (string, mandatory): The unique identifier for the cached item\n     1.3. value (object, mandatory): The actual data to be stored in the cache\n\n2. Data Validation:\n   - Validate all input parameters:\n     2.1. Validate fqn:\n         - IF fqn is null THEN generate validation error \"Fully qualified name cannot be null\"\n         - IF fqn is empty THEN use default dummy FQN value\n     2.2. Validate key:\n         - IF key is null THEN generate validation error \"Cache key cannot be null\"\n         - IF key is empty THEN generate validation error \"Cache key cannot be empty\"\n     2.3. Validate value:\n         - IF value is null THEN generate validation error \"Cache value cannot be null\"\n\n3. Business Rule Processing:\n   - Check cache system state:\n     3.1. IF cache system is not initialized THEN:\n         - Generate error \"Cache system not initialized\"\n         - Abort operation\n     3.2. IF cache system is in stopping state THEN:\n         - Generate warning \"Cache system is shutting down, item may not persist\"\n     3.3. Check if cache has capacity:\n         - IF cache is at maximum capacity THEN:\n           - Apply eviction policy to make room for new item\n           - Log eviction event\n\n4. Core Operation Execution:\n   - Add the item to cache:\n     4.1. Determine the appropriate cache node based on fqn\n         - IF node does not exist THEN create new node\n     4.2. Associate the key with the value in the specified node\n         - IF key already exists in the node THEN:\n           - Replace existing value with new value\n           - Log update event\n         - ELSE:\n           - Add new key-value pair to the node\n           - Log addition event\n     4.3. Apply any cache-specific metadata:\n         - Set timestamp for cache entry\n         - Set expiration policy if applicable\n         - Update cache statistics\n\n5. Response Generation:\n   - Generate appropriate response:\n     5.1. IF operation successful THEN:\n         - Return success indicator\n         - Include cache entry information (node, key, timestamp)\n     5.2. IF operation failed THEN:\n         - Return failure indicator\n         - Include error details and reason for failure\n         - Provide suggestion for resolution if applicable",
    "databaseEntities": [],
    "validationRules": [
      "Fully qualified name (fqn) must not be null",
      "Cache key must not be null or empty",
      "Cache value must not be null",
      "Cache system must be initialized before adding items"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "CacheValue": {
        "type": "object",
        "properties": {
          "data": {
            "type": "object",
            "description": "The actual data being cached"
          },
          "metadata": {
            "type": "object",
            "description": "Optional metadata about the cached item",
            "properties": {
              "createdAt": {
                "type": "string",
                "format": "date-time",
                "description": "When the item was added to cache"
              },
              "expiresAt": {
                "type": "string",
                "format": "date-time",
                "description": "When the item should expire from cache"
              }
            }
          }
        },
        "required": [
          "data"
        ]
      }
    }
  },
  {
    "featureName": "GetCacheItem",
    "description": "Retrieves an object from the cache using fully qualified name and key.",
    "inputValues": [
      "fqn-string-CacheIdentifier",
      "key-string-CacheKey"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the fully qualified name (fqn) as a string (mandatory)\n   - Collect the key as a string (mandatory)\n   - System will use these parameters to locate the cached item\n\n2. Data Validation:\n   - Validate the fully qualified name (fqn):\n     * Check if fqn is not null\n     * Check if fqn is a valid string format\n     * If validation fails, prepare appropriate error message\n   - Validate the key:\n     * Check if key is not null\n     * Check if key is a valid string format\n     * If validation fails, prepare appropriate error message\n\n3. Business Rule Processing:\n   - Check if the cache system is initialized:\n     * IF cache system is not initialized THEN\n       > Generate error indicating cache system is unavailable\n       > Return error response\n     * END IF\n   - Verify cache access permissions:\n     * IF current context does not have permission to access the cache THEN\n       > Generate unauthorized access error\n       > Return error response\n     * END IF\n\n4. Core Operation Execution:\n   - Locate the cache node using the provided fully qualified name (fqn):\n     * IF cache node does not exist THEN\n       > Create a new cache node with the given fqn\n       > Return null as no item exists yet\n     * END IF\n   - Retrieve the object associated with the key from the cache node:\n     * IF key does not exist in the cache node THEN\n       > Record cache miss event\n       > Return null or empty result\n     * ELSE\n       > Record cache hit event\n       > Retrieve the cached object\n     * END IF\n   - Check object validity:\n     * IF object has expired THEN\n       > Remove expired object from cache\n       > Record cache expiration event\n       > Return null or empty result\n     * END IF\n\n5. Response Generation:\n   - IF retrieval operation was successful THEN\n     * Return the cached object to the caller\n   - ELSE\n     * Return null or appropriate empty result\n     * Include information about why the cache retrieval failed\n   - END IF\n   - Log the cache access attempt at appropriate debug level",
    "databaseEntities": [],
    "validationRules": [
      "Fully qualified name (fqn) must not be null",
      "Key must not be null",
      "Cache system must be initialized before retrieval",
      "User must have permission to access the requested cache item"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "CacheMap": {
        "type": "object",
        "properties": {
          "key": {
            "type": "string",
            "description": "The identifier for the cached item"
          },
          "value": {
            "type": "object",
            "description": "The cached object value"
          }
        }
      },
      "CacheElement": {
        "type": "object",
        "properties": {
          "key": {
            "type": "string",
            "description": "The cache key"
          },
          "value": {
            "type": "object",
            "description": "The cached object value"
          },
          "timeToLive": {
            "type": "number",
            "description": "Time in seconds the item remains valid in cache"
          }
        }
      }
    }
  },
  {
    "featureName": "GetCacheNode",
    "description": "Retrieves an entire cache node using fully qualified name.",
    "inputValues": [
      "fqn-string-CacheNode"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the fully qualified name (fqn) of the cache node to retrieve\n   - The fqn is a mandatory string parameter\n   - No default value is provided for fqn\n\n2. Data Validation:\n   - Validate the fqn parameter:\n     a. Check if fqn is not null\n     b. Check if fqn is not an empty string\n     c. IF validation fails, prepare appropriate error message\n\n3. Business Rule Processing:\n   - Check if the cache system is initialized:\n     a. IF cache system is not initialized, prepare system not ready error\n     b. IF cache system is initialized, continue processing\n   - Check if the requested cache node exists:\n     a. IF cache node does not exist, prepare node not found notification\n     b. IF cache node exists, continue processing\n\n4. Core Operation Execution:\n   - Locate the cache node using the provided fully qualified name\n   - Retrieve the entire node structure with all its contained elements\n   - IF retrieval operation fails:\n     a. Log the failure reason\n     b. Prepare operation failed notification\n   - IF retrieval operation succeeds:\n     a. Prepare the node data for return\n\n5. Response Generation:\n   - IF any errors occurred during processing:\n     a. Return error information with appropriate message\n     b. Include any relevant troubleshooting information\n   - IF operation was successful:\n     a. Return the complete cache node data\n     b. Include metadata about the node (if available)",
    "databaseEntities": [],
    "validationRules": [
      "Fully qualified name (fqn) must not be null",
      "Fully qualified name (fqn) must not be empty",
      "Cache system must be initialized before retrieving nodes",
      "Requested cache node must exist in the cache system"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "CacheNode": {
        "type": "object",
        "properties": {
          "fqn": {
            "type": "string",
            "description": "Fully qualified name of the cache node"
          },
          "contents": {
            "type": "object",
            "description": "The contents of the cache node"
          }
        }
      }
    }
  },
  {
    "featureName": "GetCacheValues",
    "description": "Retrieves all values from a specific cache node.",
    "inputValues": [
      "fqn-string-CacheNode"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the fully qualified name (fqn) of the cache node as a string\n   - The fqn is mandatory and represents the cache node path to retrieve values from\n\n2. Data Validation:\n   - Validate the fqn parameter:\n     a. Check if fqn is not null\n     b. Check if fqn is not an empty string\n     c. IF validation fails, prepare appropriate error message\n\n3. Business Rule Processing:\n   - Check if the cache system is initialized:\n     a. IF cache system is not initialized, prepare system not ready error\n     b. Check if the requested cache node exists:\n        i. IF node does not exist, prepare node not found error\n\n4. Core Operation Execution:\n   - Access the cache storage system\n   - Locate the specified cache node using the provided fqn\n   - Retrieve all key-value pairs stored within the specified node\n   - Extract all values from the key-value pairs\n   - Compile all values into a collection\n   - IF the specified node doesn't exist or contains no data:\n     a. Return an empty collection\n   - IF any retrieval errors occur:\n     a. Log the error details\n     b. Prepare operation failed error\n\n5. Response Generation:\n   - IF operation was successful:\n     a. Return the collection of all values from the specified cache node\n     b. Include metadata about the cache node if available (e.g., creation time, size)\n   - IF operation failed:\n     a. Return appropriate error information\n     b. Include suggestions for troubleshooting",
    "databaseEntities": [],
    "validationRules": [
      "The fully qualified name (fqn) must not be null",
      "The fully qualified name (fqn) must not be an empty string",
      "The cache system must be initialized before retrieving values",
      "The specified cache node must exist"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "CacheNode": {
        "type": "object",
        "properties": {
          "fqn": {
            "type": "string",
            "description": "Fully qualified name that identifies the cache node"
          },
          "values": {
            "type": "array",
            "description": "Collection of values stored in the cache node"
          }
        }
      }
    }
  },
  {
    "featureName": "RemoveCacheItem",
    "description": "Removes a specific item from the cache using fully qualified name and key.",
    "inputValues": [
      "fullyQualifiedName-string-CacheIdentifier",
      "key-string-CacheKey"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect fullyQualifiedName (string, mandatory): The fully qualified name that identifies the cache location\n   - Collect key (string, mandatory): The unique identifier for the item within the cache\n\n2. Data Validation:\n   - Validate fullyQualifiedName:\n     a. Check if fullyQualifiedName is not null\n     b. IF fullyQualifiedName is null, THEN generate validation error: \"Fully qualified name cannot be null\"\n   - Validate key:\n     a. Check if key is not null\n     b. IF key is null, THEN generate validation error: \"Cache key cannot be null\"\n\n3. Business Rule Processing:\n   - Check cache system availability:\n     a. Verify the cache system is initialized and operational\n     b. IF cache system is not available, THEN generate error: \"Cache system is not available\"\n   - Check cache entry existence:\n     a. Verify the specified cache entry exists at the given fullyQualifiedName\n     b. IF entry does not exist, THEN generate notification: \"Cache entry not found\"\n     c. IF entry exists but doesn't contain the specified key, THEN generate notification: \"Cache item not found\"\n\n4. Core Operation Execution:\n   - Locate the cache entry:\n     a. Access the cache storage using the fullyQualifiedName parameter\n     b. Retrieve the map associated with the fullyQualifiedName\n     c. IF map is found, THEN proceed to remove the item\n     d. IF map is not found, THEN skip removal operation\n   - Remove the cache item:\n     a. Remove the item with the specified key from the map\n     b. Release any resources associated with the cache item\n     c. Update cache statistics if applicable\n   - Handle removal exceptions:\n     a. IF any errors occur during removal, THEN log the error details\n     b. Ensure partial removals don't leave the cache in an inconsistent state\n\n5. Response Generation:\n   - Generate success response:\n     a. Indicate successful removal of the cache item\n     b. Include the fullyQualifiedName and key in the response for confirmation\n   - Generate error response (if applicable):\n     a. Include specific error details and reason for failure\n     b. Provide guidance on how to resolve the issue",
    "databaseEntities": [],
    "validationRules": [
      "Fully qualified name must not be null",
      "Cache key must not be null",
      "Cache system must be initialized before removing items"
    ],
    "dbSeedingOperations": [],
    "schema": {}
  },
  {
    "featureName": "RemoveCacheNode",
    "description": "Removes an entire node from the cache using fully qualified name.",
    "inputValues": [
      "fqn-string-CacheNode"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the fully qualified name (fqn) of the cache node to be removed\n     1.1. The fqn is a mandatory string parameter\n     1.2. No default value is provided\n\n2. Data Validation:\n   - Validate the provided fully qualified name (fqn)\n     2.1. Check if the fqn is not null\n        IF fqn is null THEN\n           Return error: \"Cache node fully qualified name cannot be null\"\n     2.2. Check if the fqn is not an empty string\n        IF fqn is empty THEN\n           Return error: \"Cache node fully qualified name cannot be empty\"\n\n3. Business Rule Processing:\n   - Verify cache system state\n     3.1. Check if the cache system is initialized\n        IF cache system is not initialized THEN\n           Return error: \"Cache system is not initialized\"\n     3.2. Check if the node exists in the cache\n        IF node does not exist in cache THEN\n           Return warning: \"Cache node does not exist\"\n\n4. Core Operation Execution:\n   - Remove the cache node\n     4.1. Locate the node in the cache structure using the provided fqn\n     4.2. Remove the entire node and all its contents from the cache\n     4.3. Release any resources associated with the node\n     4.4. IF removal operation fails THEN\n           Log the failure details\n           Return error: \"Failed to remove cache node\"\n\n5. Response Generation:\n   - Generate appropriate response\n     5.1. IF node removal is successful THEN\n           Return success: \"Cache node successfully removed\"\n     5.2. IF node removal fails THEN\n           Include specific error details in the response\n     5.3. Include information about the removed node in the success response",
    "databaseEntities": [],
    "validationRules": [
      "Cache node fully qualified name must not be null",
      "Cache node fully qualified name must not be empty",
      "Cache system must be initialized before removing nodes"
    ],
    "dbSeedingOperations": [],
    "schema": {}
  },
  {
    "featureName": "AddNestedCacheItem",
    "description": "Adds a nested item to the cache using a fully qualified name, key and value.",
    "inputValues": [
      "fqn-string-CacheEntry",
      "key-string-CacheKey",
      "value-object-CacheValue"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the fully qualified name (fqn) as a string identifier for the cache group\n   - Collect the key as a string identifier for the specific item within the cache group\n   - Collect the value object to be stored in the cache\n   - All inputs are mandatory with no default values\n\n2. Data Validation:\n   - Validate the fully qualified name (fqn):\n     * Check if fqn is not null\n     * Check if fqn is not an empty string\n     * If validation fails, generate an error message indicating invalid fqn\n   - Validate the key:\n     * Check if key is not null\n     * Check if key is not an empty string\n     * If validation fails, generate an error message indicating invalid key\n   - Validate the value:\n     * Check if value is not null\n     * If validation fails, generate an error message indicating invalid value\n\n3. Business Rule Processing:\n   - Check if the cache system is initialized:\n     * IF cache system is not initialized, THEN initialize the cache system\n   - Check if the specified cache group (fqn) already exists:\n     * IF the cache group does not exist, THEN create a new empty map for this group\n     * IF the cache group exists, THEN retrieve the existing map\n\n4. Core Operation Execution:\n   - Add the key-value pair to the map associated with the fqn:\n     * Put the key and value into the map\n   - Update the main cache with the modified or new map:\n     * Associate the map with the fqn in the main cache\n   - IF any operation fails during execution:\n     * Log the failure details\n     * Preserve the previous cache state\n     * Prepare appropriate error information\n\n5. Response Generation:\n   - For successful operation:\n     * Confirm the item was added to the cache\n     * Return success status\n   - For failed operation:\n     * Return error status with details about the failure\n     * Include information about which validation or processing step failed",
    "databaseEntities": [],
    "validationRules": [
      "Fully qualified name (fqn) must not be null or empty",
      "Key must not be null or empty",
      "Value must not be null",
      "Cache system must be initialized before adding items"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "CacheValue": {
        "type": "object",
        "description": "Any object that needs to be stored in the cache",
        "properties": {}
      }
    }
  },
  {
    "featureName": "GetNestedCacheItem",
    "description": "Retrieves a nested item from the cache using a fully qualified name and key.",
    "inputValues": [
      "fqn-string-CacheIdentifier",
      "key-string-ItemKey"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect fully qualified name (fqn) as string (mandatory)\n   - Collect item key as string (mandatory)\n   - System will use the internal cache storage for retrieval\n\n2. Data Validation:\n   - Validate fully qualified name (fqn):\n     * Check if fqn is not null\n     * Check if fqn is not empty\n     * IF validation fails, THEN prepare appropriate error message\n   - Validate item key:\n     * Check if key is not null\n     * Check if key is not empty\n     * IF validation fails, THEN prepare appropriate error message\n\n3. Business Rule Processing:\n   - Check cache system availability:\n     * Verify that the cache system is initialized\n     * IF cache system is not available, THEN prepare system unavailable error\n   - Check access permissions:\n     * Verify the requester has permission to access the requested cache namespace\n     * IF access is not permitted, THEN prepare access denied error\n\n4. Core Operation Execution:\n   - Retrieve the cache container:\n     * Look up the container map using the provided fully qualified name (fqn)\n     * IF container does not exist, THEN return null\n   - Retrieve the requested item:\n     * From the container map, look up the value using the provided key\n     * IF key does not exist in the container, THEN return null\n     * IF key exists, THEN retrieve the associated value\n\n5. Response Generation:\n   - Success response:\n     * Return the retrieved object if found\n     * Include metadata about the retrieved object if available\n   - Error response:\n     * Return null if the container or key was not found\n     * Include appropriate error message if validation failed\n     * Include diagnostic information for troubleshooting",
    "databaseEntities": [],
    "validationRules": [
      "Fully qualified name must not be null or empty",
      "Item key must not be null or empty",
      "Cache system must be initialized before retrieval",
      "Requester must have permission to access the requested cache namespace"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "CacheIdentifier": {
        "type": "string",
        "description": "A unique identifier representing a namespace in the cache"
      },
      "ItemKey": {
        "type": "string",
        "description": "A unique key within the namespace to identify the cached item"
      }
    }
  },
  {
    "featureName": "RemoveNestedCacheItem",
    "description": "Removes a nested item from the cache using a fully qualified name and key.",
    "inputValues": [
      "fqn-string-CacheIdentifier",
      "key-string-ItemKey"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect fully qualified name (fqn) as string (mandatory)\n   - Collect key as string (mandatory)\n   - System will use these to locate and remove the specific cached item\n\n2. Data Validation:\n   - Validate fully qualified name (fqn):\n     * Check if fqn is not null\n     * Check if fqn is not an empty string\n     * IF validation fails, THEN generate appropriate error message\n   - Validate key:\n     * Check if key is not null\n     * Check if key is not an empty string\n     * IF validation fails, THEN generate appropriate error message\n\n3. Business Rule Processing:\n   - Check if cache system is initialized:\n     * Verify that the cache storage mechanism is ready\n     * IF cache is not initialized, THEN report system error\n   - Check if the specified fqn exists in cache:\n     * Look up the fqn in the cache storage\n     * IF fqn does not exist, THEN no action is needed (silent operation)\n\n4. Core Operation Execution:\n   - Retrieve the nested map associated with the fqn:\n     * Access the cache storage using the fqn as identifier\n     * Obtain the map of key-value pairs stored under this fqn\n     * IF map exists:\n       > Remove the entry with the specified key from the map\n       > No changes to other entries in the map\n     * IF map does not exist:\n       > No action required\n       > Operation completes successfully (silent operation)\n\n5. Response Generation:\n   - For successful operation:\n     * No specific success response needed as this is typically a silent operation\n     * Cache state is updated with item removed\n   - For error conditions:\n     * Return appropriate error message based on validation failures\n     * Include details about which parameter failed validation",
    "databaseEntities": [],
    "validationRules": [
      "Fully qualified name (fqn) must not be null or empty",
      "Key must not be null or empty",
      "Cache system must be initialized before removal operations"
    ],
    "dbSeedingOperations": [],
    "schema": {}
  },
  {
    "featureName": "AddNamespacedCacheItem",
    "description": "Adds an object to a specific namespace in the cache with a key.",
    "inputValues": [
      "namespace-string-CacheNamespace",
      "key-string-CacheKey",
      "value-object-CacheValue"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the following inputs:\n     a. namespace (string, mandatory): The cache namespace identifier\n     b. key (string, mandatory): The unique identifier for the cached item\n     c. value (object, mandatory): The object to be stored in cache\n\n2. Data Validation:\n   - Validate namespace:\n     a. IF namespace is null or empty THEN\n        i. Generate error: \"Namespace cannot be empty\"\n     b. ELSE proceed to next validation\n   - Validate key:\n     a. IF key is null or empty THEN\n        i. Generate error: \"Key cannot be empty\"\n     b. ELSE proceed to next validation\n   - Validate value:\n     a. IF value is null THEN\n        i. Generate error: \"Cache value cannot be null\"\n     b. ELSE IF value is not serializable THEN\n        i. Generate error: \"Cache value must be serializable\"\n     c. ELSE proceed to next step\n\n3. Business Rule Processing:\n   - Check cache system availability:\n     a. IF cache system is not initialized THEN\n        i. Generate error: \"Cache system is not initialized\"\n     b. ELSE proceed to next check\n   - Check namespace existence:\n     a. IF namespace does not exist THEN\n        i. Create new namespace in cache system\n        ii. Log namespace creation event\n     b. ELSE use existing namespace\n   - Check for existing item with same key:\n     a. IF item with same key exists in namespace THEN\n        i. Log overwrite warning\n     b. ELSE proceed with normal addition\n\n4. Core Operation Execution:\n   - Prepare cache entry:\n     a. Create cache element with provided key and value\n     b. Set any default metadata (expiration, priority) if applicable\n   - Add to cache:\n     a. Store the element in the specified namespace\n     b. Log successful cache addition\n     c. IF addition fails THEN\n        i. Log error details\n        ii. Generate error: \"Failed to add item to cache\"\n\n5. Response Generation:\n   - On success:\n     a. Return confirmation that item was added to cache\n     b. Include namespace and key in confirmation\n   - On failure:\n     a. Return appropriate error message from validation or execution steps\n     b. Include error details for troubleshooting",
    "databaseEntities": [],
    "validationRules": [
      "Namespace must not be empty",
      "Key must not be empty",
      "Value must not be null",
      "Value must be serializable"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "CacheValue": {
        "type": "object",
        "description": "Any serializable object that can be stored in cache",
        "properties": {
          "content": {
            "type": "object",
            "description": "The actual content to be cached"
          }
        }
      }
    }
  },
  {
    "featureName": "GetCacheNamespace",
    "description": "Retrieves an entire cache namespace with all its stored values.",
    "inputValues": [
      "namespaceName-string-CacheNamespace"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the namespace name (namespaceName) as a string\n   - This input is mandatory and represents the fully qualified name of the cache namespace to retrieve\n\n2. Data Validation:\n   - Validate the namespace name:\n     * Check if the namespace name is not null or empty\n     * Verify the namespace name follows the expected format\n     * IF namespace name is invalid THEN prepare appropriate error message\n\n3. Business Rule Processing:\n   - Check system state:\n     * Verify the cache system is properly initialized\n     * Confirm the cache manager is running and available\n     * IF cache system is not available THEN prepare system unavailable error\n\n4. Core Operation Execution:\n   - Check if the requested namespace exists in the cache system\n     * IF namespace does not exist:\n       - Return an empty collection as the result\n     * IF namespace exists:\n       - Retrieve the cache namespace object\n       - Extract all values from the namespace\n       - Collect all values into a result collection\n     * IF any errors occur during retrieval:\n       - Log the error details\n       - Prepare appropriate error message with exception information\n       - Handle the exception gracefully\n\n5. Response Generation:\n   - For successful retrieval:\n     * Return the collection of all values from the namespace\n     * Ensure the collection is properly initialized (empty collection if no values exist)\n   - For failed retrieval:\n     * Return appropriate error information\n     * Include guidance on possible resolution steps\n     * Provide details about the nature of the failure",
    "databaseEntities": [],
    "validationRules": [
      "Namespace name must not be null or empty",
      "Cache system must be properly initialized before retrieval",
      "Cache manager must be running and available"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "CacheNamespace": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "description": "The fully qualified name of the cache namespace"
          },
          "values": {
            "type": "array",
            "description": "Collection of cached values in this namespace",
            "items": {
              "type": "object"
            }
          }
        }
      }
    }
  },
  {
    "featureName": "GetNamespaceValues",
    "description": "Retrieves all values stored in a specific cache namespace.",
    "inputValues": [
      "namespace-string-CacheNamespace"
    ],
    "businessLogic": "1. Input Collection\n   - Collect the namespace identifier (namespace-string-CacheNamespace)\n     - This is a mandatory field representing the cache namespace to query\n     - No default value is provided\n     - The namespace serves as a fully qualified name (FQN) for the cache structure\n\n2. Data Validation\n   - Validate namespace input\n     - Check if namespace is not null or empty\n     - IF namespace is null or empty THEN\n       - Generate appropriate error message indicating namespace is required\n       - Terminate process and return error\n     - Verify namespace format follows system conventions\n       - Ensure namespace has valid structure for hierarchical caching\n       - IF namespace format is invalid THEN\n         - Generate format error message\n         - Terminate process and return error\n\n3. Business Rule Processing\n   - Verify cache system availability\n     - Check if the cache system is initialized and operational\n     - IF cache system is not available THEN\n       - Generate system unavailable error message\n       - Terminate process and return error\n   - Verify namespace existence\n     - Check if the requested namespace exists in the cache system\n     - IF namespace does not exist THEN\n       - Create an empty collection container\n       - Return empty collection as result\n   - Handle access permissions\n     - Verify current context has permission to access the namespace\n     - IF access is not permitted THEN\n       - Generate access denied error message\n       - Log access attempt\n       - Terminate process and return error\n\n4. Core Operation Execution\n   - Retrieve the namespace node from the cache system\n     - Access the cache storage using the provided namespace identifier\n     - IF node retrieval fails THEN\n       - Log retrieval error\n       - Return empty collection\n   - Extract all values from the namespace node\n     - Access the node's data container\n     - Collect all values (not keys) from the data container\n     - Create a collection to hold the retrieved values\n     - For each entry in the node's data:\n       - Extract the value portion\n       - Add the value to the result collection\n   - Handle any retrieval exceptions\n     - IF exception occurs during value extraction THEN\n       - Log the error details with exception information\n       - Generate appropriate error message\n       - Terminate process and return error\n\n5. Response Generation\n   - Prepare the response with retrieved values\n     - Format the collection of values for return\n     - Include metadata about the retrieval operation:\n       - Number of items retrieved\n       - Namespace identifier\n     - Return the formatted collection of values\n   - IF no values were found THEN\n     - Return empty collection with appropriate metadata\n   - Log successful retrieval operation\n     - Record namespace accessed\n     - Record number of values retrieved",
    "databaseEntities": [],
    "validationRules": [
      "Cache namespace identifier must not be null or empty",
      "Cache system must be initialized before retrieving values",
      "Retrieved values must be properly serialized objects",
      "Namespace format must follow system hierarchical structure",
      "Cache node must be accessible for value extraction"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "CacheNamespace": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "description": "The identifier for the cache namespace"
          },
          "values": {
            "type": "array",
            "items": {
              "type": "object",
              "description": "Cached values stored in the namespace"
            }
          }
        }
      }
    }
  },
  {
    "featureName": "RemoveCacheNamespace",
    "description": "Removes an entire namespace from the cache system.",
    "inputValues": [
      "namespace-string-CacheNamespace"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the namespace identifier (namespace-string-CacheNamespace)\n     - This is a mandatory field representing the fully qualified name of the cache namespace to be removed\n     - No default value is provided\n     - The namespace should follow the system's naming convention for cache entries\n\n2. Data Validation:\n   - Validate the namespace identifier\n     - Check if the namespace identifier is not null\n     - Check if the namespace identifier is not an empty string\n     - Verify the namespace follows the expected format for cache namespaces\n     - IF validation fails, THEN prepare appropriate error message indicating invalid namespace identifier\n\n3. Business Rule Processing:\n   - Check if the cache system is initialized\n     - IF cache manager is not initialized, THEN prepare error message indicating cache system is not available\n   - Check if the specified namespace exists in the cache\n     - IF namespace does not exist, THEN prepare notification that no action is needed\n   - Check if the user has sufficient permissions to remove the namespace\n     - IF user lacks permission, THEN prepare error message indicating insufficient privileges\n\n4. Core Operation Execution:\n   - Attempt to remove the specified namespace from the cache\n     - Access the cache manager component\n     - Request removal of the entire namespace and all its contents\n     - Handle any potential exceptions during the removal process\n     - IF removal operation encounters an error, THEN\n       * Log the error details with appropriate severity level\n       * Prepare error message with details about the failure\n       * Abort the operation\n     - ELSE\n       * Record successful removal of the namespace\n       * Update any related cache statistics or monitoring information\n\n5. Response Generation:\n   - IF operation was successful, THEN\n     - Prepare success response indicating the namespace was successfully removed\n     - Include the name of the removed namespace in the response\n     - Include information about the number of cache entries that were removed (if available)\n   - ELSE\n     - Prepare error response with details about what went wrong\n     - Include any relevant error codes or messages\n     - Provide guidance on potential next steps or troubleshooting\n     - Include support information if the error is critical",
    "databaseEntities": [],
    "validationRules": [
      "Namespace identifier must not be null",
      "Namespace identifier must not be an empty string",
      "Cache system must be initialized before removing a namespace",
      "User must have sufficient permissions to remove cache namespaces"
    ],
    "dbSeedingOperations": [],
    "schema": {}
  },
  {
    "featureName": "StopCacheService",
    "description": "Stops the JBoss cache service when no longer needed to free up system resources.",
    "inputValues": [],
    "businessLogic": "1. Input Collection:\n   - No user inputs required for this operation\n   - System-generated input: cache service reference\n\n2. Data Validation:\n   - Verify cache service status\n     a. Check if cache service is currently running\n     b. IF cache service is not running THEN\n        i. Log warning message about attempting to stop an already stopped service\n        ii. Exit process without further action\n     c. ELSE continue with shutdown process\n\n3. Business Rule Processing:\n   - Verify system readiness for cache shutdown\n     a. Check if any pending cache operations are in progress\n     b. IF pending operations exist THEN\n        i. Wait for pending operations to complete\n        ii. Set timeout period for waiting\n        iii. IF timeout exceeded THEN\n           1. Log warning about forced shutdown\n           2. Proceed with shutdown anyway\n     c. Check if cache contains unsaved data\n        i. IF unsaved data exists THEN\n           1. Attempt to persist critical data\n           2. Log any data that cannot be persisted\n\n4. Core Operation Execution:\n   - Execute cache service shutdown\n     a. Notify dependent components about imminent shutdown\n     b. Release all cached resources\n     c. Stop the cache service\n     d. IF shutdown fails THEN\n        i. Log detailed error information\n        ii. Attempt graceful recovery\n        iii. IF recovery fails THEN\n           1. Force shutdown\n           2. Log critical error\n     e. Release system resources associated with cache\n\n5. Response Generation:\n   - Generate shutdown completion status\n     a. IF shutdown successful THEN\n        i. Log successful shutdown message with timestamp\n        ii. Return success status\n     b. ELSE\n        i. Log failure details\n        ii. Return error status with diagnostic information\n        iii. Include recovery suggestions",
    "databaseEntities": [],
    "validationRules": [
      "Cache service must be in running state before attempting to stop it",
      "All pending cache operations must be completed or timed out before shutdown",
      "Critical cached data should be persisted if possible before shutdown",
      "System must release all resources associated with the cache service"
    ],
    "dbSeedingOperations": [],
    "schema": {}
  },
  {
    "featureName": "AddCacheEntry",
    "description": "Adds or updates an entry in the cache with a key and value.",
    "inputValues": [
      "fqn-string-CacheNode",
      "key-string-CacheKey",
      "value-object-CacheValue"
    ],
    "businessLogic": "1. Input Collection\n   - Collect the following inputs:\n     1.1. fqn (Fully Qualified Name): String that represents the cache node path (mandatory)\n     1.2. key: String that serves as the identifier for the cache entry (mandatory)\n     1.3. value: Object to be stored in the cache (mandatory)\n     1.4. System will use default FQN if not provided\n\n2. Data Validation\n   2.1. Validate FQN parameter:\n      - IF fqn is null or empty THEN\n        - Use default FQN value\n      - ELSE\n        - Ensure fqn follows proper format\n   2.2. Validate key parameter:\n      - IF key is null or empty THEN\n        - Generate error message: \"Cache key cannot be null or empty\"\n        - Abort operation\n   2.3. Validate value parameter:\n      - IF value is null THEN\n        - Generate warning: \"Storing null value in cache\"\n        - Continue with operation (null values are allowed)\n\n3. Business Rule Processing\n   3.1. Check cache system status:\n      - IF cache system is not initialized THEN\n        - Generate error: \"Cache system not initialized\"\n        - Abort operation\n      - IF cache system is in shutdown mode THEN\n        - Generate error: \"Cache system is shutting down\"\n        - Abort operation\n   3.2. Check node existence:\n      - IF specified FQN node doesn't exist THEN\n        - System will create the node automatically\n   3.3. Check memory constraints:\n      - IF adding this entry would exceed memory limits THEN\n        - Apply configured eviction policy\n        - Log warning about approaching cache capacity\n\n4. Core Operation Execution\n   4.1. Prepare cache entry:\n      - Format FQN path to ensure proper structure\n      - Prepare key-value pair for storage\n   4.2. Store in cache:\n      - Attempt to store the key-value pair at the specified FQN\n      - IF operation fails due to technical reasons THEN\n        - Log detailed error information\n        - Generate exception with descriptive message\n        - Abort operation\n   4.3. Update cache statistics:\n      - Increment cache entry count\n      - Update memory usage statistics\n      - Record last modified timestamp\n\n5. Response Generation\n   5.1. For successful operation:\n      - Return success indicator\n      - Include reference to the cached item\n   5.2. For failed operation:\n      - Return failure indicator\n      - Include detailed error information\n      - Provide suggestions for resolving the issue",
    "databaseEntities": [],
    "validationRules": [
      "Cache key must not be null or empty",
      "Cache system must be initialized before adding entries",
      "Cache system must not be in shutdown mode",
      "FQN must follow proper format if provided"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "CacheValue": {
        "type": "object",
        "description": "Any serializable object that can be stored in the cache",
        "properties": {}
      }
    }
  },
  {
    "featureName": "AddNamespacedCacheEntry",
    "description": "Adds an entry to the cache with a specific namespace (FQN) and key.",
    "inputValues": [
      "namespace-string-CacheNamespace",
      "key-string-CacheKey",
      "value-object-CacheValue"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the following inputs:\n     1.1. namespace (string, mandatory): The fully qualified namespace for the cache entry\n     1.2. key (string, mandatory): The unique identifier for the cache entry within the namespace\n     1.3. value (object, mandatory): The data to be stored in the cache\n\n2. Data Validation:\n   2.1. Validate namespace:\n     2.1.1. Check if namespace is not null or empty\n     2.1.2. Verify namespace format follows proper FQN structure\n     2.1.3. IF namespace is invalid THEN generate appropriate error message\n   2.2. Validate key:\n     2.2.1. Check if key is not null or empty\n     2.2.2. Verify key does not contain invalid characters\n     2.2.3. IF key is invalid THEN generate appropriate error message\n   2.3. Validate value:\n     2.3.1. Check if value is not null\n     2.3.2. Verify value is serializable or cacheable\n     2.3.3. IF value is invalid THEN generate appropriate error message\n\n3. Business Rule Processing:\n   3.1. Check cache system availability:\n     3.1.1. Verify cache service is initialized and running\n     3.1.2. IF cache service is not available THEN generate system error\n   3.2. Check namespace accessibility:\n     3.2.1. Verify the namespace is accessible for writing\n     3.2.2. IF namespace is not accessible THEN generate permission error\n   3.3. Check for existing entry:\n     3.3.1. Look for existing entry with same namespace and key\n     3.3.2. IF entry exists THEN prepare to overwrite\n\n4. Core Operation Execution:\n   4.1. Prepare cache entry:\n     4.1.1. Format namespace into proper structure\n     4.1.2. Prepare key-value pair for storage\n   4.2. Store in cache:\n     4.2.1. Add the entry to the cache using namespace and key\n     4.2.2. IF storage fails THEN attempt retry operation\n     4.2.3. IF retry fails THEN prepare rollback and error message\n   4.3. Verify storage:\n     4.3.1. Confirm entry was properly stored in cache\n     4.3.2. IF verification fails THEN log warning\n\n5. Response Generation:\n   5.1. For successful operation:\n     5.1.1. Generate success confirmation\n     5.1.2. Include namespace and key in confirmation\n   5.2. For failed operation:\n     5.2.1. Generate detailed error message\n     5.2.2. Include specific failure reason\n     5.2.3. Provide troubleshooting information",
    "databaseEntities": [],
    "validationRules": [
      "Namespace must not be null or empty",
      "Key must not be null or empty",
      "Value must not be null",
      "Cache service must be initialized before adding entries",
      "Namespace must follow proper FQN structure"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "CacheValue": {
        "type": "object",
        "description": "Represents any serializable object that can be stored in the cache",
        "properties": {
          "data": {
            "type": "any",
            "description": "The actual data to be stored"
          }
        }
      },
      "CacheNamespace": {
        "type": "string",
        "description": "Fully Qualified Name representing the namespace hierarchy"
      },
      "CacheKey": {
        "type": "string",
        "description": "Unique identifier for the cache entry within its namespace"
      }
    }
  },
  {
    "featureName": "GetCacheEntry",
    "description": "Retrieves a cached entry by its key.",
    "inputValues": [
      "key-string-CacheKey",
      "fqn-string-FullyQualifiedName"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the cache key (string, mandatory)\n   - Collect the fully qualified name (FQN) (string, optional)\n     - If not provided, use a default namespace\n\n2. Data Validation:\n   - Validate cache key:\n     - Check if key is not null or empty\n     - Verify key format is valid according to system requirements\n     - IF key is invalid THEN prepare error message indicating invalid key format\n   - Validate FQN if provided:\n     - Check if FQN follows the required hierarchical structure\n     - Verify FQN exists in the cache system\n     - IF FQN is invalid THEN prepare error message indicating invalid FQN format\n\n3. Business Rule Processing:\n   - Check cache system availability:\n     - Verify cache service is running and accessible\n     - IF cache service is unavailable THEN prepare system unavailable error\n   - Check access permissions:\n     - Verify current user has permission to access the requested cache entry\n     - IF user lacks permission THEN prepare access denied error\n   - Check cache entry existence:\n     - Determine if the requested entry exists in the cache\n     - IF entry does not exist THEN prepare entry not found notification\n\n4. Core Operation Execution:\n   - Retrieve the cache entry:\n     - IF FQN is provided:\n       - Locate the specific namespace in the cache using the FQN\n       - Retrieve the entry using the provided key within that namespace\n     - IF FQN is not provided:\n       - Use the default namespace\n       - Retrieve the entry using the provided key\n   - Handle retrieval exceptions:\n     - IF any errors occur during retrieval THEN:\n       - Log the error details\n       - Prepare appropriate error message\n       - Consider fallback mechanisms if configured\n\n5. Response Generation:\n   - Prepare success response:\n     - IF entry was found:\n       - Format the cached entry according to expected output format\n       - Include metadata about the entry (if available)\n     - IF entry was not found:\n       - Provide clear indication that no matching entry exists\n   - Include additional information:\n     - Entry expiration details if applicable\n     - Cache statistics if requested",
    "databaseEntities": [],
    "validationRules": [
      "Cache key must not be null or empty",
      "Fully qualified name must follow the hierarchical structure if provided",
      "Cache service must be available before attempting retrieval",
      "User must have permission to access the requested cache entry"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "CacheKey": {
        "type": "string",
        "description": "Unique identifier for the cached item"
      },
      "FullyQualifiedName": {
        "type": "string",
        "description": "Hierarchical namespace path for the cached item"
      }
    }
  },
  {
    "featureName": "GetNamespacedCacheEntry",
    "description": "Retrieves a cached entry using namespace (FQN) and key.",
    "inputValues": [
      "namespace-string-CacheNamespace",
      "key-string-CacheKey"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the following inputs:\n     a. namespace (mandatory): Fully Qualified Name (FQN) for the cache entry location\n     b. key (mandatory): Unique identifier for the specific cache entry\n\n2. Data Validation:\n   - Validate namespace input:\n     a. Check if namespace is not null or empty\n     b. IF namespace is null or empty THEN\n        i. Generate validation error message: \"Namespace cannot be empty\"\n        ii. Abort operation and return error\n     c. Verify namespace format follows expected structure\n\n   - Validate key input:\n     a. Check if key is not null or empty\n     b. IF key is null or empty THEN\n        i. Generate validation error message: \"Key cannot be empty\"\n        ii. Abort operation and return error\n\n3. Business Rule Processing:\n   - Check cache system availability:\n     a. Verify cache system is initialized and running\n     b. IF cache system is not available THEN\n        i. Generate system error: \"Cache system unavailable\"\n        ii. Abort operation and return error\n\n   - Check access permissions:\n     a. Verify current user has permission to access the requested cache namespace\n     b. IF user lacks permission THEN\n        i. Generate access error: \"Insufficient permissions to access cache namespace\"\n        ii. Abort operation and return error\n\n4. Core Operation Execution:\n   - Locate the cache namespace:\n     a. Search for the specified namespace in the cache system\n     b. IF namespace not found THEN\n        i. Log warning message about namespace not found\n        ii. Return null or empty result\n\n   - Retrieve the cache entry:\n     a. Within the found namespace, locate the entry with the specified key\n     b. IF key not found in namespace THEN\n        i. Log information message about key not found in namespace\n        ii. Return null or empty result\n     c. IF key found THEN\n        i. Retrieve the associated value\n        ii. Prepare value for return\n\n   - Handle any retrieval exceptions:\n     a. IF exception occurs during retrieval THEN\n        i. Log error with exception details\n        ii. Generate system error: \"Error retrieving cache entry\"\n        iii. Return error response\n\n5. Response Generation:\n   - For successful retrieval:\n     a. Format the retrieved cache entry value\n     b. Include metadata about the cache entry if available (creation time, expiry)\n     c. Return the formatted cache entry\n\n   - For failed retrieval:\n     a. Generate appropriate error response with reason\n     b. Include suggestions for troubleshooting\n     c. Return the error response",
    "databaseEntities": [],
    "validationRules": [
      "Namespace must not be null or empty",
      "Key must not be null or empty",
      "Cache system must be initialized before retrieval",
      "User must have permission to access the requested namespace"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "CacheNamespace": {
        "type": "string",
        "description": "Fully Qualified Name representing the cache namespace"
      },
      "CacheKey": {
        "type": "string",
        "description": "Unique identifier for the cache entry within the namespace"
      }
    }
  },
  {
    "featureName": "RemoveCacheEntry",
    "description": "Removes a specific entry from the cache by namespace and key.",
    "inputValues": [
      "namespace-string-CacheNamespace",
      "key-string-CacheKey"
    ],
    "businessLogic": "1. Input Collection\n   - Collect the following inputs:\n     a. namespace (mandatory): The fully qualified namespace of the cache entry\n     b. key (optional): The specific key within the namespace to remove\n\n2. Data Validation\n   - Validate namespace input:\n     a. Check if namespace is provided\n        IF namespace is null or empty THEN\n          Generate error message: \"Cache namespace cannot be empty\"\n          Return error response\n     b. Check if namespace format is valid\n        IF namespace format is invalid THEN\n          Generate error message: \"Invalid namespace format\"\n          Return error response\n   - Validate key input (if provided):\n     a. Check if key format is valid\n        IF key is provided AND key format is invalid THEN\n          Generate error message: \"Invalid key format\"\n          Return error response\n\n3. Business Rule Processing\n   - Check cache system availability:\n     a. Verify cache service is initialized and running\n        IF cache service is not available THEN\n          Log error: \"Cache service unavailable\"\n          Generate error message: \"Cache system is currently unavailable\"\n          Return error response\n   - Check access permissions:\n     a. Verify current user has permission to modify cache\n        IF user lacks permission THEN\n          Log access attempt: \"Unauthorized cache modification attempt\"\n          Generate error message: \"Insufficient permissions to modify cache\"\n          Return error response\n\n4. Core Operation Execution\n   - Determine removal operation type:\n     a. IF key is provided THEN\n          Attempt to remove specific key from namespace:\n          - Locate the namespace node in cache\n          - Remove the specific key-value pair from the namespace\n          - Log operation: \"Removed key [key] from namespace [namespace]\"\n     b. IF key is not provided THEN\n          Attempt to remove entire namespace:\n          - Remove the entire namespace node from cache\n          - Log operation: \"Removed entire namespace [namespace]\"\n   - Handle operation failures:\n     a. IF removal operation fails THEN\n        - Capture error details\n        - Log error: \"Failed to remove from cache: [error details]\"\n        - Generate error message: \"Cache removal operation failed\"\n        - Return error response\n\n5. Response Generation\n   - Generate success response:\n     a. Create response with operation status\n     b. Include details about what was removed:\n        - If key was provided: \"Successfully removed key [key] from namespace [namespace]\"\n        - If only namespace was provided: \"Successfully removed entire namespace [namespace]\"\n     c. Include timestamp of operation\n   - Return success response to caller",
    "databaseEntities": [],
    "validationRules": [
      "Cache namespace must not be empty",
      "Cache namespace must be in valid format",
      "Cache key must be in valid format if provided",
      "User must have permission to modify cache",
      "Cache service must be available"
    ],
    "dbSeedingOperations": [],
    "schema": {}
  },
  {
    "featureName": "HandleNodeModification",
    "description": "Processes cache node modification events with conditional handling for notification nodes.",
    "inputValues": [
      "fqn-object-NodeIdentifier"
    ],
    "businessLogic": "1. Input Collection:\n   - Receive modified node identifier (fqn) from the cache system\n   - Extract node path information from the identifier\n   - Determine if the node is a notification node\n\n2. Data Validation:\n   - Validate that the node identifier is not null\n   - Verify that the node path contains at least one element\n   - Check that the first element in the path can be cast to String\n   - Ensure the node path is properly formatted\n   - Generate appropriate error messages if validation fails\n\n3. Business Rule Processing:\n   - IF node identifier is valid THEN:\n     3.1. Extract the first element from the node path\n     3.2. Check if the extracted element is a String\n     3.3. Compare the extracted element with the notification prefix\n     3.4. Determine if the node is a notification node based on the comparison\n   - ELSE:\n     3.5. Skip processing as the node is invalid\n\n4. Core Operation Execution:\n   - IF the node is a notification node THEN:\n     4.1. Prepare for notification processing\n     4.2. Extract any relevant notification data from the node\n     4.3. Determine notification type and priority\n     4.4. Process the notification according to its type\n     4.5. Update any related cache entries if necessary\n   - ELSE:\n     4.6. Skip notification processing as this is a regular node modification\n\n5. Response Generation:\n   - No explicit response is generated as this is an event handler\n   - Log completion of node modification handling if needed\n   - Ensure system state is consistent after processing",
    "databaseEntities": [],
    "validationRules": [
      "Node identifier must not be null",
      "Node path must contain at least one element",
      "First element in node path must be castable to String",
      "Notification nodes must start with the defined notification prefix"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "NodeIdentifier": {
        "type": "object",
        "properties": {
          "path": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "The hierarchical path elements of the node"
          }
        },
        "required": [
          "path"
        ]
      }
    }
  },
  {
    "featureName": "EncodeURL",
    "description": "Encodes URLs with context path and extension, handling special cases for bots.",
    "inputValues": [
      "url-string-URL",
      "extension-string-Extension",
      "contextPath-string-ContextPath",
      "isEncodingDisabled-boolean-EncodingFlag",
      "isBot-boolean-BotFlag",
      "redirectAbsolutePaths-boolean-RedirectFlag",
      "redirectBaseUrl-string-BaseURL"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the following inputs:\n     a. url (string, mandatory): The base URL to be encoded\n     b. extension (string, optional): The file extension to append to the URL\n     c. contextPath (string, mandatory): The application context path\n     d. isEncodingDisabled (boolean, optional): Flag indicating if URL encoding should be skipped\n     e. isBot (boolean, optional): Flag indicating if the request is from a bot\n     f. redirectAbsolutePaths (boolean, optional): Flag indicating if redirects should use absolute paths\n     g. redirectBaseUrl (string, optional): Base URL to prepend when creating absolute paths\n\n2. Data Validation:\n   - Validate URL input:\n     a. Check if URL is not null\n     b. Verify URL format is valid\n     c. IF URL is invalid THEN generate error message indicating invalid URL format\n   - Validate extension input:\n     a. IF extension is provided THEN verify it starts with a period or add one if missing\n     b. IF extension is not provided THEN use default extension from system configuration\n   - Validate contextPath:\n     a. Check if contextPath is not null\n     b. Verify contextPath format is valid (starts with '/' if not empty)\n     c. IF contextPath is invalid THEN generate error message\n   - Validate redirectBaseUrl (when redirectAbsolutePaths is TRUE):\n     a. Check if redirectBaseUrl is not null\n     b. Verify redirectBaseUrl is a valid URL format\n     c. IF redirectBaseUrl is invalid THEN generate error message\n\n3. Business Rule Processing:\n   - Determine encoding behavior:\n     a. IF isBot is TRUE THEN set isEncodingDisabled to TRUE\n     b. Check system configuration for global encoding settings\n     c. Verify if the current session supports URL encoding\n     d. IF session does not support encoding THEN set isEncodingDisabled to TRUE\n   - Determine if URL should be absolute:\n     a. IF redirectAbsolutePaths is TRUE THEN\n        i. Check if the URL is already absolute using URI.create(url).isAbsolute()\n        ii. IF URL is not absolute THEN prepare to prepend redirectBaseUrl\n\n4. Core Operation Execution:\n   - Construct the complete URL:\n     a. Combine contextPath with the provided URL\n     b. Append the appropriate extension to the URL\n     c. Create the complete unencoded URL (contextPath + url + extension)\n   - Apply URL encoding based on conditions:\n     a. IF isEncodingDisabled is TRUE THEN\n        i. Return the complete unencoded URL\n     b. ELSE\n        i. Pass the complete URL to the response encoder\n        ii. Retrieve the encoded URL from the response\n        iii. Return the encoded URL\n   - Handle absolute path requirements:\n     a. IF redirectAbsolutePaths is TRUE AND URL is not absolute THEN\n        i. Prepend redirectBaseUrl to the encoded/unencoded URL\n        ii. Ensure proper URL formatting when combining base URL and path\n\n5. Response Generation:\n   - Return the final URL:\n     a. IF encoding was successful THEN return properly encoded URL with context path and extension\n     b. IF encoding was disabled THEN return unencoded URL with context path and extension\n     c. IF absolute path was required THEN return URL with base URL prepended\n     d. IF any errors occurred during the process THEN return error information",
    "databaseEntities": [],
    "validationRules": [
      "URL must not be null",
      "Context path must be properly formatted",
      "Bot requests should have encoding disabled",
      "Extension must be properly formatted if provided",
      "When using absolute paths, redirectBaseUrl must be valid",
      "URI must be properly checked for absolute status before prepending base URL"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "URL": {
        "type": "string",
        "description": "The base URL to be encoded"
      },
      "Extension": {
        "type": "string",
        "description": "The file extension to append to the URL"
      },
      "ContextPath": {
        "type": "string",
        "description": "The application context path"
      },
      "EncodingFlag": {
        "type": "boolean",
        "description": "Flag indicating if URL encoding should be skipped"
      },
      "BotFlag": {
        "type": "boolean",
        "description": "Flag indicating if the request is from a bot"
      },
      "RedirectFlag": {
        "type": "boolean",
        "description": "Flag indicating if redirects should use absolute paths"
      },
      "BaseURL": {
        "type": "string",
        "description": "Base URL to prepend when creating absolute paths"
      }
    }
  },
  {
    "featureName": "DetectBotRequests",
    "description": "Identifies if the current request is from a bot based on request attributes.",
    "inputValues": [
      "request-object-HttpRequest",
      "configKeys-object-ConfigKeys"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the HttpRequest object containing request information\n     - Request URI\n     - User-Agent header\n     - Remote host information\n   - Retrieve system configuration for bot detection\n     - Bot agent patterns list\n     - Bot host patterns list\n\n2. Data Validation:\n   - Validate that the HttpRequest object is not null\n     - IF HttpRequest is null THEN\n       - Return an error indicating invalid request\n     - END IF\n   - Check if the request URI is available\n     - IF request URI is null THEN\n       - Log warning about incomplete request information\n     - END IF\n   - Verify User-Agent header availability\n     - IF User-Agent is null THEN\n       - Note absence for later processing\n     - END IF\n\n3. Business Rule Processing:\n   - Check for robots.txt specific requests\n     - IF request URI contains \"robots.txt\" THEN\n       - Mark as bot with name \"Unknown (asked for robots.txt)\"\n       - Skip further checks\n     - END IF\n   - Apply User-Agent based detection\n     - IF User-Agent is available THEN\n       - Convert User-Agent to lowercase for case-insensitive matching\n       - FOR EACH bot agent pattern in configuration\n         - IF pattern is null THEN\n           - CONTINUE to next pattern\n         - END IF\n         - IF User-Agent contains the pattern THEN\n           - Mark as bot with name from User-Agent\n           - Skip further checks\n         - END IF\n       - END FOR\n     - END IF\n   - Apply hostname-based detection\n     - Retrieve remote host information\n     - IF remote host is available AND has valid format THEN\n       - Convert remote host to lowercase for case-insensitive matching\n       - FOR EACH bot host pattern in configuration\n         - IF pattern is null THEN\n           - CONTINUE to next pattern\n         - END IF\n         - IF remote host contains the pattern THEN\n           - Mark as bot with name from remote host\n           - Skip further checks\n         - END IF\n       - END FOR\n     - END IF\n\n4. Core Operation Execution:\n   - Determine final bot detection result\n     - IF any detection rule identified a bot THEN\n       - Set bot detection result to true with identified bot name\n     - ELSE\n       - Set bot detection result to false (not a bot)\n     - END IF\n   - Store the bot detection result\n     - Save bot status in request attributes for other components\n     - Record bot identification for analytics if enabled\n   - Apply system behavior adjustments for bots\n     - Modify session tracking behavior if request is from bot\n     - Adjust caching policies based on bot status\n\n5. Response Generation:\n   - Return the bot detection result\n     - IF bot was detected THEN\n       - Return the identified bot name\n     - ELSE\n       - Return null indicating no bot was detected\n     - END IF\n   - Include bot identification in session attributes\n   - Make bot status available for content customization",
    "databaseEntities": [
      "jforum_sessions"
    ],
    "validationRules": [
      "HttpRequest object must not be null",
      "Bot detection configuration must be properly loaded",
      "User-Agent pattern matching must be case-insensitive",
      "Remote host pattern matching must be case-insensitive",
      "Robots.txt requests must be automatically classified as bots",
      "Session tracking must respect bot status for analytics purposes"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "HttpRequest": {
        "type": "object",
        "properties": {
          "getRequestURI": {
            "type": "function",
            "description": "Returns the URI for this request"
          },
          "getHeader": {
            "type": "function",
            "description": "Returns the value of the specified request header"
          },
          "getRemoteHost": {
            "type": "function",
            "description": "Returns the fully qualified name of the client or the last proxy that sent the request"
          }
        }
      },
      "ConfigKeys": {
        "type": "object",
        "properties": {
          "botAgents": {
            "type": "array",
            "description": "List of user agent patterns that identify bots"
          },
          "botHosts": {
            "type": "array",
            "description": "List of host patterns that identify bots"
          }
        }
      }
    }
  },
  {
    "featureName": "ManageRequestParameters",
    "description": "Adds, replaces, and retrieves parameters from the request context.",
    "inputValues": [
      "name-string-Parameter",
      "value-object-ParameterValue",
      "operation-string-OperationType"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect parameter name (string, mandatory)\n   - Collect parameter value (object, mandatory for add/replace operations)\n   - Determine operation type (add, addOrReplace, retrieve, retrieveAsInt, retrieveAsObject, changeAction, getModule, getAction)\n   - System will determine if request is forwarded (for IP address retrieval)\n\n2. Data Validation:\n   - Validate parameter name:\n     * Check if parameter name is not null or empty\n     * Verify parameter name follows naming conventions\n     * Generate error if parameter name is invalid\n   - Validate parameter value:\n     * Check if value is appropriate for the operation\n     * For add/replace operations, value must not be null\n     * For retrieve operations, no value validation needed\n   - Validate operation type:\n     * Must be one of the supported operation types\n     * Some operations require specific parameter names (e.g., \"action\" for changeAction)\n\n3. Business Rule Processing:\n   - Check system state:\n     * Verify request context is initialized\n     * Ensure context is in a valid state for parameter operations\n   - Process based on operation type:\n     * IF operation is add:\n       - Check if parameter already exists\n       - IF parameter exists:\n         * Convert existing value to a list if not already a list\n         * Add new value to the list\n       - ELSE:\n         * Add parameter with provided value\n     * IF operation is addOrReplace:\n       - Add parameter with new value regardless of existing state\n     * IF operation is retrieve:\n       - Check if parameter exists in context\n       - IF parameter exists:\n         * Return parameter value as string\n       - ELSE:\n         * Return null or default value\n     * IF operation is retrieveAsInt:\n       - Retrieve parameter value as string\n       - Convert string value to integer\n       - Handle conversion errors\n     * IF operation is retrieveAsObject:\n       - Return parameter value as object without type conversion\n     * IF operation is changeAction:\n       - Check if \"action\" parameter exists\n       - IF exists:\n         * Replace existing action value\n       - ELSE:\n         * Add new action parameter\n     * IF operation is getAction or getModule:\n       - Return the value of \"action\" or \"module\" parameter respectively\n\n4. Core Operation Execution:\n   - Execute the selected operation on the request context:\n     * For add: Store parameter in context data structure with list handling\n     * For addOrReplace: Update parameter in context data structure\n     * For retrieve operations: Access parameter from context data structure\n     * For changeAction: Update the action parameter\n   - Handle any operation failures:\n     * Log operation failure details\n     * Prepare appropriate error response\n   - Special handling for IP address retrieval:\n     * Check for forwarded requests using \"x-forwarded-for\" header\n     * Process IP address chain to extract the original client IP\n     * Provide fallback value if IP cannot be determined\n\n5. Response Generation:\n   - For add/replace operations:\n     * Confirm successful parameter update\n     * Return success status\n   - For retrieve operations:\n     * Return requested parameter value in appropriate format (string, int, object)\n     * Include parameter type information if needed\n   - For changeAction operation:\n     * Confirm successful action parameter update\n   - For getAction/getModule operations:\n     * Return the corresponding parameter value\n   - For any failures:\n     * Return appropriate error message\n     * Include error details for troubleshooting",
    "databaseEntities": [],
    "validationRules": [
      "Parameter name must not be null or empty",
      "Request context must be initialized before parameter operations",
      "Parameter value must be appropriate for the specified operation",
      "For retrieveAsInt operations, parameter value must be convertible to integer",
      "For changeAction operations, new action value must not be null",
      "IP address processing must handle null or empty forwarded headers"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "ParameterValue": {
        "type": "object",
        "properties": {
          "value": {
            "type": "any",
            "description": "The actual value of the parameter, can be any type"
          },
          "type": {
            "type": "string",
            "description": "Optional type information for the parameter"
          }
        }
      },
      "Parameter": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "description": "The name of the parameter"
          },
          "value": {
            "type": "object",
            "description": "The value object containing the parameter data",
            "$ref": "#/ParameterValue"
          }
        },
        "required": [
          "name",
          "value"
        ]
      },
      "OperationType": {
        "type": "string",
        "enum": [
          "add",
          "addOrReplace",
          "retrieve",
          "retrieveAsInt",
          "retrieveAsObject",
          "changeAction",
          "getAction",
          "getModule"
        ],
        "description": "The type of operation to perform on the parameter"
      }
    }
  },
  {
    "featureName": "AccessRequestAttributes",
    "description": "Manages request context attributes by providing functionality to get, set, and manipulate data stored in the request context.",
    "inputValues": [
      "name-string-AttributeName",
      "value-object-AttributeValue"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect attribute name (string, mandatory)\n   - Collect attribute value (any object type, mandatory for set operations, optional for get operations)\n   - Determine operation type (get, set, remove)\n\n2. Data Validation:\n   - Validate attribute name:\n     a. Check if attribute name is not null\n     b. Check if attribute name is not empty\n     c. Generate error message if validation fails: \"Attribute name must be provided\"\n   - For set operations:\n     a. Validate that value is provided\n     b. Generate error message if validation fails: \"Value must be provided for set operations\"\n\n3. Business Rule Processing:\n   - Check if the request context exists:\n     a. IF request context is null THEN\n        i. Initialize a new request context\n     b. END IF\n   - Determine appropriate action based on operation type:\n     a. IF operation is \"get\" THEN\n        i. Prepare for attribute retrieval\n     b. ELSE IF operation is \"set\" THEN\n        i. Prepare for attribute storage\n        ii. Check if attribute already exists:\n           1. IF attribute exists THEN\n              a. Prepare for replacement\n           2. END IF\n     c. ELSE IF operation is \"remove\" THEN\n        i. Prepare for attribute removal\n     d. END IF\n\n4. Core Operation Execution:\n   - Execute the requested operation:\n     a. IF operation is \"get\" THEN\n        i. Retrieve the attribute from request context by name\n        ii. IF attribute exists THEN\n            1. Return the attribute value\n        iii. ELSE\n            1. Return null or default value\n        iv. END IF\n     b. ELSE IF operation is \"set\" THEN\n        i. Store the attribute in request context with provided name and value\n        ii. IF operation successful THEN\n            1. Confirm attribute is stored\n        iii. ELSE\n            1. Handle storage failure\n        iv. END IF\n     c. ELSE IF operation is \"remove\" THEN\n        i. Remove the attribute from request context by name\n        ii. Confirm attribute is removed\n     d. END IF\n   - Handle type conversion for special cases:\n     a. IF attribute is numeric and requested as integer THEN\n        i. Convert string representation to integer\n     b. END IF\n\n5. Response Generation:\n   - Generate appropriate response based on operation:\n     a. For get operations:\n        i. Return requested attribute value or null if not found\n        ii. For integer requests, return parsed integer value\n        iii. For object requests, return the object directly\n     b. For set operations:\n        i. Return confirmation of successful attribute storage\n     c. For remove operations:\n        i. Return confirmation of successful attribute removal\n     d. For any operation failures:\n        i. Return appropriate error message\n        ii. Include details about the failure reason",
    "databaseEntities": [],
    "validationRules": [
      "Attribute name must not be null or empty",
      "Value must be provided for set operations",
      "Request context must be initialized before operations"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "AttributeValue": {
        "type": "object",
        "description": "Represents any value that can be stored in the request context",
        "properties": {
          "value": {
            "type": "any",
            "description": "The actual value to be stored, can be of any type"
          }
        }
      }
    }
  },
  {
    "featureName": "ManageSessionContext",
    "description": "Creates and provides access to the session context for managing user session data.",
    "inputValues": [
      "sessionData-object-SessionData",
      "attributeName-string-AttributeName",
      "attributeValue-object-AttributeValue"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect sessionData (object) containing session information\n   - Collect attributeName (string) for session attribute operations\n   - Collect attributeValue (object) for session attribute operations\n   - System will generate a unique sessionId if not provided\n\n2. Data Validation:\n   - Validate attributeName:\n     a. Check if attributeName is not null when performing attribute operations\n     b. Verify attributeName is a valid string format\n     c. Return appropriate error message if validation fails\n   - Validate attributeValue:\n     a. Ensure attributeValue is properly formatted for storage\n     b. Convert complex objects to storable format if needed\n     c. Return appropriate error message if validation fails\n\n3. Business Rule Processing:\n   - Check if session context already exists:\n     a. IF session context exists, retrieve existing context\n     b. IF session context does not exist, determine if new context should be created\n        i. IF create flag is true, create new session context\n        ii. IF create flag is false, return null or empty context based on system configuration\n   - Verify session timeout status:\n     a. IF session has timed out, handle according to system policy\n        i. Either create new session\n        ii. Or return error indicating expired session\n     b. IF session is valid, proceed with requested operation\n\n4. Core Operation Execution:\n   - Session Context Creation:\n     a. Generate new session identifier if creating new context\n     b. Initialize empty data structure for session attributes\n     c. Set default session timeout parameters\n     d. Record session creation time\n   - Session Data Management:\n     a. FOR attribute operations:\n        i. IF operation is getAttribute, retrieve requested attribute value\n           - Return null if attribute doesn't exist\n        ii. IF operation is setAttribute, store attribute with provided value\n           - Replace existing value if attribute already exists\n        iii. IF operation is removeAttribute, delete attribute from session\n           - Ignore if attribute doesn't exist\n     b. Handle session invalidation if requested:\n        i. Clear all session data\n        ii. Mark session as invalid\n        iii. Prepare for garbage collection\n\n5. Response Generation:\n   - For successful operations:\n     a. Return requested attribute value for getAttribute operations\n     b. Return confirmation of success for setAttribute operations\n     c. Return session context object when requested\n   - For error conditions:\n     a. Return appropriate error message for validation failures\n     b. Return session timeout notification if session expired\n     c. Return permissions error if operation not allowed",
    "databaseEntities": [
      "jforum_sessions"
    ],
    "validationRules": [
      "Session attribute names must not be null or empty",
      "Session must be valid and not expired for operations",
      "Session timeout must be a positive integer value",
      "Session creation must generate a unique session identifier"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "SessionData": {
        "type": "object",
        "properties": {
          "sessionId": {
            "type": "string",
            "description": "Unique identifier for the session"
          },
          "creationTime": {
            "type": "number",
            "description": "Timestamp when session was created"
          },
          "lastAccessTime": {
            "type": "number",
            "description": "Timestamp of last session access"
          },
          "maxInactiveInterval": {
            "type": "number",
            "description": "Maximum time in seconds session can be inactive"
          },
          "attributes": {
            "type": "object",
            "description": "Collection of session attributes"
          }
        }
      },
      "AttributeValue": {
        "type": "object",
        "description": "Generic container for any type of session attribute value"
      }
    }
  },
  {
    "featureName": "GetSessionAttribute",
    "description": "Retrieves a stored attribute from the session context by name.",
    "inputValues": [
      "name-string-SessionAttribute"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the attribute name (name-string-SessionAttribute) from the user request\n   - Verify the session context exists and is accessible\n   - Note: The attribute name is mandatory and must be provided\n\n2. Data Validation:\n   - Validate the attribute name:\n     a. Check if attribute name is provided\n     b. Verify attribute name is not empty or null\n     c. Ensure attribute name is a valid string\n   - IF validation fails, THEN:\n     a. Generate appropriate error message\n     b. Return error response to caller\n\n3. Business Rule Processing:\n   - Verify session context is valid and active:\n     a. Check if session exists\n     b. Verify session has not expired\n     c. Ensure session ID is valid\n   - IF session is invalid, THEN:\n     a. Generate session invalid error\n     b. Return appropriate error response\n\n4. Core Operation Execution:\n   - Locate the requested attribute in the session storage:\n     a. Access the session data container\n     b. Search for the attribute using the provided name as key\n     c. Retrieve the attribute value if found\n   - IF attribute is found, THEN:\n     a. Prepare attribute value for return\n   - ELSE:\n     a. Set return value to null or appropriate default value\n\n5. Response Generation:\n   - Format the response with the retrieved attribute:\n     a. Include the attribute value if found\n     b. Include appropriate status indicator\n     c. Include session context information if relevant\n   - Return the formatted response to the caller",
    "databaseEntities": [
      "jforum_sessions"
    ],
    "validationRules": [
      "Attribute name must not be empty or null",
      "Session must be valid and active",
      "Session ID must exist in the system"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "SessionAttribute": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "description": "The name of the session attribute to retrieve"
          },
          "value": {
            "type": "object",
            "description": "The value of the retrieved attribute (can be any type)"
          }
        },
        "required": [
          "name"
        ]
      }
    }
  },
  {
    "featureName": "GetSessionAttributeNames",
    "description": "Retrieves all attribute names stored in the session context.",
    "inputValues": [
      "sessionContext-object-SessionContext"
    ],
    "businessLogic": "1. Input Collection:\n   - Receive sessionContext object (mandatory)\n   - No additional user inputs required\n   - System will use the provided session context to retrieve attribute names\n\n2. Data Validation:\n   - Validate session context existence\n     a. IF sessionContext is null THEN\n        i. Generate error message indicating invalid session context\n        ii. Terminate process and return error\n     b. ELSE\n        i. Proceed to next step\n   - Validate session context state\n     a. IF session has been invalidated THEN\n        i. Generate error message indicating session is no longer valid\n        ii. Terminate process and return error\n     b. ELSE\n        i. Proceed to next step\n\n3. Business Rule Processing:\n   - Check session access permissions\n     a. IF current user has permission to access session attributes THEN\n        i. Proceed to next step\n     b. ELSE\n        i. Generate error message indicating insufficient permissions\n        ii. Terminate process and return error\n   - Check session timeout status\n     a. IF session has timed out THEN\n        i. Generate error message indicating expired session\n        ii. Terminate process and return error\n     b. ELSE\n        i. Proceed to next step\n\n4. Core Operation Execution:\n   - Retrieve attribute names from session\n     a. Access internal data structure of session context\n     b. Extract all attribute names (keys) from the session data structure\n     c. Create a collection to hold the attribute names\n     d. Add each attribute name to the collection\n     e. IF extraction fails THEN\n        i. Generate error message indicating retrieval failure\n        ii. Terminate process and return error\n     f. ELSE\n        i. Proceed to next step\n\n5. Response Generation:\n   - Prepare attribute names collection for return\n     a. Format the collection of attribute names according to system requirements\n     b. Return the collection of attribute names\n     c. IF collection is empty THEN\n        i. Return empty collection (not an error condition)\n     d. ELSE\n        i. Return populated collection with all attribute names",
    "databaseEntities": [
      "jforum_sessions"
    ],
    "validationRules": [
      "Session context must not be null",
      "Session must not be invalidated",
      "User must have permission to access session attributes",
      "Session must not be expired"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "SessionContext": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "Unique identifier for the session"
          },
          "attributes": {
            "type": "object",
            "description": "Collection of attributes stored in the session"
          }
        },
        "required": [
          "id",
          "attributes"
        ]
      }
    }
  },
  {
    "featureName": "GetSessionId",
    "description": "Retrieves the unique identifier for the current session.",
    "inputValues": [],
    "businessLogic": "1. Input Collection:\n   - No user inputs required for this operation\n   - System will use internally stored session information\n\n2. Data Validation:\n   - Check if session context exists\n     - IF session context does not exist THEN\n       - Return appropriate error message indicating no active session\n     - END IF\n   - Verify session ID is present in the session context\n     - IF session ID is missing THEN\n       - Log session corruption warning\n       - Return error indicating session data integrity issue\n     - END IF\n\n3. Business Rule Processing:\n   - Check session validity\n     - IF session has expired THEN\n       - Return error indicating expired session\n     - END IF\n   - Verify session access permissions\n     - IF current user is not authorized to access this session THEN\n       - Return permission denied error\n     - END IF\n\n4. Core Operation Execution:\n   - Retrieve session ID from session context storage\n   - Format session ID according to system requirements\n   - Record session access timestamp for auditing purposes\n\n5. Response Generation:\n   - Return the session ID as response\n   - Include session metadata if verbose mode is enabled\n   - IF any errors occurred during processing THEN\n     - Return appropriate error message\n     - Include troubleshooting information when applicable\n   - END IF",
    "databaseEntities": [
      "jforum_sessions"
    ],
    "validationRules": [
      "Session context must exist",
      "Session ID must be present in the session context",
      "Session must not be expired",
      "User must have permission to access the session"
    ],
    "dbSeedingOperations": [],
    "schema": {}
  },
  {
    "featureName": "InvalidateSession",
    "description": "Clears all session data and generates a new session identifier.",
    "inputValues": [
      "sessionContext-object-SessionContext"
    ],
    "businessLogic": "1. Input Collection:\n   - Receive the current session context object\n   - No additional user inputs required as this is a system operation\n\n2. Data Validation:\n   - Verify session context exists\n     - IF session context is null THEN\n       - Generate error: \"Invalid session context\"\n       - Exit process\n     - END IF\n   - Verify session context is active\n     - IF session context has already been invalidated THEN\n       - Log warning: \"Attempting to invalidate an already invalidated session\"\n       - Continue with process anyway for idempotency\n     - END IF\n\n3. Business Rule Processing:\n   - Check for any critical operations in progress\n     - IF any critical operations are in progress THEN\n       - Generate warning: \"Session invalidation may interrupt current operations\"\n       - Proceed with user confirmation or based on system policy\n     - END IF\n   - Determine if any resources need cleanup before invalidation\n     - FOR each resource associated with the session\n       - Prepare resource for cleanup\n     - END FOR\n   - Check if session contains authentication information\n     - IF user is authenticated THEN\n       - Note that invalidation will require re-authentication\n     - END IF\n\n4. Core Operation Execution:\n   - Clear all session data\n     - Retrieve all attribute names from the session\n     - FOR each attribute name in the session\n       - Remove the attribute from the session\n     - END FOR\n     - Release any resources exclusively held by the session\n   - Invalidate the underlying session\n     - Call the platform's session invalidation mechanism\n     - This will automatically generate a new session identifier when needed\n   - Reset session state\n     - Initialize any required default session attributes\n     - Reset session creation timestamp\n\n5. Response Generation:\n   - Return success indicator\n   - Include the new session identifier in the response if applicable\n   - Provide guidance on next steps (e.g., re-authentication may be required)\n   - Log session invalidation event for audit purposes",
    "databaseEntities": [
      "jforum_sessions"
    ],
    "validationRules": [
      "Session context must exist",
      "New session identifier must be unique",
      "New session identifier must be cryptographically secure",
      "All previous session data must be completely removed"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "SessionContext": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "Unique identifier for the session"
          },
          "attributes": {
            "type": "object",
            "description": "Collection of session attributes stored as key-value pairs"
          },
          "creationTime": {
            "type": "date",
            "description": "Timestamp when the session was created"
          },
          "lastAccessTime": {
            "type": "date",
            "description": "Timestamp when the session was last accessed"
          }
        },
        "required": [
          "id"
        ]
      }
    }
  },
  {
    "featureName": "RemoveSessionAttribute",
    "description": "Removes a specific attribute from the session context.",
    "inputValues": [
      "attributeName-string-Session"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the following inputs:\n     a. attributeName (string, mandatory): The name of the attribute to be removed from the session\n     b. sessionContext (object, system-provided): The current session context\n\n2. Data Validation:\n   - Validate the attribute name:\n     a. Check if attributeName is provided\n        IF attributeName is null or empty THEN\n          Return error message: \"Attribute name must be provided\"\n     b. Check if attributeName is not a reserved system attribute\n        IF attributeName equals SESSION_ID THEN\n          Return error message: \"Cannot remove system reserved attributes\"\n\n3. Business Rule Processing:\n   - Verify session state:\n     a. Check if the session is valid\n        IF session is null or invalid THEN\n          Return error message: \"Invalid session\"\n     b. Check if the attribute exists in the session\n        IF attribute does not exist in session THEN\n          Return warning message: \"Attribute not found in session\"\n\n4. Core Operation Execution:\n   - Remove the attribute from the session:\n     a. Locate the attribute in the session storage\n     b. Remove the attribute entry from the session data structure\n     c. IF removal operation fails THEN\n          Log the failure\n          Return error message: \"Failed to remove attribute from session\"\n\n5. Response Generation:\n   - Generate success response:\n     a. Confirm the attribute has been removed\n     b. Return success message: \"Attribute successfully removed from session\"\n   - Generate error response (if applicable):\n     a. Include specific error details\n     b. Provide guidance on resolving the issue",
    "databaseEntities": [
      "jforum_sessions"
    ],
    "validationRules": [
      "Attribute name must not be empty",
      "Session must be valid",
      "Cannot remove system reserved attributes"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Session": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "Unique identifier for the session"
          },
          "attributes": {
            "type": "object",
            "description": "Collection of key-value pairs representing session attributes"
          }
        }
      }
    }
  },
  {
    "featureName": "SetSessionAttribute",
    "description": "Stores or updates an attribute in the session context.",
    "inputValues": [
      "name-string-SessionAttribute",
      "value-object-AttributeValue"
    ],
    "businessLogic": "1. Input Collection\n   1.1. Collect the attribute name (mandatory string)\n      1.1.1. The attribute name serves as the unique identifier for the stored value\n      1.1.2. No default value is provided; must be explicitly specified\n   1.2. Collect the attribute value (mandatory object)\n      1.2.1. The value can be of any type that needs to be stored in the session\n      1.2.2. No default value is provided; must be explicitly specified\n\n2. Data Validation\n   2.1. Validate attribute name\n      2.1.1. Check if the attribute name is provided\n         IF attribute name is null or empty THEN\n            Return error: \"Attribute name cannot be empty\"\n      2.1.2. Check if the attribute name is a valid string\n         IF attribute name is not a valid string THEN\n            Return error: \"Invalid attribute name format\"\n   2.2. Validate attribute value\n      2.2.1. Check if the attribute value is provided\n         IF attribute value is null THEN\n            Return error: \"Attribute value cannot be null\"\n\n3. Business Rule Processing\n   3.1. Check session state\n      3.1.1. Verify that the session context is active and valid\n         IF session is invalid or expired THEN\n            Return error: \"Invalid session context\"\n   3.2. Check for reserved attribute names\n      3.2.1. Verify the attribute name is not a reserved system name\n         IF attribute name equals SESSION_ID THEN\n            Return warning: \"Modifying system attributes may cause unexpected behavior\"\n\n4. Core Operation Execution\n   4.1. Check for existing attribute\n      4.1.1. Determine if the attribute already exists in the session\n         IF session contains attribute with the same name THEN\n            Remove the existing attribute to prevent duplication\n   4.2. Store the attribute\n      4.2.1. Add the attribute name and value to the session storage\n      4.2.2. Ensure the attribute is immediately available for retrieval\n   4.3. Handle storage failures\n      4.3.1. If storage operation fails\n         Return error: \"Failed to store attribute in session\"\n\n5. Response Generation\n   5.1. Generate success response\n      5.1.1. Indicate the attribute was successfully stored\n      5.1.2. Include the attribute name in the confirmation\n   5.2. Generate error response (if applicable)\n      5.2.1. Include specific error message describing the failure\n      5.2.2. Include guidance on how to resolve the issue",
    "databaseEntities": [
      "jforum_sessions"
    ],
    "validationRules": [
      "Attribute name must not be empty",
      "Session context must be valid and active",
      "Attribute value must not be null",
      "Modifying system attributes like SESSION_ID requires caution"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "AttributeValue": {
        "type": "object",
        "description": "Any type of value that can be stored in the session",
        "properties": {
          "value": {
            "type": "any",
            "description": "The actual value to be stored, can be of any valid type"
          }
        }
      },
      "SessionAttribute": {
        "type": "object",
        "description": "Represents a named attribute in the session",
        "properties": {
          "name": {
            "type": "string",
            "description": "The unique name of the attribute"
          },
          "value": {
            "type": "any",
            "description": "The value associated with the attribute"
          }
        },
        "required": [
          "name",
          "value"
        ]
      }
    }
  },
  {
    "featureName": "ParseFriendlyURL",
    "description": "Parses friendly URLs to extract module, action, and parameters from the request URI.",
    "inputValues": [
      "requestUri-string-Request",
      "servletExtension-string-System",
      "urlModel-object-URLComponents"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect requestUri (string, mandatory): The URI from the HTTP request\n   - Collect servletExtension (string, mandatory): The extension used for servlet requests\n   - System will generate urlModel (array, system-generated): Components of the URL after splitting\n\n2. Data Validation:\n   - Validate requestUri:\n      * Check if requestUri is not null or empty\n      * Verify requestUri ends with the servletExtension\n      * Error message if validation fails: \"Invalid request URI format\"\n   - Validate servletExtension:\n      * Check if servletExtension is not null or empty\n      * Error message if validation fails: \"Servlet extension not configured\"\n\n3. Business Rule Processing:\n   - Prepare requestUri for parsing:\n      * Remove the servlet extension from the end of requestUri\n      * Split the modified requestUri by \"/\" character to create urlModel array\n   - Verify URL structure:\n      * Check if urlModel has at least 3 components (baseLen)\n      * IF urlModel length < baseLen THEN\n         > Set module and action parameters to null\n         > Skip to Response Generation\n      * Define moduleIndex as 1 (position of module name in urlModel)\n      * Define actionIndex as 2 (position of action name in urlModel)\n\n4. Core Operation Execution:\n   - Construct pattern identifier:\n      * Create a string in format: \"[moduleName].[actionName].[numberOfParameters]\"\n      * Number of parameters = urlModel.length - baseLen\n   - Look up URL pattern:\n      * Search for matching pattern in pattern collection using the identifier\n      * IF matching pattern found THEN\n         > Check if pattern has enough variables for the parameters\n         > IF pattern.size >= (urlModel.length - baseLen) THEN\n            * FOR each variable in pattern:\n               - Extract corresponding value from urlModel\n               - Add parameter with name=pattern variable and value=urlModel component\n         > Add or replace \"module\" parameter with moduleName from urlModel\n         > Add \"action\" parameter with actionName from urlModel\n      * ELSE (no matching pattern)\n         > Set \"module\" parameter to null\n         > Set \"action\" parameter to null\n\n5. Response Generation:\n   - Return success with:\n      * Updated parameter collection containing:\n         > Module name (or null if not found)\n         > Action name (or null if not found)\n         > Any extracted parameters from the URL\n   - In case of errors:\n      * Return error details indicating the parsing failure\n      * Include the original requestUri for debugging",
    "databaseEntities": [],
    "validationRules": [
      "Request URI must not be null or empty",
      "Request URI must end with the configured servlet extension",
      "URL must have at least a module and action component to be parsed",
      "URL pattern must exist in the pattern collection to extract parameters"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "URLComponents": {
        "type": "object",
        "properties": {
          "moduleIndex": {
            "type": "integer",
            "description": "Index position of the module name in the URL array"
          },
          "actionIndex": {
            "type": "integer",
            "description": "Index position of the action name in the URL array"
          },
          "components": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Array of URL path components after splitting"
          }
        }
      }
    }
  },
  {
    "featureName": "HandleMultipartRequest",
    "description": "Processes multipart form data requests including file uploads with proper encoding.",
    "inputValues": [
      "superRequest-object-HttpServletRequest",
      "encoding-string-String"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the HttpServletRequest object containing the multipart form data\n   - Retrieve the system encoding setting from configuration\n   - Determine temporary directory path for file storage\n   1.1. Identify if the request contains multipart content\n   1.2. Prepare file upload configuration settings\n\n2. Data Validation:\n   - Validate that the request is properly formatted as multipart content\n   2.1. Check if the temporary directory exists\n      IF temporary directory does not exist THEN\n         Attempt to create the directory\n         IF directory creation fails THEN\n            Fall back to system temporary directory\n   2.2. Validate encoding parameter is supported\n\n3. Business Rule Processing:\n   - Configure file upload settings based on system configuration\n   3.1. Set up disk-based file item factory with appropriate buffer size\n      - Configure 100KB buffer size for memory threshold\n      - Set temporary directory for storing files that exceed buffer size\n   3.2. Create file upload handler with configured settings\n   3.3. Set proper encoding for the file upload handler\n\n4. Core Operation Execution:\n   - Process the multipart request content\n   4.1. Parse all items from the multipart request\n   4.2. FOR each item in the request DO\n      IF item is a form field THEN\n         Add the field name and value to the parameter collection\n      ELSE IF item is a file AND file size is greater than zero THEN\n         Store the file item in the query map using the field name as key\n      END IF\n   4.3. IF any error occurs during processing THEN\n      Throw appropriate exception with descriptive message\n      Ensure temporary resources are cleaned up\n   4.4. Make all processed parameters available through the request context\n\n5. Response Generation:\n   - Prepare the processed data for access by the application\n   5.1. Ensure all form fields are accessible through parameter methods\n   5.2. Ensure all file uploads are accessible through the object parameter method\n   5.3. Return control to the calling context with all data properly processed",
    "databaseEntities": [],
    "validationRules": [
      "Request must be a valid multipart form data request",
      "Temporary directory must be accessible for file storage",
      "File uploads must have size greater than zero to be processed",
      "Encoding must be supported by the system"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "HttpServletRequest": {
        "type": "object",
        "properties": {
          "method": {
            "type": "string",
            "description": "HTTP method of the request"
          },
          "contextPath": {
            "type": "string",
            "description": "Context path of the web application"
          },
          "requestURI": {
            "type": "string",
            "description": "Request URI"
          },
          "queryString": {
            "type": "string",
            "description": "Query string portion of the URL"
          },
          "parameterNames": {
            "type": "object",
            "description": "Enumeration of parameter names"
          },
          "parameterValues": {
            "type": "array",
            "description": "Values for a specific parameter name"
          }
        }
      }
    }
  },
  {
    "featureName": "GetSessionContext",
    "description": "Retrieves or creates a session context for the current web request.",
    "inputValues": [
      "request-object-HttpRequest",
      "create-boolean-System"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect HttpRequest object from the system\n   - Determine if a new session should be created (boolean create parameter)\n   - System will provide current session if it exists\n\n2. Data Validation:\n   - Validate that the request object is valid and properly initialized\n   - Check if the request contains valid session information\n   - IF request is invalid or corrupted THEN\n     - Generate appropriate error message\n     - Return error response\n   - END IF\n\n3. Business Rule Processing:\n   - Check if an existing session is available\n   - IF session exists THEN\n     - Verify session validity (not expired)\n     - Check session permissions and access rights\n   - ELSE\n     - Check if create parameter is set to true\n     - IF create is false THEN\n       - Return null or empty session context\n     - END IF\n   - END IF\n   - Verify system resources are available for session management\n\n4. Core Operation Execution:\n   - IF existing session is found and valid THEN\n     - Retrieve session data from storage\n     - Initialize session context with existing data\n   - ELSE IF create parameter is true THEN\n     - Generate new session identifier\n     - Create new empty session container\n     - Initialize session with default values\n     - Store new session in the system\n   - END IF\n   - Wrap session data in appropriate context object\n   - Associate context with current request\n   - Update session access timestamp\n\n5. Response Generation:\n   - Prepare session context object for return\n   - Include session identifier in response\n   - IF session was newly created THEN\n     - Include creation status in response\n   - ELSE\n     - Include session validity information\n   - END IF\n   - Return complete session context to caller",
    "databaseEntities": [
      "jforum_sessions"
    ],
    "validationRules": [
      "Request object must be valid and initialized",
      "Session must not be expired if it exists",
      "User must have valid permissions to access the session",
      "System must have sufficient resources to manage sessions"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "HttpRequest": {
        "type": "object",
        "properties": {
          "session": {
            "type": "object",
            "description": "The session associated with this request"
          },
          "parameters": {
            "type": "object",
            "description": "Request parameters"
          },
          "attributes": {
            "type": "object",
            "description": "Request attributes"
          }
        }
      },
      "SessionContext": {
        "type": "object",
        "properties": {
          "sessionId": {
            "type": "string",
            "description": "Unique identifier for the session"
          },
          "creationTime": {
            "type": "number",
            "description": "Timestamp when the session was created"
          },
          "lastAccessedTime": {
            "type": "number",
            "description": "Timestamp when the session was last accessed"
          },
          "attributes": {
            "type": "object",
            "description": "Session attributes"
          }
        }
      }
    }
  },
  {
    "featureName": "ExtractRequestParameters",
    "description": "Extracts and processes request parameters with proper character encoding handling.",
    "inputValues": [
      "request-object-HttpServletRequest",
      "encoding-string-SystemGlobal",
      "contextPath-string-RequestContext"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the HTTP request object (mandatory)\n   - Retrieve system encoding configuration (mandatory)\n   - Get servlet extension from system configuration (mandatory)\n   - Determine request method type (GET or POST)\n   - Extract request URI and context path (mandatory)\n\n2. Data Validation:\n   - Validate request object is not null\n     * IF request is null THEN return error\n   - Validate encoding configuration is available\n     * IF encoding is not set THEN use default encoding\n   - Validate request URI format\n     * IF URI format is invalid THEN handle as regular request\n   - Check if request is multipart\n     * IF request is multipart THEN verify content type\n\n3. Business Rule Processing:\n   - Determine request processing approach based on request type\n     * IF request is GET with empty query string and ends with servlet extension\n       THEN set character encoding and parse as friendly URL\n     * IF request is POST\n       THEN check if multipart content\n         * IF multipart THEN handle multipart processing\n         * ELSE set character encoding based on request type\n   - Check if request is AJAX\n     * IF request is AJAX THEN use UTF-8 encoding\n     * ELSE use system configured encoding\n   - Determine container encoding\n     * IF request is POST THEN use system encoding\n     * ELSE use default container encoding\n\n4. Core Operation Execution:\n   - Process request parameters based on request type\n     * FOR each parameter in the request\n       * Extract parameter name and values\n       * IF parameter has multiple values\n         THEN process each value with proper encoding conversion\n       * ELSE process single value with proper encoding conversion\n       * Add processed parameter to internal parameter map\n   - Handle friendly URL parsing if needed\n     * IF module and action parameters are not set\n       THEN parse URI as friendly URL\n         * Extract module and action from URL segments\n         * Map URL parameters according to pattern definitions\n         * Add extracted parameters to parameter map\n   - Process file uploads for multipart requests\n     * Create temporary directory for file storage\n     * Process each uploaded item\n     * Store form fields in parameter map\n     * Store file items separately for later access\n\n5. Response Generation:\n   - Provide access methods to retrieve processed parameters\n     * Return single parameter value when requested by name\n     * Return parameter value array when multiple values exist\n     * Return file items for uploaded content\n   - Support session context access\n     * Create session context when requested\n     * Provide access to existing session when available",
    "databaseEntities": [],
    "validationRules": [
      "Request object must not be null",
      "Character encoding must be properly set",
      "Temporary directory must be accessible for multipart uploads",
      "URL patterns must match defined format for friendly URL parsing",
      "File uploads must not exceed system-defined size limits"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "HttpServletRequest": {
        "type": "object",
        "properties": {
          "method": {
            "type": "string",
            "description": "HTTP method of the request (GET, POST, etc.)"
          },
          "contextPath": {
            "type": "string",
            "description": "Context path of the application"
          },
          "requestURI": {
            "type": "string",
            "description": "Full request URI"
          },
          "queryString": {
            "type": "string",
            "description": "Query string portion of the URL"
          },
          "parameterNames": {
            "type": "array",
            "description": "Names of all parameters in the request"
          },
          "parameterValues": {
            "type": "object",
            "description": "Map of parameter names to values"
          },
          "headers": {
            "type": "object",
            "description": "HTTP headers in the request"
          }
        }
      },
      "SystemGlobal": {
        "type": "object",
        "properties": {
          "encoding": {
            "type": "string",
            "description": "System character encoding setting"
          },
          "servletExtension": {
            "type": "string",
            "description": "Extension used for servlet mappings"
          },
          "containerEncoding": {
            "type": "string",
            "description": "Default container encoding"
          },
          "tmpDir": {
            "type": "string",
            "description": "Path to temporary directory"
          }
        }
      },
      "RequestContext": {
        "type": "object",
        "properties": {
          "parameters": {
            "type": "object",
            "description": "Processed request parameters"
          },
          "module": {
            "type": "string",
            "description": "Module name extracted from request"
          },
          "action": {
            "type": "string",
            "description": "Action name extracted from request"
          }
        }
      }
    }
  },
  {
    "featureName": "GetRequestParameter",
    "description": "Retrieves parameter values from web requests with support for different data types.",
    "inputValues": [
      "parameter-string-RequestParameter",
      "value-object-ParameterValue"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the parameter name (string) to retrieve\n   - Determine the expected data type (string, integer, object)\n   - Note if the operation is for retrieving or setting a parameter\n\n2. Data Validation:\n   - Validate parameter name is provided and not null\n     * IF parameter name is null or empty THEN return appropriate error\n   - For setting parameters:\n     * Validate the value to be set is appropriate for the context\n     * Check if value meets any format requirements based on parameter type\n\n3. Business Rule Processing:\n   - Determine the appropriate retrieval method based on data type:\n     * IF requesting string parameter THEN prepare for string retrieval\n     * IF requesting integer parameter THEN prepare for numeric conversion\n     * IF requesting object parameter THEN prepare for object retrieval\n   - For special parameters like 'action' and 'module':\n     * Apply specific business rules for handling these system parameters\n     * Ensure proper context is maintained when changing these values\n   - For parameter addition:\n     * Check if parameter already exists\n     * IF parameter exists THEN determine if it should be replaced or added to a collection\n     * IF parameter should be collected THEN convert existing value to a list if needed\n\n4. Core Operation Execution:\n   - For parameter retrieval:\n     * Access the parameter from the query collection\n     * Apply any necessary type conversions based on requested type\n     * Handle special cases for system parameters\n   - For parameter setting:\n     * IF adding parameter THEN check if parameter already exists\n       * IF parameter exists THEN convert to list and append new value\n       * IF parameter doesn't exist THEN add directly\n     * IF replacing parameter THEN update existing value regardless of current state\n   - For special operations:\n     * Handle action changes with proper context updates\n     * Process IP address retrieval with proxy awareness\n\n5. Response Generation:\n   - Return the parameter value in the requested format:\n     * For string parameters: return string value\n     * For integer parameters: return parsed integer value\n     * For object parameters: return the raw object\n   - For parameter setting operations:\n     * Confirm successful parameter addition or replacement\n     * Return updated parameter state if needed\n   - Handle special cases:\n     * For IP address: return properly formatted remote address with proxy handling\n     * For context path: return appropriate path based on system configuration",
    "databaseEntities": [],
    "validationRules": [
      "Parameter name must not be null or empty",
      "Integer parameters must be convertible to numeric values",
      "When adding to an existing parameter, proper list conversion must occur",
      "IP addresses must be properly extracted from forwarded requests",
      "Context paths must respect system configuration for proxied environments"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "RequestParameter": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "description": "The name of the parameter to retrieve or set"
          },
          "type": {
            "type": "string",
            "enum": [
              "string",
              "integer",
              "object"
            ],
            "description": "The expected data type of the parameter"
          }
        },
        "required": [
          "name"
        ]
      },
      "ParameterValue": {
        "type": "object",
        "properties": {
          "value": {
            "type": "object",
            "description": "The value to be set for a parameter"
          },
          "replace": {
            "type": "boolean",
            "description": "Whether to replace an existing parameter or add to a collection"
          }
        },
        "required": [
          "value"
        ]
      }
    }
  },
  {
    "featureName": "HandleRequestNavigation",
    "description": "Manages action and module parameters for determining navigation flow in the application.",
    "inputValues": [
      "parameter-string-RequestParameter",
      "value-object-ParameterValue",
      "action-string-ActionName",
      "module-string-ModuleName",
      "newAction-string-ActionName"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect request parameters:\n     a. parameter name (string, mandatory)\n     b. parameter value (object, mandatory)\n     c. action name (string, optional)\n     d. module name (string, optional)\n     e. new action name (string, optional for action change)\n\n2. Data Validation:\n   - Validate parameter name:\n     a. IF parameter name is null or empty THEN\n        i. Return error message indicating parameter name is required\n     b. ELSE continue processing\n   - Validate parameter value:\n     a. Value can be null for retrieval operations\n     b. For parameter addition operations, value must not be null\n     c. IF operation requires value and value is null THEN\n        i. Return error message indicating parameter value is required\n     d. ELSE continue processing\n\n3. Business Rule Processing:\n   - Determine operation type:\n     a. IF operation is parameter retrieval THEN\n        i. Check if parameter exists in query collection\n        ii. IF parameter does not exist THEN\n            1. Return null or appropriate default value\n        iii. ELSE continue to retrieve value\n     b. IF operation is parameter addition THEN\n        i. Check if parameter already exists\n        ii. IF parameter exists THEN\n            1. Check if current value is a list\n            2. IF not a list THEN convert to list and add new value\n            3. ELSE add new value to existing list\n        iii. ELSE add parameter with value directly\n     c. IF operation is parameter replacement THEN\n        i. Replace existing parameter value regardless of previous state\n     d. IF operation is action retrieval THEN\n        i. Return the value associated with \"action\" parameter\n     e. IF operation is action change THEN\n        i. Remove existing action parameter if present\n        ii. Add new action parameter with provided value\n     f. IF operation is module retrieval THEN\n        i. Return the value associated with \"module\" parameter\n\n4. Core Operation Execution:\n   - Execute the determined operation:\n     a. For parameter retrieval:\n        i. Get value from query collection using parameter name\n        ii. Convert value to appropriate type if needed (string, int, object)\n        iii. Return the retrieved value\n     b. For parameter addition:\n        i. IF parameter doesn't exist THEN\n           1. Add parameter with value to query collection\n        ii. ELSE\n           1. Get current value\n           2. IF current value is not a list THEN\n              a. Create new list\n              b. Add current value to list\n              c. Add new value to list\n              d. Update parameter with list\n           3. ELSE\n              a. Add new value to existing list\n              b. Update parameter with modified list\n     c. For parameter replacement:\n        i. Put parameter with new value in query collection\n     d. For action retrieval:\n        i. Return value of \"action\" parameter\n     e. For action change:\n        i. Remove existing \"action\" parameter if present\n        ii. Add \"action\" parameter with new value\n     f. For module retrieval:\n        i. Return value of \"module\" parameter\n\n5. Response Generation:\n   - Generate appropriate response based on operation:\n     a. For retrieval operations:\n        i. Return requested parameter value\n        ii. Return null or default if parameter not found\n     b. For modification operations:\n        i. Return success indicator\n        ii. Return updated parameter collection if needed\n     c. For action/module operations:\n        i. Return action or module value\n        ii. Return success indicator for action change",
    "databaseEntities": [],
    "validationRules": [
      "Parameter name must not be null or empty",
      "Parameter value must not be null for addition operations",
      "Action parameter must be a valid string",
      "Module parameter must be a valid string",
      "New action name must not be null or empty when changing actions"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "RequestParameter": {
        "type": "string",
        "description": "Name of the parameter to retrieve or modify"
      },
      "ParameterValue": {
        "type": "object",
        "description": "Value associated with a parameter, can be string, number, or complex object"
      },
      "ActionName": {
        "type": "string",
        "description": "Name of an action that determines application flow"
      },
      "ModuleName": {
        "type": "string",
        "description": "Name of a module that groups related functionality"
      }
    }
  },
  {
    "featureName": "ResolveClientIPAddress",
    "description": "Determines the actual client IP address with support for forwarded requests.",
    "inputValues": [
      "request-object-HttpRequest"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the HTTP request object\n     1.1. Access the HTTP request headers\n     1.2. Access the remote address information from the request\n\n2. Data Validation:\n   - Validate the request object\n     2.1. Verify the request object is not null\n     2.2. Check if required header information is accessible\n\n3. Business Rule Processing:\n   - Check for forwarded request scenarios\n     3.1. Check if 'x-forwarded-for' header exists in the request\n     3.2. IF 'x-forwarded-for' header exists THEN\n          3.2.1. Process the header value as a potential proxy chain\n          3.2.2. Determine if the header contains multiple IP addresses\n     3.3. ELSE\n          3.3.1. Prepare to use the direct remote address\n\n4. Core Operation Execution:\n   - Determine the client IP address\n     4.1. IF 'x-forwarded-for' header exists THEN\n          4.1.1. Parse the header value by splitting at commas\n          4.1.2. Extract the last IP address from the chain (representing the original client)\n          4.1.3. Trim any whitespace from the extracted IP\n          4.1.4. IF extracted IP is empty THEN\n                4.1.4.1. Set IP to null\n     4.2. ELSE\n          4.2.1. Get the remote address directly from the request\n     4.3. IF the IP address is null or could not be determined THEN\n          4.3.1. Set IP to a default placeholder value '[REDACTED-IP-ADDRESS]'\n\n5. Response Generation:\n   - Return the resolved client IP address\n     5.1. Return the final determined IP address string\n     5.2. Ensure the returned value is never null",
    "databaseEntities": [],
    "validationRules": [
      "The request object must not be null",
      "The returned IP address must never be null",
      "When x-forwarded-for header exists, use the last IP in the chain",
      "When no valid IP can be determined, return '[REDACTED-IP-ADDRESS]'"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "HttpRequest": {
        "type": "object",
        "properties": {
          "headers": {
            "type": "object",
            "description": "Collection of HTTP headers"
          },
          "remoteAddress": {
            "type": "string",
            "description": "Direct IP address of the connecting client"
          }
        }
      }
    }
  },
  {
    "featureName": "ResolveContextPath",
    "description": "Retrieves the application context path with support for proxied environments.",
    "inputValues": [
      "request-object-HttpServletRequest"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the HttpServletRequest object\n   - Identify if a proxied context path configuration exists in system settings\n\n2. Data Validation:\n   - Verify that the request object is not null\n   - Check if the system configuration for proxied context path is accessible\n   - Validate that context path information can be retrieved from the request\n\n3. Business Rule Processing:\n   - Determine if the application is running behind a proxy\n   - Check if a custom proxied context path has been configured in the system\n   - Establish the priority between standard context path and proxied context path\n\n4. Core Operation Execution:\n   - Retrieve the standard context path from the request\n   - Check if a proxied context path is configured in system settings\n   - IF proxied context path exists and is not empty:\n     - Use the proxied context path as the effective context path\n   - ELSE:\n     - Use the standard context path as the effective context path\n\n5. Response Generation:\n   - Return the resolved context path string\n   - Ensure the path is properly formatted for use in URL construction\n   - Handle any unexpected conditions by providing appropriate fallback values",
    "databaseEntities": [],
    "validationRules": [
      "Request object must not be null",
      "Context path must be a valid string",
      "Proxied context path configuration must be properly formatted if present"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "HttpServletRequest": {
        "type": "object",
        "properties": {
          "contextPath": {
            "type": "string",
            "description": "The context path of the application"
          },
          "headers": {
            "type": "object",
            "description": "Request headers"
          }
        }
      }
    }
  },
  {
    "featureName": "SetResponseContentLength",
    "description": "Sets the content length of the HTTP response.",
    "inputValues": [
      "contentLength-number-Response"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the content length value (number) from the caller\n   - The content length is mandatory\n   - No default value is provided\n\n2. Data Validation:\n   - Validate the content length value\n     - Ensure the content length is a positive integer\n     - IF content length is negative or zero THEN\n       - Generate an error indicating invalid content length\n       - Abort the operation\n     - END IF\n   - Ensure the content length value is within acceptable range\n     - IF content length exceeds system maximum allowed size THEN\n       - Generate a warning or error based on system configuration\n       - Consider truncation or rejection based on system policy\n     - END IF\n\n3. Business Rule Processing:\n   - Check if response is still modifiable\n     - IF response has already been committed THEN\n       - Log warning that content length cannot be modified\n       - Abort the operation\n     - END IF\n   - Determine if setting content length is appropriate for current response type\n     - IF response is using chunked encoding THEN\n       - Log information that content length might be ignored\n     - END IF\n\n4. Core Operation Execution:\n   - Apply the content length value to the response\n   - Update internal response state to reflect the new content length\n   - Record the change in any relevant logging or monitoring systems\n   - IF operation fails due to system constraints THEN\n     - Log the failure reason\n     - Provide appropriate error information\n   - END IF\n\n5. Response Generation:\n   - Return success indication if content length was set successfully\n   - IF any errors occurred during the process THEN\n     - Return appropriate error information\n     - Include details about why the operation failed\n   - END IF",
    "databaseEntities": [],
    "validationRules": [
      "Content length must be a positive integer",
      "Content length must not exceed system maximum allowed size",
      "Response must not be already committed before setting content length"
    ],
    "dbSeedingOperations": [],
    "schema": {}
  },
  {
    "featureName": "CheckResponseHeader",
    "description": "Checks if a specific header exists in the HTTP response.",
    "inputValues": [
      "headerName-string-Header"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the required header name (string) to check for in the response\n   - The header name is mandatory and must be provided as a non-empty string\n\n2. Data Validation:\n   - Validate the header name input:\n     a. Check if the header name is not null\n     b. Check if the header name is not an empty string\n     c. IF header name is null or empty THEN\n        - Generate an error indicating that a valid header name must be provided\n        - Terminate the operation and return error\n     d. ELSE continue to the next step\n\n3. Business Rule Processing:\n   - Verify the response context is properly initialized:\n     a. Check if the response context object exists\n     b. IF response context is null THEN\n        - Generate an error indicating that the response context is not available\n        - Terminate the operation and return error\n     c. ELSE continue to the next step\n\n4. Core Operation Execution:\n   - Check for the existence of the specified header:\n     a. Query the response context for the specified header name\n     b. Determine if the header exists in the current response\n     c. Store the result (true if header exists, false if not)\n\n5. Response Generation:\n   - Return the header existence check result:\n     a. IF header exists THEN\n        - Return a success response with value true\n        - Include the header name that was found\n     b. ELSE\n        - Return a success response with value false\n        - Include the header name that was not found\n     c. Include any additional context information if needed",
    "databaseEntities": [],
    "validationRules": [
      "Header name must not be null or empty",
      "Response context must be properly initialized"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Header": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "description": "The name of the HTTP header to check"
          }
        },
        "required": [
          "name"
        ]
      }
    }
  },
  {
    "featureName": "SetResponseHeader",
    "description": "Sets a header with specified name and value in the HTTP response.",
    "inputValues": [
      "name-string-Header",
      "value-string-HeaderValue"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the following required inputs:\n     a. name (string): The name of the header to be set\n     b. value (string): The value to be assigned to the header\n   - Both fields are mandatory\n   - No default values are provided\n\n2. Data Validation:\n   - Validate header name:\n     a. Check if name is not null or empty\n     b. Verify name follows valid HTTP header format (contains only valid characters)\n     c. Generate error message if name is invalid: \"Header name cannot be empty or contain invalid characters\"\n   - Validate header value:\n     a. Check if value is not null\n     b. Verify value contains only valid characters for HTTP header values\n     c. Generate error message if value is invalid: \"Header value contains invalid characters\"\n\n3. Business Rule Processing:\n   - Check if response context is available and active:\n     a. Verify the response has not been committed yet\n     b. IF response is already committed THEN\n        i. Generate error: \"Cannot set header after response has been committed\"\n        ii. Abort operation\n     c. ELSE continue processing\n   - Check if header with same name already exists:\n     a. IF header exists and should not be overwritten THEN\n        i. Generate warning: \"Header already exists and will be overwritten\"\n\n4. Core Operation Execution:\n   - Set the header in the response:\n     a. Add the header name and value to the response\n     b. IF operation fails THEN\n        i. Generate error: \"Failed to set response header\"\n        ii. Log the error details\n     c. ELSE mark operation as successful\n\n5. Response Generation:\n   - For successful operation:\n     a. Return success status indicating header was set\n     b. Include confirmation that header was added to response\n   - For failed operation:\n     a. Return failure status with appropriate error message\n     b. Include details about which validation or business rule failed",
    "databaseEntities": [],
    "validationRules": [
      "Header name must not be empty",
      "Header name must follow valid HTTP header format",
      "Header value must not be null",
      "Header value must contain only valid characters for HTTP headers",
      "Response must not be already committed"
    ],
    "dbSeedingOperations": [],
    "schema": {}
  },
  {
    "featureName": "AddResponseCookie",
    "description": "Adds a cookie to the HTTP response.",
    "inputValues": [
      "cookie-object-Cookie"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the cookie object with the following properties:\n     - name: The name of the cookie (mandatory)\n     - value: The value to store in the cookie (mandatory)\n     - maxAge: The maximum age of the cookie in seconds (optional)\n     - path: The path on the server where the cookie will be available (optional)\n     - domain: The domain where the cookie will be available (optional)\n     - secure: Whether the cookie should only be transmitted over secure protocol (optional, default: false)\n     - httpOnly: Whether the cookie should be accessible only through HTTP protocol (optional, default: false)\n\n2. Data Validation:\n   - Validate cookie name:\n     - Check if the name is not null or empty\n     - Verify the name does not contain invalid characters or spaces\n     - Ensure the name complies with cookie naming conventions\n     - IF validation fails, THEN generate appropriate error message\n   - Validate cookie value:\n     - Check if the value is properly formatted\n     - Ensure the value does not exceed maximum allowed length\n     - IF validation fails, THEN generate appropriate error message\n   - Validate optional parameters if provided:\n     - Ensure maxAge is a valid integer\n     - Verify path follows valid URL path format\n     - Check domain follows valid domain name format\n     - Confirm secure and httpOnly are boolean values\n     - IF any validation fails, THEN generate appropriate error message\n\n3. Business Rule Processing:\n   - Check system cookie policy compliance:\n     - Verify the cookie complies with the system's cookie policy\n     - Check if similar cookies already exist that might conflict\n     - Determine if cookie size is within acceptable limits\n     - IF any policy is violated, THEN generate appropriate error message\n   - Apply system-specific cookie settings:\n     - Apply default path if not specified\n     - Apply default domain if not specified\n     - Apply default security settings based on system configuration\n     - Apply default expiration settings if not specified\n\n4. Core Operation Execution:\n   - Create the cookie object with all validated parameters\n   - Add the cookie to the HTTP response\n   - Record cookie creation in system logs if required\n   - IF cookie cannot be added to response, THEN:\n     - Generate appropriate error message\n     - Log the failure\n     - Notify the caller of the failure\n\n5. Response Generation:\n   - Generate success response:\n     - Indicate the cookie was successfully added\n     - Include cookie details in the response if required\n     - Provide any additional information about the cookie's behavior\n   - IF operation failed, THEN:\n     - Include detailed error information\n     - Provide suggestions for resolving the issue\n     - Include support information if needed",
    "databaseEntities": [],
    "validationRules": [
      "Cookie name must not be null or empty",
      "Cookie name must follow valid naming conventions",
      "Cookie value must not exceed maximum allowed length",
      "Cookie path must be a valid URL path if specified",
      "Cookie domain must be a valid domain name if specified",
      "Cookie maxAge must be a valid integer if specified"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Cookie": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "description": "The name of the cookie"
          },
          "value": {
            "type": "string",
            "description": "The value to store in the cookie"
          },
          "maxAge": {
            "type": "integer",
            "description": "The maximum age of the cookie in seconds"
          },
          "path": {
            "type": "string",
            "description": "The path on the server where the cookie will be available"
          },
          "domain": {
            "type": "string",
            "description": "The domain where the cookie will be available"
          },
          "secure": {
            "type": "boolean",
            "description": "Whether the cookie should only be transmitted over secure protocol"
          },
          "httpOnly": {
            "type": "boolean",
            "description": "Whether the cookie should be accessible only through HTTP protocol"
          }
        },
        "required": [
          "name",
          "value"
        ]
      }
    }
  },
  {
    "featureName": "EncodeRedirectURL",
    "description": "Encodes a URL for HTTP redirect with session tracking if needed.",
    "inputValues": [
      "url-string-URL",
      "redirectConfig-object-RedirectConfiguration"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the URL to be encoded (mandatory)\n   - Retrieve redirect configuration settings (system-generated)\n     - Absolute paths flag\n     - Base URL for redirects\n\n2. Data Validation:\n   - Validate URL input\n     - Check if URL is not null or empty\n     - Verify URL format is valid\n     - IF URL is invalid THEN\n       - Generate appropriate error message\n       - Return error response\n     - END IF\n   - Validate redirect configuration\n     - Ensure configuration settings are available\n     - IF configuration is missing THEN\n       - Use system defaults\n     - END IF\n\n3. Business Rule Processing:\n   - Check if session tracking is required\n     - Determine if current user session needs to be maintained\n     - IF session tracking is needed THEN\n       - Mark URL for session encoding\n     - END IF\n   - Check redirect path configuration\n     - IF absolute paths are required THEN\n       - Analyze if the provided URL is already absolute\n       - Parse the URL to determine its structure\n     - END IF\n\n4. Core Operation Execution:\n   - Process URL for session tracking\n     - Apply session encoding to the URL if required\n   - Handle path resolution\n     - IF absolute paths are required AND URL is not absolute THEN\n       - Combine base URL with the provided URL path\n     - END IF\n   - Prepare final encoded URL\n     - Format URL according to system requirements\n     - Ensure proper character encoding\n\n5. Response Generation:\n   - Return the encoded URL\n     - Provide the fully processed URL ready for redirect\n   - IF any errors occurred during processing THEN\n     - Return appropriate error information\n     - Include guidance on correct URL format\n   - END IF",
    "databaseEntities": [
      "jforum_sessions"
    ],
    "validationRules": [
      "URL must not be null or empty",
      "URL must be properly formatted",
      "Redirect configuration must be available or defaults must be used"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "RedirectConfiguration": {
        "type": "object",
        "properties": {
          "absolutePaths": {
            "type": "boolean",
            "description": "Flag indicating if absolute paths should be used for redirects"
          },
          "baseUrl": {
            "type": "string",
            "description": "Base URL to prepend to relative paths when absolute paths are required"
          }
        }
      }
    }
  },
  {
    "featureName": "SendRedirect",
    "description": "Redirects client to a new URL with support for absolute path configuration.",
    "inputValues": [
      "location-string-RedirectLocation"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the target location URL (string) to redirect the client to\n   - Determine if absolute path configuration is enabled (system setting)\n   - If absolute paths are enabled, retrieve the base URL from system configuration\n\n2. Data Validation:\n   - Validate that the location string is not null or empty\n     * IF location is null or empty THEN\n       - Generate an error indicating invalid redirect location\n       - Abort the redirect operation\n     * END IF\n   - Validate that the location string is properly formatted\n     * IF location contains invalid URL characters THEN\n       - Generate an error indicating malformed URL\n       - Abort the redirect operation\n     * END IF\n\n3. Business Rule Processing:\n   - Check if absolute path configuration is enabled\n     * IF absolute path configuration is enabled THEN\n       - Parse the provided location as a URI\n       - Check if the URI is already absolute\n         * IF URI is not absolute THEN\n           - Prepend the system-configured base URL to the location\n         * END IF\n     * END IF\n   - Determine if URL encoding is required for the redirect\n     * IF URL contains special characters that need encoding THEN\n       - Apply URL encoding to ensure proper redirect handling\n     * END IF\n\n4. Core Operation Execution:\n   - Prepare the final redirect URL with all necessary modifications\n   - Set any required response headers for the redirect operation\n   - Execute the redirect operation to the target location\n   - Handle any potential errors during the redirect process\n     * IF redirect operation fails THEN\n       - Log the failure reason\n       - Generate appropriate error response\n     * END IF\n\n5. Response Generation:\n   - Set the appropriate HTTP status code for redirect (typically 302)\n   - Include the Location header with the final redirect URL\n   - Ensure all browser cache directives are properly set\n   - Complete the response processing\n     * IF successful THEN\n       - Client will be redirected to the target location\n     * ELSE\n       - Return error details to the client\n     * END IF",
    "databaseEntities": [],
    "validationRules": [
      "Redirect location must not be null or empty",
      "Redirect location must be a properly formatted URL",
      "If absolute paths are enabled, non-absolute URLs must be prefixed with the base URL"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "RedirectLocation": {
        "type": "string",
        "description": "The URL to which the client will be redirected"
      }
    }
  },
  {
    "featureName": "GetResponseEncoding",
    "description": "Retrieves the character encoding of the HTTP response.",
    "inputValues": [
      "response-object-HttpResponse"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the HTTP response object\n     - The response object is required and must be valid\n     - No additional input parameters are needed\n\n2. Data Validation:\n   - Validate HTTP response object\n     - Check if the response object is not null\n     - IF response object is null THEN\n       - Generate an error indicating invalid response object\n       - Return appropriate error message\n     - END IF\n\n3. Business Rule Processing:\n   - Verify response state\n     - Check if the response is in a valid state to retrieve encoding\n     - IF response has been committed or closed THEN\n       - Log warning about retrieving encoding from committed response\n     - END IF\n\n4. Core Operation Execution:\n   - Retrieve character encoding\n     - Access the character encoding property from the response object\n     - IF encoding is not explicitly set THEN\n       - Return the default encoding used by the system\n     - ELSE\n       - Return the explicitly set encoding value\n     - END IF\n\n5. Response Generation:\n   - Format the encoding information\n     - Return the character encoding as a string value\n     - IF encoding could not be determined THEN\n       - Return null or appropriate indication of unavailable encoding\n     - END IF",
    "databaseEntities": [],
    "validationRules": [
      "Response object must not be null",
      "Response must be in a valid state to retrieve encoding"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "HttpResponse": {
        "type": "object",
        "properties": {
          "characterEncoding": {
            "type": "string",
            "description": "The character encoding of the HTTP response"
          }
        }
      }
    }
  },
  {
    "featureName": "SetContentType",
    "description": "Sets the content type of the HTTP response.",
    "inputValues": [
      "type-string-ContentType"
    ],
    "businessLogic": "1. Input Collection\n   - Collect the content type string parameter\n     1.1. Receive the content type string (e.g., \"text/html\", \"application/json\")\n     1.2. Determine if the content type is system-provided or user-specified\n     1.3. Check if character encoding information is included in the content type\n\n2. Data Validation\n   - Validate the content type string\n     2.1. Check if the content type string is not null or empty\n        IF content type is null or empty THEN\n          Generate validation error: \"Content type cannot be empty\"\n     2.2. Verify the content type follows standard MIME type format\n        IF content type format is invalid THEN\n          Generate validation error: \"Invalid content type format\"\n     2.3. Check if the content type is supported by the system\n        IF content type is not supported THEN\n          Generate warning: \"Content type may not be recognized by all clients\"\n\n3. Business Rule Processing\n   - Process content type related business rules\n     3.1. Check if response headers have already been sent\n        IF headers already sent THEN\n          Generate error: \"Cannot set content type after response headers have been sent\"\n     3.2. Check if content type conflicts with any previously set response properties\n        IF conflict exists THEN\n          Generate warning: \"Content type conflicts with previous response settings\"\n     3.3. Determine if character encoding needs to be preserved or updated\n        IF character encoding exists AND should be preserved THEN\n          Ensure content type doesn't override existing character encoding\n\n4. Core Operation Execution\n   - Set the content type on the response\n     4.1. Apply the content type to the response object\n     4.2. Update any related response metadata if necessary\n     4.3. Log the content type change if system logging is enabled\n     4.4. IF operation fails THEN\n          Record failure reason\n          Generate appropriate error message\n\n5. Response Generation\n   - Complete the content type setting operation\n     5.1. IF content type was successfully set THEN\n          Return success status\n          Prepare system for subsequent response operations\n     5.2. IF content type setting failed THEN\n          Return error status with details\n          Provide guidance on resolving the issue",
    "databaseEntities": [],
    "validationRules": [
      "Content type string must not be null or empty",
      "Content type should follow standard MIME type format",
      "Content type must be set before response headers are sent",
      "Content type should be compatible with the response data"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "ContentType": {
        "type": "object",
        "properties": {
          "mimeType": {
            "type": "string",
            "description": "The MIME type of the content"
          },
          "charset": {
            "type": "string",
            "description": "Optional character encoding for the content"
          }
        },
        "required": [
          "mimeType"
        ]
      }
    }
  },
  {
    "featureName": "GetOutputStream",
    "description": "Retrieves the output stream for writing binary data to the response.",
    "inputValues": [
      "response-object-HttpServletResponse"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the HttpServletResponse object\n   - Verify the response object is not null\n   \n2. Data Validation:\n   - Validate that the response object is properly initialized\n   - Ensure the response is still open and available for writing\n   - Verify that the output stream has not been previously obtained\n   \n3. Business Rule Processing:\n   - Check if response headers have been set\n   - IF headers are not set:\n     a. Set default content type if needed\n     b. Set appropriate character encoding if needed\n   - Verify that the writer has not been obtained already\n   - IF writer has been obtained:\n     a. Throw appropriate error as both writer and output stream cannot be used together\n   \n4. Core Operation Execution:\n   - Request the output stream from the response object\n   - IF output stream cannot be obtained:\n     a. Handle the failure condition\n     b. Provide appropriate error information\n   - Set any necessary stream properties\n   \n5. Response Generation:\n   - Return the obtained output stream\n   - IF an error occurred during stream acquisition:\n     a. Provide appropriate error information\n     b. Include details about why the stream could not be obtained",
    "databaseEntities": [],
    "validationRules": [
      "Response object must not be null",
      "Response must be open and available for writing",
      "Writer must not have been previously obtained from this response"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "HttpServletResponse": {
        "type": "object",
        "properties": {
          "status": {
            "type": "number",
            "description": "HTTP status code"
          },
          "headers": {
            "type": "object",
            "description": "HTTP response headers"
          },
          "contentType": {
            "type": "string",
            "description": "Content type of the response"
          },
          "characterEncoding": {
            "type": "string",
            "description": "Character encoding of the response"
          }
        }
      }
    }
  },
  {
    "featureName": "GetWriter",
    "description": "Retrieves a PrintWriter for writing character data to the response.",
    "inputValues": [
      "response-object-HttpResponse"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the HttpResponse object\n   - Verify the response object is not null\n\n2. Data Validation:\n   - Validate that the response object is properly initialized\n   - Verify that the response is still open and available for writing\n   - Check if the response has not been committed yet\n\n3. Business Rule Processing:\n   - Determine if character encoding has been set\n   - IF no character encoding is set THEN\n     - Use the default system character encoding\n   - Check if content type has been set\n   - IF no content type is set THEN\n     - Use the default content type\n\n4. Core Operation Execution:\n   - Request a PrintWriter instance from the response object\n   - IF the writer cannot be obtained THEN\n     - Generate appropriate error information\n     - Log the failure to obtain writer\n     - Return error status\n   - ELSE\n     - Prepare the writer for character output\n     - Set any required writer properties\n\n5. Response Generation:\n   - Return the PrintWriter instance to the caller\n   - IF any errors occurred during writer acquisition THEN\n     - Return appropriate error information\n     - Provide guidance on how to resolve the issue\n   - ELSE\n     - Return the successfully obtained PrintWriter",
    "databaseEntities": [],
    "validationRules": [
      "Response object must not be null",
      "Response must not be committed",
      "Response must be open for writing"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "HttpResponse": {
        "type": "object",
        "properties": {
          "characterEncoding": {
            "type": "string",
            "description": "The character encoding used for the response"
          },
          "contentType": {
            "type": "string",
            "description": "The content type of the response"
          },
          "status": {
            "type": "integer",
            "description": "The HTTP status code of the response"
          }
        }
      }
    }
  },
  {
    "featureName": "SendErrorStatus",
    "description": "Sends an error response with the specified status code.",
    "inputValues": [
      "statusCode-number-ErrorStatus"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the status code (number) to be sent as the error response\n   - The status code is mandatory and must represent a valid HTTP error status\n   - No default value is provided; the caller must specify the exact error status code\n\n2. Data Validation:\n   - Validate the status code:\n     a. Check if the status code is a valid number\n     b. Verify the status code is within the valid range for HTTP error codes (typically 400-599)\n     c. Generate appropriate internal error if the status code is invalid\n   - Validate system state:\n     a. Ensure the response has not already been committed\n     b. If response is already committed, record the failure attempt in system logs\n\n3. Business Rule Processing:\n   - Check if the current system configuration allows sending the specified error code\n   - Verify that no content has already been written to the response\n   - Determine if any special headers need to be included with this error status\n   - IF custom error pages are configured for this status code:\n     a. Prepare to serve the custom error page\n     b. Set appropriate content type for the error page\n\n4. Core Operation Execution:\n   - Set the HTTP status code in the response\n   - IF the status code requires a default error message:\n     a. Include the standard error message for this status code\n   - Update any relevant system metrics for error tracking\n   - Ensure any open resources are properly managed\n   - IF the operation fails:\n     a. Log the failure with appropriate details\n     b. Attempt to send a server error if possible\n\n5. Response Generation:\n   - Complete the error response with the specified status code\n   - Include any standard headers required for error responses\n   - IF debugging is enabled:\n     a. Include additional diagnostic information in the response\n   - Finalize the response to be returned to the client\n   - Prevent any further content from being added to the response",
    "databaseEntities": [],
    "validationRules": [
      "Status code must be a valid number",
      "Status code must be within the valid HTTP error code range (typically 400-599)",
      "Response must not already be committed before sending the error",
      "System must be in a state that allows sending error responses"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "ErrorStatus": {
        "type": "object",
        "properties": {
          "statusCode": {
            "type": "number",
            "description": "HTTP error status code to be sent in the response"
          }
        },
        "required": [
          "statusCode"
        ]
      }
    }
  },
  {
    "featureName": "AddResponseHeader",
    "description": "Adds a header with specified name and value to the HTTP response.",
    "inputValues": [
      "name-string-Header",
      "value-string-Header"
    ],
    "businessLogic": "1. Input Collection\n   - Collect the following inputs:\n     a. name (string, mandatory): The name of the header to be added\n     b. value (string, mandatory): The value to be assigned to the header\n\n2. Data Validation\n   - Validate header name:\n     a. Check if name is not null or empty\n     b. Check if name follows valid HTTP header name format (contains only valid characters)\n     c. IF validation fails, THEN generate appropriate error message\n   - Validate header value:\n     a. Check if value is not null\n     b. Check if value contains only valid characters for HTTP header values\n     c. IF validation fails, THEN generate appropriate error message\n\n3. Business Rule Processing\n   - Check system state:\n     a. Verify that response is still modifiable (headers can still be added)\n     b. IF response has already been committed, THEN generate error indicating headers cannot be modified\n   - Check for header restrictions:\n     a. Verify if the header name is allowed to be set based on system security policies\n     b. IF header name is restricted, THEN generate appropriate security error\n\n4. Core Operation Execution\n   - Process header addition:\n     a. Check if header with same name already exists\n     b. IF header exists and should be replaced, THEN replace existing header with new value\n     c. IF header should be added as additional value, THEN add as new header with same name\n     d. Add the header with specified name and value to the response\n     e. IF operation fails, THEN generate appropriate error\n\n5. Response Generation\n   - Generate success response:\n     a. Indicate successful addition of header to the response\n     b. Include confirmation of header name and value added\n   - Generate error response if applicable:\n     a. Include specific error details and reason for failure\n     b. Provide guidance on how to resolve the issue",
    "databaseEntities": [],
    "validationRules": [
      "Header name must not be null or empty",
      "Header name must follow valid HTTP header format",
      "Header value must not be null",
      "Response must not be already committed",
      "Header name must not be restricted by security policies"
    ],
    "dbSeedingOperations": [],
    "schema": {}
  },
  {
    "featureName": "GetSessionIdentifier",
    "description": "Retrieves the unique identifier for the current HTTP session.",
    "inputValues": [
      "httpSession-object-Session"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the current session object\n     - The session object is required and must be valid\n     - No user-provided inputs are needed for this operation\n\n2. Data Validation:\n   - Validate session object\n     - Check if the session object exists\n     - IF session is null THEN\n       - Generate appropriate error indicating invalid session\n       - Terminate operation\n     - ENDIF\n     - Verify session has not expired\n     - IF session has expired THEN\n       - Generate appropriate error indicating expired session\n       - Terminate operation\n     - ENDIF\n\n3. Business Rule Processing:\n   - Check session access permissions\n     - Verify the requester has appropriate permissions to access session information\n     - IF requester lacks permission THEN\n       - Generate appropriate security error\n       - Log unauthorized access attempt\n       - Terminate operation\n     - ENDIF\n\n4. Core Operation Execution:\n   - Retrieve session identifier\n     - Access the unique identifier property from the session object\n     - Store the identifier value for response\n     - IF identifier cannot be retrieved THEN\n       - Generate appropriate error indicating session identifier retrieval failure\n       - Terminate operation\n     - ENDIF\n\n5. Response Generation:\n   - Prepare success response\n     - Format the session identifier for return\n     - Include the session identifier in the response\n   - Handle potential errors\n     - Include appropriate error messages for any failures\n     - Provide guidance on resolving session-related issues",
    "databaseEntities": [
      "jforum_sessions"
    ],
    "validationRules": [
      "Session object must exist and be valid",
      "Session must not be expired",
      "Requester must have permission to access session information"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Session": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "Unique identifier for the session"
          },
          "creationTime": {
            "type": "date",
            "description": "When the session was created"
          },
          "lastAccessedTime": {
            "type": "date",
            "description": "When the session was last accessed"
          },
          "attributes": {
            "type": "object",
            "description": "Collection of session attributes"
          }
        },
        "required": [
          "id"
        ]
      }
    }
  },
  {
    "featureName": "ListSessionAttributes",
    "description": "Provides enumeration of all attribute names stored in the current session.",
    "inputValues": [
      "sessionContext-object-SessionContext"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the SessionContext object\n     - This is a mandatory input representing the current user session\n     - No default values are applicable\n\n2. Data Validation:\n   - Validate SessionContext input\n     - IF SessionContext is null THEN\n       - Generate an error indicating invalid session context\n       - Return appropriate error response\n     - END IF\n     - IF SessionContext is not active or has been invalidated THEN\n       - Generate an error indicating session has expired\n       - Return appropriate error response\n     - END IF\n\n3. Business Rule Processing:\n   - Verify session access permissions\n     - IF current user does not have permission to view session attributes THEN\n       - Generate an access denied error\n       - Return appropriate error response\n     - END IF\n   - Check session state\n     - IF session is in an inconsistent state THEN\n       - Log warning about potential session corruption\n       - Attempt to proceed with available data\n     - END IF\n\n4. Core Operation Execution:\n   - Retrieve attribute names from session\n     - Request enumeration of all attribute names from the session context\n     - Create a collection to store the attribute names\n     - WHILE more attribute names exist in the enumeration DO\n       - Get next attribute name\n       - Add attribute name to the collection\n     - END WHILE\n   - Sort attribute names (optional)\n     - IF sorting is required THEN\n       - Sort the collection of attribute names alphabetically\n     - END IF\n\n5. Response Generation:\n   - Prepare the response\n     - Create a response structure containing:\n       - The collection of attribute names\n       - Total count of attributes found\n       - Session identifier (if permitted by security policy)\n     - Return the response to the caller\n   - Handle empty results\n     - IF no attributes were found THEN\n       - Include appropriate message indicating empty session\n     - END IF",
    "databaseEntities": [
      "jforum_sessions"
    ],
    "validationRules": [
      "Session context must not be null",
      "Session must be active and not invalidated",
      "User must have permission to view session attributes"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "SessionContext": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "Unique identifier for the session"
          },
          "attributes": {
            "type": "object",
            "description": "Collection of session attributes stored as key-value pairs"
          }
        },
        "required": [
          "id",
          "attributes"
        ]
      }
    }
  },
  {
    "featureName": "AddAttachment",
    "description": "Adds a new attachment to a post.",
    "inputValues": [
      "attachment-object-Attachment",
      "postId-number-Post"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the following required inputs:\n     1.1. attachment (Attachment object): Contains all attachment information\n     1.2. postId (number): The ID of the post to attach the file to\n   - System will generate:\n     1.3. attachmentId (number): Unique identifier for the attachment\n     1.4. uploadDate (date): Current timestamp when attachment is added\n\n2. Data Validation:\n   2.1. Validate Post Existence:\n      2.1.1. Check if postId exists in the system\n      2.1.2. IF post does not exist, THEN\n         2.1.2.1. Generate error message: \"Invalid post ID\"\n         2.1.2.2. Abort operation\n   2.2. Validate Attachment Object:\n      2.2.1. Check if attachment object contains required fields:\n         - fileName (string): Must not be empty\n         - fileContent (binary data): Must not be empty\n         - fileSize (number): Must be greater than 0\n         - fileComment (string): Optional\n         - fileExtension (string): Must not be empty\n      2.2.2. IF any required field is missing, THEN\n         2.2.2.1. Generate error message: \"Incomplete attachment information\"\n         2.2.2.2. Abort operation\n   2.3. Validate File Extension:\n      2.3.1. Check if the file extension is allowed in the system\n      2.3.2. IF extension is not allowed, THEN\n         2.3.2.1. Generate error message: \"File extension not allowed\"\n         2.3.2.2. Abort operation\n   2.4. Validate File Mimetype:\n      2.4.1. Check if the file mimetype is consistent with the extension\n      2.4.2. IF mimetype is inconsistent or invalid, THEN\n         2.4.2.1. Generate error message: \"Invalid file type\"\n         2.4.2.2. Abort operation\n\n3. Business Rule Processing:\n   3.1. Check User Permissions:\n      3.1.1. Verify current user has permission to add attachments to the post\n      3.1.2. IF user lacks permission, THEN\n         3.1.2.1. Generate error message: \"Insufficient permissions to add attachments\"\n         3.1.2.2. Abort operation\n   3.2. Check Quota Limits:\n      3.2.1. Retrieve quota limit for user's group\n      3.2.2. Calculate total size of user's existing attachments\n      3.2.3. IF (existing attachments size + new attachment size) > quota limit, THEN\n         3.2.3.1. Generate error message: \"Quota limit exceeded\"\n         3.2.3.2. Abort operation\n   3.3. Check File Security:\n      3.3.1. Scan file for potential security threats\n      3.3.2. IF security threat detected, THEN\n         3.3.3.1. Generate error message: \"Security check failed\"\n         3.3.3.2. Abort operation\n   3.4. Check Extension Group Download Mode:\n      3.4.1. Determine if the file extension group uses physical download mode\n      3.4.2. Set appropriate download handling based on extension group settings\n\n4. Core Operation Execution:\n   4.1. Prepare Attachment Record:\n      4.1.1. Generate unique identifier for attachment\n      4.1.2. Set upload timestamp to current time\n      4.1.3. Associate attachment with provided postId and current userId\n      4.1.4. Set initial download count to zero\n   4.2. Store Attachment:\n      4.2.1. Generate a unique physical filename for storage\n      4.2.2. Save attachment file to storage system\n      4.2.3. Create database record with attachment metadata including:\n         - Physical filename (system-generated)\n         - Real filename (original user filename)\n         - Comment\n         - Mimetype\n         - Filesize\n         - Upload timestamp\n         - Extension ID\n      4.2.4. Link attachment record to post record\n   4.3. Update Post Record:\n      4.3.1. Increment attachment count for the post\n      4.3.2. Update post record to indicate it has attachments\n      4.3.3. IF update fails, THEN\n         4.3.3.1. Delete saved attachment file\n         4.3.3.2. Remove attachment database record\n         4.3.3.3. Generate error message: \"Failed to update post record\"\n         4.3.3.4. Abort operation\n\n5. Response Generation:\n   5.1. Success Response:\n      5.1.1. Generate success message: \"Attachment added successfully\"\n      5.1.2. Include attachment details in response:\n         - attachmentId\n         - fileName\n         - fileSize\n         - uploadDate\n   5.2. Error Response:\n      5.2.1. Include specific error message from validation or processing steps\n      5.2.2. Include error code for system identification\n      5.2.3. Provide guidance on how to resolve the issue",
    "databaseEntities": [
      "jforum_attachments",
      "jforum_posts",
      "jforum_extension_groups",
      "jforum_quota_limit",
      "jforum_users"
    ],
    "validationRules": [
      "Post must exist in the system",
      "File name must not be empty",
      "File content must not be empty",
      "File size must be greater than 0",
      "File extension must be allowed in the system",
      "File mimetype must be consistent with the extension",
      "User must have permission to add attachments",
      "Total attachment size must not exceed quota limit for user's group"
    ],
    "dbSeedingOperations": [
      "Ensure extension groups are defined",
      "Ensure quota limits are configured",
      "Ensure user permissions for attachments are set",
      "Ensure allowed file extensions are configured"
    ],
    "schema": {
      "Attachment": {
        "type": "object",
        "properties": {
          "id": {
            "type": "number",
            "description": "Unique identifier for the attachment"
          },
          "postId": {
            "type": "number",
            "description": "ID of the post this attachment belongs to"
          },
          "privmsgsId": {
            "type": "number",
            "description": "ID of the private message this attachment belongs to (if applicable)"
          },
          "userId": {
            "type": "number",
            "description": "ID of the user who uploaded the attachment"
          },
          "info": {
            "type": "object",
            "description": "Detailed information about the attachment",
            "properties": {
              "physicalFilename": {
                "type": "string",
                "description": "System-generated name for storing the file"
              },
              "realFilename": {
                "type": "string",
                "description": "Original name of the uploaded file"
              },
              "comment": {
                "type": "string",
                "description": "Optional comment about the attachment"
              },
              "mimetype": {
                "type": "string",
                "description": "MIME type of the file"
              },
              "filesize": {
                "type": "number",
                "description": "Size of the file in bytes"
              },
              "uploadTime": {
                "type": "date",
                "description": "Date and time when the attachment was uploaded"
              },
              "downloadCount": {
                "type": "number",
                "description": "Number of times the attachment has been downloaded"
              },
              "extension": {
                "type": "object",
                "description": "Information about the file extension",
                "properties": {
                  "id": {
                    "type": "number",
                    "description": "ID of the extension record"
                  },
                  "extension": {
                    "type": "string",
                    "description": "The file extension"
                  },
                  "allow": {
                    "type": "boolean",
                    "description": "Whether this extension is allowed"
                  },
                  "comment": {
                    "type": "string",
                    "description": "Description of the extension"
                  },
                  "extensionGroupId": {
                    "type": "number",
                    "description": "ID of the extension group this extension belongs to"
                  },
                  "uploadIcon": {
                    "type": "string",
                    "description": "Icon to display for this file type"
                  }
                }
              }
            }
          }
        },
        "required": [
          "info"
        ]
      }
    }
  },
  {
    "featureName": "UpdateAttachment",
    "description": "Updates an attachment's comment information.",
    "inputValues": [
      "attachmentId-number-Attachment",
      "comment-string-Attachment",
      "downloadCount-number-Attachment",
      "attachment-object-Attachment"
    ],
    "businessLogic": "1. Input Collection\n   - Collect the following inputs:\n     1.1. attachmentId (number, mandatory): The unique identifier of the attachment to update\n     1.2. comment (string, optional): The new comment text for the attachment\n     1.3. downloadCount (number, optional): The current download count for the attachment\n     1.4. attachment (object, optional): Complete attachment object with updated information\n\n2. Data Validation\n   - Validate all input parameters:\n     2.1. Validate attachmentId:\n         2.1.1. IF attachmentId is null or not a positive integer THEN\n             - Generate error: \"Attachment ID must be a valid positive number\"\n         2.1.2. Check if attachment exists in the system\n             - IF attachment not found THEN\n                 - Generate error: \"Attachment with the specified ID does not exist\"\n     2.2. Validate comment:\n         2.2.1. IF comment is provided THEN\n             - Check if comment length is within allowed limits\n             - IF comment exceeds maximum length THEN\n                 - Generate error: \"Comment exceeds maximum allowed length\"\n     2.3. Validate downloadCount:\n         2.3.1. IF downloadCount is provided THEN\n             - Verify downloadCount is a non-negative integer\n             - IF downloadCount is negative THEN\n                 - Generate error: \"Download count cannot be negative\"\n\n3. Business Rule Processing\n   - Verify user permissions and system state:\n     3.1. Check if the current user has permission to update the attachment\n         3.1.1. Retrieve the attachment's associated post information\n         3.1.2. Determine if current user is the owner of the post or has moderator privileges\n         3.1.3. IF user does not have permission THEN\n             - Generate error: \"You do not have permission to update this attachment\"\n     3.2. Check if the attachment is not locked or in a state that prevents updates\n         3.2.1. IF attachment is locked or cannot be modified THEN\n             - Generate error: \"This attachment cannot be modified\"\n     3.3. Verify attachment extension information is valid\n         3.3.1. IF attachment has an invalid extension THEN\n             - Generate error: \"Invalid attachment extension\"\n\n4. Core Operation Execution\n   - Update the attachment information:\n     4.1. Retrieve the existing attachment record using attachmentId\n     4.2. Update the attachment information:\n         4.2.1. IF using complete attachment object THEN\n             - Extract comment from the attachment object\n             - Extract downloadCount from the attachment object\n         4.2.2. ELSE use the provided parameters directly\n     4.3. Save the updated attachment information to the database\n         4.3.1. Update the comment field in the attachment record\n         4.3.2. Update the download count field in the attachment record\n         4.3.3. IF database update fails THEN\n             - Log the error details\n             - Roll back any partial changes\n             - Generate error: \"Failed to update attachment information\"\n\n5. Response Generation\n   - Prepare and return the operation result:\n     5.1. IF update operation was successful THEN\n         5.1.1. Generate success response with updated attachment details\n         5.1.2. Include confirmation message: \"Attachment updated successfully\"\n     5.2. ELSE\n         5.2.1. Return appropriate error message based on the failure reason\n         5.2.2. Include guidance on how to resolve the issue",
    "databaseEntities": [
      "jforum_attachments",
      "jforum_posts",
      "jforum_extension_groups"
    ],
    "validationRules": [
      "Attachment ID must be a valid positive number",
      "Attachment must exist in the system",
      "User must have permission to update the attachment",
      "Comment length must not exceed the maximum allowed length",
      "Download count must be a non-negative integer"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Attachment": {
        "type": "object",
        "properties": {
          "id": {
            "type": "number",
            "description": "Unique identifier for the attachment"
          },
          "postId": {
            "type": "number",
            "description": "ID of the post this attachment belongs to"
          },
          "privmsgsId": {
            "type": "number",
            "description": "ID of the private message this attachment belongs to"
          },
          "userId": {
            "type": "number",
            "description": "ID of the user who uploaded the attachment"
          },
          "info": {
            "type": "object",
            "description": "Detailed information about the attachment",
            "properties": {
              "comment": {
                "type": "string",
                "description": "User-provided comment for the attachment"
              },
              "downloadCount": {
                "type": "number",
                "description": "Number of times the attachment has been downloaded"
              },
              "filesize": {
                "type": "number",
                "description": "Size of the attachment file in bytes"
              },
              "mimetype": {
                "type": "string",
                "description": "MIME type of the attachment"
              },
              "physicalFilename": {
                "type": "string",
                "description": "Name of the file as stored in the system"
              },
              "realFilename": {
                "type": "string",
                "description": "Original filename of the attachment"
              },
              "uploadTime": {
                "type": "date",
                "description": "Date and time when the attachment was uploaded"
              },
              "extension": {
                "type": "object",
                "description": "Information about the file extension",
                "properties": {
                  "id": {
                    "type": "number",
                    "description": "ID of the extension"
                  }
                }
              }
            }
          }
        },
        "required": [
          "id"
        ]
      }
    }
  },
  {
    "featureName": "RemoveAttachment",
    "description": "Removes an attachment from a post.",
    "inputValues": [
      "attachmentId-number-Attachment",
      "postId-number-Post"
    ],
    "businessLogic": "1. Input Collection\n   - Collect the following inputs:\n     1.1. attachmentId (mandatory): The unique identifier of the attachment to be removed\n     1.2. postId (mandatory): The identifier of the post containing the attachment\n\n2. Data Validation\n   - Validate all input parameters:\n     2.1. Validate attachmentId:\n         2.1.1. Check if attachmentId is provided\n         2.1.2. Verify attachmentId is a positive integer\n         2.1.3. If validation fails, generate appropriate error message\n     2.2. Validate postId:\n         2.2.1. Check if postId is provided\n         2.2.2. Verify postId is a positive integer\n         2.2.3. If validation fails, generate appropriate error message\n\n3. Business Rule Processing\n   - Verify attachment exists and can be removed:\n     3.1. Check if the attachment with the given attachmentId exists in the system\n         3.1.1. IF attachment does not exist, THEN return error message \"Attachment not found\"\n     3.2. Verify the attachment belongs to the specified post\n         3.2.1. IF attachment does not belong to the specified post, THEN return error message \"Attachment does not belong to the specified post\"\n     3.3. Check if the current user has permission to remove the attachment\n         3.3.1. Determine if user is the post owner, a moderator, or an administrator\n         3.3.2. IF user lacks permission, THEN return error message \"Insufficient permissions to remove this attachment\"\n\n4. Core Operation Execution\n   - Remove the attachment from the system:\n     4.1. Retrieve the physical file information associated with the attachment\n         4.1.1. Get file path and name from attachment record\n     4.2. Delete the attachment information record from the database\n         4.2.1. Remove entry from attachment info table using attachmentId\n         4.2.2. IF database operation fails, THEN generate error and abort process\n     4.3. Delete the attachment record from the database\n         4.3.1. Remove entry from attachment table using attachmentId\n         4.3.2. IF database operation fails, THEN generate error and abort process\n     4.4. Delete the physical file from the storage system\n         4.4.1. Locate the file in the attachment storage location\n         4.4.2. Delete the file from the storage system\n         4.4.3. IF file deletion fails, log warning but continue process\n     4.5. Update post information to reflect attachment removal\n         4.5.1. Count remaining attachments for the post\n         4.5.2. Update attachment count for the post\n\n5. Response Generation\n   - Generate appropriate response based on operation outcome:\n     5.1. IF attachment removal was successful:\n         5.1.1. Return success message indicating attachment was removed\n         5.1.2. Include updated attachment count for the post\n     5.2. IF attachment removal failed:\n         5.2.1. Return error message with details about the failure\n         5.2.2. Include suggestions for resolving the issue\n         5.2.3. Provide support contact information if needed",
    "databaseEntities": [
      "jforum_attachments",
      "jforum_posts"
    ],
    "validationRules": [
      "Attachment ID must be a positive integer",
      "Post ID must be a positive integer",
      "Attachment must exist in the system",
      "Attachment must belong to the specified post",
      "User must have permission to remove the attachment"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Attachment": {
        "id": "number",
        "postId": "number",
        "privmsgsId": "number",
        "userId": "number",
        "physicalFilename": "string",
        "realFilename": "string",
        "fileComment": "string",
        "mimetype": "string",
        "filesize": "number",
        "uploadTime": "date",
        "downloadCount": "number",
        "extensionId": "number"
      },
      "Post": {
        "id": "number",
        "topicId": "number",
        "userId": "number",
        "text": "string",
        "time": "date",
        "attachmentCount": "number"
      }
    }
  },
  {
    "featureName": "GetPostAttachments",
    "description": "Retrieves all attachments associated with a specific post.",
    "inputValues": [
      "postId-number-Post",
      "forumId-number-Forum"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect postId (mandatory) from the request\n   - Collect forumId (mandatory) from the request\n   - System will use these identifiers to locate the specific post and check permissions\n\n2. Data Validation:\n   - Validate postId:\n     a. Check if postId is provided\n     b. Verify postId is a positive integer\n     c. IF validation fails, THEN prepare appropriate error message\n   - Validate forumId:\n     a. Check if forumId is provided\n     b. Verify forumId is a positive integer\n     c. IF validation fails, THEN prepare appropriate error message\n\n3. Business Rule Processing:\n   - Verify post existence:\n     a. Check if the post with the given postId exists in the system\n     b. IF post does not exist, THEN prepare \"Post not found\" error message\n   - Verify user permissions:\n     a. Check if the current user has permission to download attachments\n     b. Check if attachments are enabled for the specified forum\n     c. IF user lacks either permission, THEN return an empty list of attachments\n\n4. Core Operation Execution:\n   - Retrieve attachments:\n     a. Query the attachment repository for all attachments linked to the specified postId\n     b. For each attachment found:\n        i. Retrieve basic attachment metadata (name, size, upload date, comment)\n        ii. Determine file type and appropriate display/download method\n        iii. Check if thumbnails exist for image attachments\n        iv. Prepare attachment information for response\n     c. IF no attachments are found, prepare empty result set\n     d. IF retrieval operation fails, prepare system error message\n\n5. Response Generation:\n   - Format attachment list response:\n     a. Include total count of attachments found\n     b. For each attachment, include:\n        i. Attachment identifier\n        ii. File name (real filename)\n        iii. File size\n        iv. Upload date\n        v. File type information and extension\n        vi. Download information and physical download mode\n        vii. Comment associated with the attachment\n        viii. Thumbnail information for image attachments if available\n     c. IF operation was successful, return attachment list with success status\n     d. IF any errors occurred, return appropriate error message with error status",
    "databaseEntities": [
      "jforum_posts",
      "jforum_attachments",
      "jforum_extension_groups",
      "jforum_users",
      "jforum_groups",
      "jforum_quota_limit"
    ],
    "validationRules": [
      "Post ID must be a positive integer",
      "Forum ID must be a positive integer",
      "Post must exist in the system",
      "User must have permission to view attachments in the specified forum",
      "Attachment records must be associated with the specified post ID"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Attachment": {
        "id": "number",
        "postId": "number",
        "userId": "number",
        "info": {
          "filesize": "number",
          "comment": "string",
          "mimetype": "string",
          "realFilename": "string",
          "uploadTimeInMillis": "number",
          "physicalFilename": "string",
          "extension": {
            "extension": "string",
            "extensionGroupId": "number"
          }
        }
      },
      "QuotaLimit": {
        "id": "number",
        "size": "number",
        "sizeInBytes": "number"
      }
    }
  },
  {
    "featureName": "GetAttachmentById",
    "description": "Retrieves a specific attachment by its ID from the system.",
    "inputValues": [
      "attachmentId-number-Attachment"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the attachment ID (mandatory)\n   - System will use the current user context (system-generated)\n\n2. Data Validation:\n   - Validate attachment ID:\n     a. Check if attachment ID is provided\n     b. Verify attachment ID is a positive integer\n     c. Return appropriate error message if validation fails\n   - Validate user permissions:\n     a. Check if current user has permission to view attachments\n     b. Verify if user has access to the specific attachment\n     c. Return appropriate error message if permission check fails\n\n3. Business Rule Processing:\n   - Check system state:\n     a. Verify attachment system is enabled\n     b. Check if attachment storage is accessible\n     c. Return appropriate error if system checks fail\n   - Process access rules:\n     a. Determine if attachment is in a restricted area\n     b. Check if user has appropriate group permissions\n     c. Verify if attachment quota or restrictions apply\n     d. Return appropriate error if access is denied\n\n4. Core Operation Execution:\n   - Locate attachment record:\n     a. Search for attachment by ID in the attachment repository\n     b. If attachment not found, prepare not found response\n     c. If found, retrieve attachment metadata (name, size, type, etc.)\n   - Process attachment data:\n     a. Determine appropriate download mode (physical or inline)\n     b. Prepare attachment content for delivery\n     c. Update attachment access statistics if required\n     d. Log the attachment access event\n\n5. Response Generation:\n   - For successful retrieval:\n     a. Prepare attachment metadata (filename, size, type)\n     b. Include attachment content or reference\n     c. Include appropriate content headers\n     d. Return success status with attachment data\n   - For failed retrieval:\n     a. Generate appropriate error message\n     b. Include error code and description\n     c. Provide troubleshooting information if applicable\n     d. Return error status with details",
    "databaseEntities": [
      "jforum_attachments",
      "jforum_extension_groups",
      "jforum_users",
      "jforum_groups",
      "jforum_posts"
    ],
    "validationRules": [
      "Attachment ID must be a positive integer",
      "User must have permission to view attachments",
      "Attachment must exist in the system",
      "User must have access to the post containing the attachment",
      "Attachment system must be enabled"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Attachment": {
        "id": "number",
        "postId": "number",
        "userId": "number",
        "filename": "string",
        "filesize": "number",
        "contentType": "string",
        "comment": "string",
        "downloadCount": "number",
        "uploadTime": "date",
        "physicalFilename": "string",
        "extensionGroupId": "number"
      }
    }
  },
  {
    "featureName": "ManageQuotaLimits",
    "description": "Creates, updates, and removes quota limits for attachments.",
    "inputValues": [
      "quotaDescription-string-QuotaLimit",
      "maxFilesize-number-QuotaLimit",
      "quotaType-number-QuotaLimit",
      "quotaId-number-QuotaLimit",
      "groupId-number-Group",
      "deleteIds-object-IdArray",
      "totalRecords-number-System"
    ],
    "businessLogic": "1. Input Collection:\n   1.1. Collect the following inputs based on the operation type:\n       1.1.1. For creation: \n           - quotaDescription: descriptive name for the quota limit\n           - maxFilesize: maximum file size allowed in bytes\n           - quotaType: type identifier for the quota limit\n       1.1.2. For update: \n           - quotaId: unique identifier of the quota limit to update\n           - quotaDescription: updated descriptive name\n           - maxFilesize: updated maximum file size\n           - quotaType: updated type identifier\n       1.1.3. For deletion: \n           - deleteIds: array of quota limit IDs to be removed\n       1.1.4. For group association: \n           - groupId: identifier of the group\n           - quotaId: identifier of the quota limit to associate\n       1.1.5. System inputs:\n           - totalRecords: count of records for batch operations\n   1.2. System will track creation and modification timestamps automatically\n\n2. Data Validation:\n   2.1. Validate quota limit inputs when creating:\n       2.1.1. Verify quotaDescription is not empty and follows naming conventions\n       2.1.2. Verify maxFilesize is a positive number and within allowed system boundaries\n       2.1.3. Verify quotaType is a valid type identifier in the system\n       2.1.4. Return appropriate error message if validation fails\n   2.2. Validate quota limit inputs when updating:\n       2.2.1. Verify quotaId exists in the system\n       2.2.2. Verify quotaDescription is not empty and follows naming conventions\n       2.2.3. Verify maxFilesize is a positive number and within allowed system boundaries\n       2.2.4. Verify quotaType is a valid type identifier in the system\n       2.2.5. Return appropriate error message if validation fails\n   2.3. Validate deletion parameters:\n       2.3.1. Verify all quota limit IDs in deleteIds exist in the system\n       2.3.2. Return appropriate error message if validation fails\n   2.4. Validate group association parameters:\n       2.4.1. Verify groupId exists in the system\n       2.4.2. Verify quotaId exists in the system\n       2.4.3. Return appropriate error message if validation fails\n\n3. Business Rule Processing:\n   3.1. Check for existing quota limits with similar attributes:\n       3.1.1. IF a quota limit with the same description exists (for creation)\n              THEN warn user about potential duplicate\n   3.2. Check for quota limit usage before deletion:\n       3.2.1. IF quota limit is currently associated with any groups\n              THEN warn user about potential impact on those groups\n       3.2.2. IF quota limit is currently used by any attachments\n              THEN warn user about potential impact on those attachments\n   3.3. Verify system constraints:\n       3.3.1. Ensure the total number of quota limits doesn't exceed system capacity\n       3.3.2. Ensure the maxFilesize is within system-defined boundaries\n       3.3.3. Ensure quotaType is consistent with system requirements\n\n4. Core Operation Execution:\n   4.1. For quota limit creation:\n       4.1.1. Generate a unique identifier for the new quota limit\n       4.1.2. Create a new quota limit record with provided data:\n              - Description: quotaDescription\n              - Size: maxFilesize\n              - Type: quotaType\n       4.1.3. Store the record in the quota limits repository\n       4.1.4. IF operation fails, log the error and notify user\n   4.2. For quota limit update:\n       4.2.1. Retrieve all existing quota limit records\n       4.2.2. For each record to update (identified by quotaId):\n              - Update description with new quotaDescription\n              - Update size with new maxFilesize\n              - Update type with new quotaType\n       4.2.3. Save all updated records\n       4.2.4. IF operation fails, revert changes and notify user\n   4.3. For quota limit deletion:\n       4.3.1. Identify all quota limits to be deleted from deleteIds\n       4.3.2. Remove all identified quota limit records\n       4.3.3. Update any associations to these quota limits\n       4.3.4. IF operation fails, log the error and notify user\n   4.4. For group quota association:\n       4.4.1. IF cleaning all associations\n              THEN remove all group-quota associations\n       4.4.2. For each group-quota pair:\n              - Create or update association between specified group and quota\n       4.4.3. IF operation fails, revert changes and notify user\n\n5. Response Generation:\n   5.1. For successful operations:\n       5.1.1. Return success status\n       5.1.2. Include details of the created/updated/deleted quota limits\n       5.1.3. For listing operations, return:\n              - Complete list of quota limits\n              - List of available groups\n              - Current group-quota associations\n   5.2. For failed operations:\n       5.2.1. Return error status\n       5.2.2. Include specific error message and reason for failure\n       5.2.3. Provide guidance on how to resolve the issue",
    "databaseEntities": [
      "jforum_quota_limit",
      "jforum_groups",
      "jforum_extension_groups",
      "jforum_user_groups"
    ],
    "validationRules": [
      "Quota limit description must not be empty",
      "Quota limit size (maxFilesize) must be a positive number",
      "Quota limit type must be a valid system type",
      "Quota limit IDs must exist when performing updates or deletions",
      "Group ID must exist in the system when associating quotas",
      "Quota ID must exist in the system when associating with groups"
    ],
    "dbSeedingOperations": [
      "Create default quota limits for new installations",
      "Associate default quota limits with default user groups"
    ],
    "schema": {
      "QuotaLimit": {
        "type": "object",
        "properties": {
          "id": {
            "type": "number",
            "description": "Unique identifier for the quota limit"
          },
          "description": {
            "type": "string",
            "description": "Descriptive name for the quota limit"
          },
          "size": {
            "type": "number",
            "description": "Maximum file size allowed in bytes"
          },
          "type": {
            "type": "number",
            "description": "Type identifier for the quota limit"
          }
        },
        "required": [
          "description",
          "size",
          "type"
        ]
      },
      "IdArray": {
        "type": "array",
        "items": {
          "type": "string",
          "description": "String representation of quota limit IDs"
        }
      }
    }
  },
  {
    "featureName": "ManageGroupQuotas",
    "description": "Associates quota limits with user groups to control attachment usage.",
    "inputValues": [
      "groupId-number-Group",
      "quotaId-number-QuotaLimit",
      "groups-object-GroupList"
    ],
    "businessLogic": "1. Input Collection\n   1.1. Collect the following inputs:\n       - groupId: Identifier of the group to set quota for (mandatory for single group operations)\n       - quotaId: Identifier of the quota limit to apply (mandatory for single group operations)\n       - groups: List of groups with associated quota limits (mandatory for batch operations)\n   1.2. Determine operation type:\n       - IF single group operation THEN use groupId and quotaId\n       - IF batch operation THEN use groups list\n\n2. Data Validation\n   2.1. Validate groupId (for single operations):\n       - IF groupId is not provided THEN display error message \"Group identifier is required\"\n       - IF groupId is not a positive integer THEN display error message \"Invalid group identifier\"\n       - IF groupId does not exist in the system THEN display error message \"Group not found\"\n   2.2. Validate quotaId (for single operations):\n       - IF quotaId is not provided THEN display error message \"Quota limit identifier is required\"\n       - IF quotaId is not a positive integer THEN display error message \"Invalid quota limit identifier\"\n       - IF quotaId does not exist in the system THEN display error message \"Quota limit not found\"\n   2.3. Validate groups list (for batch operations):\n       - IF groups list is empty THEN display error message \"No groups provided\"\n       - FOR EACH group in groups list:\n           - Verify group identifier exists\n           - Verify associated quota limit identifier exists\n           - IF any validation fails THEN collect errors for all invalid entries\n\n3. Business Rule Processing\n   3.1. Check system state:\n       - Verify quota limit system is enabled\n       - IF quota system is disabled THEN display warning message \"Quota system is currently disabled\"\n   3.2. Check group eligibility:\n       - Verify group is allowed to have quota limits\n       - IF group is not eligible for quotas THEN display error message \"Selected group cannot have quota limits\"\n   3.3. Check quota limit compatibility:\n       - Verify quota limit is compatible with group type\n       - IF incompatible THEN display error message \"Selected quota limit is not compatible with this group type\"\n\n4. Core Operation Execution\n   4.1. For single group operation:\n       - Remove any existing quota associations for the specified group\n       - Create new association between group and quota limit\n       - Record the change in system logs\n   4.2. For batch operation:\n       - IF clean existing associations option is selected THEN remove all existing group quota associations\n       - FOR EACH valid group-quota pair:\n           - Remove any existing quota association for the current group\n           - Create new association between current group and its quota limit\n           - Record the change in system logs\n   4.3. Handle special cases:\n       - IF quotaId is zero or null THEN remove quota limit from group (use default system quota)\n       - Update cached quota information if caching is used\n\n5. Response Generation\n   5.1. For successful operations:\n       - Generate success message \"Quota limits successfully associated with groups\"\n       - Include summary of changes (groups affected, quota limits applied)\n       - Provide navigation options to quota management interface\n   5.2. For partially successful batch operations:\n       - Generate partial success message \"Some quota limits were successfully associated\"\n       - Include details of successful and failed associations\n       - Provide error details for failed associations\n   5.3. For failed operations:\n       - Generate appropriate error message based on failure reason\n       - Provide guidance on how to resolve the issue\n       - Maintain form data for correction",
    "databaseEntities": [
      "jforum_groups",
      "jforum_quota_limit"
    ],
    "validationRules": [
      "Group identifier must be a positive integer",
      "Group must exist in the system",
      "Quota limit identifier must be a positive integer",
      "Quota limit must exist in the system",
      "Each group can have only one quota limit assigned",
      "Special groups may have specific quota requirements"
    ],
    "dbSeedingOperations": [
      "Ensure default quota limits exist in the system",
      "Ensure system groups are properly configured"
    ],
    "schema": {
      "GroupList": {
        "type": "array",
        "items": {
          "type": "object",
          "properties": {
            "groupId": {
              "type": "number",
              "description": "Unique identifier of the group"
            },
            "quotaId": {
              "type": "number",
              "description": "Identifier of the quota limit to apply to this group"
            }
          },
          "required": [
            "groupId",
            "quotaId"
          ]
        }
      }
    }
  },
  {
    "featureName": "ManageExtensionGroups",
    "description": "Creates, updates, and removes attachment extension groups.",
    "inputValues": [
      "extensionGroup-object-AttachmentExtensionGroup",
      "extensionIds-object-ExtensionIdList",
      "operation-string-Operation"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the following inputs:\n     a. extensionGroup (mandatory): Contains details of the extension group\n        i. name: Name of the extension group\n        ii. allow: Boolean indicating if the group is allowed\n        iii. downloadMode: Integer representing download mode\n        iv. uploadIcon: Icon to be displayed for this group\n     b. extensionIds (optional): Array of extension IDs to be processed\n     c. operation (mandatory): Type of operation to perform (CREATE, UPDATE, DELETE)\n\n2. Data Validation:\n   - Validate operation type:\n     a. IF operation is not one of CREATE, UPDATE, or DELETE THEN\n        i. Return error: \"Invalid operation type. Must be CREATE, UPDATE, or DELETE.\"\n   - Validate extension group data:\n     a. IF operation is CREATE or UPDATE THEN\n        i. Verify extensionGroup.name is not empty\n           - IF empty THEN return error: \"Extension group name cannot be empty.\"\n        ii. Verify extensionGroup.name length is between 3 and 50 characters\n           - IF not THEN return error: \"Extension group name must be between 3 and 50 characters.\"\n        iii. Verify download mode is valid\n           - IF not valid THEN return error: \"Invalid download mode specified.\"\n        iv. Verify upload icon path if provided\n           - IF provided but invalid THEN return error: \"Invalid upload icon path.\"\n     b. IF operation is DELETE THEN\n        i. Verify extensionIds array is not empty\n           - IF empty THEN return error: \"No extension groups selected for deletion.\"\n\n3. Business Rule Processing:\n   - Check for existing extension groups:\n     a. IF operation is CREATE THEN\n        i. Verify extension group name does not already exist\n           - IF exists THEN return error: \"Extension group with this name already exists.\"\n     b. IF operation is UPDATE THEN\n        i. Verify extension group exists\n           - IF not exists THEN return error: \"Extension group not found.\"\n        ii. Verify no other extension group has the same name (except the current one)\n           - IF duplicate name THEN return error: \"Another extension group with this name already exists.\"\n     c. IF operation is DELETE THEN\n        i. Verify all extension groups in extensionIds exist\n           - IF any not exist THEN return error: \"One or more extension groups not found.\"\n        ii. Check if any extensions are associated with these groups\n           - IF associations exist THEN display warning: \"Deleting these groups will affect associated extensions.\"\n\n4. Core Operation Execution:\n   - Process based on operation type:\n     a. IF operation is CREATE THEN\n        i. Create new extension group record with provided details:\n           - Set name from input\n           - Set allow status (true/false)\n           - Set download mode value\n           - Set upload icon path if provided\n        ii. Generate unique identifier for the new group\n        iii. Store extension group in the system\n     b. IF operation is UPDATE THEN\n        i. Retrieve existing extension group by ID\n        ii. Update fields with new values:\n           - Update name if provided\n           - Update allow status if provided\n           - Update download mode if provided\n           - Update upload icon if provided\n        iii. Save updated extension group\n     c. IF operation is DELETE THEN\n        i. FOR EACH id in extensionIds:\n           - Locate the extension group\n           - Remove extension group from the system\n           - Update any affected extensions to remove association\n        ii. Record deletion in system logs\n\n5. Response Generation:\n   - Generate appropriate response based on operation:\n     a. IF operation is CREATE THEN\n        i. Return success message: \"Extension group created successfully.\"\n        ii. Include the newly created extension group details\n     b. IF operation is UPDATE THEN\n        i. Return success message: \"Extension group updated successfully.\"\n        ii. Include the updated extension group details\n     c. IF operation is DELETE THEN\n        i. Return success message: \"Selected extension groups deleted successfully.\"\n        ii. Include count of deleted groups\n   - IF any errors occurred during processing:\n     a. Return appropriate error message\n     b. Include details about the error and suggestions for resolution",
    "databaseEntities": [
      "jforum_extension_groups",
      "jforum_attachments"
    ],
    "validationRules": [
      "Extension group name must not be empty",
      "Extension group name must be between 3 and 50 characters",
      "Download mode must be valid",
      "Extension group name must be unique",
      "Extension IDs must exist for deletion operations",
      "Upload icon path must be valid if provided"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "AttachmentExtensionGroup": {
        "id": "number",
        "name": "string",
        "allow": "boolean",
        "downloadMode": "number",
        "uploadIcon": "string"
      },
      "ExtensionIdList": {
        "ids": "string[]"
      }
    }
  },
  {
    "featureName": "ManageExtensions",
    "description": "Creates, updates, and removes file extensions for attachments.",
    "inputValues": [
      "extension-string-AttachmentExtension",
      "extensionGroup-object-AttachmentExtensionGroup",
      "extensionIds-object-ExtensionIdList",
      "comment-string-AttachmentExtension",
      "allowUpload-boolean-AttachmentExtension",
      "extensionGroupId-number-AttachmentExtension",
      "uploadIcon-string-AttachmentExtension"
    ],
    "businessLogic": "1. Input Collection\n   1.1. Collect extension information\n       1.1.1. Extension name (mandatory string)\n       1.1.2. Extension group ID (mandatory number)\n       1.1.3. Allow upload flag (mandatory boolean)\n       1.1.4. Comment (optional string)\n       1.1.5. Upload icon (optional string)\n   1.2. For extension removal, collect extension IDs (array of numbers)\n   1.3. For extension group management, collect group information\n       1.3.1. Group name (mandatory string)\n       1.3.2. Download mode (mandatory number - physical or inline)\n       1.3.3. Allow group flag (mandatory boolean)\n       1.3.4. Upload icon (optional string)\n\n2. Data Validation\n   2.1. Validate extension information\n       2.1.1. Extension name must not be empty\n       2.1.2. Extension name must follow proper format (alphanumeric characters)\n       2.1.3. If extension name starts with a dot, remove it before processing\n       2.1.4. Extension name must be unique in the system\n       2.1.5. Extension group ID must reference an existing extension group\n   2.2. Validate extension group information\n       2.2.1. Group name must not be empty\n       2.2.2. Group name must be unique in the system\n       2.2.3. Download mode must be a valid option\n   2.3. For extension removal\n       2.3.1. Verify all extension IDs exist in the system\n       2.3.2. Check if extensions are currently in use by attachments\n   2.4. For upload icons\n       2.4.1. Verify icon path/name is valid if provided\n\n3. Business Rule Processing\n   3.1. Check system permissions\n       3.1.1. Verify user has administrative rights to manage extensions\n       3.1.2. Ensure system allows extension management at current time\n   3.2. Evaluate extension security implications\n       3.2.1. Check if extension type is potentially dangerous (executable, script, etc.)\n       3.2.2. Apply additional security restrictions if needed\n   3.3. Determine extension group compatibility\n       3.3.1. Verify extension is appropriate for the assigned group\n       3.3.2. Check if group settings are compatible with extension requirements\n   3.4. Handle batch operations\n       3.4.1. For batch updates, verify all records exist\n       3.4.2. For batch deletions, check dependencies for each item\n\n4. Core Operation Execution\n   4.1. For adding new extension\n       4.1.1. Create new extension record with provided information\n       4.1.2. Associate extension with specified extension group\n       4.1.3. Set upload permission based on allow flag\n       4.1.4. Store comment and upload icon information\n       4.1.5. Log extension creation activity\n   4.2. For updating existing extension\n       4.2.1. Retrieve existing extension record by ID\n       4.2.2. Update extension properties with new values\n       4.2.3. If extension group changed, update association\n       4.2.4. Update upload icon if provided\n       4.2.5. Log extension modification activity\n   4.3. For removing extensions\n       4.3.1. For each extension ID in the removal list:\n           4.3.1.1. Check if extension is used by any attachments\n           4.3.1.2. If used, either prevent deletion or mark as deprecated\n           4.3.1.3. If unused, remove extension record\n       4.3.2. Log extension removal activity\n   4.4. For extension group operations\n       4.4.1. For adding new group:\n           4.4.1.1. Create group record with provided information\n           4.4.1.2. Set download mode and permissions\n           4.4.1.3. Associate upload icon if provided\n       4.4.2. For updating groups:\n           4.4.2.1. Retrieve each group by ID\n           4.4.2.2. Update properties with new values\n           4.4.2.3. Update associated extensions if needed\n       4.4.3. For removing groups:\n           4.4.3.1. Check for extensions using this group\n           4.4.3.2. Either prevent deletion or reassign extensions\n           4.4.3.3. Remove group if dependencies resolved\n\n5. Response Generation\n   5.1. For successful operations\n       5.1.1. Return confirmation message with operation details\n       5.1.2. Include summary of affected extensions/groups\n       5.1.3. Provide list of updated extension security settings\n   5.2. For failed operations\n       5.2.1. Return specific error message explaining the failure reason\n       5.2.2. Include guidance on how to resolve the issue\n       5.2.3. Maintain current state of extensions/groups\n   5.3. Update extension management interface\n       5.3.1. Refresh extension list with current information\n       5.3.2. Highlight newly added or modified extensions\n       5.3.3. Remove deleted extensions from display\n       5.3.4. Update extension group associations and display",
    "databaseEntities": [
      "jforum_attachments",
      "jforum_extension_groups",
      "jforum_quota_limit"
    ],
    "validationRules": [
      "Extension name must not be empty",
      "Extension name must follow proper format (alphanumeric characters)",
      "Extension name must be unique in the system",
      "Extension group ID must reference an existing extension group",
      "Extension group name must not be empty",
      "Extension group name must be unique in the system",
      "User must have administrative rights to manage extensions",
      "Download mode must be a valid option",
      "If extension starts with a dot, it should be removed before processing"
    ],
    "dbSeedingOperations": [
      "Create default extension groups: Images, Documents, Archives, Media",
      "Add common file extensions to appropriate groups",
      "Set default security settings for each extension group"
    ],
    "schema": {
      "AttachmentExtension": {
        "id": "number",
        "extension": "string",
        "extensionGroupId": "number",
        "allowUpload": "boolean",
        "comment": "string",
        "uploadIcon": "string"
      },
      "AttachmentExtensionGroup": {
        "id": "number",
        "name": "string",
        "allow": "boolean",
        "downloadMode": "number",
        "uploadIcon": "string"
      },
      "ExtensionIdList": {
        "ids": "number[]"
      }
    }
  },
  {
    "featureName": "CheckExtensionSecurity",
    "description": "Verifies if file extensions are allowed for upload based on security settings.",
    "inputValues": [
      "fileExtension-string-Attachment",
      "securitySettings-object-SecuritySettings"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect fileExtension (string, mandatory) - The file extension to check\n   - Retrieve securitySettings (object, system-generated) - The system's security configuration for file extensions\n\n2. Data Validation:\n   - Validate fileExtension input:\n     a. Check if fileExtension is not empty\n        IF fileExtension is empty THEN\n          Return error message \"File extension cannot be empty\"\n     b. Check if fileExtension is in proper format\n        IF fileExtension does not match valid extension pattern THEN\n          Return error message \"Invalid file extension format\"\n     c. Normalize fileExtension by:\n        - Converting to lowercase\n        - Removing any leading dots\n        - Trimming whitespace\n\n3. Business Rule Processing:\n   - Check if extension security is enabled in system settings\n     IF extension security is disabled THEN\n       Return success with \"Extension security check bypassed\"\n   - Verify if the extension list is available and loaded\n     IF extension list is not available THEN\n       Log warning about missing extension configuration\n       Return error message \"Extension security configuration unavailable\"\n   - Check if the extension is in the explicitly allowed list\n     IF extension is in allowed list THEN\n       Return success with \"Extension explicitly allowed\"\n\n4. Core Operation Execution:\n   - Look up the extension in the security settings map\n     IF extension is not found in the map THEN\n       Return success with \"Extension not restricted\"\n   - Check the security flag for the extension\n     IF security flag indicates extension is allowed THEN\n       Return success with \"Extension allowed by security settings\"\n     ELSE\n       Return error with \"Extension not allowed by security settings\"\n   - Check extension group association if applicable\n     IF extension belongs to a restricted group THEN\n       Return error with \"Extension belongs to a restricted group\"\n   - Log the security check result for audit purposes\n     Record: extension, result, timestamp, and security rule applied\n\n5. Response Generation:\n   - For successful validation:\n     a. Return success status\n     b. Include allowed status flag (true)\n     c. Include any relevant extension group information\n   - For failed validation:\n     a. Return error status\n     b. Include allowed status flag (false)\n     c. Include specific reason for rejection\n     d. Include list of allowed extensions as guidance",
    "databaseEntities": [
      "jforum_attachments",
      "jforum_extension_groups"
    ],
    "validationRules": [
      "File extension must not be empty",
      "File extension must be in valid format",
      "Extension must be allowed according to security settings",
      "Extension must not belong to a restricted group"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "SecuritySettings": {
        "type": "object",
        "properties": {
          "extensionMap": {
            "type": "object",
            "description": "Map of extensions and their security status"
          },
          "securityEnabled": {
            "type": "boolean",
            "description": "Flag indicating if extension security is enabled"
          },
          "allowedExtensions": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "List of explicitly allowed extensions"
          },
          "extensionGroups": {
            "type": "object",
            "description": "Map of extension groups and their security settings"
          }
        }
      }
    }
  },
  {
    "featureName": "InsertBanlistEntry",
    "description": "Creates a new entry in the banlist system.",
    "inputValues": [
      "userId-number-Banlist",
      "email-string-Banlist",
      "ip-string-Banlist"
    ],
    "businessLogic": "1. Input Collection\n   1.1. Collect the following inputs:\n       1.1.1. userId: The ID of the user to be banned (optional)\n       1.1.2. email: The email address to be banned (optional)\n       1.1.3. ip: The IP address to be banned (optional)\n   1.2. Note on input requirements:\n       1.2.1. At least one of the three inputs must be provided\n       1.2.2. Multiple inputs can be provided simultaneously\n\n2. Data Validation\n   2.1. Validate input presence\n       2.1.1. IF userId is empty AND email is empty AND ip is empty THEN\n           2.1.1.1. Return error: \"At least one ban criterion (userId, email, or IP) must be provided.\"\n   2.2. Validate userId format\n       2.2.1. IF userId is provided THEN\n           2.2.1.1. Verify userId is a positive integer\n           2.2.1.2. IF userId is invalid THEN\n               2.2.1.2.1. Return error: \"User ID must be a valid positive number.\"\n           2.2.1.3. Verify userId exists in the system\n           2.2.1.4. IF userId does not exist THEN\n               2.2.1.4.1. Return error: \"The specified user ID does not exist in the system.\"\n   2.3. Validate email format\n       2.3.1. IF email is provided THEN\n           2.3.1.1. Verify email follows valid email format\n           2.3.1.2. IF email format is invalid THEN\n               2.3.1.2.1. Return error: \"Invalid email format.\"\n   2.4. Validate IP address format\n       2.4.1. IF ip is provided THEN\n           2.4.1.1. Verify IP follows valid IP address format\n           2.4.1.2. IF IP format is invalid THEN\n               2.4.1.2.1. Return error: \"Invalid IP address format.\"\n   2.5. Check for duplicate entries\n       2.5.1. Query existing banlist entries\n       2.5.2. IF an entry with the same userId, email, or IP already exists THEN\n           2.5.2.1. Return error: \"A ban with these criteria already exists in the system.\"\n\n3. Business Rule Processing\n   3.1. Check user permissions\n       3.1.1. Verify the current user has administrator privileges\n       3.1.2. IF user does not have administrator privileges THEN\n           3.1.2.1. Return error: \"Insufficient permissions to create ban entries.\"\n   3.2. Validate ban scope\n       3.2.1. IF ip is provided THEN\n           3.2.1.1. Check if IP range is too broad\n           3.2.1.2. IF IP range would ban too many users THEN\n               3.2.1.2.1. Return warning: \"This IP range may affect many users.\"\n   3.3. Check system constraints\n       3.3.1. Ensure the banlist system is enabled\n       3.3.2. IF banlist system is disabled THEN\n           3.3.2.1. Return error: \"The banlist system is currently disabled.\"\n\n4. Core Operation Execution\n   4.1. Create new banlist entry\n       4.1.1. Initialize a new Banlist object\n       4.1.2. Set the userId field (if provided)\n       4.1.3. Set the email field (if provided)\n       4.1.4. Set the ip field (if provided)\n       4.1.5. Record the current timestamp as creation date\n       4.1.6. Record the administrator who created the ban\n   4.2. Store the ban entry\n       4.2.1. Generate SQL statement for inserting the ban entry\n       4.2.2. Execute the database operation\n       4.2.3. Retrieve and store the generated unique identifier\n       4.2.4. IF storage fails THEN\n           4.2.4.1. Log the error details\n           4.2.4.2. Return error: \"Failed to create ban entry. Please try again.\"\n   4.3. Update related records\n       4.3.1. IF userId is provided THEN\n           4.3.1.1. Update user status to indicate they are banned\n       4.3.2. Log the ban action in the system audit log\n\n5. Response Generation\n   5.1. Generate success response\n       5.1.1. Include the ban entry ID\n       5.1.2. Include confirmation message: \"Ban entry successfully created.\"\n       5.1.3. Include the ban details (userId, email, ip)\n   5.2. Generate notification\n       5.2.1. Notify administrators about the new ban entry\n       5.2.2. Update the system ban cache if applicable\n       5.2.3. Provide options for further actions (edit ban, remove ban, view all bans)",
    "databaseEntities": [
      "jforum_banlist"
    ],
    "validationRules": [
      "At least one ban criterion (userId, email, or IP) must be provided",
      "User ID must be a valid positive number if provided",
      "Email format must be valid if provided",
      "IP address format must be valid if provided",
      "Duplicate ban entries are not allowed",
      "Only administrators can create ban entries",
      "The specified user ID must exist in the system if provided"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Banlist": {
        "id": "number",
        "userId": "number",
        "email": "string",
        "ip": "string",
        "creationDate": "date",
        "createdBy": "number"
      }
    }
  },
  {
    "featureName": "DeleteBanlistEntry",
    "description": "Removes an entry from the banlist by its ID.",
    "inputValues": [
      "banlistId-number-Banlist"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect banlistId (mandatory, number type)\n   - No default values are provided\n   - No optional fields\n   - System will use this ID to locate the specific banlist entry to delete\n\n2. Data Validation:\n   - Validate banlistId:\n     a. Check if banlistId is provided\n        IF banlistId is null or undefined THEN\n           RETURN error message \"Banlist ID is required\"\n     b. Check if banlistId is a valid number\n        IF banlistId is not a number THEN\n           RETURN error message \"Banlist ID must be a number\"\n     c. Check if banlistId is a positive integer\n        IF banlistId <= 0 THEN\n           RETURN error message \"Banlist ID must be a positive number\"\n\n3. Business Rule Processing:\n   - Verify banlist entry exists:\n     a. Check if a banlist entry with the provided ID exists in the system\n        IF no banlist entry found with the given ID THEN\n           RETURN error message \"Banlist entry not found\"\n   - Verify user has permission to delete banlist entries:\n     a. Check if the current user has administrative privileges\n        IF user does not have required permissions THEN\n           RETURN error message \"Insufficient permissions to delete banlist entries\"\n   - Check for system constraints:\n     a. Verify that the system is not in maintenance mode\n        IF system is in maintenance mode THEN\n           RETURN error message \"Operation not allowed during system maintenance\"\n\n4. Core Operation Execution:\n   - Delete the banlist entry:\n     a. Prepare the deletion operation with the specified banlist ID\n     b. Execute the deletion operation to remove the entry from the banlist\n     c. IF deletion fails due to database connection issues THEN\n          ROLLBACK any partial changes\n          RETURN error message \"Database connection error occurred\"\n     d. IF deletion fails due to constraint violations THEN\n          ROLLBACK any partial changes\n          RETURN error message \"Cannot delete banlist entry due to system constraints\"\n     e. Log the deletion action with details including:\n        - Who performed the deletion (user ID)\n        - When the deletion occurred (timestamp)\n        - What was deleted (banlist entry ID and associated information)\n\n5. Response Generation:\n   - Success response:\n     a. Generate confirmation message \"Banlist entry successfully deleted\"\n     b. Include the ID of the deleted entry in the response\n     c. Include timestamp of when the deletion was completed\n   - Error response:\n     a. Include specific error message from the validation or processing steps\n     b. Include error code for tracking purposes\n     c. Provide guidance on how to resolve the issue if applicable\n     d. Include system administrator contact information for persistent issues",
    "databaseEntities": [
      "Banlist"
    ],
    "validationRules": [
      "Banlist ID must be provided",
      "Banlist ID must be a positive number",
      "Banlist entry must exist in the system",
      "User must have administrative privileges to delete banlist entries"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Banlist": {
        "id": "number",
        "userId": "number",
        "ip": "string",
        "email": "string"
      }
    }
  },
  {
    "featureName": "GetAllBanlistEntries",
    "description": "Retrieves all entries from the banlist for administrative review and management.",
    "inputValues": [],
    "businessLogic": "1. Input Collection:\n   - No user inputs required for this operation\n   - System will use current user's authentication context for access control\n\n2. Data Validation:\n   - Validate user permissions\n     - IF user does not have administrative privileges THEN\n       - Generate permission denied error\n       - Terminate operation\n     - END IF\n\n3. Business Rule Processing:\n   - Check system state\n     - IF system is in maintenance mode THEN\n       - Generate system unavailable error\n       - Terminate operation\n     - END IF\n   - Verify banlist functionality is enabled\n     - IF banlist feature is disabled in system configuration THEN\n       - Generate feature unavailable error\n       - Terminate operation\n     - END IF\n\n4. Core Operation Execution:\n   - Retrieve all banlist entries from storage\n     - Prepare empty collection for banlist entries\n     - Retrieve all records from banlist storage\n     - FOR each banlist record found DO\n       - Create banlist entry object with the following data:\n         - Entry ID\n         - User ID (if ban is associated with a user)\n         - Email address (if email ban)\n         - IP address (if IP ban)\n       - Add entry to collection\n     - END FOR\n   - Sort banlist entries\n     - Sort entries by ID (ascending order)\n     - Apply any secondary sorting criteria if configured\n\n5. Response Generation:\n   - Prepare success response\n     - Include total count of banlist entries\n     - Include complete collection of banlist entries\n     - Include pagination metadata if applicable\n   - IF no entries found THEN\n     - Return empty collection with appropriate indicator\n   - ELSE\n     - Return populated collection of banlist entries\n   - END IF",
    "databaseEntities": [
      "Banlist"
    ],
    "validationRules": [
      "User must have administrative privileges to view banlist",
      "System must not be in maintenance mode",
      "Banlist functionality must be enabled in system configuration"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Banlist": {
        "type": "object",
        "properties": {
          "id": {
            "type": "number",
            "description": "Unique identifier for the banlist entry"
          },
          "userId": {
            "type": "number",
            "description": "ID of the user associated with this ban (if applicable)"
          },
          "email": {
            "type": "string",
            "description": "Email address that is banned (if email ban type)"
          },
          "ip": {
            "type": "string",
            "description": "IP address that is banned (if IP ban type)"
          }
        },
        "required": [
          "id"
        ]
      }
    }
  },
  {
    "featureName": "SelectBannerById",
    "description": "Retrieves a specific banner by its ID.",
    "inputValues": [
      "bannerId-number-Banner"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the banner ID (mandatory, numeric)\n   - System will use this ID to locate the specific banner\n\n2. Data Validation:\n   - Validate banner ID:\n     a. Check if banner ID is provided\n     b. Verify banner ID is a positive integer\n     c. Generate appropriate error message if validation fails\n\n3. Business Rule Processing:\n   - Check system access permissions:\n     a. Verify if current user has permission to view banner information\n     b. If permission check fails, generate appropriate error message\n   - Check banner existence:\n     a. Verify if a banner with the provided ID exists in the system\n     b. If banner does not exist, prepare appropriate not-found response\n\n4. Core Operation Execution:\n   - Retrieve banner information:\n     a. Locate the banner record using the provided ID\n     b. Extract all banner details including:\n        i. Banner name/title\n        ii. Banner description\n        iii. Display settings (placement, dimensions - width and height)\n        iv. Activity status (active/inactive)\n        v. Click and view tracking information\n        vi. URL information\n        vii. Weight value\n        viii. Type information\n        ix. Comments\n   - Handle potential retrieval issues:\n     a. If database access fails, prepare system error response\n     b. If banner data is corrupted, prepare data integrity error response\n\n5. Response Generation:\n   - For successful retrieval:\n     a. Format banner data in appropriate structure\n     b. Include all banner attributes and metadata\n     c. Include banner status information\n   - For failed retrieval:\n     a. Generate appropriate error message\n     b. Include error code and description\n     c. Provide guidance for resolution if applicable",
    "databaseEntities": [
      "Banner"
    ],
    "validationRules": [
      "Banner ID must be a positive integer",
      "Banner ID must reference an existing banner",
      "User must have permission to view banner information"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Banner": {
        "id": "number",
        "name": "string",
        "description": "string",
        "url": "string",
        "placement": "number",
        "active": "boolean",
        "width": "number",
        "height": "number",
        "clicks": "number",
        "views": "number",
        "weight": "number",
        "comment": "string",
        "type": "number"
      }
    }
  },
  {
    "featureName": "SelectAllBanners",
    "description": "Retrieves all banners from the database.",
    "inputValues": [],
    "businessLogic": "1. Input Collection:\n   - No input parameters are required for this operation\n   - System will retrieve all banner records regardless of their status\n\n2. Data Validation:\n   - Verify database connection is available\n   - IF database connection is unavailable THEN\n     - Generate appropriate error message\n     - Terminate operation\n   - END IF\n\n3. Business Rule Processing:\n   - Verify user has appropriate permissions to view banners\n   - IF user lacks required permissions THEN\n     - Generate access denied message\n     - Log unauthorized access attempt\n     - Terminate operation\n   - END IF\n   - Check system state allows banner retrieval\n   - IF system is in maintenance mode THEN\n     - Generate system unavailable message\n     - Terminate operation\n   - END IF\n\n4. Core Operation Execution:\n   - Retrieve all banner records from the database\n   - Include all banner attributes (id, name, description, placement, active status, etc.)\n   - Sort banners according to system default ordering (e.g., by placement, then by name)\n   - IF no banners exist in the database THEN\n     - Return empty collection\n   - ELSE\n     - Prepare banner collection for response\n   - END IF\n   - IF error occurs during retrieval THEN\n     - Log error details\n     - Generate appropriate error message\n     - Terminate operation\n   - END IF\n\n5. Response Generation:\n   - Format banner collection for presentation\n   - Include all relevant banner information in the response\n   - Return complete banner collection to the requester\n   - Log successful retrieval operation",
    "databaseEntities": [
      "Banner"
    ],
    "validationRules": [
      "User must have permission to view banners",
      "Database connection must be available",
      "System must not be in maintenance mode"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Banner": {
        "id": "number",
        "name": "string",
        "description": "string",
        "url": "string",
        "placement": "number",
        "active": "boolean",
        "clicks": "number",
        "views": "number",
        "weight": "number",
        "comment": "string",
        "type": "number",
        "width": "number",
        "height": "number",
        "dateCreated": "date",
        "dateExpires": "date"
      }
    }
  },
  {
    "featureName": "AddNewBanner",
    "description": "Creates a new banner in the system.",
    "inputValues": [
      "name-string-Banner",
      "comment-string-Banner",
      "active-boolean-Banner",
      "placement-number-Banner",
      "description-string-Banner",
      "clicks-number-Banner",
      "views-number-Banner",
      "url-string-Banner",
      "weight-number-Banner",
      "type-number-Banner",
      "width-number-Banner",
      "height-number-Banner"
    ],
    "businessLogic": "1. Input Collection\n   1.1. Collect the following banner information from the user:\n       - name (mandatory): The name of the banner\n       - comment (optional): A descriptive comment for the banner\n       - active (mandatory): Whether the banner is active or not\n       - placement (mandatory): The placement position number for the banner\n       - description (mandatory): Detailed description of the banner\n       - url (mandatory): The target URL when the banner is clicked\n       - weight (optional): The weight/priority of the banner, default to 1\n       - type (mandatory): The type of banner\n       - width (optional): The width of the banner in pixels\n       - height (optional): The height of the banner in pixels\n   1.2. System will initialize:\n       - clicks: Set to 0 for new banners\n       - views: Set to 0 for new banners\n\n2. Data Validation\n   2.1. Validate name field\n       2.1.1. Check if name is not empty\n       2.1.2. Check if name length is between 1 and 255 characters\n       2.1.3. IF validation fails, THEN return error message \"Banner name is required and must be between 1 and 255 characters\"\n   \n   2.2. Validate comment field\n       2.2.1. IF comment is provided, THEN check if comment length is between 1 and 255 characters\n       2.2.2. IF validation fails, THEN return error message \"Banner comment must be between 1 and 255 characters\"\n   \n   2.3. Validate placement field\n       2.3.1. Check if placement is a positive integer\n       2.3.2. IF validation fails, THEN return error message \"Banner placement must be a positive integer\"\n   \n   2.4. Validate description field\n       2.4.1. Check if description is not empty\n       2.4.2. IF validation fails, THEN return error message \"Banner description is required\"\n   \n   2.5. Validate URL field\n       2.5.1. Check if URL is not empty\n       2.5.2. Check if URL is in a valid format\n       2.5.3. IF validation fails, THEN return error message \"Banner URL is required and must be in a valid format\"\n   \n   2.6. Validate weight field\n       2.6.1. IF weight is provided, THEN check if it is a positive integer\n       2.6.2. IF validation fails, THEN return error message \"Banner weight must be a positive integer\"\n   \n   2.7. Validate type field\n       2.7.1. Check if type is a valid banner type value\n       2.7.2. IF validation fails, THEN return error message \"Invalid banner type\"\n   \n   2.8. Validate width and height fields\n       2.8.1. IF width is provided, THEN check if it is a positive integer\n       2.8.2. IF height is provided, THEN check if it is a positive integer\n       2.8.3. IF validation fails, THEN return error message \"Banner dimensions must be positive integers\"\n\n3. Business Rule Processing\n   3.1. Check system constraints\n       3.1.1. Verify if the system has reached the maximum number of allowed banners\n       3.1.2. IF maximum reached, THEN return error message \"Maximum number of banners reached\"\n   \n   3.2. Check placement availability\n       3.2.1. Determine if the requested placement has space for another banner\n       3.2.2. IF placement is full, THEN return warning message \"The selected placement already has many banners, which may affect visibility\"\n   \n   3.3. Check banner type compatibility\n       3.3.1. Verify if the banner type is supported for the selected placement\n       3.3.2. IF incompatible, THEN return error message \"Banner type is not compatible with the selected placement\"\n\n4. Core Operation Execution\n   4.1. Create banner record\n       4.1.1. Prepare banner data object with all validated fields\n       4.1.2. Set initial values for system-managed fields (clicks, views)\n       4.1.3. Generate a unique identifier for the banner\n       4.1.4. Store the banner information in the system\n       4.1.5. IF storage operation fails, THEN rollback any partial changes and return error message \"Failed to create banner\"\n   \n   4.2. Update related records\n       4.2.1. Update placement counters or related metrics if needed\n       4.2.2. IF update fails, THEN log warning but continue with banner creation\n\n5. Response Generation\n   5.1. Success response\n       5.1.1. Generate success message \"Banner successfully created\"\n       5.1.2. Include the banner ID in the response\n       5.1.3. Include a summary of the created banner details\n   \n   5.2. Error response\n       5.2.1. IF any error occurred during the process, THEN include detailed error information\n       5.2.2. Provide guidance on how to correct the error\n       5.2.3. Preserve any valid input data for re-submission",
    "databaseEntities": [
      "Banner"
    ],
    "validationRules": [
      "Banner name must not be empty",
      "Banner name must be between 1 and 255 characters",
      "Banner comment must be between 1 and 255 characters if provided",
      "Banner placement must be a positive integer",
      "Banner description must not be empty",
      "Banner URL must not be empty",
      "Banner URL must be in a valid format",
      "Banner weight must be a positive integer",
      "Banner type must be a valid value",
      "Banner width must be a positive integer if provided",
      "Banner height must be a positive integer if provided"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Banner": {
        "type": "object",
        "properties": {
          "id": {
            "type": "number",
            "description": "Unique identifier for the banner"
          },
          "name": {
            "type": "string",
            "description": "Name of the banner"
          },
          "placement": {
            "type": "number",
            "description": "Placement position number for the banner"
          },
          "description": {
            "type": "string",
            "description": "Detailed description of the banner"
          },
          "clicks": {
            "type": "number",
            "description": "Number of clicks on the banner"
          },
          "views": {
            "type": "number",
            "description": "Number of views of the banner"
          },
          "url": {
            "type": "string",
            "description": "Target URL when the banner is clicked"
          },
          "weight": {
            "type": "number",
            "description": "Weight/priority of the banner"
          },
          "active": {
            "type": "boolean",
            "description": "Whether the banner is active or not"
          },
          "comment": {
            "type": "string",
            "description": "Descriptive comment for the banner"
          },
          "type": {
            "type": "number",
            "description": "Type of banner"
          },
          "width": {
            "type": "number",
            "description": "Width of the banner in pixels"
          },
          "height": {
            "type": "number",
            "description": "Height of the banner in pixels"
          }
        },
        "required": [
          "name",
          "placement",
          "description",
          "url",
          "active",
          "type"
        ]
      }
    }
  },
  {
    "featureName": "UpdateBanner",
    "description": "Updates an existing banner's information in the system.",
    "inputValues": [
      "bannerId-number-Banner",
      "banner-object-Banner"
    ],
    "businessLogic": "1. Input Collection:\n   1.1. Collect the banner ID (mandatory) to identify which banner to update\n   1.2. Collect banner information (mandatory) containing:\n      1.2.1. Banner name (mandatory)\n      1.2.2. Banner placement (mandatory)\n      1.2.3. Banner description (optional)\n      1.2.4. Banner URL (mandatory)\n      1.2.5. Banner weight (optional)\n      1.2.6. Active status (mandatory)\n      1.2.7. Banner comment (optional)\n      1.2.8. Banner type (mandatory)\n      1.2.9. Banner width (optional)\n      1.2.10. Banner height (optional)\n      1.2.11. Views count (optional)\n      1.2.12. Clicks count (optional)\n\n2. Data Validation:\n   2.1. Validate banner ID\n      2.1.1. Check if banner ID is provided\n      2.1.2. Verify banner ID is a positive integer\n      2.1.3. IF banner ID is invalid, THEN return error message \"Invalid banner ID format\"\n   2.2. Validate banner name\n      2.2.1. Check if banner name is provided\n      2.2.2. Verify banner name is not empty\n      2.2.3. Verify banner name length is within acceptable limits (1-255 characters)\n      2.2.4. IF banner name is invalid, THEN return error message \"Banner name is required and must be between 1-255 characters\"\n   2.3. Validate banner placement\n      2.3.1. Check if placement is provided\n      2.3.2. Verify placement is a valid integer\n      2.3.3. IF placement is invalid, THEN return error message \"Banner placement is required and must be a valid integer\"\n   2.4. Validate banner URL\n      2.4.1. Check if banner URL is provided\n      2.4.2. Verify banner URL format is valid\n      2.4.3. IF banner URL is invalid, THEN return error message \"Banner URL is required and must be in valid format\"\n   2.5. Validate banner type\n      2.5.1. Check if banner type is provided\n      2.5.2. Verify banner type is a valid integer\n      2.5.3. IF banner type is invalid, THEN return error message \"Banner type is required and must be a valid integer\"\n   2.6. Validate active status\n      2.6.1. Check if active status is provided\n      2.6.2. Verify active status is a boolean value\n      2.6.3. IF active status is invalid, THEN return error message \"Active status must be provided as true or false\"\n   2.7. Validate dimensions (if provided)\n      2.7.1. Verify width is a positive integer\n      2.7.2. Verify height is a positive integer\n      2.7.3. IF dimensions are invalid, THEN return error message \"Banner dimensions must be positive integers\"\n   2.8. Validate views and clicks (if provided)\n      2.8.1. Verify views is a non-negative integer\n      2.8.2. Verify clicks is a non-negative integer\n      2.8.3. IF views or clicks are invalid, THEN return error message \"Views and clicks must be non-negative integers\"\n\n3. Business Rule Processing:\n   3.1. Check if banner exists\n      3.1.1. Search for banner with the provided ID\n      3.1.2. IF banner not found, THEN return error message \"Banner with ID {bannerId} not found\"\n   3.2. Check for system constraints\n      3.2.1. Verify user has permission to update banners\n      3.2.2. IF user lacks permission, THEN return error message \"Insufficient permissions to update banner\"\n   3.3. Check for placement conflicts\n      3.3.1. IF placement position has changed, THEN verify it doesn't conflict with system constraints\n      3.3.2. IF placement conflict exists, THEN return warning message \"This placement position already has multiple banners\"\n   3.4. Check for banner deletion constraints\n      3.4.1. Verify the banner is not currently in use by the system\n      3.4.2. IF banner cannot be modified, THEN return error message indicating why\n\n4. Core Operation Execution:\n   4.1. Prepare banner data for update\n      4.1.1. Map all provided fields to the banner entity\n      4.1.2. Preserve any existing fields that were not provided in the update\n      4.1.3. Ensure clicks and views counters are maintained correctly\n   4.2. Update banner record\n      4.2.1. Apply changes to the banner record\n      4.2.2. IF update fails, THEN revert any partial changes\n      4.2.3. Return error message if update fails\n   4.3. Update related records if necessary\n      4.3.1. Update any dependent records that reference this banner\n      4.3.2. IF related updates fail, THEN revert banner update\n      4.3.3. Return error message if related updates fail\n\n5. Response Generation:\n   5.1. Generate success response\n      5.1.1. Include confirmation message \"Banner updated successfully\"\n      5.1.2. Include updated banner details\n      5.1.3. Include timestamp of update\n      5.1.4. Return to banner listing page to show all banners including the updated one\n   5.2. Generate error response (if needed)\n      5.2.1. Include specific error message\n      5.2.2. Include error code\n      5.2.3. Include suggestions for resolution\n      5.2.4. Include contact information for support",
    "databaseEntities": [
      "Banner"
    ],
    "validationRules": [
      "Banner ID must be a positive integer",
      "Banner name is required and must be between 1-255 characters",
      "Banner URL is required and must be in valid format",
      "Banner placement is required and must be a valid integer",
      "Banner type is required and must be a valid integer",
      "Active status must be provided as true or false",
      "Banner width and height must be positive integers if provided",
      "Banner with specified ID must exist in the system",
      "User must have permission to update banners",
      "Views and clicks must be non-negative integers"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Banner": {
        "type": "object",
        "properties": {
          "id": {
            "type": "number",
            "description": "Unique identifier for the banner"
          },
          "name": {
            "type": "string",
            "description": "Name of the banner"
          },
          "placement": {
            "type": "number",
            "description": "Position where the banner should be displayed"
          },
          "description": {
            "type": "string",
            "description": "Description of the banner"
          },
          "clicks": {
            "type": "number",
            "description": "Number of times the banner has been clicked"
          },
          "views": {
            "type": "number",
            "description": "Number of times the banner has been viewed"
          },
          "url": {
            "type": "string",
            "description": "URL that the banner links to"
          },
          "weight": {
            "type": "number",
            "description": "Weight/priority of the banner for display selection"
          },
          "active": {
            "type": "boolean",
            "description": "Whether the banner is currently active"
          },
          "comment": {
            "type": "string",
            "description": "Additional comments about the banner"
          },
          "type": {
            "type": "number",
            "description": "Type of banner"
          },
          "width": {
            "type": "number",
            "description": "Width of the banner in pixels"
          },
          "height": {
            "type": "number",
            "description": "Height of the banner in pixels"
          }
        },
        "required": [
          "name",
          "placement",
          "url",
          "active",
          "type"
        ]
      }
    }
  },
  {
    "featureName": "CheckBannerDeletionEligibility",
    "description": "Verifies if a specific banner can be deleted based on system rules and dependencies.",
    "inputValues": [
      "bannerId-number-Banner"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the bannerId (mandatory, numeric identifier)\n   - System retrieves the current user's authorization level\n\n2. Data Validation:\n   - Validate bannerId:\n     a. Check if bannerId is provided\n     b. Verify bannerId is a positive integer\n     c. If validation fails, generate appropriate error message\n   - Validate user permissions:\n     a. Check if current user has banner management privileges\n     b. If user lacks permissions, return access denied message\n\n3. Business Rule Processing:\n   - Check banner existence:\n     a. Verify the banner with the provided ID exists in the system\n     b. IF banner not found, THEN return error indicating banner does not exist\n   - Check banner dependencies:\n     a. Check if banner is currently active in any placement\n     b. Check if banner is referenced by any active campaign\n     c. Check if banner is part of any scheduled promotion\n     d. IF any dependency is found, record the specific dependency type\n\n4. Core Operation Execution:\n   - Determine deletion eligibility:\n     a. IF no dependencies were found, THEN mark banner as eligible for deletion\n     b. ELSE mark banner as ineligible for deletion and compile list of blocking dependencies\n   - Record verification attempt:\n     a. Log the verification attempt with timestamp, user, and result\n     b. Update banner metadata with last verification date\n\n5. Response Generation:\n   - Prepare eligibility response:\n     a. Include boolean result indicating if banner can be deleted\n     b. IF banner cannot be deleted, include list of blocking dependencies\n     c. Include banner information summary\n   - Return formatted response to caller",
    "databaseEntities": [
      "Banner",
      "BannerPlacement",
      "Campaign",
      "Promotion"
    ],
    "validationRules": [
      "Banner ID must be a positive integer",
      "Banner must exist in the system",
      "User must have banner management privileges",
      "Banner must not be active in any placement",
      "Banner must not be referenced by any active campaign",
      "Banner must not be part of any scheduled promotion"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Banner": {
        "id": "number",
        "name": "string",
        "description": "string",
        "active": "boolean",
        "placement": "number",
        "lastVerified": "date"
      },
      "DeletionEligibilityResponse": {
        "eligible": "boolean",
        "banner": "object",
        "blockingDependencies": "array"
      }
    }
  },
  {
    "featureName": "DeleteBanner",
    "description": "Removes a banner from the system.",
    "inputValues": [
      "bannerId-number-Banner"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the bannerId (number, mandatory) to identify the banner to be deleted\n   - System will use this identifier to locate the specific banner record\n\n2. Data Validation:\n   - Validate bannerId:\n     a. Check if bannerId is provided\n     b. Verify bannerId is a positive integer\n     c. Return appropriate error message if validation fails\n     d. If bannerId is not provided, system will return to banner listing without deletion\n\n3. Business Rule Processing:\n   - Check if banner exists in the system:\n     a. Search for banner with the provided bannerId\n     b. IF banner not found THEN\n        i. Generate error message \"Banner not found\"\n        ii. Terminate the deletion process\n     c. END IF\n   - Check if banner can be deleted:\n     a. Verify no active dependencies exist for this banner\n     b. IF dependencies exist THEN\n        i. Generate error message \"Cannot delete banner with active dependencies\"\n        ii. Terminate the deletion process and return to banner listing\n     c. END IF\n\n4. Core Operation Execution:\n   - Delete the banner:\n     a. Remove banner record from the system\n     b. IF deletion fails THEN\n        i. Log the error details\n        ii. Attempt to rollback the operation\n        iii. Generate system error message\n     c. END IF\n   - Update related records if necessary:\n     a. Remove any associated files or resources\n     b. Update any placement configurations that referenced this banner\n\n5. Response Generation:\n   - On Success:\n     a. Generate success message \"Banner successfully deleted\"\n     b. Return updated list of remaining banners\n   - On Failure:\n     a. Return specific error message based on the failure point\n     b. Provide guidance on how to resolve the issue if possible\n     c. Display the error message along with the current banner listing",
    "databaseEntities": [
      "Banner"
    ],
    "validationRules": [
      "Banner ID must be a positive integer",
      "Banner must exist in the system to be deleted",
      "Banner must not have active dependencies to be deleted"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Banner": {
        "type": "object",
        "properties": {
          "id": {
            "type": "number",
            "description": "Unique identifier for the banner"
          },
          "name": {
            "type": "string",
            "description": "Name of the banner"
          },
          "placement": {
            "type": "number",
            "description": "Placement position of the banner"
          },
          "description": {
            "type": "string",
            "description": "Description of the banner"
          },
          "clicks": {
            "type": "number",
            "description": "Number of clicks the banner has received"
          },
          "views": {
            "type": "number",
            "description": "Number of times the banner has been viewed"
          },
          "url": {
            "type": "string",
            "description": "URL the banner links to"
          },
          "weight": {
            "type": "number",
            "description": "Weight determining display priority of the banner"
          },
          "active": {
            "type": "boolean",
            "description": "Whether the banner is active or not"
          },
          "comment": {
            "type": "string",
            "description": "Additional comments about the banner"
          },
          "type": {
            "type": "number",
            "description": "Type of banner"
          },
          "width": {
            "type": "number",
            "description": "Width of the banner in pixels"
          },
          "height": {
            "type": "number",
            "description": "Height of the banner in pixels"
          }
        },
        "required": [
          "id"
        ]
      }
    }
  },
  {
    "featureName": "SelectActiveBannersByPlacement",
    "description": "Retrieves active banners filtered by placement position.",
    "inputValues": [
      "placement-number-Banner"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect placement identifier (number) from the user request\n   - Placement is a mandatory field representing the position where banners should appear\n\n2. Data Validation:\n   - Validate placement input:\n     a. Verify placement is provided and not null\n     b. Ensure placement is a valid numeric value\n     c. Verify placement value is within the system's defined range\n   - IF validation fails, THEN:\n     a. Generate appropriate error message\n     b. Return error response to caller\n\n3. Business Rule Processing:\n   - Check system state for banner functionality:\n     a. Verify banner subsystem is active\n     b. Ensure user has proper permissions to view banners\n   - Verify placement exists in the system:\n     a. Check if the requested placement position is defined\n     b. Ensure the placement is currently active\n   - IF any business rule fails, THEN:\n     a. Log the validation failure\n     b. Return appropriate error response\n\n4. Core Operation Execution:\n   - Retrieve banners from data store:\n     a. Query for banners matching the specified placement\n     b. Filter results to include only active banners\n     c. Apply additional filters based on current date/time to ensure banner is within its active period\n     d. Sort banners according to priority/weight if applicable\n   - Process retrieved banners:\n     a. Format banner data for presentation\n     b. Update impression counters for retrieved banners if tracking is enabled\n   - IF no active banners found for placement, THEN:\n     a. Return empty result set\n     b. Log the absence of active banners for the placement\n\n5. Response Generation:\n   - Prepare success response:\n     a. Include list of active banners for the specified placement\n     b. Include metadata about the banners (count, placement information)\n   - Return formatted response to caller",
    "databaseEntities": [
      "Banner"
    ],
    "validationRules": [
      "Placement must be a valid numeric value",
      "Placement must be within the system's defined range",
      "Banner must be active to be included in results",
      "Banner must have matching placement value",
      "Banner must be within its active display period"
    ],
    "dbSeedingOperations": [
      "Ensure at least one active banner exists for testing",
      "Create banners with different placement values",
      "Create both active and inactive banners to verify filtering"
    ],
    "schema": {
      "Banner": {
        "id": "number",
        "name": "string",
        "description": "string",
        "url": "string",
        "placement": "number",
        "isActive": "boolean",
        "startDate": "date",
        "endDate": "date",
        "clicks": "number",
        "views": "number",
        "weight": "number",
        "comment": "string",
        "type": "number",
        "width": "number",
        "height": "number"
      }
    }
  },
  {
    "featureName": "GetCategoryById",
    "description": "Retrieves a specific forum category by its ID.",
    "inputValues": [
      "categoryId-number-Category"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the following inputs:\n     a) categoryId (number, mandatory): The unique identifier of the category to retrieve\n\n2. Data Validation:\n   - Validate the categoryId input:\n     a) Check if categoryId is provided\n        IF categoryId is missing or null THEN\n          Return error message: \"Category ID is required\"\n     b) Check if categoryId is a valid number\n        IF categoryId is not a valid number THEN\n          Return error message: \"Category ID must be a valid number\"\n     c) Check if categoryId is a positive integer\n        IF categoryId is not a positive integer THEN\n          Return error message: \"Category ID must be a positive integer\"\n\n3. Business Rule Processing:\n   - Verify the existence of the requested category:\n     a) Check if a category with the provided ID exists in the system\n        IF category does not exist THEN\n          Return error message: \"Category not found with the provided ID\"\n\n4. Core Operation Execution:\n   - Retrieve the category information:\n     a) Fetch the category record matching the provided categoryId\n     b) Include all relevant category attributes (name, description, display order, etc.)\n     c) IF category retrieval fails due to system error THEN\n          Log the error details\n          Return error message: \"Unable to retrieve category information\"\n\n5. Response Generation:\n   - Prepare the category data response:\n     a) Format the category information for presentation\n     b) Include all category attributes in the response\n     c) Return the complete category information to the requester\n     d) IF successful THEN\n          Return success message with category data\n     e) ELSE\n          Return appropriate error message",
    "databaseEntities": [
      "jforum_categories"
    ],
    "validationRules": [
      "Category ID must be provided",
      "Category ID must be a valid positive integer",
      "Category with the provided ID must exist in the system"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Category": {
        "id": "number",
        "name": "string",
        "description": "string",
        "displayOrder": "number"
      }
    }
  },
  {
    "featureName": "ListAllCategories",
    "description": "Retrieves all forum categories from the database.",
    "inputValues": [],
    "businessLogic": "1. Input Collection:\n   - No user inputs required for this feature\n   - System will retrieve all categories without filtering parameters\n\n2. Data Validation:\n   - No input validation required as there are no user inputs\n   - System will verify database connection is available\n   - IF database connection is unavailable THEN\n     - Generate appropriate error response\n     - End process\n   - END IF\n\n3. Business Rule Processing:\n   - Verify user has permission to view categories\n   - IF user does not have required permissions THEN\n     - Generate access denied response\n     - End process\n   - END IF\n   - Determine if categories should be returned with associated forums\n   - Determine if empty categories (with no forums) should be included\n   - Determine sorting order for categories (typically by display order field)\n\n4. Core Operation Execution:\n   - Retrieve all category records from the database\n   - Sort categories according to their display order\n   - FOR each category retrieved DO\n     - Populate category data structure with:\n       - Category ID\n       - Category name\n       - Category description\n       - Display order\n       - Any other category attributes\n     - IF including associated forums THEN\n       - Retrieve forums belonging to this category\n       - Add forum information to category structure\n     - END IF\n     - Add complete category to results collection\n   - END FOR\n   - IF no categories found THEN\n     - Set empty collection as result\n   - END IF\n\n5. Response Generation:\n   - Format the collection of categories into appropriate response structure\n   - Include total count of categories retrieved\n   - Return the formatted category collection\n   - IF error occurred during retrieval THEN\n     - Generate error response with appropriate message\n     - Include troubleshooting information if applicable\n   - END IF",
    "databaseEntities": [
      "jforum_categories",
      "jforum_forums"
    ],
    "validationRules": [
      "User must have permission to view categories",
      "Database connection must be available",
      "Categories must be sorted by display order"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Category": {
        "type": "object",
        "properties": {
          "id": {
            "type": "integer",
            "description": "Unique identifier for the category"
          },
          "name": {
            "type": "string",
            "description": "Name of the category"
          },
          "description": {
            "type": "string",
            "description": "Description of the category"
          },
          "displayOrder": {
            "type": "integer",
            "description": "Order in which the category should be displayed"
          },
          "forums": {
            "type": "array",
            "description": "List of forums belonging to this category",
            "items": {
              "type": "object",
              "properties": {
                "id": {
                  "type": "integer",
                  "description": "Forum identifier"
                },
                "name": {
                  "type": "string",
                  "description": "Forum name"
                }
              }
            }
          }
        }
      }
    }
  },
  {
    "featureName": "CheckCategoryDeletability",
    "description": "Verifies if a specific category can be safely deleted from the system.",
    "inputValues": [
      "categoryId-number-Category"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the categoryId (mandatory, numeric identifier)\n   - System will use this identifier to locate the specific category\n\n2. Data Validation:\n   - Validate categoryId:\n     a. Verify categoryId is not null or empty\n     b. Verify categoryId is a positive integer\n     c. IF validation fails, THEN return error message indicating invalid category identifier\n\n3. Business Rule Processing:\n   - Check category existence:\n     a. Verify the category with the provided categoryId exists in the system\n     b. IF category does not exist, THEN return error indicating category not found\n   - Check category dependencies:\n     a. Verify if the category has any associated forums\n     b. Count the number of forums linked to this category\n     c. IF forum count is greater than zero, THEN category has dependencies\n     d. Check for any other system dependencies that would prevent deletion\n\n4. Core Operation Execution:\n   - Determine deletability status:\n     a. IF no dependencies are found, THEN set deletability status to true\n     b. IF any dependencies are found, THEN set deletability status to false\n   - Record verification result:\n     a. Document the reason for the deletability status\n     b. Log the verification attempt for audit purposes\n\n5. Response Generation:\n   - Prepare response with deletability status:\n     a. Include boolean result indicating if category can be deleted\n     b. IF category cannot be deleted, THEN include reason why deletion is not possible\n     c. Include category details in the response for reference\n   - Return the final response to the requester",
    "databaseEntities": [
      "jforum_categories",
      "jforum_forums"
    ],
    "validationRules": [
      "Category ID must be a positive integer",
      "Category must exist in the system",
      "Category cannot be deleted if it has associated forums",
      "System must verify all dependencies before allowing deletion"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Category": {
        "id": "number",
        "name": "string",
        "order": "number",
        "moderated": "boolean"
      }
    }
  },
  {
    "featureName": "DeleteCategory",
    "description": "Removes a category from the system after verifying it can be safely deleted.",
    "inputValues": [
      "categoryId-number-Category"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the categoryId (mandatory, number) to identify the category to be deleted\n   - System will use the current user's session for authorization verification\n\n2. Data Validation:\n   - Validate categoryId:\n     a. Verify categoryId is not null or empty\n     b. Verify categoryId is a positive integer\n     c. Verify categoryId exists in the system by retrieving category details\n     d. If any validation fails, generate appropriate error message\n\n3. Business Rule Processing:\n   - Check user authorization:\n     a. Verify current user has administrative privileges to delete categories\n     b. If user lacks permission, generate authorization error\n   - Check if category can be deleted:\n     a. Verify the category is not in use by calling canDelete method\n     b. Check if any forums are associated with this category\n     c. IF category has associated forums or other dependencies:\n        i. Generate error message indicating category cannot be deleted due to dependencies\n        ii. Provide information about the dependencies preventing deletion\n     c. IF category can be deleted:\n        i. Proceed to deletion process\n\n4. Core Operation Execution:\n   - Delete the category:\n     a. Remove the category record from the database\n     b. Update display order of remaining categories if necessary\n     c. IF deletion fails:\n        i. Log the error details\n        ii. Roll back any partial changes\n        iii. Generate system error message\n\n5. Response Generation:\n   - For successful deletion:\n     a. Generate success message confirming category removal\n     b. Provide updated list of remaining categories\n   - For failed deletion:\n     a. Return appropriate error message based on failure reason\n     b. Provide guidance on resolving the issue if applicable",
    "databaseEntities": [
      "jforum_categories",
      "jforum_forums"
    ],
    "validationRules": [
      "Category ID must be a positive integer",
      "Category must exist in the system",
      "User must have administrative privileges to delete categories",
      "Category must not have associated forums or other dependencies"
    ],
    "dbSeedingOperations": [],
    "schema": {}
  },
  {
    "featureName": "UpdateCategory",
    "description": "Updates an existing category's information in the system.",
    "inputValues": [
      "categoryId-number-Category",
      "name-string-Category",
      "isModerated-boolean-Category",
      "category-object-Category"
    ],
    "businessLogic": "1. Input Collection:\n   1.1. Collect the following required inputs:\n       - categoryId (number): Unique identifier of the category to update\n       - name (string): New name for the category\n       - isModerated (boolean): Flag indicating if the category is moderated\n   1.2. System will retrieve the existing category information based on categoryId\n\n2. Data Validation:\n   2.1. Validate categoryId:\n       - IF categoryId is not provided or is not a positive integer THEN\n         - Generate error: \"Category ID must be a valid positive integer\"\n       - IF category with provided categoryId does not exist THEN\n         - Generate error: \"Category not found with the provided ID\"\n   2.2. Validate name:\n       - IF name is empty or null THEN\n         - Generate error: \"Category name cannot be empty\"\n       - IF name exceeds maximum allowed length THEN\n         - Generate error: \"Category name cannot exceed [maximum] characters\"\n       - IF name contains disallowed characters THEN\n         - Generate error: \"Category name contains invalid characters\"\n   2.3. Validate isModerated:\n       - IF isModerated is provided and is not a boolean value THEN\n         - Generate error: \"Moderation status must be a boolean value\"\n\n3. Business Rule Processing:\n   3.1. Check system state:\n       - Verify user has permission to update categories\n       - IF user lacks required permissions THEN\n         - Generate error: \"Insufficient permissions to update category\"\n   3.2. Check for name conflicts:\n       - IF another category (different ID) exists with the same name THEN\n         - Generate warning: \"Another category with this name already exists\"\n   3.3. Verify category relationships:\n       - Check if category has associated forums\n       - IF category has associated forums THEN\n         - Note that forums will remain associated with the updated category\n       - IF changing moderation status THEN\n         - Verify impact on existing forums within the category\n\n4. Core Operation Execution:\n   4.1. Prepare category update:\n       - Create updated category object with new information\n       - Preserve any fields not being updated\n   4.2. Execute category update:\n       - Update category record with new name\n       - Update category moderation status\n       - IF update fails THEN\n         - Generate error: \"Failed to update category information\"\n         - Log detailed error information\n   4.3. Handle related updates:\n       - IF moderation status changed THEN\n         - Update moderation status of all forums within the category\n         - Update repository to reflect the changes\n\n5. Response Generation:\n   5.1. For successful update:\n       - Generate success message: \"Category updated successfully\"\n       - Include updated category information in response\n       - Include moderation status in response\n       - Refresh the category listing to show updated information\n   5.2. For failed update:\n       - Include specific error message explaining the failure\n       - Include guidance on how to resolve the issue\n       - Provide original category information for reference",
    "databaseEntities": [
      "jforum_categories",
      "jforum_forums"
    ],
    "validationRules": [
      "Category ID must be a valid positive integer",
      "Category must exist in the system",
      "Category name cannot be empty",
      "Category name must not exceed the maximum allowed length",
      "Moderation status must be a boolean value",
      "User must have permission to update categories"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Category": {
        "type": "object",
        "properties": {
          "id": {
            "type": "number",
            "description": "Unique identifier for the category"
          },
          "name": {
            "type": "string",
            "description": "Name of the category"
          },
          "order": {
            "type": "number",
            "description": "Position of the category in display sequence"
          },
          "isModerated": {
            "type": "boolean",
            "description": "Flag indicating if the category is moderated"
          }
        },
        "required": [
          "id",
          "name"
        ]
      }
    }
  },
  {
    "featureName": "CreateCategory",
    "description": "Adds a new category to the forum system.",
    "inputValues": [
      "name-string-Category",
      "displayOrder-number-Category",
      "description-string-Category"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the following required inputs:\n     a. name (string): The name of the category to be created\n     b. displayOrder (number): The position where the category will appear in listings\n     c. description (string): Optional description of the category\n   - System will generate:\n     a. categoryId: A unique identifier for the new category\n     b. creationDate: Timestamp of category creation\n\n2. Data Validation:\n   - Validate category name:\n     a. Check if name is not empty or null\n     b. Verify name length is within acceptable limits (3-50 characters)\n     c. Check for invalid characters in the name\n     d. IF validation fails, THEN return appropriate error message\n   - Validate display order:\n     a. Ensure displayOrder is a positive integer\n     b. IF displayOrder is negative or not a number, THEN set to default value (end of list)\n   - Validate description:\n     a. IF provided, check that description length is within acceptable limits (0-255 characters)\n     b. IF validation fails, THEN return appropriate error message\n\n3. Business Rule Processing:\n   - Check user permissions:\n     a. Verify current user has administrator privileges to create categories\n     b. IF user lacks required permissions, THEN return access denied error\n   - Check system constraints:\n     a. Verify maximum number of categories has not been reached\n     b. IF system limit reached, THEN return system constraint error\n   - Check for duplicate categories:\n     a. Verify no existing category has the same name\n     b. IF duplicate found, THEN return duplicate error message\n\n4. Core Operation Execution:\n   - Prepare category data:\n     a. Create new Category object with validated inputs\n     b. Assign system-generated values (categoryId, creationDate)\n   - Save category to database:\n     a. Insert new record in categories table\n     b. Store categoryId, name, description, displayOrder, and creationDate\n     c. IF database operation fails, THEN:\n        i. Log detailed error information\n        ii. Roll back any partial changes\n        iii. Return system error message\n   - Update display order of other categories if needed:\n     a. IF specific display order was requested, THEN:\n        i. Adjust the order of existing categories to accommodate the new position\n        ii. Update all affected category records\n\n5. Response Generation:\n   - On success:\n     a. Return success status\n     b. Include the newly created category details including generated categoryId\n     c. Provide confirmation message to user\n   - On failure:\n     a. Return failure status\n     b. Include specific error code and user-friendly message\n     c. Provide guidance on how to resolve the issue if applicable",
    "databaseEntities": [
      "jforum_categories"
    ],
    "validationRules": [
      "Category name must not be empty",
      "Category name must be between 3 and 50 characters",
      "Category name must not contain invalid characters",
      "Display order must be a positive integer",
      "Description must not exceed 255 characters",
      "Category name must be unique in the system"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Category": {
        "type": "object",
        "properties": {
          "id": {
            "type": "number",
            "description": "Unique identifier for the category"
          },
          "name": {
            "type": "string",
            "description": "Name of the category"
          },
          "displayOrder": {
            "type": "number",
            "description": "Position where the category appears in listings"
          },
          "description": {
            "type": "string",
            "description": "Optional description of the category"
          },
          "creationDate": {
            "type": "date",
            "description": "Date when the category was created"
          }
        },
        "required": [
          "name",
          "displayOrder"
        ]
      }
    }
  },
  {
    "featureName": "ChangeCategoryOrderUp",
    "description": "Moves a category up in the display order by swapping its position with the category above it.",
    "inputValues": [
      "categoryId-number-Category"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect categoryId (number, mandatory) to identify the category to move up\n   - System will determine the current display order of the category\n   - System will identify the category positioned above the selected category\n\n2. Data Validation:\n   - Validate that categoryId exists in the system\n     * IF categoryId does not exist THEN\n       - Return error: \"Category not found\"\n     * END IF\n   - Validate that the category is not already at the top position\n     * IF category is already at the top position THEN\n       - Return error: \"Category is already at the top position\"\n     * END IF\n   - Validate that the system contains at least two categories\n     * IF system has fewer than two categories THEN\n       - Return error: \"Reordering requires at least two categories\"\n     * END IF\n\n3. Business Rule Processing:\n   - Retrieve the current category using the provided categoryId\n   - Determine the current display order value of the category\n   - Identify the category positioned directly above (with next lower display order value)\n     * IF no category exists above the current one THEN\n       - Return error: \"No category exists above the current one\"\n     * END IF\n   - Verify that both categories are accessible and modifiable\n     * IF either category is locked or in use by another process THEN\n       - Return error: \"Cannot modify category order at this time\"\n     * END IF\n\n4. Core Operation Execution:\n   - Begin transaction to ensure data integrity\n   - Store the display order value of the current category (currentOrder)\n   - Store the display order value of the category above (aboveOrder)\n   - Swap the display order values between the two categories:\n     * Set current category's display order to aboveOrder\n     * Set above category's display order to currentOrder\n   - Commit the transaction\n     * IF any error occurs during the swap THEN\n       - Rollback transaction\n       - Return error: \"Failed to change category order\"\n     * END IF\n\n5. Response Generation:\n   - Return success response with updated category information\n   - Include the new display order of the moved category\n   - Include the list of all categories in their new order\n   - Provide confirmation message: \"Category successfully moved up in display order\"",
    "databaseEntities": [
      "jforum_categories"
    ],
    "validationRules": [
      "Category ID must exist in the system",
      "Category must not already be at the top position",
      "System must have at least two categories",
      "Categories must be available for modification"
    ],
    "dbSeedingOperations": [],
    "schema": {}
  },
  {
    "featureName": "ChangeCategoryOrderDown",
    "description": "Moves a category down in the display order.",
    "inputValues": [
      "categoryId-number-Category"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect categoryId (mandatory, number) - The identifier of the category to move down\n   - System will determine current display order of categories\n\n2. Data Validation:\n   - Validate categoryId:\n     a. Check if categoryId is provided and is a valid number\n     b. Verify categoryId exists in the system\n     c. If validation fails, generate appropriate error message\n   - Validate category position:\n     a. Check if the category is not already at the bottom of the list\n     b. If category is already at the bottom, generate message indicating no change possible\n\n3. Business Rule Processing:\n   - Identify the category to move down (current category)\n   - Identify the category immediately below the current category (next category)\n   - Verify both categories exist and are valid for order change\n   - IF current category is the last in order:\n     a. No change is possible, prepare appropriate message\n     b. Exit the process\n\n4. Core Operation Execution:\n   - Retrieve the current display order value of both categories\n   - Swap the display order values between the current category and the next category:\n     a. Temporarily store the current category's display order\n     b. Set current category's display order to next category's display order\n     c. Set next category's display order to the stored value\n   - Update both category records with their new display order values\n   - IF any update operation fails:\n     a. Rollback any changes made\n     b. Generate appropriate error message\n\n5. Response Generation:\n   - IF operation successful:\n     a. Generate success message indicating the category was moved down\n     b. Include updated category information in response\n     c. Include refreshed category list with new order\n   - IF operation failed:\n     a. Generate appropriate error message\n     b. Include error details and possible resolution steps",
    "databaseEntities": [
      "jforum_categories"
    ],
    "validationRules": [
      "Category ID must exist in the system",
      "Category must not already be at the bottom of the list",
      "Category display order must be a positive integer"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Category": {
        "type": "object",
        "properties": {
          "id": {
            "type": "number",
            "description": "Unique identifier for the category"
          },
          "name": {
            "type": "string",
            "description": "Name of the category"
          },
          "displayOrder": {
            "type": "number",
            "description": "Position of the category in the display sequence"
          }
        },
        "required": [
          "id",
          "name",
          "displayOrder"
        ]
      }
    }
  },
  {
    "featureName": "InsertConfig",
    "description": "Inserts a new configuration entry into the system.",
    "inputValues": [
      "name-string-Config",
      "value-string-Config",
      "config-object-Config"
    ],
    "businessLogic": "1. Input Collection:\n   1.1. Collect the configuration name (mandatory string)\n      1.1.1. Name must be a valid string identifier for the configuration\n      1.1.2. Name serves as the unique identifier for the configuration\n   1.2. Collect the configuration value (mandatory string)\n      1.2.1. Value contains the actual configuration setting\n      1.2.2. Value can be any string format appropriate for the configuration type\n   1.3. Alternatively, accept a complete configuration object containing both name and value\n      1.3.1. Extract name and value properties from the provided object\n\n2. Data Validation:\n   2.1. Validate configuration name\n      2.1.1. Check if name is not empty or null\n      2.1.2. Check if name follows the allowed naming pattern\n      2.1.3. IF validation fails, THEN prepare appropriate error message\n   2.2. Validate configuration value\n      2.2.1. Check if value is not null\n      2.2.2. Check if value meets any format requirements for the specific configuration type\n      2.2.3. IF validation fails, THEN prepare appropriate error message\n\n3. Business Rule Processing:\n   3.1. Check for existing configuration with the same name\n      3.1.1. Search for configuration entries with the provided name\n      3.1.2. IF configuration with the same name exists, THEN\n         3.1.2.1. Generate a duplicate configuration error\n         3.1.2.2. Abort the insertion process\n   3.2. Verify system state allows for configuration changes\n      3.2.1. Check if the system is in a state that allows configuration modifications\n      3.2.2. IF system state does not allow changes, THEN\n         3.2.2.1. Generate a system state error\n         3.2.2.2. Abort the insertion process\n\n4. Core Operation Execution:\n   4.1. Prepare the new configuration entry\n      4.1.1. Create a new configuration record with the provided name and value\n      4.1.2. Set any default or system-generated fields\n   4.2. Save the configuration entry\n      4.2.1. Insert the new configuration into the storage system\n      4.2.2. IF insertion fails, THEN\n         4.2.2.1. Log the failure details\n         4.2.2.2. Prepare appropriate error message\n         4.2.2.3. Rollback any partial changes\n   4.3. Update any related system caches\n      4.3.1. Refresh configuration caches if applicable\n      4.3.2. Notify any dependent components about the configuration change\n\n5. Response Generation:\n   5.1. For successful insertion\n      5.1.1. Prepare success message with details of the inserted configuration\n      5.1.2. Include the identifier of the newly created configuration\n   5.2. For failed insertion\n      5.2.1. Prepare detailed error message explaining the reason for failure\n      5.2.2. Include suggestions for resolving the issue if applicable",
    "databaseEntities": [
      "Config"
    ],
    "validationRules": [
      "Configuration name must not be empty",
      "Configuration name must be unique in the system",
      "Configuration value must not be null",
      "System must be in a state that allows configuration changes"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Config": {
        "type": "object",
        "properties": {
          "id": {
            "type": "number",
            "description": "The system-generated identifier for the configuration entry"
          },
          "name": {
            "type": "string",
            "description": "The unique identifier for the configuration entry"
          },
          "value": {
            "type": "string",
            "description": "The value associated with the configuration entry"
          }
        },
        "required": [
          "name",
          "value"
        ]
      }
    }
  },
  {
    "featureName": "UpdateConfig",
    "description": "Updates an existing configuration entry in the system.",
    "inputValues": [
      "configName-string-Config",
      "configValue-string-Config",
      "configData-object-Config"
    ],
    "businessLogic": "1. Input Collection\n   1.1. Collect the following required inputs:\n       - configName: Name of the configuration parameter to be updated\n       - configValue: New value to be assigned to the configuration parameter\n   1.2. System will retrieve the existing configuration entry using the provided configName\n\n2. Data Validation\n   2.1. Validate configuration name\n       2.1.1. Check if configName is provided\n       2.1.2. Verify configName is not empty\n       2.1.3. Check if configName follows the allowed naming convention\n       2.1.4. IF configName is invalid or missing, THEN generate validation error\n   2.2. Validate configuration value\n       2.2.1. Check if configValue is provided\n       2.2.2. Verify configValue format is appropriate for the configuration type\n       2.2.3. IF configValue is invalid, THEN generate validation error\n   2.3. Verify configuration exists\n       2.3.1. Check if a configuration with the provided configName exists in the system\n       2.3.2. IF configuration does not exist, THEN generate error message indicating the configuration was not found\n\n3. Business Rule Processing\n   3.1. Check user permissions\n       3.1.1. Verify the current user has permission to modify configuration settings\n       3.1.2. IF user lacks permission, THEN generate access denied error\n   3.2. Check configuration mutability\n       3.2.1. Verify the configuration is allowed to be modified\n       3.2.2. Some system configurations may be read-only or protected\n       3.2.3. IF configuration is immutable, THEN generate appropriate error message\n   3.3. Validate configuration value against allowed ranges or patterns\n       3.3.1. Check if the new value adheres to the specific rules for this configuration type\n       3.3.2. Verify the value will not cause system instability\n       3.3.3. IF value violates any constraints, THEN generate validation error\n\n4. Core Operation Execution\n   4.1. Prepare configuration update\n       4.1.1. Create updated configuration object with new value\n       4.1.2. Preserve any fields that are not being updated\n   4.2. Update configuration in storage\n       4.2.1. Apply the changes to the configuration entry using the configName as identifier\n       4.2.2. Record the timestamp of the update\n       4.2.3. Record the user who made the change\n   4.3. Handle update results\n       4.3.1. IF update fails, THEN revert any partial changes\n       4.3.2. Generate appropriate error message for failed update\n   4.4. Update system cache if necessary\n       4.4.1. Refresh any cached configuration values\n       4.4.2. Notify dependent components about the configuration change\n\n5. Response Generation\n   5.1. For successful update\n       5.1.1. Generate success message indicating the configuration was updated\n       5.1.2. Include details of the updated configuration\n       5.1.3. Provide timestamp of the update\n   5.2. For failed update\n       5.2.1. Generate error message with details about the failure\n       5.2.2. Include suggestions for resolving the issue\n       5.2.3. Provide support information if needed",
    "databaseEntities": [
      "Config"
    ],
    "validationRules": [
      "Configuration name must not be empty",
      "Configuration name must follow the system naming convention",
      "Configuration must exist in the system to be updated",
      "User must have permission to modify configuration settings",
      "Configuration must be mutable (not read-only)",
      "Configuration value must adhere to type-specific validation rules"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Config": {
        "type": "object",
        "properties": {
          "id": {
            "type": "number",
            "description": "Unique identifier for the configuration"
          },
          "name": {
            "type": "string",
            "description": "Name of the configuration parameter"
          },
          "value": {
            "type": "string",
            "description": "Value of the configuration parameter"
          },
          "lastUpdated": {
            "type": "date",
            "description": "Timestamp of the last update"
          },
          "updatedBy": {
            "type": "string",
            "description": "User who last updated the configuration"
          }
        },
        "required": [
          "name",
          "value"
        ]
      }
    }
  },
  {
    "featureName": "DeleteConfig",
    "description": "Removes a specific configuration entry from the system.",
    "inputValues": [
      "config-object-Config"
    ],
    "businessLogic": "1. Input Collection\n   1.1. Collect the configuration object to be deleted\n       1.1.1. Verify the configuration object contains a valid identifier\n       1.1.2. Verify the configuration object contains a name property\n       1.1.3. Check if any other required properties are present\n\n2. Data Validation\n   2.1. Validate configuration object integrity\n       2.1.1. Ensure the configuration identifier is not empty\n       2.1.2. Ensure the configuration name is not empty\n       2.1.3. IF configuration identifier is invalid THEN generate appropriate error message\n       2.1.4. IF configuration name is invalid THEN generate appropriate error message\n   2.2. Validate configuration existence\n       2.2.1. Check if the configuration with the given identifier exists in the system\n       2.2.2. IF configuration does not exist THEN generate a \"Configuration not found\" error message\n\n3. Business Rule Processing\n   3.1. Check system constraints\n       3.1.1. Verify if the configuration is a system-critical configuration\n       3.1.2. IF configuration is system-critical THEN generate a \"Cannot delete system configuration\" error message\n   3.2. Check dependencies\n       3.2.1. Verify if other system components depend on this configuration\n       3.2.2. IF dependencies exist THEN generate a \"Configuration in use by other components\" error message\n   3.3. Check user permissions\n       3.3.1. Verify if the current user has permission to delete configurations\n       3.3.2. IF user lacks permission THEN generate a \"Insufficient permissions\" error message\n\n4. Core Operation Execution\n   4.1. Delete configuration\n       4.1.1. Remove the configuration entry from the system\n       4.1.2. IF deletion fails THEN generate a \"Failed to delete configuration\" error message\n       4.1.3. Log the deletion operation with details about the deleted configuration\n   4.2. Update related caches\n       4.2.1. Clear any system caches that might contain the deleted configuration\n       4.2.2. Notify relevant system components about the configuration change\n\n5. Response Generation\n   5.1. Generate success response\n       5.1.1. Create a success message indicating the configuration was deleted successfully\n       5.1.2. Include the name of the deleted configuration in the success message\n   5.2. Generate error response if applicable\n       5.2.1. Include detailed error information explaining why the deletion failed\n       5.2.2. Provide guidance on how to resolve the error if possible",
    "databaseEntities": [
      "jforum_config"
    ],
    "validationRules": [
      "Configuration identifier must not be empty",
      "Configuration name must not be empty",
      "Configuration must exist in the system before deletion",
      "System-critical configurations cannot be deleted",
      "Configurations in use by other components cannot be deleted",
      "User must have permission to delete configurations"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Config": {
        "type": "object",
        "properties": {
          "id": {
            "type": "number",
            "description": "Unique identifier for the configuration"
          },
          "name": {
            "type": "string",
            "description": "Name of the configuration"
          },
          "value": {
            "type": "string",
            "description": "Value of the configuration"
          }
        },
        "required": [
          "id",
          "name"
        ]
      }
    }
  },
  {
    "featureName": "GetAllConfigs",
    "description": "Retrieves all existing configuration entries from the system.",
    "inputValues": [],
    "businessLogic": "1. Input Collection:\n   - No user inputs required for this feature\n   - System will use current user session context for access control\n\n2. Data Validation:\n   - Validate user permissions\n     - IF user does not have sufficient permissions THEN\n       - Generate appropriate error message\n       - Terminate process\n     - END IF\n\n3. Business Rule Processing:\n   - Check system state\n     - IF system is in maintenance mode THEN\n       - Log access attempt\n       - Return appropriate notification\n       - Terminate process\n     - END IF\n   - Verify configuration access is enabled\n     - IF configuration access is disabled THEN\n       - Log access attempt\n       - Return appropriate notification\n       - Terminate process\n     - END IF\n\n4. Core Operation Execution:\n   - Retrieve all configuration entries\n     - Access configuration storage\n     - Collect all configuration records\n     - Organize configuration entries in appropriate structure\n     - IF no configuration entries exist THEN\n       - Prepare empty result set\n     - END IF\n   - Process retrieved configurations\n     - Filter sensitive configuration data based on user permissions\n     - Sort configuration entries if needed\n     - Format configuration data for presentation\n\n5. Response Generation:\n   - Prepare configuration data for return\n     - Format configuration entries in appropriate structure\n     - Include metadata (total count, etc.)\n   - Return configuration data\n     - IF operation successful THEN\n       - Return complete list of configuration entries\n       - Include success status indicator\n     - ELSE\n       - Return error details\n       - Include failure status indicator\n     - END IF",
    "databaseEntities": [
      "Config"
    ],
    "validationRules": [
      "User must have sufficient permissions to view configuration entries",
      "System must not be in maintenance mode",
      "Configuration access must be enabled"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Config": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "description": "Unique identifier for the configuration entry"
          },
          "value": {
            "type": "string",
            "description": "Value of the configuration entry"
          }
        },
        "required": [
          "name",
          "value"
        ]
      }
    }
  },
  {
    "featureName": "GetConfigByName",
    "description": "Retrieves a specific configuration entry by its name.",
    "inputValues": [
      "name-string-Config"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the configuration name (name-string) from the user\n   - The name field is mandatory\n   - No default values are provided\n\n2. Data Validation:\n   - Validate the configuration name:\n     a. Check if the name is not null or empty\n     b. Check if the name follows the allowed naming pattern\n     c. If validation fails, prepare appropriate error message\n\n3. Business Rule Processing:\n   - Check system state to ensure configuration repository is accessible\n   - Verify user has appropriate permissions to access configuration data\n   - IF access is restricted:\n     a. Verify user authorization level\n     b. Log access attempt\n     c. IF unauthorized, prepare access denied response\n\n4. Core Operation Execution:\n   - Search for the configuration entry matching the provided name\n   - IF configuration entry is found:\n     a. Retrieve the complete configuration object\n     b. Prepare the configuration data for response\n   - ELSE IF configuration entry is not found:\n     a. Record the failed lookup attempt\n     b. Prepare not-found response\n\n5. Response Generation:\n   - IF operation was successful:\n     a. Format the configuration data for presentation\n     b. Include metadata about the configuration (if available)\n     c. Return the complete configuration object\n   - ELSE:\n     a. Generate appropriate error message\n     b. Include suggestions for resolving the issue\n     c. Provide reference to available configuration options if applicable",
    "databaseEntities": [
      "Config"
    ],
    "validationRules": [
      "Configuration name must not be empty",
      "Configuration name must follow the system naming conventions",
      "User must have appropriate permissions to access configuration data"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Config": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "description": "Unique identifier for the configuration entry"
          },
          "value": {
            "type": "string",
            "description": "Value associated with the configuration entry"
          }
        },
        "required": [
          "name",
          "value"
        ]
      }
    }
  },
  {
    "featureName": "SelectGroupById",
    "description": "Retrieves a specific group by its ID.",
    "inputValues": [
      "groupId-number-Group"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the groupId (number, mandatory) from the request\n   - No optional fields are required for this operation\n   - No default values are applicable\n\n2. Data Validation:\n   - Validate groupId:\n     a. Check if groupId is provided\n     b. Verify groupId is a positive integer\n     c. If validation fails, prepare appropriate error message\n\n3. Business Rule Processing:\n   - Check system access permissions:\n     a. Verify if the current user has permission to view group information\n     b. If permission check fails, prepare access denied response\n   - Check if the system is in a valid state for group retrieval\n\n4. Core Operation Execution:\n   - Search for the group in the system:\n     a. Query the group repository using the provided groupId\n     b. IF group is found:\n        i. Retrieve all group attributes (id, name, description, parentId)\n        ii. Create a Group object with the retrieved attributes\n        iii. Prepare success response with group details\n     c. IF group is not found:\n        i. Return an empty Group object\n        ii. Log the failed retrieval attempt\n\n5. Response Generation:\n   - For successful retrieval:\n     a. Format the group data in the appropriate structure\n     b. Include all relevant group attributes (id, name, description, parentId)\n     c. Return the Group object with the information\n   - For failed retrieval:\n     a. Return an empty Group object\n     b. Include specific error details if applicable\n     c. Provide appropriate status indication",
    "databaseEntities": [
      "Group",
      "User"
    ],
    "validationRules": [
      "Group ID must be a positive integer",
      "User must have permission to view group information"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Group": {
        "id": "number",
        "name": "string",
        "description": "string",
        "parentId": "number"
      }
    }
  },
  {
    "featureName": "SelectAllGroups",
    "description": "Retrieves all groups in the system.",
    "inputValues": [],
    "businessLogic": "1. Input Collection:\n   - No user inputs required for this feature\n   - System will retrieve all groups without filtering parameters\n\n2. Data Validation:\n   - Verify user has appropriate permissions to view groups\n   - IF user does not have sufficient permissions THEN\n     - Generate appropriate access denied message\n     - Terminate process\n   - END IF\n\n3. Business Rule Processing:\n   - Check system state to ensure group data is accessible\n   - IF system is in maintenance mode THEN\n     - Generate system unavailable message\n     - Terminate process\n   - END IF\n   - Verify group repository is available\n   - IF group repository is unavailable THEN\n     - Generate repository unavailable message\n     - Log system error\n     - Terminate process\n   - END IF\n\n4. Core Operation Execution:\n   - Retrieve all group records from the data store\n   - Sort groups according to system default ordering (typically by name or ID)\n   - IF no groups exist in the system THEN\n     - Prepare empty result set\n   - ELSE\n     - Prepare result set with all group data\n   - END IF\n   - Apply any system-level filtering rules to the result set\n   - Format group data for presentation\n\n5. Response Generation:\n   - Prepare success response containing:\n     - Complete list of groups with their properties\n     - Total count of groups retrieved\n     - Any pagination metadata if applicable\n   - IF operation failed at any point THEN\n     - Generate error response with appropriate message\n     - Include troubleshooting information\n   - END IF",
    "databaseEntities": [
      "jforum_groups",
      "jforum_user_groups"
    ],
    "validationRules": [
      "User must have permission to view groups",
      "System must not be in maintenance mode",
      "Group repository must be accessible"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Group": {
        "type": "object",
        "properties": {
          "id": {
            "type": "number",
            "description": "Unique identifier for the group"
          },
          "name": {
            "type": "string",
            "description": "Name of the group"
          },
          "description": {
            "type": "string",
            "description": "Description of the group's purpose"
          }
        }
      }
    }
  },
  {
    "featureName": "CheckGroupDeletionEligibility",
    "description": "Verifies if a specific group can be deleted from the system.",
    "inputValues": [
      "groupId-number-Group"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the groupId (mandatory) to identify the group to check for deletion eligibility\n   - System will use the provided groupId to perform eligibility checks\n\n2. Data Validation:\n   - Validate groupId:\n     a. Verify groupId is not null or empty\n     b. Verify groupId is a positive integer\n     c. IF validation fails, THEN return appropriate error message\n\n3. Business Rule Processing:\n   - Check if group exists in the system:\n     a. Verify the group with the provided groupId exists in the database\n     b. IF group does not exist, THEN return error indicating group not found\n   - Check if group is a system-reserved group:\n     a. Verify if the group is marked as a system-reserved group\n     b. IF group is system-reserved, THEN mark as ineligible for deletion\n   - Check for user associations:\n     a. Query the database to check if any users are associated with the group\n     b. IF the total count of associated users is greater than zero, THEN mark as ineligible for deletion\n   - Check for parent-child relationships:\n     a. Verify if the group serves as a parent group for other groups\n     b. IF group has child groups, THEN mark as ineligible for deletion\n   - Check for forum associations:\n     a. Verify if the group has any forum moderation privileges\n     b. IF group has moderation privileges, THEN mark as ineligible for deletion\n   - Check for other dependencies:\n     a. Verify if the group is referenced in any other critical system functions\n     b. IF other dependencies exist, THEN mark as ineligible for deletion\n\n4. Core Operation Execution:\n   - Determine final eligibility status based on all checks:\n     a. IF any check failed (system-reserved, user associations, forum associations, other dependencies), THEN set eligibility status to false\n     b. ELSE set eligibility status to true\n   - Record the reason for ineligibility if applicable:\n     a. Store the specific reason why the group cannot be deleted\n     b. This information will be used in the response\n\n5. Response Generation:\n   - Prepare the deletion eligibility response:\n     a. Include the eligibility status (boolean: true/false)\n     b. IF ineligible, THEN include the reason for ineligibility\n     c. Include the group ID and basic group information for reference\n   - Return the final response to the caller",
    "databaseEntities": [
      "Group",
      "User",
      "UserGroup",
      "ModeratorGroup",
      "Forum"
    ],
    "validationRules": [
      "Group ID must be a positive integer",
      "Group must exist in the system",
      "System-reserved groups cannot be deleted",
      "Groups with associated users cannot be deleted",
      "Groups with forum moderation privileges cannot be deleted"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Group": {
        "id": "number",
        "name": "string",
        "description": "string",
        "parentId": "number",
        "isSystemReserved": "boolean"
      },
      "UserGroup": {
        "userId": "number",
        "groupId": "number"
      },
      "ModeratorGroup": {
        "groupId": "number",
        "forumId": "number"
      }
    }
  },
  {
    "featureName": "DeleteGroup",
    "description": "Removes a group from the system after verifying if deletion is possible.",
    "inputValues": [
      "groupId-number-Group"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the groupId (mandatory) to identify the group to be deleted\n   - System must have authenticated user with appropriate permissions (system-generated)\n\n2. Data Validation:\n   - Validate groupId:\n     a. Verify groupId is a positive integer\n     b. Verify groupId is not null or empty\n     c. Return appropriate error message if validation fails\n   - Validate user permissions:\n     a. Verify current user has administrative privileges to delete groups\n     b. Return permission denied error if user lacks required permissions\n\n3. Business Rule Processing:\n   - Check if group exists:\n     a. Search for group with the provided groupId\n     b. IF group not found, THEN\n        i. Generate group not found error\n        ii. Terminate the deletion process\n   - Check if group can be deleted:\n     a. Verify if the group is not a system-required group\n     b. Check if the group has no dependent relationships preventing deletion\n        i. Verify no users are currently assigned to this group\n        ii. Verify no forum permissions depend on this group\n     c. IF group cannot be deleted, THEN\n        i. Generate cannot delete group error with reason\n        ii. Terminate the deletion process\n\n4. Core Operation Execution:\n   - Begin deletion transaction:\n     a. Remove all user-group associations for this group\n     b. Remove all moderator-group associations for this group\n     c. Remove all permission settings and security roles associated with this group\n     d. Delete the group record itself\n     e. IF any step fails, THEN\n        i. Rollback all changes\n        ii. Generate system error message\n        iii. Terminate the process\n\n5. Response Generation:\n   - On successful deletion:\n     a. Generate success confirmation message\n     b. Include information about the deleted group\n     c. Provide navigation options to group management area\n   - On failure:\n     a. Return specific error message based on the failure reason\n     b. Provide guidance on how to resolve the issue\n     c. Maintain current state to allow user to try again",
    "databaseEntities": [
      "Group",
      "User",
      "GroupSecurity",
      "UserGroup",
      "ModeratorGroup"
    ],
    "validationRules": [
      "Group ID must be a positive integer",
      "Group must exist in the system",
      "Group must be eligible for deletion",
      "User must have administrative privileges to delete groups",
      "System-required groups cannot be deleted",
      "Groups with assigned users cannot be deleted"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Group": {
        "properties": {
          "id": {
            "type": "number",
            "description": "Unique identifier for the group"
          },
          "name": {
            "type": "string",
            "description": "Name of the group"
          },
          "description": {
            "type": "string",
            "description": "Description of the group"
          },
          "parentId": {
            "type": "number",
            "description": "Parent group identifier for hierarchical group structures"
          }
        },
        "required": [
          "id",
          "name"
        ]
      }
    }
  },
  {
    "featureName": "UpdateGroup",
    "description": "Updates an existing group's information in the system.",
    "inputValues": [
      "groupId-number-Group",
      "groupName-string-Group",
      "groupDescription-string-Group",
      "permissions-object-GroupPermissions"
    ],
    "businessLogic": "1. Input Collection:\n   1.1. Collect the following required inputs:\n       - groupId (mandatory): Unique identifier of the group to update\n       - groupName (mandatory): New name for the group\n       - groupDescription (mandatory): New description for the group\n       - permissions (mandatory): Set of permissions for the group\n   1.2. System will retrieve the current group information using the provided groupId\n\n2. Data Validation:\n   2.1. Validate groupId:\n       - IF groupId is not provided or not a positive integer THEN\n         - Return error: \"Group ID must be a valid positive integer\"\n       - IF group with provided groupId does not exist THEN\n         - Return error: \"Group not found with the specified ID\"\n   2.2. Validate groupName:\n       - IF groupName is empty or null THEN\n         - Return error: \"Group name cannot be empty\"\n       - IF groupName length is less than 3 characters THEN\n         - Return error: \"Group name must be at least 3 characters long\"\n       - IF groupName length exceeds 50 characters THEN\n         - Return error: \"Group name cannot exceed 50 characters\"\n       - IF groupName contains special characters other than spaces, hyphens, or underscores THEN\n         - Return error: \"Group name contains invalid characters\"\n   2.3. Validate groupDescription:\n       - IF groupDescription length exceeds 255 characters THEN\n         - Return error: \"Group description cannot exceed 255 characters\"\n   2.4. Validate permissions:\n       - FOR EACH permission in permissions object:\n         - IF permission value is not a boolean THEN\n           - Return error: \"Permission values must be true or false\"\n\n3. Business Rule Processing:\n   3.1. Check for name conflicts:\n       - IF another group (with different groupId) already has the same groupName THEN\n         - Return error: \"Another group with this name already exists\"\n   3.2. Check for system groups:\n       - IF the group is a system-reserved group THEN\n         - Verify the update doesn't compromise system integrity\n         - IF update would compromise system integrity THEN\n           - Return error: \"Cannot modify core properties of system groups\"\n   3.3. Check user associations:\n       - Retrieve list of users associated with this group\n       - IF group has associated users AND permissions are being restricted THEN\n         - Generate warning: \"This update will affect permissions for X users\"\n\n4. Core Operation Execution:\n   4.1. Prepare group data for update:\n       - Create updated group object with new information\n       - Preserve any fields not included in the update request\n   4.2. Update group record:\n       - Update the group information in the system\n       - Update associated permission records\n   4.3. Handle related updates:\n       - IF group name changed THEN\n         - Update any references to this group name in other parts of the system\n   4.4. Transaction handling:\n       - IF any part of the update fails THEN\n         - Rollback all changes\n         - Return appropriate error message\n\n5. Response Generation:\n   5.1. For successful update:\n       - Return success status\n       - Include updated group information\n       - Include timestamp of update\n       - Include summary of changes made\n   5.2. For failed update:\n       - Return failure status\n       - Include specific error message\n       - Include guidance on how to resolve the issue\n       - Log detailed error information for administrators",
    "databaseEntities": [
      "jforum_groups",
      "jforum_user_groups",
      "jforum_moderator_groups"
    ],
    "validationRules": [
      "Group ID must be a valid positive integer",
      "Group must exist in the system",
      "Group name cannot be empty",
      "Group name must be at least 3 characters long",
      "Group name cannot exceed 50 characters",
      "Group name can only contain alphanumeric characters, spaces, hyphens, or underscores",
      "Group name must be unique across all groups",
      "Group description cannot exceed 255 characters",
      "Permission values must be boolean (true/false)"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "GroupPermissions": {
        "type": "object",
        "properties": {
          "canAccessForums": {
            "type": "boolean",
            "description": "Permission to access forums"
          },
          "canCreateTopics": {
            "type": "boolean",
            "description": "Permission to create new topics"
          },
          "canReplyTopics": {
            "type": "boolean",
            "description": "Permission to reply to existing topics"
          },
          "canEditPosts": {
            "type": "boolean",
            "description": "Permission to edit posts"
          },
          "canDeletePosts": {
            "type": "boolean",
            "description": "Permission to delete posts"
          },
          "canModerate": {
            "type": "boolean",
            "description": "Permission to moderate forums"
          },
          "canAdministrate": {
            "type": "boolean",
            "description": "Permission to access administration features"
          }
        }
      }
    }
  },
  {
    "featureName": "AddNewGroup",
    "description": "Creates a new group in the system.",
    "inputValues": [
      "name-string-Group",
      "description-string-Group",
      "permissions-object-GroupPermissions"
    ],
    "businessLogic": "1. Input Collection:\n   1.1. Collect required group information:\n       1.1.1. Group name (mandatory)\n       1.1.2. Group description (optional)\n       1.1.3. Group permissions (mandatory)\n   1.2. Set system-generated fields:\n       1.2.1. Group ID will be auto-generated\n       1.2.2. Creation timestamp will be set to current time\n\n2. Data Validation:\n   2.1. Validate group name:\n       2.1.1. Check if name is provided\n       2.1.2. Check if name length is between 3 and 50 characters\n       2.1.3. Check if name contains only allowed characters\n       2.1.4. Check if name is unique in the system\n       2.1.5. IF any validation fails, THEN return appropriate error message\n   2.2. Validate group description:\n       2.2.1. IF description is provided, THEN check if length is less than 255 characters\n       2.2.2. IF validation fails, THEN return appropriate error message\n   2.3. Validate permissions:\n       2.3.1. Check if at least one permission is provided\n       2.3.2. Check if all provided permissions are valid system permissions\n       2.3.3. IF any validation fails, THEN return appropriate error message\n\n3. Business Rule Processing:\n   3.1. Check system constraints:\n       3.1.1. Verify if maximum number of groups limit has not been reached\n       3.1.2. Verify if current user has permission to create groups\n       3.1.3. IF any constraint check fails, THEN return appropriate error message\n   3.2. Check group hierarchy rules:\n       3.2.1. Determine if the new group conflicts with existing group hierarchies\n       3.2.2. IF conflicts exist, THEN return appropriate error message\n\n4. Core Operation Execution:\n   4.1. Create new group record:\n       4.1.1. Generate unique identifier for the group\n       4.1.2. Set group name and description\n       4.1.3. Set default group status as active\n       4.1.4. Save group record to database\n       4.1.5. IF save operation fails, THEN rollback and return error message\n   4.2. Assign permissions to group:\n       4.2.1. For EACH permission in the provided permissions list:\n           4.2.1.1. Create group-permission association\n           4.2.1.2. Save association to database\n       4.2.2. IF any permission assignment fails, THEN rollback all operations and return error message\n   4.3. Initialize group relationships:\n       4.3.1. Create necessary default relationships for the new group\n       4.3.2. IF relationship creation fails, THEN rollback all operations and return error message\n\n5. Response Generation:\n   5.1. Prepare success response:\n       5.1.1. Include newly created group ID\n       5.1.2. Include confirmation message\n       5.1.3. Include summary of assigned permissions\n   5.2. Return success response with appropriate status\n   5.3. IF any error occurred during the process, THEN:\n       5.3.1. Include detailed error message\n       5.3.2. Include error code\n       5.3.3. Include suggestions for resolution\n       5.3.4. Return error response with appropriate status",
    "databaseEntities": [
      "jforum_groups",
      "jforum_user_groups",
      "jforum_moderator_groups"
    ],
    "validationRules": [
      "Group name must not be empty",
      "Group name must be between 3 and 50 characters",
      "Group name must be unique in the system",
      "Group description must be less than 255 characters if provided",
      "At least one permission must be assigned to the group",
      "All assigned permissions must be valid system permissions",
      "User must have permission to create groups"
    ],
    "dbSeedingOperations": [
      "Default permission types must be pre-seeded in the system"
    ],
    "schema": {
      "GroupPermissions": {
        "type": "object",
        "properties": {
          "canAccessForums": {
            "type": "boolean",
            "description": "Permission to access forums"
          },
          "canCreateTopics": {
            "type": "boolean",
            "description": "Permission to create new topics"
          },
          "canReplyTopics": {
            "type": "boolean",
            "description": "Permission to reply to existing topics"
          },
          "canModerateForums": {
            "type": "boolean",
            "description": "Permission to moderate forums"
          },
          "canAdministerSystem": {
            "type": "boolean",
            "description": "Permission to administer system settings"
          }
        }
      }
    }
  },
  {
    "featureName": "SelectUsersInGroup",
    "description": "Retrieves user IDs associated with a specific group.",
    "inputValues": [
      "groupId-number-Group"
    ],
    "businessLogic": "1. Input Collection\n   - Collect the following input:\n     a. groupId (number, mandatory): The unique identifier of the group\n\n2. Data Validation\n   - Validate the groupId input:\n     a. Check if groupId is provided\n        IF groupId is null or undefined THEN\n          Return error: \"Group ID is required\"\n     b. Check if groupId is a valid number\n        IF groupId is not a number THEN\n          Return error: \"Group ID must be a numeric value\"\n     c. Check if groupId is a positive integer\n        IF groupId <= 0 THEN\n          Return error: \"Group ID must be a positive integer\"\n\n3. Business Rule Processing\n   - Verify the group exists in the system\n     a. Check if a group with the provided groupId exists\n        IF group does not exist THEN\n          Return error: \"Group not found with the provided ID\"\n   - Verify the current user has permission to view group members\n     a. Check if the current user has appropriate access rights\n        IF user does not have permission THEN\n          Return error: \"Insufficient permissions to view group members\"\n\n4. Core Operation Execution\n   - Retrieve all user IDs associated with the specified group\n     a. Access the user-group relationship records\n     b. Filter records by the provided groupId\n     c. Extract the user IDs from the filtered records\n     d. Create a list of user IDs\n   - Handle empty results appropriately\n     a. IF no users are found in the group THEN\n        Return an empty list with appropriate message\n\n5. Response Generation\n   - Prepare the success response\n     a. Format the list of user IDs\n     b. Include metadata such as:\n        i. Total count of users in the group\n        ii. Group information (name, description) if available\n   - Return the formatted response with the list of user IDs",
    "databaseEntities": [
      "jforum_groups",
      "jforum_user_groups",
      "jforum_users"
    ],
    "validationRules": [
      "Group ID must be provided",
      "Group ID must be a valid positive integer",
      "Group must exist in the system",
      "User must have permission to view group members"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Group": {
        "type": "object",
        "properties": {
          "id": {
            "type": "number",
            "description": "Unique identifier for the group"
          },
          "name": {
            "type": "string",
            "description": "Name of the group"
          },
          "description": {
            "type": "string",
            "description": "Description of the group"
          }
        },
        "required": [
          "id"
        ]
      },
      "UserGroup": {
        "type": "object",
        "properties": {
          "userId": {
            "type": "number",
            "description": "User identifier"
          },
          "groupId": {
            "type": "number",
            "description": "Group identifier"
          }
        },
        "required": [
          "userId",
          "groupId"
        ]
      }
    }
  },
  {
    "featureName": "DeleteForumRoles",
    "description": "Deletes all security roles related to a specific forum.",
    "inputValues": [
      "forumId-number-Forum"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect forumId (mandatory, number) that identifies the forum whose roles will be deleted\n   - System must verify the user has administrative privileges to perform this operation\n\n2. Data Validation:\n   - Validate forumId:\n     a. Check if forumId is provided and is a positive integer\n     b. Verify the forum exists in the system\n     c. Return appropriate error message if validation fails\n   - Validate user permissions:\n     a. Verify current user has permission to manage forum security roles\n     b. Return appropriate error message if user lacks required permissions\n\n3. Business Rule Processing:\n   - Check system state:\n     a. Verify the system is not in maintenance mode\n     b. Ensure no conflicting operations are in progress\n   - Check dependencies:\n     a. Determine if any active sessions depend on these roles\n     b. Identify if any critical system functions rely on these roles\n   - IF critical dependencies exist THEN:\n     a. Generate warning about potential system impact\n     b. Request confirmation before proceeding\n\n4. Core Operation Execution:\n   - Retrieve all security roles associated with the specified forum:\n     a. Query the system to identify all role IDs linked to the forumId\n     b. Create a list to store these role IDs for processing\n   - Execute deletion process:\n     a. Begin transaction to ensure data integrity\n     b. Construct a string of role IDs for batch processing\n     c. Delete all role-value associations for the forum using the role IDs\n     d. Commit transaction if all operations succeed\n     e. IF any operation fails THEN rollback transaction and log error details\n   - Update related records:\n     a. Update any cached security information in the roles repository\n     b. Clear relevant permission caches to ensure system consistency\n\n5. Response Generation:\n   - For successful deletion:\n     a. Generate success message indicating roles were deleted\n     b. Include count of deleted roles in response\n     c. Provide timestamp of operation\n   - For failed deletion:\n     a. Generate detailed error message\n     b. Include error code and specific failure reason\n     c. Provide troubleshooting information\n   - Log the operation:\n     a. Record the operation details in system audit log\n     b. Include user who performed the operation, timestamp, and result",
    "databaseEntities": [
      "jforum_forums",
      "jforum_groups",
      "jforum_user_groups",
      "jforum_roles",
      "jforum_role_values"
    ],
    "validationRules": [
      "Forum ID must be a positive integer",
      "Forum must exist in the system",
      "User must have administrative privileges to delete forum roles",
      "System must not be in maintenance mode during role deletion",
      "All role values must be properly identified before deletion"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Forum": {
        "type": "object",
        "properties": {
          "id": {
            "type": "number",
            "description": "Unique identifier for the forum"
          },
          "name": {
            "type": "string",
            "description": "Name of the forum"
          }
        },
        "required": [
          "id"
        ]
      },
      "Role": {
        "type": "object",
        "properties": {
          "id": {
            "type": "number",
            "description": "Unique identifier for the role"
          },
          "name": {
            "type": "string",
            "description": "Name of the security role"
          },
          "values": {
            "type": "array",
            "description": "Collection of values associated with this role"
          }
        },
        "required": [
          "id",
          "name"
        ]
      },
      "RoleValue": {
        "type": "object",
        "properties": {
          "roleId": {
            "type": "number",
            "description": "ID of the associated role"
          },
          "value": {
            "type": "string",
            "description": "The value assigned to this role"
          }
        },
        "required": [
          "roleId",
          "value"
        ]
      }
    }
  },
  {
    "featureName": "DeleteAllRoles",
    "description": "Deletes all security roles from a specific user group.",
    "inputValues": [
      "groupId-number-Group"
    ],
    "businessLogic": "1. Input Collection:\n   1.1. Collect the group ID (mandatory).\n   1.2. System prepares to remove all security roles associated with this group.\n\n2. Data Validation:\n   2.1. Validate Group ID:\n      2.1.1. Check if group ID is provided.\n      2.1.2. Verify group ID is a positive integer.\n      2.1.3. IF group ID is invalid or missing, THEN display error message and terminate operation.\n   2.2. Verify Group Existence:\n      2.2.1. Check if the group with the provided ID exists in the system.\n      2.2.2. IF group does not exist, THEN display appropriate error message and terminate operation.\n\n3. Business Rule Processing:\n   3.1. Check User Permissions:\n      3.1.1. Verify if the current user has administrative privileges to modify security roles.\n      3.1.2. IF user lacks sufficient permissions, THEN display access denied message and terminate operation.\n   3.2. Check System Constraints:\n      3.2.1. Verify if the group is not a system-reserved group with mandatory roles.\n      3.2.2. IF attempting to modify a protected system group, THEN display warning message and request confirmation.\n   3.3. Check for Dependent Operations:\n      3.3.1. Determine if any critical system functions depend on roles in this group.\n      3.3.2. IF critical dependencies exist, THEN display warning message with potential impacts.\n   3.4. Check Role Collection Status:\n      3.4.1. Verify if the security model is properly initialized.\n      3.4.2. IF security model is not initialized, THEN log error and terminate operation.\n\n4. Core Operation Execution:\n   4.1. Begin Role Deletion Transaction:\n      4.1.1. Start a database transaction to ensure data integrity.\n      4.1.2. Prepare to track all changes for potential rollback.\n   4.2. Retrieve Role IDs:\n      4.2.1. Retrieve all role IDs associated with the specified group.\n      4.2.2. Create a list of these role IDs for processing.\n      4.2.3. IF no roles are found, THEN proceed to step 5 as the operation is complete.\n   4.3. Remove Role Values:\n      4.3.1. Delete all role values linked to the retrieved role IDs.\n      4.3.2. Verify all role values are successfully removed.\n   4.4. Remove Group Roles:\n      4.4.1. Delete all role entries for the specified group.\n      4.4.2. Verify all group roles are successfully removed.\n   4.5. Update Role Collection:\n      4.5.1. Update the in-memory role collection to reflect the changes.\n      4.5.2. Ensure consistency between database and memory representation.\n   4.6. Commit or Rollback:\n      4.6.1. IF all deletion operations complete successfully, THEN commit the transaction.\n      4.6.2. IF any errors occur during deletion, THEN rollback all changes and log the error.\n\n5. Response Generation:\n   5.1. Success Response:\n      5.1.1. Generate confirmation message indicating all roles were successfully deleted.\n      5.1.2. Include summary of the number of roles removed.\n      5.1.3. Provide option to review the updated group permissions.\n   5.2. Error Response:\n      5.2.1. IF operation failed, THEN provide detailed error information.\n      5.2.2. Include guidance on how to resolve common issues.\n      5.2.3. Provide contact information for support if needed.",
    "databaseEntities": [
      "Group",
      "Role",
      "RoleValue",
      "User",
      "Forum",
      "GroupSecurity"
    ],
    "validationRules": [
      "Group ID must be a positive integer",
      "Group must exist in the system",
      "User must have administrative privileges to delete roles",
      "System-reserved groups may require special confirmation before role deletion",
      "Security model must be properly initialized before performing role operations"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Group": {
        "id": "number",
        "name": "string",
        "description": "string"
      },
      "Role": {
        "id": "number",
        "name": "string",
        "description": "string"
      },
      "RoleValue": {
        "id": "number",
        "roleId": "number",
        "value": "string"
      },
      "Forum": {
        "id": "number",
        "name": "string",
        "description": "string"
      },
      "GroupSecurity": {
        "groupId": "number",
        "roleId": "number"
      }
    }
  },
  {
    "featureName": "AddRole",
    "description": "Adds a new security role to a user group.",
    "inputValues": [
      "groupId-number-Group",
      "role-object-Role",
      "roleValues-object-RoleValueCollection"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the following required inputs:\n     a. groupId (number): The identifier of the group to which the role will be added\n     b. role (object): The security role to be added\n     c. roleValues (object, optional): Collection of values associated with the role\n\n2. Data Validation:\n   - Validate groupId:\n     a. Check if groupId is provided\n     b. Verify groupId is a positive integer\n     c. IF groupId is invalid THEN generate appropriate error message\n   - Validate role object:\n     a. Check if role is provided\n     b. Verify role has required properties (name, etc.)\n     c. IF role is invalid THEN generate appropriate error message\n   - Validate roleValues (if provided):\n     a. Check if roleValues collection is properly structured\n     b. Verify roleValues contains valid entries\n     c. IF roleValues is invalid THEN generate appropriate error message\n\n3. Business Rule Processing:\n   - Check group existence:\n     a. Verify the group with provided groupId exists in the system\n     b. IF group does not exist THEN return error indicating invalid group\n   - Check user permissions:\n     a. Verify current user has permission to modify group security roles\n     b. IF user lacks permission THEN return access denied error\n   - Check role uniqueness:\n     a. Query the system to determine if the role is already assigned to the group\n     b. IF role already exists for this group THEN determine if update is needed instead of add\n     c. IF role exists with same name but different group THEN verify it can be added to multiple groups\n   - Check role collection capacity:\n     a. Verify the role collection can accommodate another role\n     b. IF collection has reached capacity THEN return appropriate error message\n\n4. Core Operation Execution:\n   - Prepare role assignment:\n     a. Format role data for storage\n     b. Generate unique identifiers for the role if required\n     c. Prepare role values for association with the role if provided\n   - Perform role addition:\n     a. Create a new role entry for the specified group\n     b. Associate the role with the specified group using the role name as key\n     c. IF roleValues are provided THEN associate the role values with the role\n     d. IF any operation fails THEN rollback all changes and return error\n   - Update related records:\n     a. Update group's security information to reflect new role\n     b. Update any cached security information in the role repository\n     c. Record the change in system audit logs\n\n5. Response Generation:\n   - For successful addition:\n     a. Generate success confirmation\n     b. Include summary of the added role\n     c. Include the updated group security information\n     d. Include the role ID for reference\n   - For failed addition:\n     a. Generate detailed error message\n     b. Include specific reason for failure\n     c. Provide guidance on how to resolve the issue",
    "databaseEntities": [
      "jforum_groups",
      "jforum_users",
      "jforum_user_groups"
    ],
    "validationRules": [
      "Group ID must be a positive integer",
      "Group must exist in the system",
      "Role object must be properly structured",
      "Role name must not be empty",
      "User must have permission to modify group security",
      "Role values must be properly formatted",
      "Role name must be unique within the collection"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Role": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "description": "The name of the security role"
          },
          "id": {
            "type": "number",
            "description": "The identifier of the role"
          }
        },
        "required": [
          "name"
        ]
      },
      "RoleValueCollection": {
        "type": "object",
        "properties": {
          "values": {
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "id": {
                  "type": "number",
                  "description": "The identifier of the role value"
                },
                "value": {
                  "type": "string",
                  "description": "The value associated with the role"
                }
              }
            }
          }
        }
      }
    }
  },
  {
    "featureName": "AddRoleValue",
    "description": "Adds role values to a specific role for a group.",
    "inputValues": [
      "groupId-number-Group",
      "role-object-Role",
      "roleValue-object-RoleValue"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the following inputs:\n     1.1. groupId (number, mandatory): The identifier of the group to which the role value will be added\n     1.2. role (object, mandatory): The role object containing role information\n     1.3. roleValue (object, mandatory): The role value to be added to the role\n\n2. Data Validation:\n   - Validate all input parameters:\n     2.1. Validate groupId:\n         IF groupId is null or not a positive integer THEN\n             Generate error: \"Group ID must be a valid positive integer\"\n     2.2. Validate role object:\n         IF role is null THEN\n             Generate error: \"Role object cannot be null\"\n         IF role name is empty THEN\n             Generate error: \"Role name cannot be empty\"\n     2.3. Validate roleValue object:\n         IF roleValue is null THEN\n             Generate error: \"Role value cannot be null\"\n         IF roleValue.value is empty THEN\n             Generate error: \"Role value content cannot be empty\"\n\n3. Business Rule Processing:\n   - Verify system state and dependencies:\n     3.1. Check if the group exists:\n         IF group with groupId does not exist THEN\n             Generate error: \"Group not found with the provided ID\"\n     3.2. Check if the role is valid for the system:\n         IF role is not a recognized system role THEN\n             Generate error: \"Invalid role type provided\"\n     3.3. Check for duplicate role values:\n         IF roleValue already exists for this role and group THEN\n             Generate warning: \"Duplicate role value detected\"\n             Skip addition process and return success with notification\n\n4. Core Operation Execution:\n   - Process the role value addition:\n     4.1. Check if the role already exists for the group:\n         Query the system to find if the role is already assigned to the group\n         IF role exists for the group THEN\n             Retrieve the existing roleId and associated RoleValueCollection\n         ELSE\n             Create a new role association for the group\n             Generate a new roleId\n             Create a new empty RoleValueCollection for this role\n     4.2. Add the role value to the collection:\n         Check if the RoleValueCollection already contains the value\n         IF collection does not contain the value THEN\n             Add the roleValue to the RoleValueCollection\n         ELSE\n             Skip addition (value already exists)\n     4.3. Persist the updated collection:\n         Save the updated RoleValueCollection to the system\n         IF persistence operation fails THEN\n             Rollback changes\n             Generate error: \"Failed to save role value\"\n\n5. Response Generation:\n   - Generate appropriate response:\n     5.1. For successful operation:\n         Return success status\n         Include summary of the added role value\n         Include the updated RoleValueCollection size\n     5.2. For failed operation:\n         Return failure status\n         Include specific error details\n         Provide guidance on how to resolve the issue",
    "databaseEntities": [
      "jforum_groups",
      "jforum_roles",
      "jforum_role_values"
    ],
    "validationRules": [
      "Group ID must be a valid positive integer",
      "Role object cannot be null",
      "Role name cannot be empty",
      "Role value cannot be null",
      "Role value content cannot be empty",
      "Group must exist in the system",
      "Role must be a valid system role",
      "Role value must be a valid RoleValue type"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Role": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "description": "The name of the role"
          },
          "id": {
            "type": "number",
            "description": "The unique identifier of the role"
          }
        },
        "required": [
          "name"
        ]
      },
      "RoleValue": {
        "type": "object",
        "properties": {
          "value": {
            "type": "string",
            "description": "The value associated with the role"
          }
        },
        "required": [
          "value"
        ]
      },
      "RoleValueCollection": {
        "type": "object",
        "properties": {
          "values": {
            "type": "array",
            "items": {
              "$ref": "#/RoleValue"
            }
          }
        },
        "methods": {
          "add": {
            "description": "Adds a RoleValue to the collection if not already present"
          },
          "get": {
            "description": "Retrieves a RoleValue by its value name"
          },
          "contains": {
            "description": "Checks if a RoleValue exists in the collection"
          }
        }
      }
    }
  },
  {
    "featureName": "LoadRoles",
    "description": "Retrieves all security roles associated with a specific group.",
    "inputValues": [
      "groupIds-number-Group"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the following required inputs:\n     - groupIds (number array): The unique identifiers of the groups whose roles need to be retrieved\n   - No optional fields are required for this operation\n   - No default values are applicable\n\n2. Data Validation:\n   - Validate the groupIds input:\n     - Check if at least one groupId is provided\n     - Verify each groupId is a positive integer\n     - Ensure each groupId represents an existing group in the system\n   - IF any validation fails, THEN:\n     - Generate appropriate error message\n     - Abort the operation\n\n3. Business Rule Processing:\n   - Verify the system state:\n     - Check if the security subsystem is properly initialized\n     - Verify the current user has permission to view role information\n   - Check dependencies:\n     - Ensure all specified groups exist in the system\n     - Verify the groups are active and not marked for deletion\n   - IF any business rule fails, THEN:\n     - Log the failure reason\n     - Return appropriate error message\n\n4. Core Operation Execution:\n   - Convert the group IDs into a comma-separated string format for processing\n   - Retrieve all role records associated with the specified groups:\n     - Query the role storage system using the groupIds as keys\n     - Collect all roles linked to the groups\n     - For each role found:\n       - Retrieve the role name\n       - Retrieve the role values/permissions\n       - Build the role object with its properties\n     - Organize the roles into a structured collection\n   - IF no roles are found, THEN:\n     - Return an empty role collection\n   - IF retrieval operation fails, THEN:\n     - Log the error details\n     - Handle the exception appropriately\n     - Ensure all database resources are properly closed\n\n5. Response Generation:\n   - On success:\n     - Return the complete collection of roles\n     - Include metadata about the collection (total count, etc.)\n   - On failure:\n     - Return error details including:\n       - Error code\n       - User-friendly error message\n       - Suggested resolution steps if applicable\n     - Ensure proper cleanup of any allocated resources",
    "databaseEntities": [
      "jforum_groups",
      "jforum_user_groups",
      "jforum_roles",
      "jforum_role_values"
    ],
    "validationRules": [
      "Group IDs must be positive integers",
      "At least one group ID must be provided",
      "All specified groups must exist in the system",
      "User must have permission to view role information"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Role": {
        "type": "object",
        "properties": {
          "id": {
            "type": "number",
            "description": "The unique identifier of the role"
          },
          "name": {
            "type": "string",
            "description": "The name of the security role"
          },
          "values": {
            "type": "array",
            "description": "Collection of values/permissions associated with this role",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "RoleCollection": {
        "type": "object",
        "properties": {
          "roles": {
            "type": "array",
            "description": "List of roles",
            "items": {
              "$ref": "#/Role"
            }
          },
          "count": {
            "type": "number",
            "description": "Total number of roles in the collection"
          }
        }
      }
    }
  },
  {
    "featureName": "LoadRolesByUserGroups",
    "description": "Retrieves all security roles associated with a user's groups.",
    "inputValues": [
      "user-object-User"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the User object which contains:\n     * User ID (mandatory)\n     * User group associations (mandatory)\n   - System will use these inputs to retrieve associated security roles\n\n2. Data Validation:\n   - Validate User object:\n     * IF User object is null THEN\n       - Return error: \"User object cannot be null\"\n     * IF User ID is invalid or not found THEN\n       - Return error: \"Invalid user identifier\"\n     * IF User has no associated groups THEN\n       - Log warning: \"User has no group associations\"\n       - Return empty role collection\n\n3. Business Rule Processing:\n   - Check user account status:\n     * IF User account is inactive or suspended THEN\n       - Log access attempt\n       - Return error: \"User account is not active\"\n   - Check system permissions:\n     * IF System is in maintenance mode AND user is not an administrator THEN\n       - Return error: \"System is currently in maintenance mode\"\n     * IF Role retrieval is restricted for this user THEN\n       - Log access attempt\n       - Return error: \"Insufficient permissions to retrieve roles\"\n\n4. Core Operation Execution:\n   - Initialize empty role collection to store results\n   - Extract group IDs from user's group list:\n     * Create an array to hold all group IDs\n     * FOR EACH group in the user's groups list:\n       - Add the group ID to the array\n     * END FOR\n     * Sort the group IDs in ascending order for consistent caching\n   - Check if roles for these groups are already cached:\n     * Generate a unique cache key based on the sorted group IDs\n     * IF roles exist in cache for this key THEN\n       - Retrieve cached roles collection\n       - Return the cached collection\n     * ELSE\n       - Continue with database retrieval\n   - Retrieve roles from database:\n     * Prepare query parameters using the group IDs\n     * Execute query to fetch all roles associated with these groups\n     * FOR EACH role record retrieved:\n       - Create role object with name and values\n       - Add to role collection\n     * END FOR\n   - Process role inheritance and overrides:\n     * FOR EACH role in the collection:\n       - Resolve any role conflicts where the same role appears in multiple groups\n       - Apply role inheritance rules\n       - Determine final role values and permissions\n     * END FOR\n   - Cache the final role collection:\n     * Store the role collection in cache using the group IDs as key\n     * Set appropriate cache expiration\n\n5. Response Generation:\n   - IF Role retrieval is successful THEN\n     * Return complete role collection with all roles and their values\n     * Include metadata about role sources (which group provided which role)\n   - IF Any errors occurred during processing THEN\n     * Return appropriate error message\n     * Include details about which part of the process failed\n   - Log the role retrieval operation for audit purposes",
    "databaseEntities": [
      "jforum_users",
      "jforum_groups",
      "jforum_user_groups",
      "jforum_roles",
      "jforum_role_values"
    ],
    "validationRules": [
      "User object must not be null",
      "User ID must be valid",
      "User account must be active",
      "System must not be in maintenance mode for non-admin users",
      "User must have at least one associated group",
      "Group IDs must be valid"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "User": {
        "type": "object",
        "properties": {
          "id": {
            "type": "number",
            "description": "Unique identifier for the user"
          },
          "username": {
            "type": "string",
            "description": "User's login name"
          },
          "groups": {
            "type": "array",
            "description": "Groups the user belongs to",
            "items": {
              "type": "object",
              "properties": {
                "id": {
                  "type": "number",
                  "description": "Group identifier"
                },
                "name": {
                  "type": "string",
                  "description": "Group name"
                }
              }
            }
          },
          "active": {
            "type": "boolean",
            "description": "Whether the user account is active"
          }
        },
        "required": [
          "id",
          "username",
          "groups",
          "active"
        ]
      },
      "Role": {
        "type": "object",
        "properties": {
          "id": {
            "type": "number",
            "description": "Unique identifier for the role"
          },
          "name": {
            "type": "string",
            "description": "Name of the security role"
          },
          "values": {
            "type": "array",
            "description": "Collection of values associated with this role",
            "items": {
              "type": "object",
              "properties": {
                "value": {
                  "type": "string",
                  "description": "The role value"
                }
              }
            }
          }
        },
        "required": [
          "id",
          "name"
        ]
      }
    }
  },
  {
    "featureName": "AddKarma",
    "description": "Inserts a new karma record for a user.",
    "inputValues": [
      "postId-number-Post",
      "postUserId-number-User",
      "fromUserId-number-User",
      "points-number-Karma",
      "topicId-number-Topic"
    ],
    "businessLogic": "1. Input Collection:\n   1.1. Collect the following required inputs:\n       - postId: The ID of the post being rated (mandatory)\n       - postUserId: The ID of the user receiving karma (mandatory)\n       - fromUserId: The ID of the user giving karma (mandatory)\n       - points: The karma points being assigned (mandatory)\n       - topicId: The ID of the topic containing the post (mandatory)\n\n2. Data Validation:\n   2.1. Validate postId:\n       - IF postId is null or not a positive integer THEN\n           - Return error: \"Post ID must be a valid positive integer\"\n   2.2. Validate postUserId:\n       - IF postUserId is null or not a positive integer THEN\n           - Return error: \"Post user ID must be a valid positive integer\"\n   2.3. Validate fromUserId:\n       - IF fromUserId is null or not a positive integer THEN\n           - Return error: \"From user ID must be a valid positive integer\"\n       - IF fromUserId equals postUserId THEN\n           - Return error: \"Users cannot give karma to themselves\"\n   2.4. Validate points:\n       - IF points is null THEN\n           - Return error: \"Karma points must be provided\"\n       - IF points is not within the allowed range THEN\n           - Return error: \"Karma points must be within the allowed range\"\n   2.5. Validate topicId:\n       - IF topicId is null or not a positive integer THEN\n           - Return error: \"Topic ID must be a valid positive integer\"\n\n3. Business Rule Processing:\n   3.1. Check if giving user exists:\n       - IF giving user does not exist THEN\n           - Return error: \"Giving user does not exist\"\n   3.2. Check if receiving user exists:\n       - IF receiving user does not exist THEN\n           - Return error: \"Receiving user does not exist\"\n   3.3. Check if post exists:\n       - IF post does not exist THEN\n           - Return error: \"Post does not exist\"\n       - IF post does not belong to the specified topic THEN\n           - Return error: \"Post does not belong to the specified topic\"\n       - IF post does not belong to the receiving user THEN\n           - Return error: \"Post does not belong to the receiving user\"\n   3.4. Check if user can add karma:\n       - IF user has already given karma to this post THEN\n           - Return error: \"User has already given karma to this post\"\n\n4. Core Operation Execution:\n   4.1. Create new karma record:\n       - Create a new karma entry with the following attributes:\n           - Post ID\n           - Post User ID (receiving user)\n           - From User ID (giving user)\n           - Points\n           - Topic ID\n           - Current timestamp\n   4.2. Store the karma record:\n       - Save the new karma record to the database\n   4.3. Update user karma status:\n       - Calculate the user's karma points using the following steps:\n           - Retrieve all karma records for the user\n           - For each karma record, calculate the average points (points/votes)\n           - Sum all average points\n           - Divide by the total number of records to get overall karma\n           - If no records exist, set karma to 0\n       - Update the receiving user's karma status in the database\n\n5. Response Generation:\n   5.1. For successful karma addition:\n       - Return success status\n       - Include the updated karma total for the receiving user\n   5.2. For failed karma addition:\n       - Return failure status\n       - Include specific error message explaining the failure reason",
    "databaseEntities": [
      "jforum_users",
      "jforum_karma",
      "jforum_posts",
      "jforum_topics"
    ],
    "validationRules": [
      "Post ID must be a valid positive integer",
      "Post user ID must be a valid positive integer",
      "From user ID must be a valid positive integer",
      "Users cannot give karma to themselves",
      "Karma points must be within the allowed range",
      "Topic ID must be a valid positive integer",
      "Giving user must exist in the system",
      "Receiving user must exist in the system",
      "Post must exist in the system",
      "Post must belong to the specified topic",
      "Post must belong to the receiving user",
      "User cannot give karma to the same post more than once"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Karma": {
        "type": "object",
        "properties": {
          "id": {
            "type": "number",
            "description": "Unique identifier for the karma record"
          },
          "postId": {
            "type": "number",
            "description": "ID of the post being rated"
          },
          "postUserId": {
            "type": "number",
            "description": "ID of the user receiving karma"
          },
          "fromUserId": {
            "type": "number",
            "description": "ID of the user giving karma"
          },
          "points": {
            "type": "number",
            "description": "Karma points being assigned"
          },
          "topicId": {
            "type": "number",
            "description": "ID of the topic containing the post"
          },
          "ratingDate": {
            "type": "date",
            "description": "Date when the karma was given"
          }
        },
        "required": [
          "postId",
          "postUserId",
          "fromUserId",
          "points",
          "topicId",
          "ratingDate"
        ]
      },
      "KarmaStatus": {
        "type": "object",
        "properties": {
          "karmaPoints": {
            "type": "number",
            "description": "Total karma points for a user or post"
          },
          "totalPoints": {
            "type": "number",
            "description": "Sum of all karma points received"
          },
          "votesReceived": {
            "type": "number",
            "description": "Number of karma votes received"
          },
          "votesGiven": {
            "type": "number",
            "description": "Number of karma votes given by a user"
          }
        }
      }
    }
  },
  {
    "featureName": "GetUserKarma",
    "description": "Retrieves the karma status of a specific user.",
    "inputValues": [
      "userId-number-User"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect userId (number, mandatory) to identify the user whose karma status is being requested\n   - System will use current session information for access control validation\n\n2. Data Validation:\n   - Validate userId:\n     a. Check if userId is provided\n     b. Verify userId is a positive integer\n     c. IF userId is invalid or missing THEN\n        - Generate appropriate error message\n        - Terminate process\n     d. END IF\n   - Verify user exists in the system:\n     a. Check if userId corresponds to an existing user record\n     b. IF user does not exist THEN\n        - Generate user not found error message\n        - Terminate process\n     c. END IF\n\n3. Business Rule Processing:\n   - Check access permissions:\n     a. Verify if the requesting user has permission to view karma information\n     b. IF permission check fails THEN\n        - Generate permission denied error message\n        - Terminate process\n     c. END IF\n   - Check karma feature availability:\n     a. Verify if karma functionality is enabled in the system\n     b. IF karma feature is disabled THEN\n        - Generate feature unavailable message\n        - Terminate process\n     c. END IF\n\n4. Core Operation Execution:\n   - Retrieve user karma information:\n     a. Gather all karma records associated with the specified userId\n     b. Calculate total karma points received by the user\n     c. Determine karma rating level based on points\n     d. Compile karma statistics including:\n        - Total positive karma points\n        - Total negative karma points\n        - Net karma score\n        - Karma rating level\n        - Votes received\n        - Votes given by the user\n     e. IF no karma records exist for user THEN\n        - Set default karma values for new users (zero points, zero votes)\n     f. END IF\n     g. Calculate average karma points (total points divided by votes received)\n     h. IF votes received is zero THEN\n        - Set karma points to zero to prevent division by zero\n     i. END IF\n\n5. Response Generation:\n   - Format karma status response:\n     a. Include all karma statistics in the response:\n        - Karma points (rounded to nearest integer)\n        - Total points\n        - Votes received\n        - Votes given\n     b. Include user identification information\n     c. Include timestamp of when karma was last updated\n   - Return success response with karma status information\n   - IF any errors occurred during processing THEN\n     a. Generate appropriate error response with details\n     b. Include support information if needed\n   - END IF",
    "databaseEntities": [
      "jforum_karma",
      "jforum_users"
    ],
    "validationRules": [
      "User ID must be a positive integer",
      "User must exist in the system",
      "Requesting user must have permission to view karma information",
      "Karma feature must be enabled in the system"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "KarmaStatus": {
        "type": "object",
        "properties": {
          "userId": {
            "type": "number",
            "description": "ID of the user"
          },
          "totalPoints": {
            "type": "number",
            "description": "Total karma points"
          },
          "karmaPoints": {
            "type": "number",
            "description": "Calculated karma points (rounded average)"
          },
          "votesReceived": {
            "type": "number",
            "description": "Total number of votes received"
          },
          "votesGiven": {
            "type": "number",
            "description": "Total number of votes given by the user"
          },
          "karmaLevel": {
            "type": "string",
            "description": "Karma level based on points"
          },
          "positivePoints": {
            "type": "number",
            "description": "Total positive karma points received"
          },
          "negativePoints": {
            "type": "number",
            "description": "Total negative karma points received"
          },
          "lastUpdated": {
            "type": "date",
            "description": "When the karma was last updated"
          }
        }
      }
    }
  },
  {
    "featureName": "UpdateUserKarma",
    "description": "Updates the karma status for a user in the system based on received votes.",
    "inputValues": [
      "userId-number-User"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect userId (number, mandatory) - Identifier of the user whose karma needs to be updated\n   - System will generate currentTimestamp (date, system-generated) - Time of karma update\n\n2. Data Validation:\n   - Validate userId:\n      * Check if userId is provided\n      * Verify userId is a positive integer\n      * Verify userId exists in the system\n      * IF userId is invalid or not found THEN\n         - Generate appropriate error message\n         - Terminate process\n\n3. Business Rule Processing:\n   - Check system access permissions:\n      * Verify the requesting entity has permission to update karma\n      * IF permission check fails THEN\n         - Generate unauthorized access error\n         - Log access attempt\n         - Terminate process\n   - Check if user has any karma records:\n      * Verify if the user has received any karma points\n      * IF no karma records exist THEN\n         - Set default karma value to zero\n         - Skip calculation and proceed to update user record\n\n4. Core Operation Execution:\n   - Retrieve all karma points for the user:\n      * Collect all karma points received by the user\n      * Count total number of votes received\n   - Calculate karma average:\n      * Initialize totalPoints to 0\n      * Initialize totalRecords to 0\n      * FOR each karma record associated with the user:\n         - Add points/votes ratio to totalPoints\n         - Increment totalRecords counter\n      * Calculate final karma score as totalPoints/totalRecords\n      * IF calculation results in Not-a-Number (NaN) THEN\n         - Set karma points to 0\n   - Update user record:\n      * Set user's karma value to the calculated average\n      * Save updated user record\n      * IF update operation fails THEN\n         - Log error details\n         - Attempt rollback if applicable\n         - Generate system error message\n         - Terminate process\n\n5. Response Generation:\n   - On successful update:\n      * Generate success confirmation message\n      * Include updated karma value in response\n      * Include timestamp of update\n   - On failure:\n      * Generate appropriate error message\n      * Include error details for troubleshooting\n      * Provide guidance on next steps or retry options",
    "databaseEntities": [
      "User",
      "Karma"
    ],
    "validationRules": [
      "User ID must be a positive integer",
      "User ID must exist in the system",
      "Requesting entity must have permission to update karma",
      "Karma calculation must follow the formula: average of (points/votes) for all karma records",
      "If calculation results in NaN, karma value defaults to 0"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "KarmaStatus": {
        "type": "object",
        "properties": {
          "karmaPoints": {
            "type": "number",
            "description": "The calculated karma points for the user"
          },
          "totalPoints": {
            "type": "number",
            "description": "Total karma points received"
          },
          "votesReceived": {
            "type": "number",
            "description": "Total number of votes received"
          },
          "votesGiven": {
            "type": "number",
            "description": "Total number of votes given by the user"
          }
        }
      }
    }
  },
  {
    "featureName": "CheckUserKarmaPermission",
    "description": "Verifies if a user can add karma to a specific post.",
    "inputValues": [
      "userId-number-User",
      "postId-number-Post"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect userId (mandatory, number): The identifier of the user attempting to add karma\n   - Collect postId (mandatory, number): The identifier of the post to which karma would be added\n   - System will use these inputs to determine if the user has permission to add karma\n\n2. Data Validation:\n   - Validate userId:\n     a. Check if userId is provided\n     b. Verify userId is a positive integer\n     c. Return error message if validation fails: \"Invalid user identifier provided\"\n   - Validate postId:\n     a. Check if postId is provided\n     b. Verify postId is a positive integer\n     c. Return error message if validation fails: \"Invalid post identifier provided\"\n\n3. Business Rule Processing:\n   - Verify user existence:\n     a. Check if the user with the provided userId exists in the system\n     b. IF user does not exist, THEN return error: \"User not found\"\n   - Verify post existence:\n     a. Check if the post with the provided postId exists in the system\n     b. IF post does not exist, THEN return error: \"Post not found\"\n   - Check user status:\n     a. Verify if the user account is active and not banned\n     b. IF user is banned or inactive, THEN return error: \"User account is not in good standing\"\n   - Check karma voting history:\n     a. Search for existing karma entries associated with both the userId and postId\n     b. IF an entry is found, THEN user has already voted on this post\n\n4. Core Operation Execution:\n   - Determine permission status:\n     a. IF no previous karma entry exists for this user-post combination, THEN:\n        i. Set permission status to \"allowed\"\n     b. ELSE:\n        i. Set permission status to \"denied\"\n   - Record permission check:\n     a. Log the permission check attempt with timestamp, userId, postId, and result\n     b. Update user's last activity timestamp\n\n5. Response Generation:\n   - Prepare permission response:\n     a. Include permission status (allowed/denied)\n     b. IF denied, include reason: \"User has already added karma to this post\"\n     c. Include timestamp of the permission check\n   - Return final response:\n     a. IF permission allowed, return success response with permission status\n     b. IF permission denied, return error response with reason",
    "databaseEntities": [
      "jforum_users",
      "jforum_posts",
      "jforum_karma"
    ],
    "validationRules": [
      "User ID must be a positive integer",
      "Post ID must be a positive integer",
      "User must exist in the system",
      "Post must exist in the system",
      "User must not have previously added karma to the specified post",
      "User account must be active and in good standing"
    ],
    "dbSeedingOperations": [],
    "schema": {}
  },
  {
    "featureName": "GetPostKarma",
    "description": "Retrieves the karma status of a specific post.",
    "inputValues": [
      "postId-number-Post"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect postId (mandatory, number) from the request\n   - System will use this identifier to locate the specific post\n\n2. Data Validation:\n   - Validate postId:\n     a. Check if postId is provided\n     b. Verify postId is a positive integer\n     c. IF postId is missing or invalid THEN\n        - Generate appropriate error message\n        - Terminate process and return validation error\n\n3. Business Rule Processing:\n   - Check post existence:\n     a. Verify the post with the given postId exists in the system\n     b. IF post does not exist THEN\n        - Generate \"Post not found\" error message\n        - Terminate process and return error\n   - Check karma feature availability:\n     a. Verify the karma feature is enabled in the system\n     b. IF karma feature is disabled THEN\n        - Generate appropriate notification\n        - Terminate process and return notification\n\n4. Core Operation Execution:\n   - Retrieve karma data:\n     a. Fetch all karma votes associated with the specified post\n     b. Calculate total karma points for the post\n     c. Count positive votes\n     d. Count negative votes\n     e. Determine karma rating (positive/negative/neutral)\n   - Compile karma status:\n     a. Create karma status object containing:\n        - Total karma points\n        - Vote count (positive and negative)\n        - Average rating\n        - Rating trend (increasing/decreasing/stable)\n\n5. Response Generation:\n   - Success response:\n     a. Return karma status object with all calculated metrics\n     b. Include timestamp of when the karma was last updated\n   - Error response:\n     a. Return appropriate error code and message if any issues occurred\n     b. Include guidance on how to resolve the error if applicable",
    "databaseEntities": [
      "jforum_karma",
      "jforum_posts",
      "jforum_users"
    ],
    "validationRules": [
      "Post ID must be a positive integer",
      "Post must exist in the system",
      "Karma feature must be enabled in the system"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "KarmaStatus": {
        "type": "object",
        "properties": {
          "totalPoints": {
            "type": "number",
            "description": "Sum of all karma points for the post"
          },
          "positiveVotes": {
            "type": "number",
            "description": "Count of positive votes"
          },
          "negativeVotes": {
            "type": "number",
            "description": "Count of negative votes"
          },
          "totalVotes": {
            "type": "number",
            "description": "Total number of votes cast"
          },
          "averageRating": {
            "type": "number",
            "description": "Average karma rating"
          },
          "lastUpdated": {
            "type": "date",
            "description": "Timestamp of last karma update"
          }
        }
      }
    }
  },
  {
    "featureName": "UpdateKarma",
    "description": "Updates an existing karma record in the system.",
    "inputValues": [
      "karmaId-number-Karma",
      "points-number-Karma"
    ],
    "businessLogic": "1. Input Collection:\n   1.1. Collect the following required inputs:\n       - karmaId: Unique identifier of the karma record to update (mandatory)\n       - points: New karma rating value (mandatory)\n\n2. Data Validation:\n   2.1. Validate karmaId:\n       - IF karmaId is not provided or not a positive integer, THEN\n         - Return error: \"Invalid karma identifier provided\"\n   2.2. Validate points:\n       - IF points is not a number, THEN\n         - Return error: \"Karma points must be a valid number\"\n       - IF points is not within the allowed range for karma ratings, THEN\n         - Return error: \"Karma points must be within the valid range\"\n\n3. Business Rule Processing:\n   3.1. Check if karma record exists:\n       - IF no karma record exists with the provided karmaId, THEN\n         - Return error: \"Karma record not found\"\n   3.2. Verify user permissions:\n       - IF current user is not the original karma giver and not an administrator, THEN\n         - Return error: \"User not authorized to update this karma record\"\n   3.3. Check for rating time restrictions:\n       - IF system has time restrictions on karma updates AND the time limit has passed, THEN\n         - Return error: \"Time limit for updating karma has expired\"\n\n4. Core Operation Execution:\n   4.1. Retrieve the existing karma record:\n       - Load the karma record using karmaId\n       - Store original values for potential rollback\n   4.2. Update the karma record:\n       - Update the points value with the new rating\n       - Save the updated karma record\n   4.3. Update user karma status:\n       - Retrieve all karma points received by the user\n       - Calculate total points and number of votes\n       - Compute average karma points (total points / total votes)\n       - If no votes exist, set karma points to zero\n       - Update the user's karma status in the user record\n   4.4. Handle failures:\n       - IF any update operation fails, THEN\n         - Rollback all changes to maintain data consistency\n         - Log the failure details\n         - Return error: \"Failed to update karma record\"\n\n5. Response Generation:\n   5.1. For successful update:\n       - Generate success response with updated karma details\n       - Include the new karma points value\n       - Include the updated user karma total\n       - Include timestamp of the update\n   5.2. For failed update:\n       - Generate error response with specific failure reason\n       - Include guidance on how to resolve the issue\n       - Provide support reference if applicable",
    "databaseEntities": [
      "jforum_karma",
      "jforum_users"
    ],
    "validationRules": [
      "Karma ID must exist in the system",
      "Karma points must be a valid number",
      "Karma points must be within the valid range",
      "Only the original karma giver or an administrator can update a karma record"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Karma": {
        "type": "object",
        "properties": {
          "id": {
            "type": "number",
            "description": "Unique identifier for the karma record"
          },
          "postId": {
            "type": "number",
            "description": "Identifier of the post receiving karma"
          },
          "postUserId": {
            "type": "number",
            "description": "Identifier of the user receiving karma"
          },
          "fromUserId": {
            "type": "number",
            "description": "Identifier of the user giving karma"
          },
          "points": {
            "type": "number",
            "description": "Karma rating value"
          },
          "topicId": {
            "type": "number",
            "description": "Identifier of the topic containing the post"
          },
          "ratingDate": {
            "type": "date",
            "description": "Date when the rating was given or updated"
          }
        },
        "required": [
          "id",
          "postId",
          "postUserId",
          "fromUserId",
          "points",
          "topicId",
          "ratingDate"
        ]
      },
      "KarmaStatus": {
        "type": "object",
        "properties": {
          "karmaPoints": {
            "type": "number",
            "description": "Average karma points for a user"
          },
          "totalPoints": {
            "type": "number",
            "description": "Total karma points received"
          },
          "votesReceived": {
            "type": "number",
            "description": "Number of karma votes received"
          },
          "votesGiven": {
            "type": "number",
            "description": "Number of karma votes given by the user"
          }
        },
        "required": [
          "karmaPoints"
        ]
      }
    }
  },
  {
    "featureName": "GetUserVotes",
    "description": "Retrieves votes made by a user on posts within a topic.",
    "inputValues": [
      "topicId-number-Topic",
      "userId-number-User"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect topicId (mandatory): Numeric identifier of the topic\n   - Collect userId (mandatory): Numeric identifier of the user\n   - System will use these inputs to retrieve user's voting history\n\n2. Data Validation:\n   - Validate topicId:\n      * Verify topicId is a positive integer\n      * Verify topicId exists in the system\n      * IF topicId is invalid or not found, THEN return appropriate error message\n   - Validate userId:\n      * Verify userId is a positive integer\n      * Verify userId exists in the system\n      * IF userId is invalid or not found, THEN return appropriate error message\n\n3. Business Rule Processing:\n   - Verify user has permission to view voting information:\n      * Check if user has required access level to view votes\n      * IF user lacks permission, THEN return access denied error\n   - Verify topic status:\n      * Check if topic is active and not deleted\n      * IF topic is inactive or deleted, THEN return appropriate error message\n\n4. Core Operation Execution:\n   - Retrieve all posts associated with the specified topic\n   - For each post in the topic:\n      * Check if the specified user has cast a vote on the post\n      * IF vote exists, THEN record the post identifier and the rating value\n   - Compile a mapping of post identifiers to their corresponding vote ratings\n   - IF no votes are found, THEN prepare an empty result set\n\n5. Response Generation:\n   - Format the voting data as a collection of post-to-rating mappings\n   - Include metadata such as:\n      * Total number of votes cast by the user in the topic\n      * Timestamp of the most recent vote (if applicable)\n   - Return the compiled voting information to the requester\n   - IF any errors occurred during processing, THEN return appropriate error details",
    "databaseEntities": [
      "jforum_karma",
      "jforum_topics",
      "jforum_posts",
      "jforum_users"
    ],
    "validationRules": [
      "Topic ID must be a positive integer",
      "User ID must be a positive integer",
      "Topic must exist in the system",
      "User must exist in the system",
      "User must have permission to view voting information"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "VoteMapping": {
        "type": "object",
        "properties": {
          "postId": {
            "type": "integer",
            "description": "Identifier of the post that received a vote"
          },
          "points": {
            "type": "integer",
            "description": "Number of karma points assigned to the post"
          }
        }
      }
    }
  },
  {
    "featureName": "GetUserTotalKarma",
    "description": "Calculates and retrieves the total karma points accumulated by a user.",
    "inputValues": [
      "userId-number-User"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect userId as a numeric identifier\n   - System will use the userId to retrieve karma information\n   - No additional input parameters required\n\n2. Data Validation:\n   - Validate userId exists and is valid\n     - IF userId is missing THEN return error \"User identifier is required\"\n     - IF userId is not a positive integer THEN return error \"Valid user identifier is required\"\n     - IF userId does not correspond to an existing user THEN return error \"User not found\"\n\n3. Business Rule Processing:\n   - Check if karma feature is enabled in the system\n     - IF karma feature is disabled THEN return appropriate notification\n   - Verify user account status\n     - IF user account is inactive or suspended THEN proceed but note this in response\n   - Check karma calculation permissions\n     - IF current user lacks permission to view karma THEN return appropriate error\n\n4. Core Operation Execution:\n   - Create a karma status object to hold the user's karma information\n   - Retrieve total karma votes received by the user\n     - Query the database for total points received\n     - Query the database for total number of votes received\n   - Calculate karma points average\n     - IF votes received is zero THEN set karma points to zero\n     - ELSE divide total points by votes received to get average karma points\n   - Retrieve votes given by the user\n     - Query the database for total number of votes given by the user\n   - Populate the karma status object with:\n     - Total points received\n     - Total votes received\n     - Calculated karma points average\n     - Total votes given by the user\n   - Associate the karma status with the user object\n\n5. Response Generation:\n   - Prepare user object with karma information\n     - Include user identification details\n     - Include karma status containing:\n       * Total points received\n       * Number of votes received\n       * Average karma points\n       * Number of votes given\n   - Format response according to system standards\n   - Return complete user with karma information to the requester\n   - IF any errors occurred during processing THEN include error details in response",
    "databaseEntities": [
      "jforum_users",
      "jforum_karma"
    ],
    "validationRules": [
      "User ID must be a positive integer",
      "User must exist in the system",
      "Karma feature must be enabled in the system",
      "Requesting user must have permission to view karma information"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "User": {
        "type": "object",
        "properties": {
          "id": {
            "type": "number",
            "description": "Unique identifier for the user"
          },
          "username": {
            "type": "string",
            "description": "User's login name"
          },
          "karma": {
            "type": "object",
            "description": "User's karma status information",
            "properties": {
              "totalPoints": {
                "type": "number",
                "description": "Total karma points received"
              },
              "votesReceived": {
                "type": "number",
                "description": "Number of karma votes received"
              },
              "karmaPoints": {
                "type": "number",
                "description": "Average karma points (totalPoints/votesReceived)"
              },
              "votesGiven": {
                "type": "number",
                "description": "Number of karma votes given to others"
              }
            }
          }
        },
        "required": [
          "id"
        ]
      }
    }
  },
  {
    "featureName": "GetMostRatedUsers",
    "description": "Retrieves users with highest karma ratings within a specified date range.",
    "inputValues": [
      "startDate-date-Date",
      "endDate-date-Date",
      "startIndex-number-Integer",
      "orderField-string-String"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect startDate (mandatory): The beginning date of the period to analyze\n   - Collect endDate (mandatory): The ending date of the period to analyze\n   - Collect startIndex (mandatory): The starting position for pagination\n   - Collect orderField (optional): Field to sort results by, defaults to total karma points\n\n2. Data Validation:\n   - Validate startDate:\n     * Must be a valid date format\n     * Cannot be null or empty\n     * Error message if invalid: \"Start date must be a valid date\"\n   - Validate endDate:\n     * Must be a valid date format\n     * Cannot be null or empty\n     * Must be greater than or equal to startDate\n     * Error message if invalid: \"End date must be a valid date and not before start date\"\n   - Validate startIndex:\n     * Must be a non-negative integer\n     * Error message if invalid: \"Start index must be a non-negative number\"\n   - Validate orderField:\n     * If provided, must be one of the allowed sorting fields\n     * Error message if invalid: \"Invalid order field specified\"\n\n3. Business Rule Processing:\n   - Check system state:\n     * Verify karma rating system is enabled in the system\n     * IF karma system is disabled, THEN return appropriate message\n   - Verify date range validity:\n     * IF date range exceeds maximum allowed period, THEN adjust or return error\n     * IF date range is in the future, THEN return appropriate message\n   - Check access permissions:\n     * Verify current user has permission to view karma statistics\n     * IF user lacks permission, THEN return access denied message\n\n4. Core Operation Execution:\n   - Retrieve karma data:\n     * Query karma records within the specified date range\n     * Group karma points by recipient user\n     * Calculate total karma points for each user\n     * Apply pagination using startIndex parameter\n     * Sort results according to orderField parameter\n   - Process user information:\n     * For each user in results, retrieve relevant profile information\n     * Calculate karma statistics (average rating, total votes received)\n     * Format data for presentation\n   - Handle edge cases:\n     * IF no karma records exist in date range, THEN prepare empty result set\n     * IF system error occurs during retrieval, THEN prepare error message\n\n5. Response Generation:\n   - Prepare success response:\n     * Format list of users with their karma statistics\n     * Include total count of users with karma in the period\n     * Include pagination information (current page, total pages)\n     * Include date range information in response\n   - Handle potential errors:\n     * Return appropriate error messages for any failures\n     * Include suggestions for corrective action if applicable\n   - Provide additional information:\n     * Include system-wide karma statistics for the period if relevant",
    "databaseEntities": [
      "jforum_users",
      "jforum_karma"
    ],
    "validationRules": [
      "Start date must be a valid date format",
      "End date must be a valid date format",
      "End date must not be before start date",
      "Start index must be a non-negative integer",
      "Order field must be a valid sorting option if specified",
      "User must have permission to view karma statistics"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "UserKarmaRating": {
        "type": "object",
        "properties": {
          "userId": {
            "type": "integer",
            "description": "Unique identifier of the user"
          },
          "username": {
            "type": "string",
            "description": "Display name of the user"
          },
          "totalPoints": {
            "type": "number",
            "description": "Total karma points received in the period"
          },
          "votesReceived": {
            "type": "integer",
            "description": "Number of karma votes received in the period"
          },
          "averageRating": {
            "type": "number",
            "description": "Average karma rating in the period"
          }
        }
      }
    }
  },
  {
    "featureName": "GetPostsToIndex",
    "description": "Retrieves posts for indexing based on post ID range.",
    "inputValues": [
      "fromPostId-number-Post",
      "toPostId-number-Post"
    ],
    "businessLogic": "1. Input Collection\n   - Collect the following inputs:\n     1.1. fromPostId (mandatory): The starting post ID for the range\n     1.2. toPostId (mandatory): The ending post ID for the range\n\n2. Data Validation\n   - Validate all input parameters:\n     2.1. Validate fromPostId:\n         2.1.1. Check IF fromPostId is provided\n         2.1.2. Verify IF fromPostId is a positive integer\n         2.1.3. IF validation fails, generate appropriate error message\n     2.2. Validate toPostId:\n         2.2.1. Check IF toPostId is provided\n         2.2.2. Verify IF toPostId is a positive integer\n         2.2.3. IF validation fails, generate appropriate error message\n     2.3. Validate relationship between IDs:\n         2.3.1. Verify IF fromPostId is less than or equal to toPostId\n         2.3.2. IF validation fails, generate error message indicating invalid range\n\n3. Business Rule Processing\n   - Process business rules related to post retrieval:\n     3.1. Check system state for indexing availability:\n         3.1.1. Verify IF the system is in a state that allows indexing operations\n         3.1.2. IF system is not available for indexing, generate appropriate error\n     3.2. Verify post existence:\n         3.2.1. Check IF posts exist within the specified range\n         3.2.2. IF no posts exist in the range, prepare for empty result set\n     3.3. Apply access control rules:\n         3.3.1. Determine which posts within the range are accessible for indexing\n         3.3.2. Filter out posts that should not be indexed based on forum rules\n\n4. Core Operation Execution\n   - Retrieve posts within the specified range:\n     4.1. Query the post repository:\n         4.1.1. Construct query parameters using fromPostId and toPostId\n         4.1.2. Execute query to retrieve posts within the specified range\n         4.1.3. IF query execution fails, handle the error appropriately\n     4.2. Process retrieved posts:\n         4.2.1. For EACH post retrieved:\n             4.2.1.1. Extract post ID, forum ID, topic ID, and user ID\n             4.2.1.2. Extract post creation timestamp and convert to appropriate date format\n             4.2.1.3. Extract post text content\n             4.2.1.4. Determine if BBCode is enabled for the post\n             4.2.1.5. Determine if smilies are enabled for the post\n             4.2.1.6. Extract post subject or use topic title if subject is empty\n         4.2.2. Organize posts in appropriate structure for return\n\n5. Response Generation\n   - Prepare and return the response:\n     5.1. For successful retrieval:\n         5.1.1. Compile list of posts with their content and metadata\n         5.1.2. Return the compiled list of posts\n     5.2. For error scenarios:\n         5.2.1. Generate appropriate error response with details\n         5.2.2. Include guidance on how to resolve the issue\n         5.2.3. Return error information",
    "databaseEntities": [
      "jforum_posts",
      "jforum_posts_text",
      "jforum_topics",
      "jforum_forums",
      "jforum_users"
    ],
    "validationRules": [
      "fromPostId must be a positive integer",
      "toPostId must be a positive integer",
      "fromPostId must be less than or equal to toPostId",
      "Posts must exist within the specified ID range",
      "System must be available for indexing operations"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Post": {
        "id": "number",
        "forumId": "number",
        "topicId": "number",
        "userId": "number",
        "time": "date",
        "text": "string",
        "subject": "string",
        "bbCodeEnabled": "boolean",
        "smiliesEnabled": "boolean",
        "postUsername": "string"
      }
    }
  },
  {
    "featureName": "GetPostsData",
    "description": "Retrieves data for specified post IDs from the system.",
    "inputValues": [
      "postIds-number-Post"
    ],
    "businessLogic": "1. Input Collection\n   1.1. Collect the array of post IDs to retrieve\n       1.1.1. Verify that post IDs are provided as integers\n       1.1.2. Check if the array is not empty\n\n2. Data Validation\n   2.1. Validate post IDs\n       2.1.1. Check if each post ID is a positive integer\n       2.1.2. IF any post ID is invalid THEN prepare error message\n       2.1.3. Check if the number of post IDs doesn't exceed system limits\n       2.1.4. IF too many post IDs are requested THEN prepare error message about exceeding limit\n\n3. Business Rule Processing\n   3.1. Check user permissions\n       3.1.1. Verify if the current user has permission to access the requested posts\n       3.1.2. IF user lacks permission THEN prepare access denied error\n   3.2. Check system state\n       3.2.1. Verify if the system is in a state that allows data retrieval\n       3.2.2. IF system is in maintenance mode THEN prepare system unavailable error\n\n4. Core Operation Execution\n   4.1. Prepare data retrieval operation\n       4.1.1. Format the post IDs for efficient retrieval\n       4.1.2. Determine which data fields need to be retrieved\n   4.2. Retrieve post data\n       4.2.1. Access the posts repository\n       4.2.2. Fetch post records matching the provided IDs\n       4.2.3. IF any post is not found THEN note the missing posts\n   4.3. Process retrieved data\n       4.3.1. Format each post's content according to system requirements\n       4.3.2. Filter out any sensitive information based on user permissions\n       4.3.3. Sort posts in the requested order if specified\n       4.3.4. Enrich posts with additional information like username\n\n5. Response Generation\n   5.1. Prepare success response\n       5.1.1. Format the retrieved post data into the expected structure\n       5.1.2. Include metadata about the retrieval (total count, missing posts, etc.)\n       5.1.3. Return a collection of post objects with complete information\n   5.2. Handle error cases\n       5.2.1. IF no posts were found THEN return empty result with appropriate message\n       5.2.2. IF some posts were not found THEN include partial results with warning\n       5.2.3. IF critical error occurred THEN return error message with support information",
    "databaseEntities": [
      "jforum_posts",
      "jforum_posts_text",
      "jforum_users",
      "jforum_topics",
      "jforum_forums"
    ],
    "validationRules": [
      "Post IDs must be positive integers",
      "Post IDs array must not be empty",
      "Number of requested post IDs must not exceed system limit",
      "User must have permission to access the requested posts"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Post": {
        "id": "number",
        "topicId": "number",
        "forumId": "number",
        "userId": "number",
        "postTime": "date",
        "postSubject": "string",
        "postText": "string",
        "postUsername": "string",
        "bbCodeEnabled": "boolean",
        "smiliesEnabled": "boolean",
        "attachments": "object[]"
      }
    }
  },
  {
    "featureName": "FirstPostIdByDate",
    "description": "Finds the first post ID created on or after a specified date.",
    "inputValues": [
      "date-date-Post"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the target date (date) from the user\n   - Verify the date is properly formatted\n   - Verify the date is not null\n\n2. Data Validation:\n   - Validate that the provided date is a valid date format\n   - IF date is in the future THEN\n     - Generate an error message indicating that future dates are not valid\n     - Return an appropriate error response\n   - IF date is null THEN\n     - Generate an error message indicating that date is required\n     - Return an appropriate error response\n\n3. Business Rule Processing:\n   - Verify that the post repository is accessible\n   - Check if the system has any posts in the database\n   - IF no posts exist in the system THEN\n     - Return a response indicating no posts are available\n\n4. Core Operation Execution:\n   - Query the post repository for all posts\n   - Sort the posts by their creation date in ascending order\n   - Iterate through the sorted posts\n   - FOR each post in the sorted collection:\n     - Compare the post's creation date with the target date\n     - IF post creation date is greater than or equal to the target date THEN\n       - Store the post ID as the result\n       - Exit the iteration loop\n   - IF no matching post is found THEN\n     - Set the result to indicate no matching post (e.g., -1 or appropriate indicator)\n\n5. Response Generation:\n   - IF a matching post ID was found THEN\n     - Return the post ID as the operation result\n   - ELSE\n     - Return an indicator that no post exists on or after the specified date\n   - Include appropriate status information in the response",
    "databaseEntities": [
      "jforum_posts"
    ],
    "validationRules": [
      "Date must be a valid date format",
      "Date must not be in the future",
      "Date must not be null"
    ],
    "dbSeedingOperations": [],
    "schema": {}
  },
  {
    "featureName": "LastPostIdByDate",
    "description": "Finds the last post ID created on or before a specified date.",
    "inputValues": [
      "targetDate-date-Post"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the target date (targetDate) from the user\n   - Validate that targetDate is a valid date format\n   - Determine if targetDate is required or if system should use current date as default\n\n2. Data Validation:\n   - Validate that targetDate is not null if required\n   - Validate that targetDate is a valid date format\n   - Validate that targetDate is not in the future\n   - IF targetDate is invalid THEN\n     - Generate appropriate error message\n     - Return error response\n   - END IF\n\n3. Business Rule Processing:\n   - Verify that the post repository is accessible\n   - Verify that post data exists in the system\n   - IF post repository is not accessible THEN\n     - Generate system error message\n     - Return error response\n   - END IF\n   - IF no posts exist in the system THEN\n     - Generate appropriate message indicating no posts exist\n     - Return zero or null as post ID\n   - END IF\n\n4. Core Operation Execution:\n   - Query the post repository for all posts\n   - Filter posts to include only those created on or before the targetDate\n   - IF no posts match the date criteria THEN\n     - Return zero or null as post ID\n   - ELSE\n     - Sort the filtered posts by creation date in descending order\n     - Identify the post with the most recent creation date that is still on or before targetDate\n     - Extract the ID of this identified post\n   - END IF\n\n5. Response Generation:\n   - IF a matching post was found THEN\n     - Return the post ID as the result\n     - Include metadata about the found post (optional)\n   - ELSE\n     - Return appropriate message indicating no posts were found for the given date criteria\n     - Return zero or null as post ID\n   - END IF",
    "databaseEntities": [
      "jforum_posts"
    ],
    "validationRules": [
      "Target date must be a valid date format",
      "Target date must not be in the future",
      "Post repository must be accessible",
      "Return value must be an integer representing a post ID or zero/null if no matching post exists"
    ],
    "dbSeedingOperations": [],
    "schema": {}
  },
  {
    "featureName": "FirstPostId",
    "description": "Retrieves the ID of the first post in the system.",
    "inputValues": [],
    "businessLogic": "1. Input Collection:\n   - No user inputs required for this feature\n   - System will automatically determine the first post ID\n\n2. Data Validation:\n   - Verify system access permissions\n   - Validate that the posts repository is accessible\n   - Check that the database connection is active\n   - IF any validation fails THEN\n     - Generate appropriate error message\n     - Terminate operation\n   - END IF\n\n3. Business Rule Processing:\n   - Check if post records exist in the system\n   - IF no posts exist in the system THEN\n     - Return appropriate indication that no posts are available\n     - Terminate operation\n   - END IF\n   - Verify post data integrity\n   - Ensure post ID sequence is valid\n\n4. Core Operation Execution:\n   - Query the posts repository for the lowest post ID value\n   - Order all posts by ID in ascending order\n   - Select the first record from the ordered list\n   - Extract the ID value from the selected record\n   - Store the ID value for return\n   - IF retrieval operation fails THEN\n     - Log the failure reason\n     - Prepare error response\n     - Terminate operation\n   - END IF\n\n5. Response Generation:\n   - Format the post ID as required by the calling system\n   - Return the first post ID value\n   - IF operation was successful THEN\n     - Include success status in response\n   - ELSE\n     - Include error details in response\n     - Provide troubleshooting information\n   - END IF",
    "databaseEntities": [
      "jforum_posts"
    ],
    "validationRules": [
      "System must have access to post records",
      "Database connection must be active",
      "Post repository must contain at least one record for successful retrieval",
      "Post ID must be a positive integer value"
    ],
    "dbSeedingOperations": [],
    "schema": {}
  },
  {
    "featureName": "ApprovePost",
    "description": "Approves a post for publication based on its ID.",
    "inputValues": [
      "postId-number-Post"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect postId (number, mandatory) from the user input\n   - System will use current user information for authorization checks\n   - System will use current timestamp for approval recording\n\n2. Data Validation:\n   - Validate postId:\n     a. Check if postId is provided and is a positive integer\n     b. Verify the postId exists in the system\n     c. Return appropriate error if validation fails\n   - Validate user permissions:\n     a. Verify current user has moderation privileges for the forum containing this post\n     b. Check if user belongs to moderator groups for the relevant forum\n     c. Return appropriate error if user lacks required permissions\n\n3. Business Rule Processing:\n   - Check post current status:\n     a. Verify the post is in a pending moderation state\n     b. If post is already approved, return appropriate message\n     c. If post is deleted or in another state, return error message\n   - Check forum moderation settings:\n     a. Verify the forum has moderation enabled\n     b. Ensure the post belongs to a forum that requires moderation\n\n4. Core Operation Execution:\n   - Update post status:\n     a. Change post status from 'pending' to 'approved'\n     b. Record the moderator ID who approved the post\n     c. Set approval timestamp to current system time\n   - Update related records:\n     a. If this is the first approved post in a topic, update topic visibility\n     b. Update forum statistics to reflect the newly approved post\n     c. Update user post count for the post author\n   - Notification processing:\n     a. Generate notification to the post author about approval\n     b. Update moderation queue to remove the approved post\n\n5. Response Generation:\n   - Success response:\n     a. Return confirmation message that post was successfully approved\n     b. Include post details (topic, forum) in the response\n     c. Provide link or reference to view the approved post\n   - Error response:\n     a. Return specific error message if operation failed\n     b. Include error code and suggested resolution steps\n     c. Provide contact information for support if needed",
    "databaseEntities": [
      "jforum_posts",
      "jforum_topics",
      "jforum_forums",
      "jforum_users",
      "jforum_moderator_groups",
      "jforum_user_groups",
      "jforum_posts_text"
    ],
    "validationRules": [
      "Post ID must be a positive integer",
      "Post must exist in the system",
      "Post must be in pending moderation state",
      "User must have moderation privileges for the forum",
      "Forum must have moderation enabled"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Post": {
        "type": "object",
        "properties": {
          "id": {
            "type": "number",
            "description": "Unique identifier for the post"
          },
          "topicId": {
            "type": "number",
            "description": "ID of the topic this post belongs to"
          },
          "forumId": {
            "type": "number",
            "description": "ID of the forum this post belongs to"
          },
          "userId": {
            "type": "number",
            "description": "ID of the user who created the post"
          },
          "status": {
            "type": "string",
            "description": "Current status of the post (pending, approved, etc.)"
          },
          "creationDate": {
            "type": "date",
            "description": "Date when the post was created"
          },
          "approvalDate": {
            "type": "date",
            "description": "Date when the post was approved"
          },
          "moderatorId": {
            "type": "number",
            "description": "ID of the moderator who approved the post"
          },
          "postUsername": {
            "type": "string",
            "description": "Username of the post author"
          },
          "bbCodeEnabled": {
            "type": "boolean",
            "description": "Whether BBCode is enabled for this post"
          },
          "htmlEnabled": {
            "type": "boolean",
            "description": "Whether HTML is enabled for this post"
          },
          "smiliesEnabled": {
            "type": "boolean",
            "description": "Whether smilies are enabled for this post"
          },
          "subject": {
            "type": "string",
            "description": "Subject of the post"
          },
          "text": {
            "type": "string",
            "description": "Content text of the post"
          }
        },
        "required": [
          "id",
          "topicId",
          "forumId",
          "userId",
          "status",
          "creationDate"
        ]
      }
    }
  },
  {
    "featureName": "GetTopicsByForum",
    "description": "Retrieves all topics for a specific forum with pagination support.",
    "inputValues": [
      "forumId-number-Forum",
      "startIndex-number-Pagination"
    ],
    "businessLogic": "1. Input Collection\n   - Collect forumId (number, mandatory) to identify the target forum\n   - Collect startIndex (number, mandatory) to determine the starting position for pagination\n\n2. Data Validation\n   - Validate forumId\n     - Check if forumId is provided\n     - Verify forumId is a positive integer\n     - Verify forumId corresponds to an existing forum\n     - IF validation fails, THEN generate appropriate error message\n   - Validate startIndex\n     - Check if startIndex is provided\n     - Verify startIndex is a non-negative integer\n     - IF validation fails, THEN generate appropriate error message\n\n3. Business Rule Processing\n   - Verify user has permission to access the forum\n     - Check if the forum exists in the system\n     - Check if the forum's category is accessible to the current user\n     - IF forum doesn't exist OR category is not accessible, THEN deny access and return error message\n   - Determine topic retrieval strategy\n     - IF startIndex is 0 AND topic caching is enabled, THEN attempt to retrieve topics from cache\n     - ELSE retrieve topics directly from the database\n\n4. Core Operation Execution\n   - Retrieve topics from cache (if applicable)\n     - Check if topics for the specified forum exist in the cache\n     - Check if the forum is marked as loaded in the cache\n     - IF topics don't exist in cache OR forum is not loaded:\n       - Synchronize access to prevent multiple simultaneous loads\n       - Retrieve topics from database with pagination limits\n       - Store topics in the cache for future use\n   - Retrieve topics from database (if not using cache)\n     - Query for topics in the specified forum with pagination\n     - Limit results to the configured number of topics per page\n     - Start from the specified index position\n   - Process retrieved topics\n     - For each topic:\n       - Determine if the topic has been read by the current user\n       - Calculate if pagination is needed for the topic's posts\n       - Mark hot topics based on reply count threshold\n       - Set topic status flags (sticky, announcement, locked)\n\n5. Response Generation\n   - Prepare topic listing response\n     - Return the list of processed topics\n     - Include all topic metadata:\n       - Topic ID, title, and description\n       - Post counts and view counts\n       - Last post information\n       - Topic type and status indicators\n       - Read/unread status for current user\n       - Pagination information for topics with many posts\n   - Format response for presentation\n     - Structure data for easy display in forum view\n     - Include all necessary information for topic listing",
    "databaseEntities": [
      "jforum_forums",
      "jforum_topics",
      "jforum_posts",
      "jforum_users",
      "jforum_categories"
    ],
    "validationRules": [
      "Forum ID must be a positive integer",
      "Forum ID must reference an existing forum",
      "Start index must be a non-negative integer",
      "User must have access permissions to the forum's category",
      "Forum must be active and accessible"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Topic": {
        "type": "object",
        "properties": {
          "id": {
            "type": "number",
            "description": "Unique identifier for the topic"
          },
          "forumId": {
            "type": "number",
            "description": "ID of the forum this topic belongs to"
          },
          "title": {
            "type": "string",
            "description": "Title of the topic"
          },
          "totalReplies": {
            "type": "number",
            "description": "Number of replies in the topic"
          },
          "totalViews": {
            "type": "number",
            "description": "Number of times the topic has been viewed"
          },
          "lastPostDate": {
            "type": "string",
            "format": "date-time",
            "description": "Date and time of the last post"
          },
          "lastPostId": {
            "type": "number",
            "description": "ID of the last post in the topic"
          },
          "type": {
            "type": "number",
            "description": "Type of topic (normal, sticky, announcement)"
          },
          "status": {
            "type": "number",
            "description": "Status of the topic (locked, unlocked)"
          },
          "isRead": {
            "type": "boolean",
            "description": "Whether the current user has read this topic"
          },
          "isHot": {
            "type": "boolean",
            "description": "Whether this is considered a hot topic based on reply count"
          },
          "paginate": {
            "type": "boolean",
            "description": "Whether pagination is needed for this topic's posts"
          },
          "totalPages": {
            "type": "number",
            "description": "Total number of pages for this topic's posts"
          }
        }
      }
    }
  },
  {
    "featureName": "GetCategoryPendingModeration",
    "description": "Retrieves information about categories and forums with posts awaiting moderation.",
    "inputValues": [],
    "businessLogic": "1. Input Collection:\n   - No user inputs required for this feature\n   - System will use current user's authentication context\n\n2. Data Validation:\n   - Validate user permissions\n     - IF user does not have moderation privileges THEN\n       - Generate permission denied error\n       - Exit process\n     - END IF\n\n3. Business Rule Processing:\n   - Check system configuration for moderation settings\n     - IF moderation feature is disabled system-wide THEN\n       - Return empty result set\n       - Exit process\n     - END IF\n   - Determine user's moderation scope\n     - IF user is global moderator THEN\n       - Set scope to all categories and forums\n     - ELSE\n       - Retrieve list of forums user has moderation rights for\n     - END IF\n\n4. Core Operation Execution:\n   - Retrieve pending moderation information\n     - Query database for categories containing forums with pending posts\n     - For each category:\n       - Retrieve basic category information (ID, name, description)\n       - Identify forums within category that have pending posts\n       - For each forum with pending posts:\n         - Retrieve forum information (ID, name, description)\n         - Count number of topics with pending posts\n         - Count total number of pending posts\n     - Organize data hierarchically by category and forum\n     - Process results sequentially:\n       - Track the last processed category ID\n       - Create new category information object when ID changes\n       - Add forum information to the current category object\n       - Add completed category to the results list\n   - Apply user's moderation scope filter\n     - IF user is not global moderator THEN\n       - Filter results to only include forums user can moderate\n     - END IF\n\n5. Response Generation:\n   - Prepare moderation summary data\n     - Format category and forum information\n     - Include pending post counts for each forum\n     - Include total pending post count across all accessible forums\n   - Return structured moderation data\n     - Categories with pending moderation\n     - Forums within each category with pending moderation\n     - Count of pending posts per forum\n     - Total count of pending posts",
    "databaseEntities": [
      "jforum_categories",
      "jforum_forums",
      "jforum_posts",
      "jforum_topics",
      "jforum_users",
      "jforum_groups",
      "jforum_moderator_groups",
      "jforum_user_groups"
    ],
    "validationRules": [
      "User must have moderation privileges",
      "Moderation feature must be enabled in system settings",
      "Only return categories and forums with at least one post pending moderation",
      "Only return forums the user has permission to moderate"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "ModerationPendingInfo": {
        "type": "object",
        "properties": {
          "categoryId": {
            "type": "integer",
            "description": "Unique identifier for the category"
          },
          "categoryName": {
            "type": "string",
            "description": "Name of the category"
          },
          "forums": {
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "forumId": {
                  "type": "integer",
                  "description": "Unique identifier for the forum"
                },
                "forumName": {
                  "type": "string",
                  "description": "Name of the forum"
                },
                "pendingPostsCount": {
                  "type": "integer",
                  "description": "Number of posts awaiting moderation in this forum"
                }
              }
            }
          },
          "totalPendingPosts": {
            "type": "integer",
            "description": "Total number of posts awaiting moderation in this category"
          }
        }
      }
    }
  },
  {
    "featureName": "AddModerationLog",
    "description": "Records a new moderation log entry in the system.",
    "inputValues": [
      "user-object-User",
      "description-string-ModerationLog",
      "originalMessage-string-ModerationLog",
      "type-number-ModerationLog",
      "postId-number-Post",
      "topicId-number-Topic",
      "posterUser-object-User"
    ],
    "businessLogic": "1. Input Collection:\n   1.1. Collect the following required inputs:\n       - user: Object containing moderator information (id, username)\n       - description: Textual description of the moderation action\n       - type: Numeric code representing the type of moderation action\n       - posterUser: Object containing information about the user whose content is being moderated\n   1.2. Collect the following optional inputs based on moderation context:\n       - originalMessage: Original content before moderation (if applicable)\n       - postId: Identifier of the post being moderated (if applicable)\n       - topicId: Identifier of the topic being moderated (if applicable)\n   1.3. System will automatically generate:\n       - timestamp: Current date and time when the log entry is created\n       - logId: Unique identifier for the moderation log entry\n\n2. Data Validation:\n   2.1. Validate user object:\n       - IF user is null THEN\n         - Return error: \"Moderator information is required\"\n       - IF user.id is empty, null, or less than 1 THEN\n         - Return error: \"Valid moderator ID is required\"\n       - IF user does not have moderation privileges THEN\n         - Return error: \"User does not have moderation privileges\"\n   2.2. Validate posterUser object:\n       - IF posterUser is null THEN\n         - Return error: \"Poster user information is required\"\n       - IF posterUser.id is empty, null, or less than 1 THEN\n         - Return error: \"Valid poster user ID is required\"\n   2.3. Validate type:\n       - IF type is null or less than 1 THEN\n         - Return error: \"Valid moderation type is required\"\n       - IF type is not a recognized moderation action code THEN\n         - Return error: \"Invalid moderation type code\"\n   2.4. Validate description:\n       - IF description is empty or null THEN\n         - Return error: \"Description is required\"\n       - IF description length exceeds maximum allowed characters THEN\n         - Return error: \"Description exceeds maximum length\"\n   2.5. Validate context-specific fields:\n       - IF type requires a post reference AND postId is null or less than 1 THEN\n         - Return error: \"Valid post ID is required for this moderation type\"\n       - IF type requires a topic reference AND topicId is null or less than 1 THEN\n         - Return error: \"Valid topic ID is required for this moderation type\"\n\n3. Business Rule Processing:\n   3.1. Check moderator permissions:\n       - IF moderation action is forum-specific THEN\n         - Verify moderator has permission for the specific forum\n         - IF not authorized THEN\n           - Return error: \"Moderator not authorized for this forum\"\n   3.2. Check for duplicate entries:\n       - IF an identical moderation log entry exists within short time window THEN\n         - Skip creating duplicate entry\n         - Return success with existing entry ID\n   3.3. Verify referenced entities exist:\n       - IF postId is provided THEN\n         - Verify post exists\n         - IF not exists THEN\n           - Return error: \"Referenced post does not exist\"\n       - IF topicId is provided THEN\n         - Verify topic exists\n         - IF not exists THEN\n           - Return error: \"Referenced topic does not exist\"\n\n4. Core Operation Execution:\n   4.1. Create moderation log entry:\n       - Create new ModerationLog object\n       - Set user to the provided moderator user object\n       - Set description to the provided description\n       - Set originalMessage to the provided original message (if applicable)\n         - IF originalMessage is null THEN\n           - Set originalMessage to empty string \"\"\n       - Set type to the provided moderation type code\n       - Set postId to the provided post ID (if applicable)\n       - Set topicId to the provided topic ID (if applicable)\n       - Set posterUser to the provided user object\n       - Set timestamp to current system time\n   4.2. Store log entry:\n       - Prepare database statement for inserting the log entry\n       - Execute the statement with all field values\n       - Retrieve the generated log ID\n       - Set the ID in the ModerationLog object\n       - Store description text in the database as a binary stream\n       - Store originalMessage text in the database as a binary stream\n       - IF save operation fails THEN\n         - Log system error\n         - Return error: \"Failed to save moderation log entry\"\n   4.3. Update related statistics:\n       - Increment moderator activity counter\n       - Update last moderation timestamp for the moderator\n\n5. Response Generation:\n   5.1. On success:\n       - Return success status\n       - Include the ModerationLog object with its newly assigned ID\n       - Include timestamp of the recorded action\n   5.2. On failure:\n       - Return error status\n       - Include specific error message\n       - Include error code for programmatic handling",
    "databaseEntities": [
      "ModerationLog",
      "User",
      "Post",
      "Topic"
    ],
    "validationRules": [
      "Moderator user object must be provided with a valid ID",
      "Poster user object must be provided with a valid ID",
      "Moderation type must be a valid action code",
      "Description is required and must not exceed maximum length",
      "Post ID must be valid if provided",
      "Topic ID must be valid if provided",
      "Moderator must have permission for the forum being moderated",
      "Original message will be set to empty string if null"
    ],
    "dbSeedingOperations": [
      "Insert default moderation action types",
      "Ensure moderator permissions are properly set"
    ],
    "schema": {
      "ModerationLog": {
        "id": "number",
        "user": {
          "id": "number",
          "username": "string"
        },
        "description": "string",
        "originalMessage": "string",
        "date": "date",
        "type": "number",
        "postId": "number",
        "topicId": "number",
        "posterUser": {
          "id": "number",
          "username": "string"
        }
      },
      "User": {
        "id": "number",
        "username": "string"
      }
    }
  },
  {
    "featureName": "GetModerationLogs",
    "description": "Retrieves a paginated list of moderation log entries.",
    "inputValues": [
      "startIndex-number-Pagination",
      "count-number-Pagination"
    ],
    "businessLogic": "1. Input Collection\n   - Collect the following inputs:\n     a. startIndex (number): The starting position for pagination (mandatory)\n     b. count (number): The number of records to retrieve (mandatory)\n\n2. Data Validation\n   - Validate pagination parameters:\n     a. IF startIndex is not provided OR is less than 0 THEN\n        - Set error message: \"Start index must be a non-negative number\"\n        - Return validation error\n     b. IF count is not provided OR is less than or equal to 0 THEN\n        - Set error message: \"Count must be a positive number\"\n        - Return validation error\n     c. IF count exceeds system-defined maximum page size THEN\n        - Set count to system-defined maximum page size\n\n3. Business Rule Processing\n   - Verify user permissions:\n     a. Check if current user has permission to view moderation logs\n     b. IF user does not have required permissions THEN\n        - Set error message: \"Insufficient permissions to view moderation logs\"\n        - Return access denied error\n   - Verify system state:\n     a. Check if the moderation log feature is enabled in system settings\n     b. IF feature is disabled THEN\n        - Set error message: \"Moderation log feature is currently disabled\"\n        - Return feature unavailable error\n\n4. Core Operation Execution\n   - Retrieve total count of moderation log entries\n     a. Query the total number of records in the moderation log\n     b. Store the total count for pagination metadata\n   - Retrieve paginated moderation log entries:\n     a. Fetch moderation log entries starting from startIndex\n     b. Limit results to specified count\n     c. Sort entries by timestamp in descending order (newest first)\n   - For each moderation log entry:\n     a. Retrieve associated user information (username, user ID)\n     b. Retrieve associated content information (post, topic, or forum)\n     c. Format timestamp to user-friendly format\n   - IF no records are found THEN\n     a. Set empty result list\n     b. Set appropriate message indicating no logs were found\n\n5. Response Generation\n   - Prepare success response with:\n     a. List of moderation log entries containing:\n        - Log ID\n        - Timestamp\n        - Moderator information (name, ID)\n        - Action performed\n        - Description of action\n        - Affected content information\n     b. Pagination metadata:\n        - Total record count\n        - Current page information\n        - More records indicator (boolean)\n   - IF any errors occurred during processing THEN\n     a. Generate appropriate error response with:\n        - Error code\n        - Error message\n        - Suggested resolution steps if applicable",
    "databaseEntities": [
      "jforum_users",
      "jforum_topics",
      "jforum_posts",
      "jforum_forums"
    ],
    "validationRules": [
      "Start index must be a non-negative number",
      "Count must be a positive number",
      "Count cannot exceed the maximum allowed page size",
      "User must have permission to view moderation logs"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "ModerationLog": {
        "type": "object",
        "properties": {
          "id": {
            "type": "number",
            "description": "Unique identifier for the moderation log entry"
          },
          "timestamp": {
            "type": "date",
            "description": "Date and time when the moderation action occurred"
          },
          "userId": {
            "type": "number",
            "description": "ID of the moderator who performed the action"
          },
          "username": {
            "type": "string",
            "description": "Username of the moderator who performed the action"
          },
          "action": {
            "type": "string",
            "description": "Type of moderation action performed"
          },
          "description": {
            "type": "string",
            "description": "Detailed description of the moderation action"
          },
          "affectedContentId": {
            "type": "number",
            "description": "ID of the content affected by the moderation action"
          },
          "affectedContentType": {
            "type": "string",
            "description": "Type of content affected (post, topic, forum, etc.)"
          }
        }
      },
      "Pagination": {
        "type": "object",
        "properties": {
          "startIndex": {
            "type": "number",
            "description": "Starting position for pagination"
          },
          "count": {
            "type": "number",
            "description": "Number of records to retrieve"
          },
          "totalRecords": {
            "type": "number",
            "description": "Total number of records available"
          },
          "hasMoreRecords": {
            "type": "boolean",
            "description": "Indicates if more records are available beyond the current page"
          }
        }
      }
    }
  },
  {
    "featureName": "CountModerationLogs",
    "description": "Returns the total number of moderation log records in the system.",
    "inputValues": [],
    "businessLogic": "1. Input Collection:\n   - No user inputs required for this feature\n   - System will use existing authentication context to verify access rights\n\n2. Data Validation:\n   - Verify user authorization\n     a. Check if current user has administrator privileges\n     b. IF user is not authorized THEN\n        i. Generate access denied error\n        ii. Terminate process\n     c. ELSE continue to next step\n\n3. Business Rule Processing:\n   - Verify system state\n     a. Check if the moderation log functionality is enabled in system settings\n     b. IF moderation logging is disabled THEN\n        i. Return zero as count\n        ii. Terminate process\n     c. ELSE continue to next step\n\n4. Core Operation Execution:\n   - Count moderation log records\n     a. Access the moderation log storage\n     b. Count all moderation log entries regardless of type or date\n     c. IF counting operation fails THEN\n        i. Log system error\n        ii. Generate appropriate error message\n        iii. Terminate process\n     d. ELSE continue to next step\n\n5. Response Generation:\n   - Prepare count result\n     a. Format the count as an integer number\n     b. Return the total count of moderation log records\n     c. IF display formatting is required THEN\n        i. Apply any necessary formatting (thousands separators, etc.)\n     d. Return the final count value to the caller",
    "databaseEntities": [
      "jforum_moderation_log"
    ],
    "validationRules": [
      "User must have administrator privileges to access moderation log counts",
      "Moderation logging must be enabled in system settings"
    ],
    "dbSeedingOperations": [],
    "schema": {}
  },
  {
    "featureName": "HandleMySQLWorkarounds",
    "description": "Detects MySQL version and applies appropriate configuration fixes for database compatibility.",
    "inputValues": [
      "databaseConnection-object-Connection"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect database connection object\n   - Retrieve current database configuration settings\n   - Identify database type from system configuration\n\n2. Data Validation:\n   - Validate database connection is not null\n     * IF connection is null THEN\n       * Log warning message about null connection\n       * Exit process\n     * END IF\n   - Validate database type is MySQL\n     * IF database type is not MySQL THEN\n       * Exit process as workarounds only apply to MySQL\n     * END IF\n\n3. Business Rule Processing:\n   - Retrieve database metadata from connection\n   - Extract database version information (major and minor version)\n   - Determine appropriate configuration based on version\n     * IF major version is 3 AND minor version is 23 THEN\n       * Mark for MySQL 3.23 specific configuration\n     * ELSE IF major version is 4 AND minor version is 0 THEN\n       * Mark for MySQL 4.0 specific configuration\n     * ELSE IF major version is greater than 4 OR (major version is 4 AND minor version is greater than 0) THEN\n       * Mark for MySQL 4.1+ specific configuration\n     * END IF\n\n4. Core Operation Execution:\n   - Apply MySQL 3.23 specific workarounds if needed\n     * Update data access driver class to MySQL 3.23 specific driver\n     * Load necessary SQL queries for MySQL 3.23\n     * Update SQL query configuration file with version-specific queries\n   - Apply MySQL 4.0 specific workarounds if needed\n     * Update data access driver class to standard MySQL driver\n     * Load necessary SQL queries for MySQL 4.0\n     * Update SQL query configuration file with version-specific queries\n   - Apply MySQL 4.1+ specific workarounds if needed\n     * Update data access driver class to standard MySQL driver\n     * Clear any unnecessary SQL query overrides\n     * Fix character encoding settings in configuration\n   - Reload system configuration to apply changes\n\n5. Response Generation:\n   - Log completion of workaround application\n   - Log any errors encountered during the process\n   - Return success or failure status",
    "databaseEntities": [
      "jforum_users",
      "jforum_groups",
      "jforum_categories",
      "jforum_forums",
      "jforum_topics",
      "jforum_posts",
      "jforum_posts_text",
      "jforum_attachments",
      "jforum_privmsgs",
      "jforum_privmsgs_text",
      "jforum_moderator_groups",
      "jforum_user_groups",
      "jforum_sessions",
      "jforum_smilies",
      "jforum_words",
      "jforum_karma",
      "jforum_bookmarks",
      "jforum_quota_limit",
      "jforum_extension_groups"
    ],
    "validationRules": [
      "Database connection must not be null",
      "Database type must be MySQL",
      "Configuration files must be writable for updates",
      "SQL query file must exist and be accessible",
      "Database driver configuration file must exist and be accessible"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Connection": {
        "type": "object",
        "properties": {
          "metaData": {
            "type": "object",
            "description": "Database metadata information"
          }
        },
        "description": "Database connection object"
      }
    }
  },
  {
    "featureName": "FixMySQLEncoding",
    "description": "Adjusts MySQL encoding settings for proper character handling in newer MySQL versions.",
    "inputValues": [
      "databaseConnection-object-DatabaseConnection",
      "configurationFile-object-ConfigurationFile"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect database connection object with metadata access capabilities\n   - Collect configuration file path with read/write permissions\n   - System configuration settings containing database driver information\n\n2. Data Validation:\n   - Validate database connection is not null\n     * IF connection is null THEN\n       * Log warning message about null connection\n       * Exit process\n     * END IF\n   - Validate database type is MySQL\n     * IF database type is not MySQL THEN\n       * Exit process as this feature is MySQL-specific\n     * END IF\n   - Validate configuration file exists and is writable\n     * IF configuration file cannot be accessed or written THEN\n       * Log warning about insufficient privileges\n       * Continue with limited functionality\n     * END IF\n\n3. Business Rule Processing:\n   - Detect MySQL version from database metadata\n     * Retrieve major and minor version numbers\n     * Categorize version into one of three groups:\n       * MySQL 3.23\n       * MySQL 4.0x\n       * MySQL 4.1x or higher\n   - Determine required actions based on version\n     * For MySQL 3.23:\n       * Ensure correct data access driver is set\n       * Update SQL queries if necessary\n     * For MySQL 4.0x:\n       * Ensure correct data access driver is set\n       * Update SQL queries if necessary\n     * For MySQL 4.1x or higher:\n       * Ensure correct data access driver is set\n       * Clear any unnecessary SQL queries\n       * Fix encoding settings\n\n4. Core Operation Execution:\n   - For MySQL 4.1x or higher versions:\n     * Load database configuration properties\n     * Remove MySQL-specific encoding settings:\n       * Set 'mysql.encoding' property to empty string\n       * Set 'mysql.unicode' property to empty string\n     * Save updated configuration back to file\n   - For all MySQL versions:\n     * Update data access driver class if needed\n       * Load driver configuration file\n       * Set appropriate driver class name\n       * Save updated configuration\n       * Reload driver implementation in system\n   - For MySQL 3.23 and 4.0x:\n     * Update SQL query definitions if needed\n       * Load current SQL queries\n       * Check for missing required queries\n       * If missing, load version-specific SQL definitions\n       * Save updated queries\n       * Reload queries in system\n\n5. Response Generation:\n   - Log completion status of encoding fix\n   - Log any errors encountered during the process\n   - No direct user response as this is a system maintenance feature",
    "databaseEntities": [],
    "validationRules": [
      "Database connection must not be null",
      "Database must be MySQL type",
      "Configuration files must be writable for changes to take effect",
      "MySQL version must be correctly identified before applying fixes"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "DatabaseConnection": {
        "type": "object",
        "properties": {
          "connection": {
            "type": "object",
            "description": "Active database connection"
          },
          "metadata": {
            "type": "object",
            "description": "Database metadata information"
          }
        }
      },
      "ConfigurationFile": {
        "type": "object",
        "properties": {
          "path": {
            "type": "string",
            "description": "Path to configuration file"
          },
          "properties": {
            "type": "object",
            "description": "Configuration properties"
          }
        }
      }
    }
  },
  {
    "featureName": "ConfigureDAOImplementation",
    "description": "Updates data access driver configuration based on detected MySQL version.",
    "inputValues": [
      "databaseConnection-object-DatabaseConnection"
    ],
    "businessLogic": "1. Input Collection\n   - Collect database connection object\n     1.1. Verify connection is not null\n     1.2. Check if database type is MySQL\n\n2. Data Validation\n   - Validate database connection parameters\n     2.1. Verify connection is active and accessible\n     2.2. Confirm database metadata can be retrieved\n     2.3. IF connection is null THEN\n          2.3.1. Log warning message\n          2.3.2. Exit process\n     2.4. IF database is not MySQL THEN\n          2.4.1. Exit process without changes\n\n3. Business Rule Processing\n   - Detect MySQL version and determine appropriate configuration\n     3.1. Retrieve database metadata from connection\n     3.2. Extract MySQL major and minor version numbers\n     3.3. Determine appropriate data access driver based on version\n        3.3.1. IF version is 3.23 THEN\n               - Select MySQL 3.23 specific driver\n        3.3.2. ELSE IF version is 4.0 THEN\n               - Select standard MySQL driver with 4.0 compatibility\n        3.3.3. ELSE IF version is 4.1 or higher THEN\n               - Select standard MySQL driver with modern features\n\n4. Core Operation Execution\n   - Apply appropriate configuration changes\n     4.1. For MySQL 3.23:\n        4.1.1. Update DAO class to MySQL 3.23 specific implementation\n        4.1.2. Load MySQL 3.23 specific SQL queries\n        4.1.3. Save updated SQL queries configuration\n     4.2. For MySQL 4.0:\n        4.2.1. Update DAO class to standard MySQL implementation\n        4.2.2. Load MySQL 4.0 specific SQL queries\n        4.2.3. Save updated SQL queries configuration\n     4.3. For MySQL 4.1+:\n        4.3.1. Update DAO class to standard MySQL implementation\n        4.3.2. Clear any version-specific SQL queries\n        4.3.3. Update encoding settings to support Unicode\n     4.4. Reload configuration to apply changes\n\n5. Response Generation\n   - Complete configuration update process\n     5.1. Log completion of configuration update\n     5.2. Return status of configuration update\n     5.3. IF any errors occurred during configuration THEN\n          5.3.1. Log detailed error information\n          5.3.2. Return error status with details",
    "databaseEntities": [],
    "validationRules": [
      "Database connection must not be null",
      "Database must be MySQL to apply version-specific configurations",
      "Configuration files must be writable to update settings",
      "Database version must be correctly identified from metadata"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "DatabaseConnection": {
        "type": "object",
        "properties": {
          "connection": {
            "type": "object",
            "description": "Active database connection"
          },
          "metadata": {
            "type": "object",
            "description": "Database metadata information"
          }
        },
        "required": [
          "connection"
        ]
      }
    }
  },
  {
    "featureName": "UpdateSQLQueries",
    "description": "Loads and updates SQL query definitions appropriate for the detected MySQL version.",
    "inputValues": [
      "databaseConnection-object-Connection",
      "systemConfiguration-object-SystemConfiguration"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect database connection object\n   - Collect system configuration settings\n   - Determine database driver name from configuration\n   \n2. Data Validation:\n   - Validate database connection is not null\n     * IF connection is null THEN\n       * Log warning message\n       * Exit process\n     * END IF\n   - Validate database driver is MySQL\n     * IF database driver is not MySQL THEN\n       * Exit process without changes\n     * END IF\n   \n3. Business Rule Processing:\n   - Detect MySQL version information\n     * Retrieve database metadata from connection\n     * Extract major and minor version numbers\n     * Log detected version information\n   - Determine appropriate configuration based on version\n     * IF major version is 3 AND minor version is 23 THEN\n       * Mark for MySQL 3.23 specific handling\n     * ELSE IF major version is 4 AND minor version is 0 THEN\n       * Mark for MySQL 4.0 specific handling\n     * ELSE IF major version is greater than 4 OR (major version is 4 AND minor version is greater than 0) THEN\n       * Mark for MySQL 4.1+ specific handling\n     * END IF\n   \n4. Core Operation Execution:\n   - Process MySQL 3.23 specific configuration (if applicable)\n     * Ensure data access driver class is set to MySQL 3.23 specific driver\n     * Load current SQL queries configuration\n     * Check for necessary query keys in configuration\n     * IF required keys are missing or configuration is empty THEN\n       * Load MySQL 3.23 specific SQL queries from file\n       * Save updated SQL queries configuration\n     * END IF\n   - Process MySQL 4.0 specific configuration (if applicable)\n     * Ensure data access driver class is set to standard MySQL driver\n     * Load current SQL queries configuration\n     * IF configuration is empty or missing specific keys THEN\n       * Load MySQL 4.0 specific SQL queries from file\n       * Save updated SQL queries configuration\n     * END IF\n   - Process MySQL 4.1+ specific configuration (if applicable)\n     * Ensure data access driver class is set to standard MySQL driver\n     * Load current SQL queries configuration\n     * IF configuration is not empty THEN\n       * Reset SQL queries configuration to empty\n     * END IF\n     * Update encoding settings to remove MySQL-specific encoding parameters\n   \n5. Response Generation:\n   - Log completion of configuration updates\n   - Reload system configuration with updated settings\n   - Return success status indicating whether changes were made",
    "databaseEntities": [],
    "validationRules": [
      "Database connection must not be null",
      "Database driver must be MySQL to apply workarounds",
      "Configuration files must be writable to apply changes",
      "SQL query definition files must exist in the expected locations"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Connection": {
        "type": "object",
        "properties": {
          "metaData": {
            "type": "object",
            "description": "Database metadata information"
          }
        }
      },
      "SystemConfiguration": {
        "type": "object",
        "properties": {
          "databaseDriverName": {
            "type": "string",
            "description": "Name of the database driver"
          },
          "configurationPaths": {
            "type": "object",
            "description": "Paths to configuration files"
          }
        }
      }
    }
  },
  {
    "featureName": "GetPollById",
    "description": "Retrieves a specific poll by its ID with all associated information.",
    "inputValues": [
      "pollId-number-Poll"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the Poll ID (pollId) as a mandatory numeric input\n   - No optional fields required\n   - No default values needed\n\n2. Data Validation:\n   - Validate Poll ID:\n     a. Check if Poll ID is provided\n     b. Verify Poll ID is a positive integer\n     c. Return appropriate error message if validation fails\n\n3. Business Rule Processing:\n   - Check system access permissions:\n     a. Verify if the current user has permission to view polls\n     b. If permission check fails, generate appropriate access denied message\n   - Check poll existence:\n     a. Verify if a poll with the provided ID exists in the system\n     b. If poll does not exist, prepare appropriate not found message\n\n4. Core Operation Execution:\n   - Retrieve poll data:\n     a. Fetch the poll record using the provided Poll ID\n     b. Retrieve all poll options associated with this poll\n     c. Retrieve vote counts for each option\n     d. Retrieve total vote count for the poll\n   - Compile poll information:\n     a. Combine poll details with its options\n     b. Calculate percentage of votes for each option\n     c. Determine if the poll is still active or expired\n     d. IF poll has an associated topic, include reference to the topic\n\n5. Response Generation:\n   - Success response:\n     a. Return the complete poll object with all details\n     b. Include poll options and their vote statistics\n     c. Include poll metadata (creation date, expiration status, etc.)\n   - Error response:\n     a. Return appropriate error message if poll was not found\n     b. Return permission denied message if applicable\n     c. Return validation error details if input validation failed",
    "databaseEntities": [
      "Poll",
      "PollOption",
      "PollVote",
      "User",
      "Topic"
    ],
    "validationRules": [
      "Poll ID must be a positive integer",
      "Poll must exist in the system",
      "User must have permission to view the poll"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Poll": {
        "id": "number",
        "label": "string",
        "startDate": "date",
        "length": "number",
        "options": "array",
        "topicId": "number",
        "totalVotes": "number"
      },
      "PollOption": {
        "id": "number",
        "pollId": "number",
        "text": "string",
        "voteCount": "number",
        "percentage": "number"
      }
    }
  },
  {
    "featureName": "DeletePoll",
    "description": "Removes a poll from the system using its poll ID.",
    "inputValues": [
      "pollId-number-Poll"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the poll ID (pollId) as a required numeric input\n   - System must verify the user has appropriate permissions to delete polls\n\n2. Data Validation:\n   - Validate poll ID:\n     a. Verify poll ID is provided and is a positive integer\n     b. Check if poll ID exists in the system\n     c. Generate appropriate error message if validation fails\n   - Validate user permissions:\n     a. Check if the current user has permission to delete polls\n     b. If user is not authorized, generate permission denied error\n\n3. Business Rule Processing:\n   - Check poll deletion constraints:\n     a. Verify if the poll has any active voting sessions\n     b. Check if the poll is associated with an active topic\n     c. Determine if historical data needs to be preserved\n   - Prepare for cascading deletions:\n     a. Identify all poll options associated with this poll\n     b. Identify all votes cast for this poll\n     c. Determine impact on related topics or forums\n\n4. Core Operation Execution:\n   - Delete poll votes:\n     a. Remove all vote records associated with the poll\n     b. Update any vote count statistics if necessary\n   - Delete poll options:\n     a. Remove all option records associated with the poll\n   - Delete the poll record:\n     a. Remove the main poll record from the system\n     b. If deletion fails at any point, roll back all changes\n     c. Log the deletion operation with relevant details\n\n5. Response Generation:\n   - Success response:\n     a. Confirm poll deletion was successful\n     b. Include summary of deleted poll information\n     c. Provide navigation options to return to relevant section\n   - Error response:\n     a. Provide specific error details if deletion failed\n     b. Include guidance on how to resolve the issue\n     c. Offer option to retry or cancel the operation",
    "databaseEntities": [
      "Poll",
      "PollOption",
      "PollVote",
      "Topic",
      "User"
    ],
    "validationRules": [
      "Poll ID must be a positive integer",
      "Poll must exist in the system",
      "User must have permission to delete polls",
      "System must properly handle cascading deletions of poll options and votes"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Poll": {
        "id": "number",
        "topicId": "number",
        "label": "string",
        "length": "number",
        "startTime": "date",
        "options": "array"
      },
      "PollOption": {
        "id": "number",
        "pollId": "number",
        "text": "string",
        "voteCount": "number"
      },
      "PollVote": {
        "pollId": "number",
        "userId": "number",
        "ipAddress": "string"
      }
    }
  },
  {
    "featureName": "DeletePollByTopicId",
    "description": "Removes a poll associated with a specific forum topic.",
    "inputValues": [
      "topicId-number-Topic"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the topic ID (mandatory) from the user request\n   - System must have access to current user session information\n\n2. Data Validation:\n   - Validate that topicId is provided\n     - IF topicId is missing or null THEN\n       - Return error: \"Topic ID is required\"\n     - END IF\n   - Validate that topicId is a positive integer\n     - IF topicId is not a positive integer THEN\n       - Return error: \"Invalid Topic ID format\"\n     - END IF\n   - Validate that the topic exists in the system\n     - IF topic does not exist THEN\n       - Return error: \"Topic not found\"\n     - END IF\n   - Validate that a poll exists for the specified topic\n     - IF no poll exists for the topic THEN\n       - Return error: \"No poll found for this topic\"\n     - END IF\n\n3. Business Rule Processing:\n   - Check user permissions\n     - IF current user is not authorized to delete polls THEN\n       - Return error: \"Insufficient permissions to delete poll\"\n     - END IF\n   - Check if the topic is locked\n     - IF topic is locked THEN\n       - Return error: \"Cannot delete poll from a locked topic\"\n     - END IF\n   - Check if votes have already been cast on the poll\n     - IF votes exist for this poll THEN\n       - Determine if votes should be preserved in logs or completely removed\n     - END IF\n\n4. Core Operation Execution:\n   - Begin transaction\n     - Retrieve poll information associated with the topic ID\n       - Query the database to find the poll ID using the topic ID\n       - IF poll ID is found THEN\n         - Store the poll ID for deletion operations\n       - ELSE\n         - End process as no poll exists\n       - END IF\n     - Delete all votes cast on the poll\n       - Remove all voter records associated with the poll ID\n     - Delete all poll options related to the poll\n       - Remove all option records associated with the poll ID\n     - Delete the poll record itself\n       - Remove the main poll record using the poll ID\n     - Update the topic to indicate it no longer has an associated poll\n     - IF any operation fails THEN\n       - Rollback all changes\n       - Return error: \"Failed to delete poll\"\n     - END IF\n   - Commit transaction\n\n5. Response Generation:\n   - IF deletion is successful THEN\n     - Return success response with message: \"Poll successfully deleted\"\n     - Include topic ID in the response\n   - ELSE\n     - Return error response with appropriate error message\n     - Include error details for troubleshooting\n   - END IF",
    "databaseEntities": [
      "Topic",
      "Poll",
      "PollOption",
      "PollVote",
      "User"
    ],
    "validationRules": [
      "Topic ID must be a positive integer",
      "Topic must exist in the system",
      "Poll must exist for the specified topic",
      "User must have permission to delete polls",
      "Topic must not be locked"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Poll": {
        "id": "number",
        "topicId": "number",
        "label": "string",
        "length": "number",
        "startTime": "date",
        "options": "array"
      },
      "PollOption": {
        "id": "number",
        "pollId": "number",
        "text": "string",
        "voteCount": "number"
      },
      "PollVote": {
        "pollId": "number",
        "optionId": "number",
        "userId": "number",
        "ipAddress": "string",
        "voteDate": "date"
      }
    }
  },
  {
    "featureName": "UpdatePoll",
    "description": "Modifies an existing poll's information.",
    "inputValues": [
      "pollId-number-Poll",
      "pollTitle-string-Poll",
      "pollLength-number-Poll",
      "pollOptions-object-PollOptions",
      "userId-number-User"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the following inputs:\n     1.1. pollId (mandatory): Numeric identifier of the poll to update\n     1.2. pollTitle (mandatory): String containing the new title for the poll\n     1.3. pollLength (mandatory): Numeric value representing the duration of the poll in days\n     1.4. pollOptions (mandatory): Collection of poll option objects\n     1.5. userId (mandatory): Numeric identifier of the user performing the update\n\n2. Data Validation:\n   2.1. Validate Poll Existence:\n      - Check if pollId corresponds to an existing poll\n      - IF poll does not exist, THEN\n        - Generate error: \"Poll not found\"\n        - Terminate process\n   2.2. Validate Poll Title:\n      - Check if pollTitle is not empty\n      - Check if pollTitle length is within acceptable range (5-100 characters)\n      - IF validation fails, THEN\n        - Generate error: \"Poll title must be between 5 and 100 characters\"\n        - Terminate process\n   2.3. Validate Poll Length:\n      - Check if pollLength is a positive number\n      - Check if pollLength is within acceptable range (1-365 days)\n      - IF validation fails, THEN\n        - Generate error: \"Poll length must be between 1 and 365 days\"\n        - Terminate process\n   2.4. Validate Poll Options:\n      - Check if at least 2 options are provided\n      - Check if each option has non-empty text\n      - Check if each option text is within acceptable length (1-255 characters)\n      - Identify new options (those without optionId)\n      - Identify modified options (those with optionId and changed text)\n      - Identify deleted options (those in original poll but not in update list)\n      - IF validation fails, THEN\n        - Generate appropriate error message\n        - Terminate process\n\n3. Business Rule Processing:\n   3.1. Check User Authorization:\n      - Verify if the user has permission to update this poll\n      - IF user is not the poll creator or a moderator/administrator, THEN\n        - Generate error: \"Insufficient permissions to update this poll\"\n        - Terminate process\n   3.2. Check Poll Status:\n      - Verify if the poll has already received votes\n      - IF poll has votes AND option structure is being changed (options added/removed), THEN\n        - Generate warning: \"Changing poll options after voting has started may affect poll integrity\"\n        - Request confirmation to proceed\n   3.3. Verify Poll Constraints:\n      - Check if the poll is associated with an active topic\n      - IF associated topic is locked or deleted, THEN\n        - Generate error: \"Cannot update poll for locked or deleted topic\"\n        - Terminate process\n   3.4. Analyze Option Changes:\n      - Create three separate lists:\n        - New options to be added\n        - Existing options to be updated\n        - Existing options to be deleted\n      - IF any options with votes are being deleted, THEN\n        - Generate warning: \"Deleting options with votes will remove those votes from the poll results\"\n        - Request confirmation to proceed\n\n4. Core Operation Execution:\n   4.1. Update Poll Record:\n      - Update the poll title in the database\n      - Update poll length setting\n      - Record the modification timestamp\n   4.2. Process Poll Options:\n      - For each option in the update list:\n        - IF option is new (no optionId), THEN add as new poll option\n        - IF option exists (has optionId), THEN update its text\n      - For each option marked for deletion:\n        - Remove the option from the poll\n        - IF option had votes, THEN handle vote removal according to system policy\n   4.3. Handle Option Changes:\n      - For deleted options with votes:\n        - Remove associated votes from the system\n        - Update vote counts and statistics\n      - For new options:\n        - Initialize with zero votes\n        - Assign appropriate option identifiers\n   4.4. Update Related Records:\n      - Update any related topic records to reflect poll changes\n      - Update modification timestamp on parent topic\n\n5. Response Generation:\n   5.1. Success Response:\n      - Return success status\n      - Include updated poll information with:\n        - Poll ID\n        - Updated title\n        - Updated length\n        - Complete list of current options\n        - Vote counts (if any)\n      - Include summary of changes made (options added, modified, removed)\n   5.2. Error Response:\n      - Return failure status\n      - Include specific error message\n      - Include guidance for resolution\n      - Provide information on which validation failed\n   5.3. Notification:\n      - Notify relevant users about poll update if required by system settings\n      - Log the poll update activity for audit purposes",
    "databaseEntities": [
      "Poll",
      "PollOption",
      "PollVote",
      "User",
      "Topic"
    ],
    "validationRules": [
      "Poll must exist in the system",
      "Poll title must not be empty",
      "Poll title must be between 5 and 100 characters",
      "Poll length must be a positive number",
      "Poll length must be between 1 and 365 days",
      "Poll must have at least 2 options",
      "Each poll option must have non-empty text",
      "Each poll option text must be between 1 and 255 characters",
      "User must have permission to update the poll",
      "Associated topic must not be locked or deleted"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "PollOptions": {
        "type": "array",
        "items": {
          "type": "object",
          "properties": {
            "optionId": {
              "type": "number",
              "description": "Identifier for existing options, null for new options"
            },
            "text": {
              "type": "string",
              "description": "The text of the poll option"
            },
            "displayOrder": {
              "type": "number",
              "description": "The display order of the option"
            },
            "voteCount": {
              "type": "number",
              "description": "The number of votes for this option",
              "readOnly": true
            }
          },
          "required": [
            "text"
          ]
        }
      }
    }
  },
  {
    "featureName": "CreatePoll",
    "description": "Creates a new poll in the system and returns its ID.",
    "inputValues": [
      "poll-object-Poll",
      "topicId-number-Topic"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect Poll object with the following fields:\n     * question-string (mandatory): The main question of the poll\n     * options-array (mandatory): List of possible answers for the poll\n     * length-number (optional): Duration of the poll in days\n     * isMultipleAnswersAllowed-boolean (optional): Whether users can select multiple options\n     * topicId-number (mandatory): The topic this poll is associated with\n\n2. Data Validation:\n   - Validate Poll question:\n     * Check if question is not empty\n     * Verify question length is within allowed limits (5-255 characters)\n     * Error message if validation fails: \"Poll question is required and must be between 5-255 characters\"\n   - Validate Poll options:\n     * Ensure at least 2 options are provided\n     * Verify each option is not empty\n     * Check that each option is within allowed length (1-255 characters)\n     * Error message if validation fails: \"Poll requires at least 2 non-empty options\"\n   - Validate Topic association:\n     * Verify topicId exists in the system\n     * Check if topic already has an associated poll\n     * Error message if validation fails: \"Invalid topic or topic already has a poll\"\n\n3. Business Rule Processing:\n   - Check user permissions:\n     * Verify current user has permission to create polls\n     * Ensure user has appropriate access to the specified topic\n     * Error message if validation fails: \"Insufficient permissions to create poll\"\n   - Validate system constraints:\n     * Check if system poll limit has been reached\n     * Verify poll creation is enabled in system settings\n     * Error message if validation fails: \"Poll creation is currently disabled or limit reached\"\n\n4. Core Operation Execution:\n   - Create new Poll record:\n     * Generate unique identifier for the poll\n     * Store poll question\n     * Store poll options with initial vote count of zero for each\n     * Set poll creation timestamp\n     * Associate poll with the specified topic\n     * Set poll status as active\n   - Update related records:\n     * Update topic record to indicate it has an associated poll\n   - IF any operation fails:\n     * Rollback all changes\n     * Log error details\n     * Return appropriate error message\n\n5. Response Generation:\n   - Success response:\n     * Return the newly created poll ID\n     * Include confirmation message\n   - Error response:\n     * Return specific error message based on failure point\n     * Include guidance for resolution if applicable",
    "databaseEntities": [
      "jforum_topics",
      "jforum_polls",
      "jforum_poll_options",
      "jforum_users"
    ],
    "validationRules": [
      "Poll question must not be empty",
      "Poll question must be between 5-255 characters",
      "Poll must have at least 2 options",
      "Each poll option must not be empty",
      "Each poll option must be within 1-255 characters",
      "Topic must exist in the system",
      "Topic must not already have an associated poll",
      "User must have permission to create polls",
      "User must have access to the specified topic"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Poll": {
        "type": "object",
        "properties": {
          "question": {
            "type": "string",
            "description": "The main question of the poll"
          },
          "options": {
            "type": "array",
            "items": {
              "type": "string",
              "description": "An answer option for the poll"
            },
            "description": "List of possible answers for the poll"
          },
          "length": {
            "type": "number",
            "description": "Duration of the poll in days"
          },
          "isMultipleAnswersAllowed": {
            "type": "boolean",
            "description": "Whether users can select multiple options"
          }
        },
        "required": [
          "question",
          "options"
        ]
      }
    }
  },
  {
    "featureName": "VoteOnPoll",
    "description": "Records a user's vote on a specific poll option.",
    "inputValues": [
      "pollId-number-Poll",
      "optionId-number-PollOption",
      "userId-number-User",
      "ipAddress-string-User",
      "topicId-number-Topic"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect pollId (mandatory): Unique identifier for the poll\n   - Collect optionId (mandatory): Identifier for the selected poll option\n   - Collect userId (mandatory): Identifier of the user casting the vote\n   - Collect ipAddress (mandatory): IP address of the user casting the vote\n   - Collect topicId (mandatory): Identifier of the topic containing the poll\n\n2. Data Validation:\n   - Validate pollId:\n     a. Check if pollId is a positive integer\n     b. Verify poll exists in the system\n     c. Generate error if poll not found\n   - Validate optionId:\n     a. Check if optionId is a positive integer\n     b. Verify option belongs to the specified poll\n     c. Generate error if option not found or not associated with poll\n   - Validate userId:\n     a. Check if userId is a positive integer\n     b. Verify user exists in the system\n     c. Generate error if user not found\n   - Validate ipAddress:\n     a. Check if ipAddress is in valid format\n     b. Generate error if format is invalid\n   - Validate topicId:\n     a. Check if topicId is a positive integer\n     b. Verify topic exists in the system\n     c. Verify topic has an associated poll\n     d. Generate error if topic not found or has no poll\n\n3. Business Rule Processing:\n   - Check user authentication status:\n     a. IF user is not logged in THEN\n        i. Generate error indicating authentication required\n   - Check user permissions:\n     a. Verify user has permission to vote on polls\n     b. IF user lacks voting permission THEN\n        i. Generate error indicating insufficient privileges\n   - Check topic status:\n     a. Retrieve topic information using topicId\n     b. IF topic is locked (status = LOCKED) THEN\n        i. Generate error indicating voting not allowed on locked topics\n   - Check voting eligibility:\n     a. IF poll is closed or expired THEN\n        i. Generate error indicating voting is no longer allowed\n     b. IF poll allows only one vote per user THEN\n        i. Check if user has already voted using hasUserVotedOnPoll(pollId, userId)\n        ii. IF user has already voted THEN\n            1. Generate error indicating duplicate vote not allowed\n     c. IF poll restricts votes from same IP address THEN\n        i. Check if IP has already been used for voting using hasUserVotedOnPoll(pollId, ipAddress)\n        ii. IF IP has already been used THEN\n            1. Generate error indicating duplicate vote not allowed from same IP\n\n4. Core Operation Execution:\n   - Record the vote:\n     a. Increment vote count for the selected option in the poll\n     b. Record voting activity with user information:\n        i. Store pollId, optionId, userId, and ipAddress\n        ii. Store timestamp of when vote was cast\n     c. IF any failure occurs during vote recording THEN\n        i. Rollback any partial changes\n        ii. Generate appropriate error message\n\n5. Response Generation:\n   - On successful vote:\n     a. Return confirmation that vote was recorded successfully\n     b. Include updated poll statistics (optional)\n     c. Include information about total votes cast\n     d. Redirect user to the topic page to view updated poll results\n   - On failure:\n     a. Return specific error message explaining why vote could not be recorded\n     b. Include guidance on how to resolve the issue if applicable",
    "databaseEntities": [
      "jforum_users",
      "jforum_topics",
      "jforum_polls",
      "jforum_poll_options",
      "jforum_poll_votes",
      "jforum_forums"
    ],
    "validationRules": [
      "Poll ID must exist in the system",
      "Option ID must exist and belong to the specified poll",
      "User ID must exist in the system",
      "IP address must be in valid format",
      "User must not have already voted on this poll if duplicate votes are not allowed",
      "IP address must not have been used to vote on this poll if IP restriction is enabled",
      "Poll must be active and not expired",
      "Topic must not be locked",
      "User must be logged in to vote",
      "User must have permission to vote on polls"
    ],
    "dbSeedingOperations": [
      "Ensure poll status types are defined (active, closed, expired)",
      "Ensure poll configuration options exist (allow multiple votes, restrict by IP)",
      "Ensure security permissions for poll voting are configured"
    ],
    "schema": {
      "Poll": {
        "id": "number",
        "topicId": "number",
        "question": "string",
        "options": "array",
        "isActive": "boolean",
        "expirationDate": "date",
        "allowMultipleVotes": "boolean",
        "restrictByIp": "boolean"
      },
      "PollOption": {
        "id": "number",
        "pollId": "number",
        "text": "string",
        "voteCount": "number"
      },
      "PollVote": {
        "pollId": "number",
        "optionId": "number",
        "userId": "number",
        "ipAddress": "string",
        "voteDate": "date"
      },
      "Topic": {
        "id": "number",
        "forumId": "number",
        "title": "string",
        "status": "number",
        "voteId": "number",
        "isVote": "boolean"
      }
    }
  },
  {
    "featureName": "CheckUserVotedByUserId",
    "description": "Verifies if a user has already voted on a specific poll using user ID.",
    "inputValues": [
      "pollId-number-Poll",
      "userId-number-User"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect pollId (mandatory, number) - The unique identifier of the poll to check\n   - Collect userId (mandatory, number) - The unique identifier of the user to check\n   - System will use these identifiers to verify voting status\n\n2. Data Validation:\n   - Validate pollId:\n      a. Check if pollId is provided\n      b. Verify pollId is a positive integer\n      c. IF pollId is invalid or missing, THEN return error message indicating invalid poll identifier\n   - Validate userId:\n      a. Check if userId is provided\n      b. Verify userId is a positive integer\n      c. IF userId is invalid or missing, THEN return error message indicating invalid user identifier\n\n3. Business Rule Processing:\n   - Verify Poll Existence:\n      a. Check if the poll with the given pollId exists in the system\n      b. IF poll does not exist, THEN return error message indicating poll not found\n   - Verify User Existence:\n      a. Check if the user with the given userId exists in the system\n      b. IF user does not exist, THEN return error message indicating user not found\n\n4. Core Operation Execution:\n   - Check Voting Records:\n      a. Search voting records for the combination of pollId and userId\n      b. Determine if a vote record exists for this specific user on this specific poll\n      c. IF a vote record is found, THEN set hasVoted flag to true\n      d. IF no vote record is found, THEN set hasVoted flag to false\n\n5. Response Generation:\n   - Format Response:\n      a. Return the hasVoted flag (boolean) indicating whether the user has voted\n      b. Include pollId and userId in the response for reference\n   - Error Handling:\n      a. If any errors occurred during processing, return appropriate error message\n      b. Include error details and suggestions for resolution",
    "databaseEntities": [
      "Poll",
      "User",
      "Vote"
    ],
    "validationRules": [
      "Poll ID must be a positive integer",
      "User ID must be a positive integer",
      "Poll must exist in the system",
      "User must exist in the system"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Poll": {
        "id": "number",
        "title": "string",
        "options": "array",
        "topicId": "number"
      },
      "User": {
        "id": "number",
        "username": "string"
      },
      "Vote": {
        "pollId": "number",
        "userId": "number",
        "optionId": "number",
        "voteDate": "date"
      }
    }
  },
  {
    "featureName": "CheckUserVotedByIpAddress",
    "description": "Verifies if a vote has been cast from a specific IP address on a poll.",
    "inputValues": [
      "pollId-number-Poll",
      "ipAddress-string-IpAddress"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the following required inputs:\n     a. pollId (number): The unique identifier of the poll to check\n     b. ipAddress (string): The IP address to verify for previous votes\n   - Both fields are mandatory and must be provided by the caller\n\n2. Data Validation:\n   - Validate pollId:\n     a. Verify pollId is a positive integer\n     b. IF pollId is missing or invalid THEN\n        i. Generate validation error: \"Poll identifier must be a valid positive number\"\n     c. Verify pollId corresponds to an existing poll\n     d. IF poll does not exist THEN\n        i. Generate validation error: \"The specified poll does not exist\"\n   - Validate ipAddress:\n     a. Verify ipAddress is not empty\n     b. IF ipAddress is missing THEN\n        i. Generate validation error: \"IP address must be provided\"\n     c. Verify ipAddress follows a valid IP address format\n     d. IF ipAddress format is invalid THEN\n        i. Generate validation error: \"Invalid IP address format\"\n\n3. Business Rule Processing:\n   - Check system configuration:\n     a. Verify if IP-based vote tracking is enabled in the system\n     b. IF IP-based vote tracking is disabled THEN\n        i. Return false (indicating no vote found) and exit process\n   - Check poll status:\n     a. Verify if the poll is active and accepting votes\n     b. IF poll is closed or expired THEN\n        i. Log attempt to check votes on inactive poll\n        ii. Continue with the verification process regardless\n\n4. Core Operation Execution:\n   - Search for vote records:\n     a. Query the vote tracking system for records matching both:\n        i. The specified pollId\n        ii. The specified ipAddress\n     b. IF matching vote record is found THEN\n        i. Set result flag to true (vote exists)\n     c. ELSE\n        i. Set result flag to false (no vote exists)\n   - Record verification activity:\n     a. Log the verification attempt with timestamp, poll identifier, and IP address\n     b. Update poll access statistics if required\n\n5. Response Generation:\n   - Prepare the response:\n     a. Return the boolean result flag indicating whether a vote was found\n     b. IF true THEN\n        i. Indicate that the specified IP address has already voted on this poll\n     c. IF false THEN\n        i. Indicate that no vote from the specified IP address was found for this poll\n   - Include additional context if needed:\n     a. IF configured to provide details, include timestamp of found vote\n     b. IF configured to provide details, include the selected option if a vote was found",
    "databaseEntities": [
      "jforum_topics",
      "jforum_polls",
      "jforum_vote_results",
      "jforum_vote_voters"
    ],
    "validationRules": [
      "Poll ID must be a positive integer",
      "Poll must exist in the system",
      "IP address must not be empty",
      "IP address must follow valid format",
      "IP-based vote tracking must be enabled to perform check"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Poll": {
        "id": "number",
        "topicId": "number",
        "label": "string",
        "options": "array",
        "voteCount": "number",
        "isActive": "boolean",
        "expirationDate": "date"
      },
      "IpAddress": {
        "value": "string",
        "timestamp": "date"
      }
    }
  },
  {
    "featureName": "SendPrivateMessage",
    "description": "Sends a new private message between users in the system.",
    "inputValues": [
      "fromUserId-number-User",
      "toUserId-number-User",
      "subject-string-PrivateMessage",
      "messageText-string-PrivateMessage",
      "bbCodeEnabled-boolean-PrivateMessage",
      "htmlEnabled-boolean-PrivateMessage",
      "smiliesEnabled-boolean-PrivateMessage",
      "signatureEnabled-boolean-PrivateMessage"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect sender user ID (fromUserId, mandatory)\n   - Collect recipient user ID (toUserId, mandatory)\n   - Collect message subject (subject, mandatory)\n   - Collect message text content (messageText, mandatory)\n   - Collect formatting preferences (optional):\n     a. bbCodeEnabled (optional, defaults to true)\n     b. htmlEnabled (optional, defaults to false)\n     c. smiliesEnabled (optional, defaults to true)\n     d. signatureEnabled (optional, defaults to true)\n\n2. Data Validation:\n   - Validate sender ID:\n     a. Check if sender ID is provided\n     b. Verify sender exists in the system\n     c. Confirm sender has permission to send messages\n     d. If validation fails, return error message \"Invalid sender\"\n   - Validate recipient ID:\n     a. Check if recipient ID is provided\n     b. Verify recipient exists in the system\n     c. Confirm recipient can receive messages\n     d. If validation fails, return error message \"Invalid recipient\"\n   - Validate message subject:\n     a. Check if subject is provided\n     b. Verify subject is not empty\n     c. Ensure subject length is within allowed limits (1-100 characters)\n     d. If validation fails, return error message \"Invalid subject\"\n   - Validate message text:\n     a. Check if message text is provided\n     b. Verify message text is not empty\n     c. Ensure message text length is within allowed limits\n     d. If validation fails, return error message \"Invalid message content\"\n\n3. Business Rule Processing:\n   - Check user relationship rules:\n     a. Verify if recipient has blocked the sender\n     b. IF recipient has blocked sender THEN\n        i. Return error message \"Cannot send message to this user\"\n     c. ELSE continue processing\n   - Check message quota:\n     a. Verify if recipient's inbox has available space\n     b. IF inbox is full THEN\n        i. Return error message \"Recipient's inbox is full\"\n     c. ELSE continue processing\n   - Check message rate limits:\n     a. Verify if sender has exceeded message sending limits\n     b. IF rate limit exceeded THEN\n        i. Return error message \"Message sending limit reached\"\n     c. ELSE continue processing\n\n4. Core Operation Execution:\n   - Create two copies of the message:\n     a. First copy for sender's sent box:\n        i. Set message type to SENT\n        ii. Set sender ID (fromUserId)\n        iii. Set recipient ID (toUserId)\n        iv. Set message subject\n        v. Set current timestamp\n        vi. Set formatting flags (bbCode, HTML, smilies, signature)\n        vii. Generate and store message ID\n        viii. Store message text linked to message ID\n     b. Second copy for recipient's inbox:\n        i. Set message type to NEW (unread)\n        ii. Set sender ID (fromUserId)\n        iii. Set recipient ID (toUserId)\n        iv. Set message subject\n        v. Set current timestamp\n        vi. Set formatting flags (bbCode, HTML, smilies, signature)\n        vii. Generate and store message ID\n        viii. Store message text linked to message ID\n   - IF any storage operation fails THEN\n     a. Rollback all changes\n     b. Return error message \"Failed to send message\"\n\n5. Response Generation:\n   - IF message successfully sent THEN\n     a. Generate success response with message IDs\n     b. Include timestamp of message sending\n     c. Return confirmation \"Message successfully sent\"\n   - ELSE\n     a. Generate error response\n     b. Include specific error details\n     c. Return appropriate error message",
    "databaseEntities": [
      "User",
      "PrivateMessage",
      "PrivateMessageText"
    ],
    "validationRules": [
      "Sender must be a valid user in the system",
      "Recipient must be a valid user in the system",
      "Message subject must not be empty",
      "Message subject must not exceed maximum length",
      "Message text must not be empty",
      "Message text must not exceed maximum length",
      "Sender must have permission to send messages",
      "Recipient must be able to receive messages",
      "Sender must not exceed message sending rate limits",
      "Recipient's inbox must not be full"
    ],
    "dbSeedingOperations": [
      "Ensure message types are defined (NEW, SENT)",
      "Ensure default formatting preferences are defined"
    ],
    "schema": {
      "User": {
        "id": "number",
        "username": "string",
        "messageQuota": "number",
        "canSendMessages": "boolean"
      },
      "PrivateMessage": {
        "id": "number",
        "type": "number",
        "subject": "string",
        "fromUserId": "number",
        "toUserId": "number",
        "date": "date",
        "bbCodeEnabled": "boolean",
        "htmlEnabled": "boolean",
        "smiliesEnabled": "boolean",
        "signatureEnabled": "boolean"
      },
      "PrivateMessageText": {
        "messageId": "number",
        "text": "string"
      }
    }
  },
  {
    "featureName": "DeletePrivateMessages",
    "description": "Deletes a collection of private messages for a specific user.",
    "inputValues": [
      "privateMessages-object-PrivateMessage[]",
      "userId-number-User"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the following inputs:\n     a. privateMessages (array of PrivateMessage objects, mandatory)\n     b. userId (number, mandatory) - The identifier of the user performing the deletion\n\n2. Data Validation:\n   - Validate privateMessages array:\n     a. Check if privateMessages is not null or empty\n     b. IF privateMessages is null or empty THEN\n        i. Generate error message: \"No messages selected for deletion\"\n        ii. Terminate process\n     c. FOR EACH message in privateMessages:\n        i. Verify message has a valid identifier\n        ii. IF message identifier is invalid THEN\n            1. Generate error message: \"Invalid message identifier found\"\n            2. Terminate process\n   - Validate userId:\n     a. Check if userId is a positive integer\n     b. IF userId is invalid THEN\n        i. Generate error message: \"Invalid user identifier\"\n        ii. Terminate process\n\n3. Business Rule Processing:\n   - Verify ownership of messages:\n     a. FOR EACH message in privateMessages:\n        i. Check if the message belongs to the specified user\n        ii. IF message does not belong to user THEN\n            1. Generate error message: \"User does not have permission to delete one or more selected messages\"\n            2. Terminate process\n   - Check system state:\n     a. Verify the messaging system is operational\n     b. IF system is in maintenance mode THEN\n        i. Generate error message: \"Message system currently unavailable\"\n        ii. Terminate process\n\n4. Core Operation Execution:\n   - Process message deletion:\n     a. Begin transaction\n     b. FOR EACH message in privateMessages:\n        i. Mark message as deleted for the current user\n        ii. IF message is marked as deleted by both sender and recipient THEN\n            1. Permanently remove message from storage\n            2. Remove associated message text content\n     c. Update message counts for user's inbox/sent folders\n     d. IF any deletion operation fails THEN\n        i. Rollback all changes\n        ii. Generate error message: \"Failed to delete one or more messages\"\n        iii. Terminate process\n     e. Commit transaction\n\n5. Response Generation:\n   - Generate success response:\n     a. Create confirmation of deletion\n     b. Include count of successfully deleted messages\n     c. Update user interface to reflect deleted messages\n   - IF partial success (some messages couldn't be deleted) THEN\n     a. Include information about which messages were successfully deleted\n     b. Include reason why other messages couldn't be deleted",
    "databaseEntities": [
      "User",
      "PrivateMessage"
    ],
    "validationRules": [
      "Private messages array must not be empty",
      "User ID must be a positive integer",
      "User must be the owner of all messages being deleted",
      "Each private message must have a valid identifier"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "PrivateMessage": {
        "type": "object",
        "properties": {
          "id": {
            "type": "number",
            "description": "Unique identifier for the private message"
          },
          "fromUser": {
            "type": "number",
            "description": "User ID of the sender"
          },
          "toUser": {
            "type": "number",
            "description": "User ID of the recipient"
          },
          "type": {
            "type": "number",
            "description": "Message status/type indicator"
          },
          "text": {
            "type": "string",
            "description": "Content of the private message"
          },
          "subject": {
            "type": "string",
            "description": "Subject line of the private message"
          },
          "date": {
            "type": "date",
            "description": "Date when the message was sent"
          }
        },
        "required": [
          "id"
        ]
      }
    }
  },
  {
    "featureName": "UpdateMessageType",
    "description": "Updates the status or type of a private message in the system.",
    "inputValues": [
      "messageId-number-PrivateMessage",
      "newType-number-PrivateMessageType",
      "userId-number-User"
    ],
    "businessLogic": "1. Input Collection:\n   1.1. Collect the private message ID (mandatory).\n   1.2. Collect the new message type/status code (mandatory).\n      1.2.1. Valid message types include NEW, READ, UNREAD, SENT, SAVED, etc.\n   1.3. Collect the user ID of the requester (mandatory, system-generated).\n\n2. Data Validation:\n   2.1. Validate Private Message ID:\n      2.1.1. Check if the message ID is provided.\n      2.1.2. Verify the message ID is a positive integer.\n      2.1.3. IF validation fails, THEN return appropriate error message.\n   2.2. Validate New Message Type:\n      2.2.1. Check if the new type is provided.\n      2.2.2. Verify the new type is within the allowed range of message types.\n      2.2.3. Ensure the new type is different from the current type.\n      2.2.4. IF validation fails, THEN return appropriate error message.\n   2.3. Validate User ID:\n      2.3.1. Check if the user ID is provided.\n      2.3.2. Verify the user ID is a positive integer.\n      2.3.3. Confirm the user exists in the system.\n      2.3.4. IF validation fails, THEN return appropriate error message.\n\n3. Business Rule Processing:\n   3.1. Verify Message Ownership:\n      3.1.1. Check if the message exists in the system.\n      3.1.2. Verify the requesting user is either the sender or recipient of the message.\n      3.1.3. IF user is not authorized to modify this message, THEN return access denied error.\n   3.2. Verify Message State:\n      3.2.1. Check if the message is in a state that allows type modification.\n      3.2.2. Verify the requested type change is valid for the current message state.\n      3.2.3. Ensure the type change follows the allowed state transitions (e.g., NEW to READ).\n      3.2.4. IF state transition is invalid, THEN return appropriate error message.\n\n4. Core Operation Execution:\n   4.1. Update Message Type:\n      4.1.1. Prepare the message update with the new type value.\n      4.1.2. Apply the type change to the message record in the database.\n      4.1.3. Record the timestamp of the update if required.\n      4.1.4. IF update operation fails, THEN rollback changes and return system error.\n   4.2. Update Related Records:\n      4.2.1. If the type change affects message visibility, update relevant counters.\n      4.2.2. If the type change affects message status, update any related notification settings.\n      4.2.3. Update any message flags that depend on the message type.\n      4.2.4. IF related updates fail, THEN attempt to restore previous state.\n\n5. Response Generation:\n   5.1. Success Response:\n      5.1.1. Prepare confirmation of successful type update.\n      5.1.2. Include the message ID and new type in the response.\n      5.1.3. Include any relevant updated message metadata.\n      5.1.4. Return success status to the user.\n   5.2. Error Response:\n      5.2.1. For validation errors, provide specific field-level error messages.\n      5.2.2. For authorization errors, return appropriate access denied message.\n      5.2.3. For system errors, return generic error with support reference.",
    "databaseEntities": [
      "jforum_privmsgs",
      "jforum_privmsgs_text",
      "jforum_users"
    ],
    "validationRules": [
      "Message ID must be a positive integer",
      "New message type must be a valid type code (NEW, READ, UNREAD, SENT, SAVED)",
      "User must be either the sender or recipient of the message",
      "Message must exist in the system",
      "User must be authorized to modify the message type",
      "The new type must be different from the current message type",
      "The type change must follow allowed state transitions"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "PrivateMessage": {
        "id": "number",
        "type": "number",
        "fromUser": "object-User",
        "toUser": "object-User",
        "sentDate": "date",
        "subject": "string",
        "text": "string",
        "bbCodeEnabled": "boolean",
        "htmlEnabled": "boolean",
        "smiliesEnabled": "boolean",
        "signatureEnabled": "boolean"
      },
      "PrivateMessageType": {
        "id": "number",
        "name": "string",
        "description": "string"
      },
      "User": {
        "id": "number",
        "username": "string",
        "email": "string"
      }
    }
  },
  {
    "featureName": "GetInboxMessages",
    "description": "Retrieves all private messages from a user's inbox.",
    "inputValues": [
      "user-object-User"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect User object with following properties:\n     - userId: Unique identifier for the user\n     - username: Name of the user\n     - All other user properties required for authentication\n   - System will determine if the user is authenticated\n\n2. Data Validation:\n   - Validate User object:\n     - Verify userId is not null and is a valid identifier\n     - Verify user exists in the system\n     - Verify user has proper permissions to access their inbox\n   - IF any validation fails THEN:\n     - Generate appropriate error message\n     - Terminate process and return error response\n\n3. Business Rule Processing:\n   - Verify user session is active\n   - Check if user has inbox access permission\n   - IF user lacks necessary permissions THEN:\n     - Generate permission denied error\n     - Terminate process and return error response\n   - Determine sorting criteria for messages (default: newest first)\n   - Determine if any filtering should be applied\n\n4. Core Operation Execution:\n   - Retrieve all private messages where:\n     - The recipient is the current user\n     - Messages are marked as inbox messages (type = NEW)\n   - For each message retrieved:\n     - Load message metadata (sender, date, subject)\n     - Load message content from message text storage\n     - Determine message status (read/unread)\n     - Format date according to system's configured date format\n   - Process message attributes:\n     - Check if BBCode is enabled for the message\n     - Check if HTML is enabled for the message\n     - Check if smilies are enabled for the message\n     - Check if signature is enabled for the message\n   - Sort messages according to determined criteria\n   - Count total number of messages\n   - Count number of unread messages\n\n5. Response Generation:\n   - Prepare response with:\n     - List of private messages with:\n       - Message ID\n       - Sender information (user ID and username)\n       - Subject\n       - Send date (both raw and formatted)\n       - Message status (read/unread)\n       - Message content\n       - Message formatting options (BBCode, HTML, smilies, signature)\n     - Total message count\n     - Unread message count\n   - IF no messages found THEN:\n     - Return empty list with appropriate indication\n   - Return success response with message collection",
    "databaseEntities": [
      "User",
      "PrivateMessage",
      "PrivateMessageText"
    ],
    "validationRules": [
      "User must be authenticated",
      "User must exist in the system",
      "User must have permission to access their inbox",
      "User session must be active",
      "Private messages must be associated with the requesting user as recipient",
      "Private messages must be of type NEW (inbox) for inbox retrieval"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "User": {
        "type": "object",
        "properties": {
          "id": {
            "type": "number",
            "description": "Unique identifier for the user"
          },
          "username": {
            "type": "string",
            "description": "Username of the user"
          }
        },
        "required": [
          "id",
          "username"
        ]
      },
      "PrivateMessage": {
        "type": "object",
        "properties": {
          "id": {
            "type": "number",
            "description": "Unique identifier for the message"
          },
          "fromUser": {
            "type": "object",
            "description": "User who sent the message",
            "$ref": "#/User"
          },
          "toUser": {
            "type": "object",
            "description": "User who received the message",
            "$ref": "#/User"
          },
          "subject": {
            "type": "string",
            "description": "Subject of the message"
          },
          "text": {
            "type": "string",
            "description": "Content of the message"
          },
          "date": {
            "type": "date",
            "description": "Date when the message was sent"
          },
          "formattedDate": {
            "type": "string",
            "description": "Formatted date string according to system preferences"
          },
          "type": {
            "type": "number",
            "description": "Type of the message (NEW for inbox, SENT for sent items)"
          },
          "isBBCodeEnabled": {
            "type": "boolean",
            "description": "Indicates if BBCode is enabled for this message"
          },
          "isHtmlEnabled": {
            "type": "boolean",
            "description": "Indicates if HTML is enabled for this message"
          },
          "isSmiliesEnabled": {
            "type": "boolean",
            "description": "Indicates if smilies are enabled for this message"
          },
          "isSignatureEnabled": {
            "type": "boolean",
            "description": "Indicates if signature is enabled for this message"
          }
        },
        "required": [
          "id",
          "fromUser",
          "toUser",
          "subject",
          "text",
          "date",
          "type"
        ]
      },
      "PrivateMessageText": {
        "type": "object",
        "properties": {
          "messageId": {
            "type": "number",
            "description": "ID of the associated private message"
          },
          "text": {
            "type": "string",
            "description": "Content text of the message"
          }
        },
        "required": [
          "messageId",
          "text"
        ]
      }
    }
  },
  {
    "featureName": "GetSentMessages",
    "description": "Retrieves all private messages from a user's sent box.",
    "inputValues": [
      "user-object-User"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect User object with the following attributes:\n     - userId (mandatory): Unique identifier for the user\n     - username (optional): Name of the user requesting their sent messages\n   - System will use the authenticated user information if not explicitly provided\n\n2. Data Validation:\n   - Validate User object:\n     - Check if userId is provided and is a valid identifier\n     - Verify that the user exists in the system\n     - Confirm the user has permission to access their sent messages\n   - IF any validation fails, THEN:\n     - Generate appropriate error message\n     - Terminate the process and return error response\n\n3. Business Rule Processing:\n   - Check if the user account is active and not suspended\n   - Verify user has permission to view sent messages\n   - IF user account is inactive or suspended, THEN:\n     - Generate access denied message\n     - Terminate the process\n   - Check if the user has any sent messages\n     - IF no sent messages exist, THEN prepare to return empty result set\n\n4. Core Operation Execution:\n   - Retrieve all messages from sent box for the specified user\n     - Filter messages by the user as sender (where message type is SENT)\n     - Include message metadata (recipient, date sent, subject)\n     - Include message status information (read/unread by recipient)\n     - Sort messages by date sent (newest first by default)\n   - Process message data for display\n     - Format dates to user-friendly format using system date format settings\n     - Prepare message previews (truncated content)\n     - Include recipient information (username and ID)\n\n5. Response Generation:\n   - Prepare the list of sent messages with the following information for each message:\n     - Message identifier (privmsgs_id)\n     - Recipient information (username and ID)\n     - Subject line\n     - Date and time sent (formatted according to system preferences)\n     - Message status (read/unread by recipient)\n     - Message preview (if applicable)\n   - Include pagination information if applicable\n   - Return the complete list of sent messages as an array\n   - IF no messages found, return empty list with appropriate notification",
    "databaseEntities": [
      "User",
      "PrivateMessage",
      "jforum_privmsgs",
      "jforum_privmsgs_text"
    ],
    "validationRules": [
      "User must be authenticated and authorized",
      "User ID must be valid",
      "User account must be active",
      "User must have permission to view sent messages"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "User": {
        "type": "object",
        "properties": {
          "id": {
            "type": "number",
            "description": "Unique identifier for the user"
          },
          "username": {
            "type": "string",
            "description": "Username of the user"
          }
        },
        "required": [
          "id"
        ]
      },
      "PrivateMessage": {
        "type": "object",
        "properties": {
          "id": {
            "type": "number",
            "description": "Unique identifier for the private message"
          },
          "type": {
            "type": "number",
            "description": "Type of message (SENT, NEW, etc.)"
          },
          "fromUser": {
            "type": "object",
            "description": "User who sent the message",
            "$ref": "#/User"
          },
          "toUser": {
            "type": "object",
            "description": "User who received the message",
            "$ref": "#/User"
          },
          "post": {
            "type": "object",
            "properties": {
              "subject": {
                "type": "string",
                "description": "Subject line of the message"
              },
              "text": {
                "type": "string",
                "description": "Content of the message"
              },
              "time": {
                "type": "string",
                "format": "date-time",
                "description": "Date and time when the message was sent"
              },
              "bbCodeEnabled": {
                "type": "boolean",
                "description": "Indicates if BBCode is enabled for this message"
              },
              "htmlEnabled": {
                "type": "boolean",
                "description": "Indicates if HTML is enabled for this message"
              },
              "smiliesEnabled": {
                "type": "boolean",
                "description": "Indicates if smilies are enabled for this message"
              },
              "signatureEnabled": {
                "type": "boolean",
                "description": "Indicates if signature is enabled for this message"
              }
            }
          },
          "formatedDate": {
            "type": "string",
            "description": "Formatted date string according to system preferences"
          }
        }
      }
    }
  },
  {
    "featureName": "GetPrivateMessageById",
    "description": "Retrieves a specific private message by its ID.",
    "inputValues": [
      "messageId-number-PrivateMessage",
      "currentUser-object-User"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the private message ID (messageId) from the request\n   - Obtain the current user information (currentUser) from the session\n   - Both inputs are mandatory for this operation\n\n2. Data Validation:\n   - Validate message ID:\n     a. Verify the message ID is provided\n     b. Confirm the message ID is a positive integer\n     c. Return appropriate error if validation fails\n   - Validate user authentication:\n     a. Verify the current user is authenticated\n     b. Confirm the user object contains valid identification\n     c. Return authentication error if user validation fails\n\n3. Business Rule Processing:\n   - Verify access permissions:\n     a. Check if the requested message belongs to the current user's inbox or sent items\n     b. IF message does not belong to current user THEN\n        i. Generate unauthorized access error\n        ii. Log access attempt for security monitoring\n        iii. Return permission denied response\n     c. ELSE continue processing\n   - Check message existence:\n     a. Verify the message with the provided ID exists in the system\n     b. IF message not found THEN\n        i. Generate not found error\n        ii. Return appropriate error response\n     c. ELSE continue processing\n\n4. Core Operation Execution:\n   - Retrieve the private message:\n     a. Fetch the complete message details including:\n        i. Message header information (sender, recipient, date, subject)\n        ii. Message content/body\n        iii. Message status (read/unread/sent)\n        iv. Message formatting options (BBCode, HTML, smilies, signature)\n        v. Timestamps and creation date\n     b. Load associated user information:\n        i. Fetch sender (fromUser) details\n        ii. Fetch recipient (toUser) details\n     c. IF message is currently marked as new/unread AND user is the recipient THEN\n        i. Update message status to read\n        ii. Record the time when message was read\n     d. Format date according to system preferences\n     e. IF retrieval fails due to system error THEN\n        i. Log the failure with error details\n        ii. Generate appropriate system error\n        iii. Return error response\n\n5. Response Generation:\n   - Format successful response:\n     a. Include complete message details:\n        i. Message ID\n        ii. Sender information (username, ID)\n        iii. Recipient information (username, ID)\n        iv. Subject line\n        v. Message body/content\n        vi. Timestamp information (sent date, formatted date)\n        vii. Current status (new, read, sent)\n        viii. Formatting flags (BBCode, HTML, smilies, signature)\n     b. Include navigation references:\n        i. Links to reply functionality\n        ii. Links to delete functionality\n        iii. Links to return to message list\n   - Return the formatted message to the user interface for display",
    "databaseEntities": [
      "jforum_privmsgs",
      "jforum_privmsgs_text",
      "jforum_users"
    ],
    "validationRules": [
      "Message ID must be a positive integer",
      "User must be authenticated to access private messages",
      "User must be either the sender or recipient of the requested message",
      "The requested message must exist in the system"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "User": {
        "type": "object",
        "properties": {
          "id": {
            "type": "number",
            "description": "Unique identifier for the user"
          },
          "username": {
            "type": "string",
            "description": "User's login name"
          },
          "authenticated": {
            "type": "boolean",
            "description": "Flag indicating if user is currently authenticated"
          }
        },
        "required": [
          "id",
          "username",
          "authenticated"
        ]
      },
      "PrivateMessage": {
        "type": "object",
        "properties": {
          "id": {
            "type": "number",
            "description": "Unique identifier for the private message"
          },
          "fromUser": {
            "type": "object",
            "description": "User who sent the message",
            "$ref": "#/User"
          },
          "toUser": {
            "type": "object",
            "description": "User who received the message",
            "$ref": "#/User"
          },
          "subject": {
            "type": "string",
            "description": "Subject line of the message"
          },
          "text": {
            "type": "string",
            "description": "Content of the message"
          },
          "type": {
            "type": "number",
            "description": "Status flag for the message (new/read/sent)"
          },
          "postDate": {
            "type": "date",
            "description": "Date and time when the message was sent"
          },
          "formatedDate": {
            "type": "string",
            "description": "Formatted date string according to system preferences"
          },
          "bbCodeEnabled": {
            "type": "boolean",
            "description": "Indicates if BBCode is enabled for this message"
          },
          "htmlEnabled": {
            "type": "boolean",
            "description": "Indicates if HTML is enabled for this message"
          },
          "smiliesEnabled": {
            "type": "boolean",
            "description": "Indicates if smilies are enabled for this message"
          },
          "signatureEnabled": {
            "type": "boolean",
            "description": "Indicates if signature is enabled for this message"
          }
        },
        "required": [
          "id",
          "fromUser",
          "toUser",
          "subject",
          "text",
          "type",
          "postDate"
        ]
      }
    }
  },
  {
    "featureName": "SelectRankingById",
    "description": "Retrieves a specific ranking by its ID from the system.",
    "inputValues": [
      "rankingId-number-Ranking"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the required rankingId (number) from the user\n   - The rankingId is mandatory and must be provided\n   - No default values are applicable for this operation\n\n2. Data Validation:\n   - Validate rankingId:\n     a. Verify rankingId is not null\n     b. Verify rankingId is a positive integer\n     c. Verify rankingId is within valid system range\n   - IF any validation fails, THEN:\n     a. Generate appropriate error message\n     b. Halt further processing\n     c. Return error information to caller\n\n3. Business Rule Processing:\n   - Verify system access permissions:\n     a. Check if the current user has permission to view ranking information\n     b. IF user lacks permission, THEN return appropriate access denied message\n   - Verify system state:\n     a. Ensure ranking system is active and available\n     b. IF system is in maintenance mode, THEN notify user and halt processing\n\n4. Core Operation Execution:\n   - Search for ranking with the specified ID:\n     a. Look up ranking record using the provided rankingId\n     b. IF ranking is found, THEN:\n        i. Retrieve all ranking details (title, minimum posts, image, special status)\n        ii. Prepare ranking information for response\n     c. IF ranking is not found, THEN:\n        i. Set appropriate not-found status\n        ii. Prepare error message for response\n   - Handle any unexpected errors:\n     a. Log error details\n     b. Prepare generic error message\n\n5. Response Generation:\n   - For successful retrieval:\n     a. Format ranking details for presentation\n     b. Include all relevant ranking attributes (id, title, image, minimum posts, special status)\n     c. Return complete ranking information\n   - For failed retrieval:\n     a. Include specific error reason\n     b. Provide guidance on possible resolution\n     c. Return appropriate status information",
    "databaseEntities": [
      "Ranking"
    ],
    "validationRules": [
      "Ranking ID must be a positive integer",
      "Ranking ID must exist in the system",
      "User must have permission to view ranking information"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Ranking": {
        "id": "number",
        "title": "string",
        "minPosts": "number",
        "image": "string",
        "special": "boolean"
      }
    }
  },
  {
    "featureName": "SelectAllRankings",
    "description": "Retrieves all rankings from the database.",
    "inputValues": [],
    "businessLogic": "1. Input Collection\n   - No user inputs required for this feature\n   - System will retrieve all ranking records without filtering parameters\n\n2. Data Validation\n   - Verify system access permissions\n     - IF user does not have sufficient permissions THEN\n       - Generate appropriate error message\n       - Terminate process\n     - END IF\n   - Verify database connection status\n     - IF database connection is unavailable THEN\n       - Log connection failure\n       - Generate system error message\n       - Terminate process\n     - END IF\n\n3. Business Rule Processing\n   - Check system state for ranking data availability\n     - IF ranking system is disabled or under maintenance THEN\n       - Generate appropriate notification message\n       - Terminate process\n     - END IF\n   - Verify ranking data access rules\n     - IF rankings are restricted based on current system configuration THEN\n       - Apply appropriate access filters\n     - END IF\n\n4. Core Operation Execution\n   - Retrieve all ranking records from the database\n     - Query the ranking data store for all available rankings\n     - Sort rankings according to predefined order (typically by minimum points or ranking level)\n     - IF no rankings exist THEN\n       - Return empty collection\n     - END IF\n   - Process retrieved ranking data\n     - Format each ranking record with required attributes (id, title, image, minimum points, special status)\n     - Apply any system-wide formatting rules to ranking titles or descriptions\n     - Build complete ranking objects with all properties populated\n\n5. Response Generation\n   - Prepare collection of ranking objects\n     - Include all ranking attributes for each record\n     - Format according to system display requirements\n   - Return complete ranking collection\n     - IF operation successful THEN\n       - Return formatted ranking collection\n     - ELSE\n       - Generate appropriate error message\n       - Include error details for troubleshooting\n     - END IF",
    "databaseEntities": [
      "Ranking"
    ],
    "validationRules": [
      "User must have sufficient permissions to view rankings",
      "Database connection must be available",
      "Ranking system must be active and not under maintenance"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Ranking": {
        "type": "object",
        "properties": {
          "id": {
            "type": "integer",
            "description": "Unique identifier for the ranking"
          },
          "title": {
            "type": "string",
            "description": "Display name of the ranking"
          },
          "minPoints": {
            "type": "integer",
            "description": "Minimum points required to achieve this ranking"
          },
          "special": {
            "type": "boolean",
            "description": "Indicates if this is a special ranking not based on points"
          },
          "image": {
            "type": "string",
            "description": "Optional image associated with the ranking"
          }
        },
        "required": [
          "id",
          "title",
          "minPoints",
          "special"
        ]
      }
    }
  },
  {
    "featureName": "DeleteRanking",
    "description": "Removes a ranking from the system by its ID.",
    "inputValues": [
      "rankingId-number-Ranking"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the following required input:\n     a. rankingId (number, mandatory): The unique identifier of the ranking to be deleted\n\n2. Data Validation:\n   - Validate the rankingId input:\n     a. Check if rankingId is provided\n        IF rankingId is missing or null THEN\n          Generate error message: \"Ranking ID is required\"\n          Exit process\n     b. Verify rankingId is a positive integer\n        IF rankingId is not a positive integer THEN\n          Generate error message: \"Ranking ID must be a positive integer\"\n          Exit process\n     c. Check if rankingId exists in the system\n        IF rankingId does not exist in the system THEN\n          Generate error message: \"Ranking with the specified ID does not exist\"\n          Exit process\n\n3. Business Rule Processing:\n   - Check if the ranking is currently in use:\n     a. Verify if any users are currently assigned this ranking\n        IF ranking is assigned to one or more users THEN\n          Generate error message: \"Cannot delete ranking as it is currently assigned to users\"\n          Exit process\n     b. Check if the ranking is a system default ranking\n        IF ranking is a system default ranking THEN\n          Generate error message: \"Cannot delete a system default ranking\"\n          Exit process\n     c. Check if the ranking is referenced by other system components\n        IF ranking is referenced by other components THEN\n          Generate error message: \"Cannot delete ranking as it is referenced by other system components\"\n          Exit process\n     d. Check if the ranking is a special ranking\n        IF ranking is marked as special THEN\n          Verify no special permissions are required to delete it\n          IF special permissions are required but not present THEN\n            Generate error message: \"Cannot delete special ranking without proper authorization\"\n            Exit process\n\n4. Core Operation Execution:\n   - Perform the ranking deletion:\n     a. Begin transaction\n     b. Remove the ranking record from the database using the rankingId\n     c. IF deletion operation fails THEN\n          Rollback transaction\n          Generate error message: \"Failed to delete ranking due to system error\"\n          Exit process\n     d. Commit transaction\n     e. Update any caches or in-memory structures that may contain ranking information\n\n5. Response Generation:\n   - Generate success response:\n     a. Create confirmation message: \"Ranking successfully deleted\"\n     b. Include the ID of the deleted ranking in the response\n     c. Return success status and confirmation message",
    "databaseEntities": [
      "Ranking",
      "User"
    ],
    "validationRules": [
      "Ranking ID must be provided",
      "Ranking ID must be a positive integer",
      "Ranking must exist in the system",
      "Ranking must not be currently assigned to any users",
      "System default rankings cannot be deleted",
      "Rankings referenced by other system components cannot be deleted",
      "Special rankings may require additional authorization to delete"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Ranking": {
        "id": "number",
        "title": "string",
        "image": "string",
        "min": "number",
        "special": "boolean"
      }
    }
  },
  {
    "featureName": "UpdateRanking",
    "description": "Updates an existing ranking's information in the system.",
    "inputValues": [
      "rankingId-number-Ranking",
      "title-string-Ranking",
      "image-string-Ranking",
      "minPosts-number-Ranking",
      "isSpecial-boolean-Ranking"
    ],
    "businessLogic": "1. Input Collection\n   1.1. Collect the following inputs:\n       - rankingId (mandatory): Unique identifier of the ranking to update\n       - title (mandatory): New title for the ranking\n       - image (optional): Path or name of the image associated with the ranking\n       - minPosts (mandatory for non-special rankings): Minimum number of posts required to achieve this ranking\n       - isSpecial (mandatory): Flag indicating if this is a special ranking\n   1.2. System retrieves the current ranking data using the provided rankingId\n\n2. Data Validation\n   2.1. Validate rankingId\n       2.1.1. Check if rankingId is provided\n       2.1.2. Verify rankingId is a positive integer\n       2.1.3. IF validation fails, THEN return error message \"Invalid ranking ID format\"\n   2.2. Validate title\n       2.2.1. Check if title is provided\n       2.2.2. Verify title is not empty\n       2.2.3. Verify title length is between 1 and 100 characters\n       2.2.4. IF validation fails, THEN return error message \"Title must be between 1 and 100 characters\"\n   2.3. Validate image (if provided)\n       2.3.1. Verify image path/name is valid\n       2.3.2. IF validation fails, THEN return error message \"Invalid image format or path\"\n   2.4. Validate minPosts\n       2.4.1. IF isSpecial is false, THEN verify minPosts is provided\n       2.4.2. Verify minPosts is a non-negative integer\n       2.4.3. IF validation fails, THEN return error message \"Minimum posts must be a non-negative number\"\n   2.5. Validate isSpecial\n       2.5.1. Verify isSpecial is a boolean value\n       2.5.2. IF validation fails, THEN return error message \"Special status must be true or false\"\n\n3. Business Rule Processing\n   3.1. Check if ranking exists\n       3.1.1. Verify that a ranking with the provided rankingId exists in the system\n       3.1.2. IF ranking does not exist, THEN return error message \"Ranking not found\"\n   3.2. Check for duplicate titles\n       3.2.1. Verify that no other ranking (except the current one) has the same title\n       3.2.2. IF duplicate title found, THEN return error message \"A ranking with this title already exists\"\n   3.3. Validate ranking type consistency\n       3.3.1. IF changing from regular to special ranking, THEN verify system impact\n       3.3.2. IF changing from special to regular ranking, THEN verify minPosts is properly set\n\n4. Core Operation Execution\n   4.1. Prepare ranking data for update\n       4.1.1. Create updated ranking object with new values\n       4.1.2. Preserve any fields not being updated\n   4.2. Update ranking record\n       4.2.1. Update the ranking information in the system\n       4.2.2. IF update operation fails, THEN log error details and return error message\n   4.3. Handle related data\n       4.3.1. IF ranking type changed (special/regular), THEN update any dependent records\n       4.3.2. IF update affects user rankings, THEN flag for recalculation\n\n5. Response Generation\n   5.1. Generate success response\n       5.1.1. Include confirmation message \"Ranking updated successfully\"\n       5.1.2. Include updated ranking details\n   5.2. Generate error response (if needed)\n       5.2.1. Include specific error message explaining the failure\n       5.2.2. Include guidance on how to resolve the issue",
    "databaseEntities": [
      "Ranking"
    ],
    "validationRules": [
      "Ranking ID must exist in the system",
      "Ranking title must not be empty",
      "Ranking title must be between 1 and 100 characters",
      "Ranking title must be unique across all rankings",
      "Minimum posts must be a non-negative number for regular rankings",
      "Special rankings must be properly flagged"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Ranking": {
        "id": "number",
        "title": "string",
        "image": "string",
        "minPosts": "number",
        "isSpecial": "boolean"
      }
    }
  },
  {
    "featureName": "AddNewRanking",
    "description": "Creates a new ranking in the system.",
    "inputValues": [
      "title-string-Ranking",
      "minPoints-number-Ranking",
      "isSpecial-boolean-Ranking",
      "imageUrl-string-Ranking"
    ],
    "businessLogic": "1. Input Collection:\n   1.1. Collect the following required inputs:\n       - title (string): The name of the ranking (mandatory)\n       - minPoints (number): Minimum points required for this ranking (mandatory)\n       - isSpecial (boolean): Whether this is a special ranking (mandatory)\n       - imageUrl (string): URL to the ranking image (optional)\n\n2. Data Validation:\n   2.1. Validate title:\n       IF title is empty or null THEN\n           Return error message \"Ranking title cannot be empty\"\n       IF title length > 100 characters THEN\n           Return error message \"Ranking title cannot exceed 100 characters\"\n   \n   2.2. Validate minimum points:\n       IF minPoints is negative THEN\n           Return error message \"Minimum points cannot be negative\"\n   \n   2.3. Validate image URL:\n       IF imageUrl is provided THEN\n           IF imageUrl format is invalid THEN\n               Return error message \"Invalid image URL format\"\n\n3. Business Rule Processing:\n   3.1. Check for duplicate ranking titles:\n       FOR EACH existing ranking in the system\n           IF title equals existing.title THEN\n               Return error message \"Ranking with this title already exists\"\n   \n   3.2. Check for special ranking conflicts:\n       IF isSpecial is true THEN\n           Verify special ranking requirements are met\n       ELSE\n           Check for overlapping point ranges with other non-special rankings:\n           FOR EACH existing non-special ranking in the system\n               IF minPoints equals existing.minPoints THEN\n                   Return error message \"Another ranking already exists with the same minimum points\"\n   \n   3.3. Check system limits:\n       IF total number of rankings >= system maximum allowed rankings THEN\n           Return error message \"Maximum number of rankings reached\"\n\n4. Core Operation Execution:\n   4.1. Create new ranking record:\n       - Create a new ranking with the provided information\n       - Set the title to the provided value\n       - Set the minimum points to the provided value\n       - Set the special flag to the provided value\n       - Set the image URL if provided\n   \n   4.2. Store the ranking:\n       - Save the ranking to the system\n       - IF save operation fails THEN\n           Log the error details\n           Return error message \"Failed to create ranking\"\n\n5. Response Generation:\n   5.1. On success:\n       - Return success message \"Ranking created successfully\"\n       - Include the generated ranking ID\n       - Include a summary of the created ranking details\n   \n   5.2. On failure:\n       - Return appropriate error message from validation or processing steps\n       - Include guidance on how to correct the issue",
    "databaseEntities": [
      "Ranking"
    ],
    "validationRules": [
      "Ranking title must not be empty",
      "Ranking title must not exceed 100 characters",
      "Minimum points must not be negative",
      "Special rankings must be properly flagged",
      "Non-special rankings must not have duplicate minimum point values",
      "Image URL must have a valid format if provided"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Ranking": {
        "id": "number",
        "title": "string",
        "minPoints": "number",
        "isSpecial": "boolean",
        "imageUrl": "string"
      }
    }
  },
  {
    "featureName": "SelectSpecialRankings",
    "description": "Retrieves all special rankings from the database.",
    "inputValues": [],
    "businessLogic": "1. Input Collection:\n   - No user inputs required for this feature\n   - System will use internal parameters to retrieve special rankings\n\n2. Data Validation:\n   - Verify database connection is available\n   - IF database connection is unavailable THEN\n     - Generate appropriate error message\n     - Log connection failure\n     - Exit process\n   - END IF\n\n3. Business Rule Processing:\n   - Verify user has appropriate permissions to view rankings\n   - IF user lacks required permissions THEN\n     - Generate access denied message\n     - Log unauthorized access attempt\n     - Exit process\n   - END IF\n   - Determine which rankings qualify as \"special\"\n     - Special rankings are those not tied to post count thresholds\n     - Special rankings are manually assigned to users\n\n4. Core Operation Execution:\n   - Query the ranking data store for all special rankings\n   - Filter rankings based on the special designation\n   - Sort rankings according to predefined order (if applicable)\n   - Collect all matching ranking records\n   - IF no special rankings are found THEN\n     - Prepare empty result set\n   - ELSE\n     - Prepare result set with found special rankings\n   - END IF\n\n5. Response Generation:\n   - Format the retrieved special rankings into appropriate structure\n   - Include all relevant ranking attributes in the response:\n     - Ranking ID\n     - Ranking title\n     - Ranking image path (if available)\n     - Minimum post count (always 0 for special rankings)\n     - Special status flag (always true)\n   - Return the complete list of special rankings\n   - IF any errors occurred during retrieval THEN\n     - Include error details in response\n     - Provide guidance for resolving the issue\n   - END IF",
    "databaseEntities": [
      "jforum_users",
      "jforum_groups",
      "jforum_ranks"
    ],
    "validationRules": [
      "User must have permission to view rankings",
      "Database connection must be available",
      "Special rankings must be properly identified in the system"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Ranking": {
        "type": "object",
        "properties": {
          "id": {
            "type": "number",
            "description": "Unique identifier for the ranking"
          },
          "title": {
            "type": "string",
            "description": "Display name of the ranking"
          },
          "image": {
            "type": "string",
            "description": "Path to the ranking image"
          },
          "min": {
            "type": "number",
            "description": "Minimum post count required for this ranking (0 for special rankings)"
          },
          "special": {
            "type": "boolean",
            "description": "Flag indicating if this is a special ranking"
          }
        },
        "required": [
          "id",
          "title",
          "special"
        ]
      }
    }
  },
  {
    "featureName": "AddNewSmilie",
    "description": "Creates a new smilie emoticon in the forum system.",
    "inputValues": [
      "code-string-Smilie",
      "url-string-Smilie",
      "description-string-Smilie",
      "smilie-object-Smilie"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the following required inputs:\n     a. code (string): The text code that triggers the smilie (e.g., ':)' or ':smile:')\n     b. url (string): The path to the smilie image file\n     c. description (string): A brief description of the smilie\n   - All fields are mandatory\n   - No default values are provided\n\n2. Data Validation:\n   a. Validate smilie code:\n      - Check if code is not empty\n      - Verify code follows allowed pattern (special characters and text)\n      - Ensure code length is within acceptable limits (1-20 characters)\n      - IF validation fails, THEN return error message indicating invalid code format\n   \n   b. Validate smilie URL:\n      - Check if URL is not empty\n      - Verify URL points to a valid image file (check file extension)\n      - Ensure URL length is within acceptable limits\n      - IF validation fails, THEN return error message indicating invalid URL format\n   \n   c. Validate description:\n      - Check if description is not empty\n      - Ensure description length is within acceptable limits (1-50 characters)\n      - IF validation fails, THEN return error message indicating invalid description format\n   \n   d. Check for duplicate smilie code:\n      - Verify the smilie code doesn't already exist in the system\n      - IF code already exists, THEN return error message indicating duplicate smilie code\n\n3. Business Rule Processing:\n   a. Check system limits:\n      - Verify that adding a new smilie won't exceed system-defined limits\n      - IF limit would be exceeded, THEN return error message\n   \n   b. Check image file validity:\n      - Verify the image exists at the specified URL\n      - Check that the image format is supported (gif, png, jpg, etc.)\n      - Ensure image dimensions are within acceptable limits\n      - IF any check fails, THEN return appropriate error message\n   \n   c. Check user permissions:\n      - Verify the current user has permission to add smilies\n      - IF user lacks permission, THEN return error message indicating insufficient privileges\n\n4. Core Operation Execution:\n   a. Create new smilie record:\n      - Generate a new smilie object with provided inputs\n      - Assign a unique identifier to the new smilie\n      - Store the smilie in the system database\n      - IF storage operation fails, THEN log error details and return system error message\n   \n   b. Update smilie cache:\n      - Refresh the system's smilie cache to include the new smilie\n      - Ensure the smilie is immediately available for use\n      - IF cache update fails, THEN log warning but continue process\n\n5. Response Generation:\n   a. Success response:\n      - Return success status\n      - Include the ID of the newly created smilie\n      - Provide confirmation message that smilie was successfully added\n   \n   b. Error response:\n      - Return error status if any step failed\n      - Include specific error message describing the issue\n      - Provide guidance on how to resolve the problem",
    "databaseEntities": [
      "jforum_smilies"
    ],
    "validationRules": [
      "Smilie code must not be empty",
      "Smilie code must be unique in the system",
      "Smilie code must be between 1 and 20 characters",
      "Smilie URL must not be empty",
      "Smilie URL must point to a valid image file",
      "Smilie description must not be empty",
      "Smilie description must be between 1 and 50 characters",
      "User must have permission to add smilies"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Smilie": {
        "id": "number",
        "code": "string",
        "url": "string",
        "description": "string"
      }
    }
  },
  {
    "featureName": "DeleteSmilie",
    "description": "Removes a smilie emoticon from the forum system by its ID.",
    "inputValues": [
      "id-number-Smilie"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the following input:\n     - id (number, mandatory): The unique identifier of the smilie to be deleted\n\n2. Data Validation:\n   - Validate the smilie ID:\n     - Check if the ID is provided\n       IF ID is not provided THEN\n         Return an error message indicating that the smilie ID is required\n     - Verify that the ID is a positive integer\n       IF ID is not a positive integer THEN\n         Return an error message indicating that the ID must be a valid positive number\n\n3. Business Rule Processing:\n   - Verify the smilie exists in the system:\n     - Check if a smilie with the provided ID exists in the database\n       IF smilie does not exist THEN\n         Return an error message indicating that the smilie with the given ID was not found\n   - Check if the smilie is in use:\n     - Determine if the smilie is currently referenced in any forum posts\n       IF smilie is referenced in posts THEN\n         Decide whether to proceed with deletion (may affect post display)\n\n4. Core Operation Execution:\n   - Delete the smilie record:\n     - Remove the smilie entry from the system database\n     - If the smilie has an associated image file:\n       - Determine if the image file should be retained or deleted\n       - If deletion is required, remove the image file from storage\n   - Update any cached smilie data:\n     - Clear any system cache that might contain the deleted smilie\n     - Ensure the smilie list is refreshed for all active users\n\n5. Response Generation:\n   - For successful deletion:\n     - Generate a success message indicating the smilie was successfully removed\n     - Include the ID of the deleted smilie in the response\n   - For failed deletion:\n     - Generate an appropriate error message explaining the reason for failure\n     - Include suggestions for resolving the issue if applicable",
    "databaseEntities": [
      "jforum_smilies"
    ],
    "validationRules": [
      "Smilie ID must be provided",
      "Smilie ID must be a positive integer",
      "Smilie must exist in the system before deletion"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Smilie": {
        "id": "number",
        "code": "string",
        "url": "string",
        "diskName": "string"
      }
    }
  },
  {
    "featureName": "UpdateSmilie",
    "description": "Modifies an existing smilie emoticon's properties in the system.",
    "inputValues": [
      "id-number-Smilie",
      "code-string-Smilie",
      "smilie_img-object-FileItem"
    ],
    "businessLogic": "1. Input Collection\n   1.1. Collect the following inputs:\n       - id (number, mandatory): Unique identifier of the smilie to update\n       - code (string, mandatory): Text representation of the smilie\n       - smilie_img (object, optional): New image file for the smilie\n   1.2. System retrieves the current smilie record using the provided id\n\n2. Data Validation\n   2.1. Validate smilie id\n       2.1.1. Check if id is provided\n       2.1.2. Verify id is a positive integer\n       2.1.3. Confirm smilie with provided id exists in the system\n       2.1.4. IF smilie not found, THEN display error message \"Smilie not found\"\n   2.2. Validate smilie code\n       2.2.1. Check if code is provided\n       2.2.2. Verify code is not empty\n       2.2.3. Check if code length is within acceptable limits (1-50 characters)\n       2.2.4. IF code is invalid, THEN display error message \"Invalid smilie code\"\n   2.3. Validate smilie image (if provided)\n       2.3.1. Check if uploaded file is an image\n       2.3.2. Verify image file size is within acceptable limits\n       2.3.3. Confirm image format is supported (e.g., JPG, PNG, GIF)\n       2.3.4. IF image is invalid, THEN display error message \"Invalid smilie image\"\n\n3. Business Rule Processing\n   3.1. Check for duplicate smilie codes\n       3.1.1. Search for existing smilies with the same code (excluding current smilie)\n       3.1.2. IF duplicate found, THEN display error message \"Smilie code already exists\"\n   3.2. Verify system constraints\n       3.2.1. Verify user has permission to update smilies\n       3.2.2. IF user lacks permission, THEN display error message \"Insufficient privileges\"\n   3.3. Check storage availability (if new image provided)\n       3.3.1. Verify sufficient storage space for new image\n       3.3.2. IF storage space insufficient, THEN display error message \"Insufficient storage space\"\n\n4. Core Operation Execution\n   4.1. Process image upload (if new image provided)\n       4.1.1. Generate unique filename for the image using cryptographic hash\n       4.1.2. Save uploaded image to the smilie image directory\n       4.1.3. IF image save fails, THEN log error and display message \"Failed to save image\"\n   4.2. Prepare smilie data for update\n       4.2.1. Update smilie code with new value\n       4.2.2. IF new image uploaded, update URL and disk name properties\n       4.2.3. Preserve existing URL and disk name if no new image provided\n   4.3. Update smilie record\n       4.3.1. Update the smilie record in the database\n       4.3.2. IF update fails, THEN log error details and display message \"Failed to update smilie\"\n       4.3.3. Revert any file system changes if update fails\n   4.4. Update system cache\n       4.4.1. Refresh smilies repository to reflect changes\n       4.4.2. IF cache refresh fails, THEN log warning but continue\n\n5. Response Generation\n   5.1. Generate success response\n       5.1.1. Create confirmation message \"Smilie updated successfully\"\n       5.1.2. Prepare list of all smilies for display\n   5.2. Handle error responses\n       5.2.1. For validation errors, return specific error messages\n       5.2.2. For system errors, return generic error message with error code\n   5.3. Provide next steps\n       5.3.1. Display updated list of all smilies\n       5.3.2. Offer options to edit another smilie or return to administration panel",
    "databaseEntities": [
      "jforum_smilies"
    ],
    "validationRules": [
      "Smilie ID must exist in the system",
      "Smilie code must not be empty",
      "Smilie code must be unique across all smilies",
      "If provided, smilie image must be a valid image file",
      "If provided, smilie image must be within acceptable file size limits",
      "If provided, smilie image must be in a supported format"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Smilie": {
        "id": "number",
        "code": "string",
        "url": "string",
        "diskName": "string"
      },
      "FileItem": {
        "name": "string",
        "size": "number",
        "contentType": "string",
        "content": "binary"
      }
    }
  },
  {
    "featureName": "GetAllSmilies",
    "description": "Retrieves all smilie emoticons available in the forum system.",
    "inputValues": [],
    "businessLogic": "1. Input Collection:\n   - No user inputs required for this feature\n   - System will retrieve all smilie records without filtering parameters\n\n2. Data Validation:\n   - Verify system access permissions\n      - IF user does not have appropriate permissions THEN\n         - Generate access denied error\n         - Terminate process\n      - END IF\n   - Verify system state is operational\n      - IF system is in maintenance mode THEN\n         - Generate system unavailable error\n         - Terminate process\n      - END IF\n\n3. Business Rule Processing:\n   - Check resource availability\n      - IF database connection cannot be established THEN\n         - Generate database connection error\n         - Log connection failure details\n         - Terminate process\n      - END IF\n   - Verify smilie data access is permitted\n      - IF smilie data access is restricted THEN\n         - Generate access restriction error\n         - Terminate process\n      - END IF\n\n4. Core Operation Execution:\n   - Retrieve all smilie records from storage\n      - Fetch all records from the smilie repository\n      - Include all smilie attributes (id, code, url, disk_name)\n      - Sort smilies in appropriate order (by id or display order)\n   - Process retrieved smilie records\n      - IF no smilies are found THEN\n         - Prepare empty collection response\n      - ELSE\n         - Prepare collection with all smilie records\n      - END IF\n   - Handle any retrieval errors\n      - IF errors occur during retrieval THEN\n         - Log error details\n         - Generate appropriate error message\n         - Terminate process\n      - END IF\n\n5. Response Generation:\n   - Prepare success response\n      - Format collection of smilie records\n      - Include total count of smilies\n   - Return formatted response to caller\n      - Include all smilie details in response\n      - Ensure proper formatting of response data",
    "databaseEntities": [
      "jforum_smilies"
    ],
    "validationRules": [
      "User must have appropriate permissions to view smilies",
      "System must be in operational state",
      "Database connection must be available"
    ],
    "dbSeedingOperations": [
      "Ensure default system smilies are available in the database"
    ],
    "schema": {
      "Smilie": {
        "id": "number",
        "code": "string",
        "diskName": "string",
        "url": "string",
        "displayOrder": "number"
      }
    }
  },
  {
    "featureName": "GetSmilieById",
    "description": "Retrieves a specific smilie emoticon by its ID.",
    "inputValues": [
      "id-number-Smilie"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the smilie ID (number) from the user request\n   - The ID is mandatory and must be provided by the user\n   - No default value is available for the ID\n\n2. Data Validation:\n   - Validate the smilie ID:\n     a. Check if the ID is provided\n     b. Verify the ID is a positive integer\n     c. Generate appropriate error message if validation fails\n\n3. Business Rule Processing:\n   - Check if the system is in a valid state to retrieve smilie data\n   - Verify user has appropriate permissions to view smilie information\n   - Ensure the smilie repository is accessible\n\n4. Core Operation Execution:\n   - Search for the smilie record using the provided ID\n   - IF smilie with the given ID exists:\n     a. Retrieve the complete smilie information including:\n        i. Smilie code\n        ii. Smilie image URL\n        iii. Disk name\n        iv. Smilie ID\n   - ELSE:\n     a. Record that no smilie was found with the given ID\n     b. Prepare for appropriate response\n\n5. Response Generation:\n   - IF smilie was found:\n     a. Prepare success response with complete smilie details\n     b. Include all smilie attributes in the response (ID, code, URL, disk name)\n   - ELSE:\n     a. Prepare error response indicating smilie not found\n     b. Include the requested ID in the error message\n     c. Provide suggestions for next steps (e.g., view all available smilies)",
    "databaseEntities": [
      "jforum_smilies"
    ],
    "validationRules": [
      "Smilie ID must be provided",
      "Smilie ID must be a positive integer",
      "Smilie must exist in the system"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Smilie": {
        "id": "number",
        "code": "string",
        "url": "string",
        "diskName": "string"
      }
    }
  },
  {
    "featureName": "SelectLastPosts",
    "description": "Retrieves posts from the database within a specified date range.",
    "inputValues": [
      "firstDate-date-Post",
      "lastDate-date-Post"
    ],
    "businessLogic": "1. Input Collection\n   1.1. Collect the following required inputs:\n       - firstDate: The starting date for the post retrieval period\n       - lastDate: The ending date for the post retrieval period\n   1.2. Validate that both dates are provided and properly formatted\n\n2. Data Validation\n   2.1. Validate firstDate:\n       2.1.1. Check if firstDate is a valid date format\n       2.1.2. IF firstDate is invalid or missing, THEN generate an error message indicating valid date format is required\n   2.2. Validate lastDate:\n       2.2.1. Check if lastDate is a valid date format\n       2.2.2. IF lastDate is invalid or missing, THEN generate an error message indicating valid date format is required\n   2.3. Validate date range:\n       2.3.1. Check if firstDate is before or equal to lastDate\n       2.3.2. IF firstDate is after lastDate, THEN generate an error message indicating invalid date range\n\n3. Business Rule Processing\n   3.1. Check system state:\n       3.1.1. Verify that the post repository is accessible\n       3.1.2. IF post repository is not accessible, THEN generate a system unavailable error\n   3.2. Apply access control:\n       3.2.1. Verify that the current user has permission to view posts\n       3.2.2. IF user lacks permission, THEN generate an access denied error\n   3.3. Check resource constraints:\n       3.3.1. Determine if the date range is within acceptable query limits\n       3.3.2. IF date range exceeds system limits, THEN generate an error message suggesting a narrower date range\n\n4. Core Operation Execution\n   4.1. Prepare post retrieval parameters:\n       4.1.1. Format date parameters to system-required format\n       4.1.2. Set up sorting criteria (default: chronological order, newest first)\n   4.2. Retrieve posts:\n       4.2.1. Query the post repository for posts created between firstDate and lastDate (inclusive)\n       4.2.2. Apply any system-defined filters for retrievable posts\n       4.2.3. IF no posts are found, THEN prepare an empty result set\n   4.3. Process retrieved posts:\n       4.3.1. For each post retrieved:\n           - Extract relevant post information (ID, content, author, timestamp, etc.)\n           - Format post data according to system requirements\n           - Calculate and include karma score for each post\n       4.3.2. Format post timestamps according to system date format preferences\n       4.3.3. Organize posts in the required order\n\n5. Response Generation\n   5.1. Prepare success response:\n       5.1.1. Create a collection of retrieved posts\n       5.1.2. Include metadata about the query (total count, date range used)\n   5.2. Handle error responses:\n       5.2.1. IF any errors occurred during processing, THEN include appropriate error messages\n       5.2.2. For validation errors, include specific field-level error information\n   5.3. Return final response:\n       5.3.1. Package all post data and metadata into the response\n       5.3.2. Include any pagination information if applicable",
    "databaseEntities": [
      "jforum_posts",
      "jforum_posts_text",
      "jforum_topics",
      "jforum_forums",
      "jforum_users",
      "jforum_karma"
    ],
    "validationRules": [
      "First date must be a valid date format",
      "Last date must be a valid date format",
      "First date must be before or equal to last date",
      "User must have permission to view posts",
      "Date range must be within system-defined query limits"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Post": {
        "type": "object",
        "properties": {
          "id": {
            "type": "number"
          },
          "topicId": {
            "type": "number"
          },
          "forumId": {
            "type": "number"
          },
          "userId": {
            "type": "number"
          },
          "time": {
            "type": "date"
          },
          "subject": {
            "type": "string"
          },
          "text": {
            "type": "string"
          },
          "postUsername": {
            "type": "string"
          },
          "formatedTime": {
            "type": "string"
          },
          "karma": {
            "type": "object"
          }
        }
      }
    }
  },
  {
    "featureName": "ListRecipients",
    "description": "Retrieves a list of recipients from the database.",
    "inputValues": [],
    "businessLogic": "1. Input Collection:\n   - No user inputs required for this feature\n   - System will use current session context for authorization\n\n2. Data Validation:\n   - Validate user authorization\n     - IF user is not authorized to view recipients list THEN\n       - Generate authorization error\n       - Terminate process\n     - END IF\n\n3. Business Rule Processing:\n   - Check system configuration for recipient visibility settings\n     - IF recipient visibility is restricted THEN\n       - Apply visibility filters based on user permissions\n     - END IF\n   - Determine sorting order for recipients list\n     - Default sort order is alphabetical by recipient name\n   - Check for any active filters that should be applied\n     - IF filters exist THEN\n       - Prepare filter criteria for database query\n     - END IF\n\n4. Core Operation Execution:\n   - Retrieve recipients list from database\n     - Query user email addresses from the system\n     - Filter out empty or invalid email addresses\n     - Apply any filters determined in previous step\n     - Apply sorting order determined in previous step\n     - Limit results based on system pagination settings if applicable\n   - Process recipient data for display\n     - Format recipient information according to display requirements\n     - Remove sensitive information based on privacy settings\n     - Group recipients by category if grouping is enabled\n\n5. Response Generation:\n   - Prepare recipients list for presentation\n     - Format data according to view requirements\n     - Include pagination metadata if applicable\n   - IF no recipients found THEN\n     - Generate appropriate empty list message\n   - ELSE\n     - Return formatted list of recipients\n   - END IF",
    "databaseEntities": [
      "jforum_users",
      "jforum_groups",
      "jforum_user_groups"
    ],
    "validationRules": [
      "User must have permission to view recipients list",
      "System must be configured to allow recipient listing",
      "Recipients must be active users in the system",
      "Email addresses must not be empty or invalid"
    ],
    "dbSeedingOperations": [],
    "schema": {}
  },
  {
    "featureName": "SelectTopicById",
    "description": "Retrieves a specific topic by its ID with complete information.",
    "inputValues": [
      "topicId-number-Topic"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the topicId (mandatory, number type)\n   - No optional fields required\n   - No default values needed\n\n2. Data Validation:\n   - Validate topicId:\n     a. Check if topicId is provided\n     b. Verify topicId is a positive integer\n     c. Generate appropriate error message if validation fails\n\n3. Business Rule Processing:\n   - Check system state:\n     a. Verify the system is operational\n     b. Ensure the user has appropriate permissions to view topics\n   - Verify dependencies:\n     a. Confirm the topic database is accessible\n     b. Check if any required services are available\n\n4. Core Operation Execution:\n   - Retrieve topic information:\n     a. Fetch the basic topic data using the provided topicId\n     b. If topic not found, prepare appropriate error response\n     c. If topic found, retrieve associated information:\n        i. Get topic creator details\n        ii. Get topic status (locked/unlocked)\n        iii. Get topic view count\n        iv. Get topic reply count\n        v. Get first and last post information\n   - Process topic metadata:\n     a. Check if topic is marked as read for the current user\n     b. Check if user is subscribed to the topic\n     c. Determine if the topic has attachments\n\n5. Response Generation:\n   - For successful retrieval:\n     a. Prepare complete topic object with all related information\n     b. Include topic metadata (creation date, last post date)\n     c. Include topic status information\n   - For failed retrieval:\n     a. Generate appropriate error message\n     b. Include error code and description\n     c. Provide guidance for next steps",
    "databaseEntities": [
      "jforum_topics",
      "jforum_posts",
      "jforum_users",
      "jforum_forums"
    ],
    "validationRules": [
      "Topic ID must be a positive integer",
      "Topic must exist in the database",
      "User must have permission to view the topic",
      "Forum containing the topic must be accessible to the user"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Topic": {
        "id": "number",
        "title": "string",
        "forumId": "number",
        "status": "number",
        "totalViews": "number",
        "totalReplies": "number",
        "firstPostId": "number",
        "lastPostId": "number",
        "type": "number",
        "creationDate": "date",
        "lastPostDate": "date",
        "userId": "number",
        "isRead": "boolean",
        "isSubscribed": "boolean",
        "hasAttachments": "boolean"
      }
    }
  },
  {
    "featureName": "SelectRawTopic",
    "description": "Retrieves basic topic information without additional data like usernames.",
    "inputValues": [
      "topicId-number-Topic"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect topicId (number, mandatory) to identify the topic to retrieve\n   - No optional fields required\n   - No default values needed\n\n2. Data Validation:\n   - Validate topicId:\n     a. Check if topicId is provided\n     b. Verify topicId is a positive integer\n     c. Generate appropriate error message if validation fails\n\n3. Business Rule Processing:\n   - Verify system state:\n     a. Check if the system is operational\n     b. Verify the database connection is active\n   - Verify resource availability:\n     a. Ensure the topics database is accessible\n     b. Check if the user has permission to view topics\n\n4. Core Operation Execution:\n   - Retrieve topic data:\n     a. Fetch only the basic topic information from the topics table\n     b. Do not retrieve associated user information\n     c. Do not retrieve post content or other related data\n     d. IF topic with specified ID exists:\n        i. Collect topic data including topic ID, title, status, creation date, and other basic attributes\n     e. ELSE:\n        i. Prepare for \"topic not found\" response\n        ii. Log the failed retrieval attempt\n\n5. Response Generation:\n   - Success response:\n     a. Return the topic object with basic information\n     b. Include topic ID, title, status, and other basic attributes\n   - Error response:\n     a. IF topic not found:\n        i. Return appropriate \"topic not found\" message\n     b. IF system error occurred:\n        i. Return error details\n        ii. Include support information",
    "databaseEntities": [
      "jforum_topics"
    ],
    "validationRules": [
      "Topic ID must be a positive integer",
      "Topic ID must reference an existing topic",
      "User must have permission to view topics"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Topic": {
        "type": "object",
        "properties": {
          "id": {
            "type": "number",
            "description": "Unique identifier for the topic"
          },
          "title": {
            "type": "string",
            "description": "Title of the topic"
          },
          "status": {
            "type": "number",
            "description": "Status code of the topic (locked, unlocked, etc.)"
          },
          "forumId": {
            "type": "number",
            "description": "ID of the forum this topic belongs to"
          },
          "lastPostId": {
            "type": "number",
            "description": "ID of the last post in this topic"
          },
          "firstPostId": {
            "type": "number",
            "description": "ID of the first post in this topic"
          },
          "totalReplies": {
            "type": "number",
            "description": "Count of replies in this topic"
          },
          "totalViews": {
            "type": "number",
            "description": "Count of views for this topic"
          },
          "creationDate": {
            "type": "date",
            "description": "Date when the topic was created"
          },
          "moderated": {
            "type": "boolean",
            "description": "Whether the topic is moderated"
          },
          "type": {
            "type": "number",
            "description": "Type of the topic"
          },
          "voteId": {
            "type": "number",
            "description": "ID of the associated vote/poll if any"
          }
        },
        "required": [
          "id",
          "title",
          "forumId"
        ]
      }
    }
  },
  {
    "featureName": "SelectTopicsByForum",
    "description": "Retrieves all topics associated with a specific forum.",
    "inputValues": [
      "forumId-number-Forum"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect forumId (number, mandatory) - Unique identifier of the forum\n\n2. Data Validation:\n   - Validate forumId:\n     a. Check if forumId is provided\n     b. Verify forumId is a positive integer\n     c. If validation fails, generate appropriate error message\n\n3. Business Rule Processing:\n   - Verify forum existence:\n     a. Check if forum with provided forumId exists in the system\n     b. If forum does not exist, generate \"Forum not found\" error\n   - Verify user access permissions:\n     a. Check if current user has permission to view the specified forum\n     b. If user lacks permission, generate \"Access denied\" error\n\n4. Core Operation Execution:\n   - Retrieve topics data:\n     a. Fetch all topics associated with the specified forumId\n     b. For each topic, collect:\n        i. Topic ID\n        ii. Topic title\n        iii. Creation date\n        iv. Last post date\n        v. Total views\n        vi. Total replies\n        vii. Status (locked/unlocked)\n        viii. Creator information\n        ix. Last poster information\n     c. Sort topics according to system's default sorting criteria (typically by last post date)\n   - Handle empty results:\n     a. If no topics are found for the forum, prepare empty result set\n\n5. Response Generation:\n   - Success response:\n     a. Return collection of topic objects with all retrieved data\n     b. Include pagination metadata if applicable\n   - Error response:\n     a. Return appropriate error message based on validation or business rule failures\n     b. Include error code and description",
    "databaseEntities": [
      "jforum_forums",
      "jforum_topics",
      "jforum_users",
      "jforum_posts"
    ],
    "validationRules": [
      "Forum ID must be a positive integer",
      "Forum must exist in the system",
      "User must have permission to view the forum",
      "Topics must be sorted by system's default sorting criteria"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Topic": {
        "type": "object",
        "properties": {
          "id": {
            "type": "number",
            "description": "Unique identifier for the topic"
          },
          "title": {
            "type": "string",
            "description": "Title of the topic"
          },
          "creationDate": {
            "type": "date",
            "description": "Date when the topic was created"
          },
          "lastPostDate": {
            "type": "date",
            "description": "Date of the last post in the topic"
          },
          "totalViews": {
            "type": "number",
            "description": "Number of times the topic was viewed"
          },
          "totalReplies": {
            "type": "number",
            "description": "Number of replies in the topic"
          },
          "status": {
            "type": "number",
            "description": "Status of the topic (locked/unlocked)"
          },
          "creator": {
            "type": "object",
            "description": "Information about the topic creator",
            "properties": {
              "id": {
                "type": "number"
              },
              "username": {
                "type": "string"
              }
            }
          },
          "lastPoster": {
            "type": "object",
            "description": "Information about the last poster",
            "properties": {
              "id": {
                "type": "number"
              },
              "username": {
                "type": "string"
              }
            }
          }
        }
      },
      "Forum": {
        "type": "object",
        "properties": {
          "id": {
            "type": "number",
            "description": "Unique identifier for the forum"
          },
          "name": {
            "type": "string",
            "description": "Name of the forum"
          },
          "description": {
            "type": "string",
            "description": "Description of the forum"
          }
        }
      }
    }
  },
  {
    "featureName": "SelectTopicTitlesByIds",
    "description": "Retrieves topic titles for a collection of topic IDs.",
    "inputValues": [
      "idList-object-Collection"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect a list of topic IDs (idList) as a Collection object\n   - The idList is mandatory and must contain valid topic identifiers\n   - System will process this collection to retrieve corresponding topic titles\n\n2. Data Validation:\n   - Validate that the idList is not null\n     IF idList is null THEN\n       Return an empty list\n     END IF\n   - Validate that the idList is not empty\n     IF idList is empty THEN\n       Return an empty list\n     END IF\n   - Validate that all IDs in the collection are valid integers\n     FOR EACH id IN idList\n       IF id is not a valid integer THEN\n         Skip this ID in processing\n       END IF\n     END FOR\n\n3. Business Rule Processing:\n   - Check system access permissions\n     IF user does not have permission to view topics THEN\n       Return empty list or appropriate error\n     END IF\n   - Verify that the topics exist in the system\n     FOR EACH id IN idList\n       IF topic with id does not exist THEN\n         Skip this ID in processing\n       END IF\n     END FOR\n\n4. Core Operation Execution:\n   - Prepare to retrieve topic titles\n   - Convert the collection of IDs into a comma-separated string\n     Initialize a string buffer\n     FOR EACH id IN idList\n       Append id and comma to string buffer\n     END FOR\n     Remove the trailing comma if present\n   - Query the database for topic titles using the prepared string of IDs\n   - Create a result list to store topic information\n   - FOR EACH retrieved topic\n     Create a map containing topic ID and title\n     Add map to result list\n   END FOR\n\n5. Response Generation:\n   - IF operation successful THEN\n     Return list of maps containing topic IDs and titles\n   - ELSE\n     Return appropriate error message or empty list\n   - END IF",
    "databaseEntities": [
      "jforum_topics"
    ],
    "validationRules": [
      "The input collection must not be null",
      "The input collection must contain at least one topic ID",
      "All IDs must be valid integers",
      "User must have permission to view the requested topics"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Collection": {
        "type": "array",
        "items": {
          "type": "integer",
          "description": "Topic ID"
        }
      },
      "ResultItem": {
        "type": "object",
        "properties": {
          "id": {
            "type": "integer",
            "description": "Topic ID"
          },
          "title": {
            "type": "string",
            "description": "Topic title"
          }
        }
      }
    }
  },
  {
    "featureName": "SelectTopicsByForumWithPagination",
    "description": "Retrieves paginated topics for a specific forum.",
    "inputValues": [
      "forumId-number-Forum",
      "startFrom-number-Pagination",
      "count-number-Pagination"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect forumId (mandatory): numeric identifier of the forum\n   - Collect startFrom (mandatory): numeric position to start retrieving records from\n   - Collect count (mandatory): maximum number of records to retrieve\n   - System will use these parameters to fetch a limited set of topics from the specified forum\n\n2. Data Validation:\n   - Validate forumId:\n     a. Must be a positive integer\n     b. Must represent an existing forum in the system\n     c. Return error if forum does not exist\n   - Validate startFrom:\n     a. Must be a non-negative integer\n     b. Return error if negative value provided\n   - Validate count:\n     a. Must be a positive integer\n     b. Must not exceed system-defined maximum page size\n     c. Return error if count is zero or negative\n     d. Return error if count exceeds maximum allowed value\n\n3. Business Rule Processing:\n   - Check user permissions:\n     a. Verify if the current user has access to view the specified forum\n     b. IF user does not have permission, THEN return appropriate error message\n   - Check forum status:\n     a. Verify if the forum is active and not archived\n     b. IF forum is inactive or archived, THEN return appropriate status message\n   - Determine pagination strategy:\n     a. For database-specific implementations, adjust the query parameters accordingly\n     b. Calculate the endpoint as startFrom + count for certain database systems\n\n4. Core Operation Execution:\n   - Retrieve topics from the specified forum:\n     a. Query topics associated with the forumId\n     b. Apply pagination using startFrom and count parameters\n        i. Position the result set cursor at the startFrom position\n        ii. Retrieve up to 'count' records from that position\n     c. Sort topics according to system's default sorting criteria (typically by last post date)\n     d. For each topic retrieved:\n        i. Include basic topic information (id, title, creation date)\n        ii. Include topic statistics (view count, reply count)\n        iii. Include information about the topic creator (user_id, username)\n        iv. Include information about the last post (last_user_id, post_time)\n        v. Include attachment information (has_attach flag)\n        vi. Format dates according to system's configured date format\n   - IF no topics found:\n     a. Return empty result set with appropriate metadata\n\n5. Response Generation:\n   - Prepare paginated topic list response:\n     a. Include list of topic objects with their details\n     b. Include pagination metadata:\n        i. Total number of topics in the forum\n        ii. Current page information\n        iii. Information about next/previous pages if applicable\n     c. Include forum information for context\n     d. Format dates in the configured system format\n   - Return the complete response to the caller",
    "databaseEntities": [
      "jforum_forums",
      "jforum_topics",
      "jforum_posts",
      "jforum_users"
    ],
    "validationRules": [
      "Forum ID must be a positive integer",
      "Forum must exist in the system",
      "Start position must be a non-negative integer",
      "Count must be a positive integer",
      "Count must not exceed system-defined maximum page size",
      "User must have permission to view the specified forum"
    ],
    "dbSeedingOperations": [],
    "schema": {}
  },
  {
    "featureName": "SelectTopicsByUser",
    "description": "Retrieves topics created by a specific user with pagination.",
    "inputValues": [
      "userId-number-User",
      "startFrom-number-Pagination",
      "count-number-Pagination"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the following inputs:\n     a. userId (mandatory): Numeric identifier of the user whose topics are being retrieved\n     b. startFrom (mandatory): Numeric value indicating the starting position for pagination\n     c. count (mandatory): Numeric value indicating the maximum number of topics to retrieve\n\n2. Data Validation:\n   - Validate userId:\n     a. Check if userId is provided\n     b. Verify userId is a positive integer\n     c. IF userId is invalid or missing, THEN generate an error message\n   - Validate pagination parameters:\n     a. Ensure startFrom is a non-negative integer\n     b. Ensure count is a positive integer\n     c. IF either pagination parameter is invalid, THEN use system defaults\n\n3. Business Rule Processing:\n   - Check user existence:\n     a. Verify the specified user exists in the system\n     b. IF user does not exist, THEN return an appropriate error message\n   - Check user permissions:\n     a. Verify the requesting user has permission to view the target user's topics\n     b. IF permission is denied, THEN return an access denied error\n   - Check forum access permissions:\n     a. Determine which forums the requesting user has access to\n     b. Filter topics to only include those from accessible forums\n     c. IF no forums are accessible, THEN return an empty result set\n\n4. Core Operation Execution:\n   - Retrieve user topics:\n     a. Query the database for topics created by the specified user\n     b. Apply pagination parameters (startFrom and count) to limit results\n     c. Order topics by creation date (newest first)\n     d. For each topic, retrieve:\n        i. Topic identifier\n        ii. Topic title\n        iii. Creation date\n        iv. Last post date\n        v. View count\n        vi. Reply count\n        vii. Forum information the topic belongs to\n        viii. Topic status (locked, normal, etc.)\n        ix. Topic type (sticky, announcement, normal)\n        x. First post ID\n        xi. Last post ID\n   - Count total topics:\n     a. Determine the total number of topics created by the user\n     b. Use this count for pagination metadata\n   - Handle empty results:\n     a. IF no topics are found, THEN prepare an empty result set\n     b. Include metadata indicating zero results found\n\n5. Response Generation:\n   - Prepare successful response:\n     a. Format the list of topics with all retrieved attributes\n     b. Include pagination metadata:\n        i. Total number of topics by the user\n        ii. Current page information\n        iii. Whether more topics are available\n     c. Include user information summary\n   - Handle errors:\n     a. For validation errors, return appropriate error messages\n     b. For permission errors, return access denied message\n     c. For system errors, return a generic error message with support information",
    "databaseEntities": [
      "jforum_users",
      "jforum_topics",
      "jforum_forums",
      "jforum_posts"
    ],
    "validationRules": [
      "User ID must be a positive integer",
      "User must exist in the system",
      "Start position must be a non-negative integer",
      "Count must be a positive integer",
      "Requesting user must have permission to view the target user's topics",
      "Topics must be filtered based on forum access permissions"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Topic": {
        "type": "object",
        "properties": {
          "id": {
            "type": "number",
            "description": "Unique identifier for the topic"
          },
          "title": {
            "type": "string",
            "description": "Title of the topic"
          },
          "creationDate": {
            "type": "date",
            "description": "Date when the topic was created"
          },
          "lastPostDate": {
            "type": "date",
            "description": "Date of the last post in the topic"
          },
          "viewCount": {
            "type": "number",
            "description": "Number of times the topic has been viewed"
          },
          "replyCount": {
            "type": "number",
            "description": "Number of replies to the topic"
          },
          "forumId": {
            "type": "number",
            "description": "ID of the forum the topic belongs to"
          },
          "forumName": {
            "type": "string",
            "description": "Name of the forum the topic belongs to"
          },
          "status": {
            "type": "number",
            "description": "Status of the topic (locked, normal, etc.)"
          },
          "type": {
            "type": "number",
            "description": "Type of the topic (sticky, announcement, normal)"
          },
          "firstPostId": {
            "type": "number",
            "description": "ID of the first post in the topic"
          },
          "lastPostId": {
            "type": "number",
            "description": "ID of the last post in the topic"
          }
        }
      },
      "PaginationInfo": {
        "type": "object",
        "properties": {
          "totalTopics": {
            "type": "number",
            "description": "Total number of topics created by the user"
          },
          "startFrom": {
            "type": "number",
            "description": "Starting position of the current page"
          },
          "count": {
            "type": "number",
            "description": "Number of topics in the current page"
          },
          "hasMore": {
            "type": "boolean",
            "description": "Indicates if more topics are available"
          }
        }
      }
    }
  },
  {
    "featureName": "CountUserTopics",
    "description": "Counts the number of topics created by a specific user.",
    "inputValues": [
      "userId-number-User"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect userId (number, mandatory) to identify the user whose topics will be counted\n\n2. Data Validation:\n   - Validate userId:\n     a. Check if userId is provided\n     b. Verify userId is a positive integer\n     c. IF userId is invalid or missing, THEN return appropriate error message\n   - Validate user existence:\n     a. Check if the user with the provided userId exists in the system\n     b. IF user does not exist, THEN return appropriate error message indicating user not found\n\n3. Business Rule Processing:\n   - Verify system access permissions:\n     a. Check if the current user has permission to view topic statistics\n     b. IF permission is denied, THEN return access denied error\n   - Verify forum access permissions:\n     a. Determine which forums the requesting user has access to view\n     b. Only count topics from forums the user has permission to access\n     c. IF user has no forum access, THEN return zero count with appropriate message\n   - Verify system state:\n     a. Ensure the topic tracking system is operational\n     b. IF system is in maintenance mode, THEN notify user and abort operation\n\n4. Core Operation Execution:\n   - Retrieve topic count:\n     a. Access the topic repository\n     b. Count all topics where the creator/author ID matches the provided userId\n     c. Include only non-deleted topics in the count\n     d. Filter topics based on forum access permissions\n     e. IF database access fails, THEN handle the error and provide appropriate message\n\n5. Response Generation:\n   - Success response:\n     a. Return the total count of topics created by the user\n     b. Include user identification information for reference\n   - Error response:\n     a. Return specific error details if any step failed\n     b. Provide guidance on how to resolve the issue",
    "databaseEntities": [
      "jforum_users",
      "jforum_topics",
      "jforum_forums"
    ],
    "validationRules": [
      "User ID must be a positive integer",
      "User must exist in the system",
      "Requesting user must have permission to view topic statistics",
      "Only count topics from forums the user has permission to access"
    ],
    "dbSeedingOperations": [],
    "schema": {}
  },
  {
    "featureName": "DeleteTopic",
    "description": "Deletes a specific topic with moderation flag.",
    "inputValues": [
      "topicId-number-Topic",
      "forumId-number-Forum",
      "fromModeration-boolean-Topic"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect topicId (mandatory): Unique identifier of the topic to be deleted\n   - Collect forumId (mandatory): Identifier of the forum containing the topic\n   - Collect fromModeration flag (mandatory): Boolean indicating if deletion is initiated from moderation panel\n   - System will use current user context for authorization\n\n2. Data Validation:\n   - Validate topicId:\n      a. Check if topicId is provided and is a positive integer\n      b. Verify topicId exists in the system\n      c. Return error if topic does not exist: \"Topic not found\"\n   - Validate forumId:\n      a. Check if forumId is provided and is a positive integer\n      b. Verify forumId exists in the system\n      c. Return error if forum does not exist: \"Forum not found\"\n   - Validate user permissions:\n      a. Check if current user has permission to delete the topic\n      b. If fromModeration is true, verify user has moderation privileges\n      c. Return error if unauthorized: \"Insufficient permissions to delete topic\"\n   - Validate forum accessibility:\n      a. Check if the forum is accessible to the current user\n      b. Verify if the category containing the forum is accessible\n      c. Return error if inaccessible: \"Access denied to this forum\"\n\n3. Business Rule Processing:\n   - Check topic state:\n      a. Verify if topic is not already in deletion process\n      b. Check if topic is locked and if locked topics can be deleted\n   - Verify dependencies:\n      a. Check if topic has associated posts\n      b. Determine if associated content should be deleted\n      c. Check if topic has associated polls\n   - Prepare notification data:\n      a. Identify users to notify about topic deletion\n      b. Prepare notification content based on deletion context\n   - Verify system cache status:\n      a. Check if topic is cached in recent topics list\n      b. Check if topic is cached in hottest topics list\n\n4. Core Operation Execution:\n   - Begin deletion transaction:\n      a. Remove all user subscriptions for the topic\n      b. Delete all associated notifications\n      c. If fromModeration is true, follow moderation deletion process:\n         i. Archive topic content if required by moderation rules\n         ii. Log moderation action with reason and moderator information\n      d. If fromModeration is false, follow standard deletion process:\n         i. Delete all posts associated with the topic\n         ii. Remove topic from user bookmarks\n         iii. Delete any polls associated with the topic\n      e. Update forum statistics:\n         i. Decrement total topics count if not from moderation\n         ii. Recalculate last post information\n      f. Remove topic record from database\n      g. If any step fails, rollback transaction and log error\n   - Update system caches:\n      a. If not from moderation:\n         i. Reload most recent topics list\n         ii. Reload hottest topics list\n         iii. Clear forum-specific topic cache\n\n5. Response Generation:\n   - If deletion successful:\n      a. Return success status\n      b. Include summary of deleted content (number of posts removed)\n      c. Provide forum information where topic was deleted from\n   - If deletion fails:\n      a. Return error status\n      b. Include specific error message explaining failure reason\n      c. Provide guidance on how to resolve the issue",
    "databaseEntities": [
      "jforum_topics",
      "jforum_posts",
      "jforum_posts_text",
      "jforum_forums",
      "jforum_bookmarks",
      "jforum_polls",
      "jforum_categories"
    ],
    "validationRules": [
      "Topic ID must exist in the system",
      "Forum ID must exist in the system",
      "User must have permission to delete the topic",
      "If fromModeration is true, user must have moderation privileges",
      "Topic must not be in deletion process already",
      "Forum must be accessible to the current user",
      "Category containing the forum must be accessible"
    ],
    "dbSeedingOperations": [],
    "schema": {}
  },
  {
    "featureName": "DeleteMultipleTopics",
    "description": "Deletes multiple topics with moderation flag.",
    "inputValues": [
      "topicIds-object-TopicList",
      "moderationFlag-boolean-ModerationType"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the following inputs:\n     1.1. topicIds (mandatory): List of topic identifiers to be deleted\n     1.2. moderationFlag (mandatory): Boolean flag indicating if deletion is from moderation\n\n2. Data Validation:\n   2.1. Validate topic identifiers:\n      2.1.1. Check if topicIds list is not empty\n      2.1.2. Verify all topic IDs are valid positive integers\n      2.1.3. IF any ID is invalid, THEN generate appropriate error message\n   2.2. Validate moderation flag:\n      2.2.1. Ensure moderationFlag is a valid boolean value\n      2.2.2. IF moderationFlag is invalid, THEN use default value (false)\n\n3. Business Rule Processing:\n   3.1. Check user permissions:\n      3.1.1. Verify current user has permission to delete topics\n      3.1.2. IF moderationFlag is true, THEN verify user has moderation privileges\n      3.1.3. IF permissions are insufficient, THEN abort operation and return error\n   3.2. Verify topic status:\n      3.2.1. For each topic ID, check if topic exists in the system\n      3.2.2. Verify topics are not locked or in special states preventing deletion\n      3.2.3. IF any topic cannot be deleted, THEN collect in a list of failed deletions\n\n4. Core Operation Execution:\n   4.1. Begin deletion transaction:\n      4.1.1. Create a transaction to ensure data integrity during multiple deletions\n   4.2. Process each topic for deletion:\n      4.2.1. For each valid topic ID in the list:\n         a. Retrieve complete topic information\n         b. Remove all topic subscriptions\n         c. Delete all posts associated with the topic\n         d. Delete all attachments linked to the topic's posts\n         e. Remove topic from user bookmarks if present\n         f. Update forum statistics (post count, topic count)\n         g. IF moderationFlag is true, THEN log moderation action\n   4.3. Commit transaction:\n      4.3.1. IF all deletions successful, THEN commit transaction\n      4.3.2. IF any errors occur, THEN rollback transaction\n\n5. Response Generation:\n   5.1. Generate success response:\n      5.1.1. Create summary of deleted topics\n      5.1.2. Include count of successfully deleted topics\n      5.1.3. Include list of any topics that could not be deleted with reasons\n   5.2. Generate notification:\n      5.2.1. IF moderationFlag is true, THEN notify relevant users about moderation action\n      5.2.2. Update activity logs with deletion information\n   5.3. Return response to user:\n      5.3.1. Format response according to system standards\n      5.3.2. Include any next steps or related actions user might want to take",
    "databaseEntities": [
      "jforum_topics",
      "jforum_posts",
      "jforum_posts_text",
      "jforum_forums",
      "jforum_attachments",
      "jforum_bookmarks",
      "jforum_users"
    ],
    "validationRules": [
      "Topic IDs must be valid positive integers",
      "Topic IDs must reference existing topics in the system",
      "User must have permission to delete topics",
      "If moderationFlag is true, user must have moderation privileges",
      "Topics must not be in a state that prevents deletion"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "TopicList": {
        "type": "array",
        "items": {
          "type": "integer",
          "description": "Unique identifier for a topic"
        }
      },
      "ModerationType": {
        "type": "boolean",
        "description": "Flag indicating if deletion is performed as a moderation action"
      }
    }
  },
  {
    "featureName": "DeleteTopicsByForum",
    "description": "Deletes all topics belonging to a specific forum.",
    "inputValues": [
      "forumId-number-Forum"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the forumId (mandatory) to identify the forum whose topics will be deleted\n\n2. Data Validation:\n   - Validate forumId:\n     a. Check if forumId is provided\n     b. Verify forumId is a positive integer\n     c. Generate error message if validation fails: \"Invalid forum identifier provided\"\n   - Verify forum existence:\n     a. Check if a forum with the provided forumId exists in the system\n     b. Generate error message if validation fails: \"Forum not found\"\n\n3. Business Rule Processing:\n   - Check user permissions:\n     a. Verify if the current user has administrative privileges to delete topics\n     b. If user lacks permissions, generate error: \"Insufficient permissions to delete forum topics\"\n   - Check forum state:\n     a. Verify if the forum is in a state that allows topic deletion\n     b. If forum is locked or in special state, generate error: \"Cannot delete topics from this forum due to its current state\"\n\n4. Core Operation Execution:\n   - Retrieve all topics associated with the forum:\n     a. Get a list of all topic IDs belonging to the specified forum\n     b. If no topics exist, skip to response generation with appropriate message\n   - For each topic in the forum:\n     a. Remove all topic subscriptions and watches\n     b. Identify all posts associated with the topic\n     c. Delete all post content and metadata\n     d. Remove any polls associated with the topic\n     e. Delete any topic bookmarks\n     f. Remove topic voting/rating data if applicable\n     g. Delete the topic record itself\n   - Update forum statistics:\n     a. Decrement total topics count for the forum\n     b. Update last post information for the forum\n     c. Update any cached forum data\n   - System cleanup:\n     a. Remove any orphaned data related to the deleted topics\n     b. Update search indexes to remove deleted content\n\n5. Response Generation:\n   - Success response:\n     a. Indicate successful deletion of topics\n     b. Include count of topics deleted\n     c. Provide forum information with updated statistics\n   - Error response:\n     a. Include specific error message explaining the failure\n     b. Provide guidance on resolving the issue\n     c. Include any system error codes for troubleshooting",
    "databaseEntities": [
      "jforum_forums",
      "jforum_topics",
      "jforum_posts",
      "jforum_posts_text",
      "jforum_bookmarks",
      "jforum_privmsgs",
      "jforum_attachments"
    ],
    "validationRules": [
      "Forum ID must be a positive integer",
      "Forum must exist in the system",
      "User must have administrative privileges to delete topics",
      "Forum must be in a state that allows topic deletion"
    ],
    "dbSeedingOperations": [],
    "schema": {}
  },
  {
    "featureName": "UpdateTopic",
    "description": "Updates topic information in the forum system.",
    "inputValues": [
      "topicId-number-Topic",
      "title-string-Topic",
      "type-number-Topic",
      "status-number-Topic",
      "isModerated-boolean-Topic",
      "voteId-number-Topic",
      "lastPostId-number-Post",
      "firstPostId-number-Post"
    ],
    "businessLogic": "1. Input Collection:\n   1.1. Collect the following required inputs:\n       - topicId: Unique identifier for the topic to update (mandatory)\n       - title: New title for the topic (mandatory)\n       - type: Type classification for the topic (mandatory)\n   1.2. Collect the following optional inputs:\n       - status: Current status of the topic (optional)\n       - isModerated: Flag indicating if topic requires moderation (optional)\n       - voteId: Reference to associated poll/vote (optional)\n       - lastPostId: Reference to the most recent post in the topic (optional)\n       - firstPostId: Reference to the initial post in the topic (optional)\n\n2. Data Validation:\n   2.1. Validate topicId:\n       - VERIFY topicId is a positive integer\n       - VERIFY topicId exists in the system\n       - IF topicId is invalid or not found THEN\n           - Generate error message: \"Invalid topic identifier provided\"\n           - Terminate process\n   2.2. Validate title:\n       - VERIFY title is not empty\n       - VERIFY title length is between 1 and 100 characters\n       - IF title validation fails THEN\n           - Generate error message: \"Topic title must be between 1 and 100 characters\"\n           - Terminate process\n   2.3. Validate type:\n       - VERIFY type is within valid range of topic types\n       - IF type is invalid THEN\n           - Generate error message: \"Invalid topic type specified\"\n           - Terminate process\n   2.4. Validate post references if provided:\n       - IF lastPostId is provided THEN\n           - VERIFY lastPostId exists in the system\n           - VERIFY lastPostId is associated with this topic\n       - IF firstPostId is provided THEN\n           - VERIFY firstPostId exists in the system\n           - VERIFY firstPostId is associated with this topic\n       - IF validation fails THEN\n           - Generate error message: \"Invalid post reference provided\"\n           - Terminate process\n   2.5. Validate voteId if provided:\n       - VERIFY voteId exists in the system\n       - IF validation fails THEN\n           - Generate error message: \"Invalid vote reference provided\"\n           - Terminate process\n\n3. Business Rule Processing:\n   3.1. Check user permissions:\n       - VERIFY current user has permission to update the topic\n       - IF user is not the topic creator AND not a moderator THEN\n           - Generate error message: \"Insufficient permissions to update this topic\"\n           - Terminate process\n   3.2. Check forum status:\n       - RETRIEVE forum information associated with the topic\n       - VERIFY the forum is active and not locked\n       - IF forum is locked or inactive THEN\n           - Generate error message: \"Cannot update topic in a locked or inactive forum\"\n           - Terminate process\n   3.3. Check topic status:\n       - IF topic is locked AND user is not a moderator THEN\n           - Generate error message: \"Cannot update a locked topic without moderator privileges\"\n           - Terminate process\n   3.4. Check moderation requirements:\n       - IF isModerated flag is changing THEN\n           - VERIFY user has permission to change moderation settings\n           - IF user lacks permission THEN\n               - Generate error message: \"Insufficient permissions to change moderation settings\"\n               - Terminate process\n\n4. Core Operation Execution:\n   4.1. Retrieve existing topic data:\n       - Load current topic information from database\n       - Store original values for comparison and audit purposes\n   4.2. Update topic information:\n       - Update topic title with new value\n       - Update topic type with new value\n       - IF isModerated is provided THEN\n           - Update moderation flag with new value\n       - IF voteId is provided THEN\n           - Update vote/poll reference with new value\n   4.3. Update post references if provided:\n       - IF lastPostId is provided THEN\n           - Update topic's last post reference\n       - IF firstPostId is provided THEN\n           - Update topic's first post reference\n   4.4. Save changes to database:\n       - Persist all topic changes to database\n       - IF database operation fails THEN\n           - Roll back all changes\n           - Generate error message: \"Failed to update topic information\"\n           - Terminate process\n   4.5. Update related data:\n       - IF post references were updated THEN\n           - Ensure post-topic relationships are consistent\n       - Update search indexes with new topic information\n\n5. Response Generation:\n   5.1. Prepare success response:\n       - Include updated topic identifier\n       - Include confirmation message: \"Topic successfully updated\"\n       - Include timestamp of update\n   5.2. Include next action options:\n       - Option to view the updated topic\n       - Option to return to forum listing\n       - Option to make additional edits\n   5.3. Return success response to user",
    "databaseEntities": [
      "jforum_topics",
      "jforum_forums",
      "jforum_posts",
      "jforum_users"
    ],
    "validationRules": [
      "Topic ID must exist in the system",
      "Topic title must not be empty",
      "Topic title must be between 1 and 100 characters",
      "Topic type must be a valid type value",
      "User must have permission to update the topic",
      "Last post ID must exist in the system if provided",
      "First post ID must exist in the system if provided",
      "Vote ID must exist in the system if provided"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Topic": {
        "id": "number",
        "title": "string",
        "type": "number",
        "isModerated": "boolean",
        "forumId": "number",
        "lastPostId": "number",
        "firstPostId": "number",
        "voteId": "number",
        "totalReplies": "number",
        "totalViews": "number"
      },
      "Forum": {
        "id": "number",
        "name": "string",
        "description": "string",
        "categoryId": "number",
        "totalTopics": "number",
        "totalPosts": "number"
      },
      "Post": {
        "id": "number",
        "topicId": "number",
        "userId": "number",
        "text": "string",
        "creationDate": "date"
      }
    }
  },
  {
    "featureName": "CreateTopic",
    "description": "Creates a new topic in the forum system and returns its ID.",
    "inputValues": [
      "title-string-Topic",
      "content-string-Topic",
      "forumId-number-Forum",
      "userId-number-User",
      "topic-object-Topic"
    ],
    "businessLogic": "1. Input Collection:\n   1.1. Collect the following required inputs:\n       - title (string): The title of the new topic\n       - content (string): The initial post content for the topic\n       - forumId (number): The ID of the forum where the topic will be created\n       - userId (number): The ID of the user creating the topic\n   1.2. System will generate:\n       - creationDate (date): Current system timestamp\n       - status (number): Default status (typically unlocked)\n       - type (number): Default type (typically normal)\n       - viewCount (number): Initialized to 0\n       - replyCount (number): Initialized to 0\n\n2. Data Validation:\n   2.1. Validate topic title:\n       - IF title is empty or null THEN\n           - Return error: \"Topic title cannot be empty\"\n       - IF title length exceeds maximum allowed length THEN\n           - Return error: \"Topic title exceeds maximum allowed length\"\n   2.2. Validate content:\n       - IF content is empty or null THEN\n           - Return error: \"Topic content cannot be empty\"\n       - IF content length exceeds maximum allowed length THEN\n           - Return error: \"Topic content exceeds maximum allowed length\"\n   2.3. Validate forum ID:\n       - IF forumId is invalid or does not exist THEN\n           - Return error: \"Invalid forum selected\"\n   2.4. Validate user ID:\n       - IF userId is invalid or does not exist THEN\n           - Return error: \"Invalid user credentials\"\n\n3. Business Rule Processing:\n   3.1. Check forum permissions:\n       - Verify if the user has permission to create topics in the specified forum\n       - IF user does not have permission THEN\n           - Return error: \"User does not have permission to create topics in this forum\"\n   3.2. Check forum status:\n       - IF forum is locked or inactive THEN\n           - Return error: \"Cannot create topic in a locked or inactive forum\"\n   3.3. Check user status:\n       - IF user account is suspended or inactive THEN\n           - Return error: \"User account is not active\"\n   3.4. Check moderation settings:\n       - Determine if the forum requires topic moderation\n       - IF forum requires moderation THEN\n           - Set topic moderation flag to true\n       - ELSE\n           - Set topic moderation flag to false\n\n4. Core Operation Execution:\n   4.1. Create topic record:\n       - Create a new Topic object with the collected inputs\n       - Set the creation date to current timestamp\n       - Set initial view count to 0\n       - Set initial reply count to 0\n       - Set appropriate status and type flags\n   4.2. Create initial post:\n       - Create a new Post object with the topic content\n       - Associate the post with the new topic\n       - Set the post creation date to current timestamp\n       - Set the post author to the current user\n   4.3. Save topic and post:\n       - Save the topic record to the database\n       - Save the post record to the database\n       - Update the topic with first post ID and last post ID\n   4.4. Update forum statistics:\n       - Increment the total topics count for the forum\n       - Update the forum's last post information\n\n5. Response Generation:\n   5.1. For successful creation:\n       - Return the newly created topic ID\n       - Include basic topic information (title, creation date, forum ID)\n       - Include the ID of the initial post\n   5.2. For creation failure:\n       - Return appropriate error message based on the failure reason\n       - Include guidance on how to correct the issue\n       - Log the failure details for system administrators",
    "databaseEntities": [
      "jforum_topics",
      "jforum_posts",
      "jforum_posts_text",
      "jforum_forums",
      "jforum_users"
    ],
    "validationRules": [
      "Topic title must not be empty",
      "Topic content must not be empty",
      "Forum ID must be valid and exist in the system",
      "User must have permission to create topics in the specified forum",
      "Forum must be active and unlocked",
      "User account must be active",
      "Topic title length must not exceed maximum allowed characters",
      "Topic content length must not exceed maximum allowed characters"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Topic": {
        "id": "number",
        "title": "string",
        "forumId": "number",
        "userId": "number",
        "creationDate": "date",
        "lastPostId": "number",
        "firstPostId": "number",
        "status": "number",
        "type": "number",
        "viewCount": "number",
        "replyCount": "number",
        "moderated": "boolean"
      }
    }
  },
  {
    "featureName": "IncrementTopicViews",
    "description": "Increments the view count for a specific topic.",
    "inputValues": [
      "topicId-number-Topic"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect topicId (mandatory, number)\n   - System will use this identifier to locate the specific topic\n\n2. Data Validation:\n   - Validate topicId:\n     a. Check if topicId is provided\n     b. Verify topicId is a positive integer\n     c. Return error message if validation fails: \"Invalid topic identifier provided\"\n   - Verify topic exists:\n     a. Check if a topic with the provided topicId exists in the system\n     b. Return error message if not found: \"Topic not found\"\n\n3. Business Rule Processing:\n   - Check system state:\n     a. Verify the topic tracking system is operational\n     b. Ensure the topic is not in a locked or deleted state\n     c. If topic is in an invalid state, log the attempt and return appropriate message\n\n4. Core Operation Execution:\n   - Retrieve current view count for the topic\n   - Increment the view count by one\n   - Update the topic record with the new view count\n   - Persist the updated view count to ensure data consistency\n   - If update fails:\n     a. Log the failure with appropriate details\n     b. Attempt rollback if necessary\n     c. Return error message: \"Failed to update topic view count\"\n\n5. Response Generation:\n   - On success:\n     a. Return confirmation that view count was incremented\n     b. Include the new view count in the response\n   - On failure:\n     a. Return appropriate error message\n     b. Include support information if needed",
    "databaseEntities": [
      "jforum_topics"
    ],
    "validationRules": [
      "Topic ID must be a positive integer",
      "Topic must exist in the system",
      "Topic must not be in a deleted state"
    ],
    "dbSeedingOperations": [],
    "schema": {}
  },
  {
    "featureName": "IncrementTopicReplies",
    "description": "Increments the reply count for a specific topic.",
    "inputValues": [
      "topicId-number-Topic"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect topicId (mandatory, number) from the request\n   - System will use this identifier to locate the specific topic\n\n2. Data Validation:\n   - Validate topicId:\n     a. Check if topicId is provided\n     b. Verify topicId is a positive integer\n     c. If validation fails, generate appropriate error message\n\n3. Business Rule Processing:\n   - Verify topic existence:\n     a. Check if topic with provided topicId exists in the system\n     b. If topic not found, generate \"Topic not found\" error\n   - Verify topic status:\n     a. Check if topic is not locked or deleted\n     b. If topic is locked, generate \"Cannot update locked topic\" error\n     c. If topic is deleted, generate \"Cannot update deleted topic\" error\n\n4. Core Operation Execution:\n   - Retrieve current reply count for the topic\n   - Increment the reply count by 1\n   - Update the topic record with new reply count\n   - Update the last modified timestamp for the topic\n   - If any operation fails:\n     a. Revert any partial changes\n     b. Generate appropriate error message\n\n5. Response Generation:\n   - On success:\n     a. Return confirmation message\n     b. Include updated reply count in response\n   - On failure:\n     a. Return error details\n     b. Include error code and description",
    "databaseEntities": [
      "jforum_topics",
      "jforum_posts"
    ],
    "validationRules": [
      "Topic ID must be a positive integer",
      "Topic must exist in the system",
      "Topic must not be locked or deleted"
    ],
    "dbSeedingOperations": [],
    "schema": {}
  },
  {
    "featureName": "DecrementTopicReplies",
    "description": "Decrements the reply count for a specific topic.",
    "inputValues": [
      "topicId-number-Topic"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the topicId (mandatory) from the request\n   - System will use this identifier to locate the specific topic\n\n2. Data Validation:\n   - Validate topicId:\n      a. Check if topicId is provided\n      b. Verify topicId is a positive integer\n      c. Return appropriate error if validation fails\n   - Verify topic existence:\n      a. Check if a topic with the provided topicId exists in the system\n      b. If topic does not exist, return appropriate error message\n\n3. Business Rule Processing:\n   - Check current reply count:\n      a. Retrieve the current reply count for the topic\n      b. Verify the reply count is greater than zero\n      c. If reply count is already zero, return appropriate message indicating no action needed\n   - Check user permissions:\n      a. Verify the current user has permission to modify topic statistics\n      b. If permission is denied, return appropriate error message\n\n4. Core Operation Execution:\n   - Update topic statistics:\n      a. Decrement the total reply count for the topic by one\n      b. Update the last modified timestamp for the topic\n      c. If the topic has no more replies, update the topic status accordingly\n   - Update related forum statistics if necessary:\n      a. Check if forum statistics need updating\n      b. Update forum post count if required\n   - Handle transaction integrity:\n      a. Ensure all updates are performed within a single transaction\n      b. Roll back changes if any part of the operation fails\n\n5. Response Generation:\n   - Success response:\n      a. Return confirmation message that reply count was decremented\n      b. Include the updated reply count in the response\n      c. Include the topic information in the response\n   - Error response:\n      a. Return appropriate error message if operation failed\n      b. Include error details and suggestions for resolution",
    "databaseEntities": [
      "jforum_topics",
      "jforum_forums"
    ],
    "validationRules": [
      "Topic ID must be a positive integer",
      "Topic must exist in the system",
      "Topic must have at least one reply before decrementing",
      "User must have permission to modify topic statistics"
    ],
    "dbSeedingOperations": [],
    "schema": {}
  },
  {
    "featureName": "ManageTopicSubscription",
    "description": "Manages user subscriptions for topic notifications.",
    "inputValues": [
      "topicId-number-Topic",
      "userId-number-User",
      "subscriptionAction-string-Subscription"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the following inputs:\n     a. topicId (mandatory): Unique identifier for the topic\n     b. userId (mandatory): Unique identifier for the user\n     c. subscriptionAction (mandatory): Action to perform ('subscribe', 'unsubscribe', 'checkStatus')\n\n2. Data Validation:\n   - Validate topicId:\n     a. Ensure topicId is provided and is a positive integer\n     b. IF topicId is missing or invalid, THEN return error message \"Valid topic identifier required\"\n   - Validate userId:\n     a. Ensure userId is provided and is a positive integer\n     b. IF userId is missing or invalid, THEN return error message \"Valid user identifier required\"\n   - Validate subscriptionAction:\n     a. Ensure subscriptionAction is one of the allowed values ('subscribe', 'unsubscribe', 'checkStatus')\n     b. IF subscriptionAction is invalid, THEN return error message \"Invalid subscription action requested\"\n\n3. Business Rule Processing:\n   - Verify topic existence:\n     a. Check if topic with given topicId exists in the system\n     b. IF topic does not exist, THEN return error message \"Topic not found\"\n   - Verify user existence:\n     a. Check if user with given userId exists in the system\n     b. IF user does not exist, THEN return error message \"User not found\"\n   - Verify user permissions:\n     a. Check if user has permission to subscribe to topics\n     b. IF user lacks permission, THEN return error message \"Insufficient permissions to manage subscriptions\"\n\n4. Core Operation Execution:\n   - Process based on subscriptionAction:\n     a. IF subscriptionAction is 'subscribe':\n        i. Check if user is already subscribed to the topic\n        ii. IF already subscribed, THEN return message \"User is already subscribed to this topic\"\n        iii. ELSE create a new subscription record linking the user to the topic\n        iv. Record subscription timestamp\n     b. IF subscriptionAction is 'unsubscribe':\n        i. Check if user is currently subscribed to the topic\n        ii. IF not subscribed, THEN return message \"User is not subscribed to this topic\"\n        iii. ELSE remove the subscription record for the user and topic\n     c. IF subscriptionAction is 'checkStatus':\n        i. Retrieve subscription status for the user and topic\n\n5. Response Generation:\n   - For 'subscribe' action:\n     a. On success: Return confirmation message \"Successfully subscribed to topic\"\n     b. On failure: Return appropriate error message with reason\n   - For 'unsubscribe' action:\n     a. On success: Return confirmation message \"Successfully unsubscribed from topic\"\n     b. On failure: Return appropriate error message with reason\n   - For 'checkStatus' action:\n     a. Return subscription status (true/false) indicating if user is subscribed\n   - Include topic details in response:\n     a. Topic title\n     b. Forum information\n     c. Subscription date (for status checks and successful subscriptions)",
    "databaseEntities": [
      "jforum_users",
      "jforum_topics",
      "jforum_topic_subscriptions"
    ],
    "validationRules": [
      "Topic ID must be a positive integer",
      "User ID must be a positive integer",
      "Subscription action must be one of: 'subscribe', 'unsubscribe', 'checkStatus'",
      "Topic must exist in the system",
      "User must exist in the system",
      "User must have permission to manage subscriptions"
    ],
    "dbSeedingOperations": [
      "Create jforum_topic_subscriptions table if not exists with columns: subscription_id, topic_id, user_id, subscription_date"
    ],
    "schema": {
      "Subscription": {
        "type": "object",
        "properties": {
          "topicId": {
            "type": "number",
            "description": "Unique identifier for the topic"
          },
          "userId": {
            "type": "number",
            "description": "Unique identifier for the user"
          },
          "subscribed": {
            "type": "boolean",
            "description": "Subscription status"
          },
          "subscriptionDate": {
            "type": "date",
            "description": "Date when subscription was created"
          }
        },
        "required": [
          "topicId",
          "userId",
          "subscribed"
        ]
      }
    }
  },
  {
    "featureName": "CheckUserSubscription",
    "description": "Checks if a user is subscribed to a specific topic.",
    "inputValues": [
      "topicId-number-Topic",
      "userId-number-User"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect topicId (mandatory, number): The unique identifier of the topic to check subscription status\n   - Collect userId (mandatory, number): The unique identifier of the user to check subscription status\n\n2. Data Validation:\n   - Validate topicId:\n      a. Verify topicId is provided and not null\n      b. Verify topicId is a positive integer\n      c. If validation fails, generate error message: \"Invalid topic identifier provided\"\n   - Validate userId:\n      a. Verify userId is provided and not null\n      b. Verify userId is a positive integer\n      c. If validation fails, generate error message: \"Invalid user identifier provided\"\n\n3. Business Rule Processing:\n   - Verify topic existence:\n      a. Check if the topic with the provided topicId exists in the system\n      b. If topic does not exist, generate error message: \"Topic not found\"\n   - Verify user existence:\n      a. Check if the user with the provided userId exists in the system\n      b. If user does not exist, generate error message: \"User not found\"\n   - Verify system state:\n      a. Ensure the subscription tracking system is operational\n      b. If system is not operational, generate error message: \"Subscription system unavailable\"\n\n4. Core Operation Execution:\n   - Check subscription status:\n      a. Query the subscription records for the specified topic and user\n      b. Determine if a subscription record exists for the given topicId and userId combination\n      c. If record exists, set subscriptionStatus to true\n      d. If record does not exist, set subscriptionStatus to false\n   - Record access information:\n      a. Log the subscription check operation for auditing purposes\n      b. Include timestamp, user information, and result of the check\n\n5. Response Generation:\n   - Success response:\n      a. Return the subscription status (true/false)\n      b. Include topic information (title, creation date)\n      c. Include subscription details if subscribed (subscription date)\n   - Error response:\n      a. Return appropriate error message based on the validation or processing failure\n      b. Include guidance on how to resolve the issue\n      c. Provide support contact information if needed",
    "databaseEntities": [
      "jforum_topics",
      "jforum_users",
      "jforum_topics_watch"
    ],
    "validationRules": [
      "Topic ID must be a positive integer",
      "User ID must be a positive integer",
      "Topic must exist in the system",
      "User must exist in the system",
      "User must not be the anonymous user",
      "User must not be the topic poster"
    ],
    "dbSeedingOperations": [],
    "schema": {}
  },
  {
    "featureName": "RemoveTopicSubscription",
    "description": "Removes a user's subscription from a topic.",
    "inputValues": [
      "topicId-number-Topic",
      "userId-number-User"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the following required inputs:\n     a) topicId (mandatory): The unique identifier of the topic\n     b) userId (mandatory): The unique identifier of the user\n   - No optional fields or default values are required\n\n2. Data Validation:\n   - Validate topicId:\n     a) Verify topicId is a positive integer\n     b) Verify topicId is not null\n     c) Return error message if validation fails: \"Invalid topic identifier provided\"\n   - Validate userId:\n     a) Verify userId is a positive integer\n     b) Verify userId is not null\n     c) Return error message if validation fails: \"Invalid user identifier provided\"\n\n3. Business Rule Processing:\n   - Verify topic existence:\n     a) Check if topic with topicId exists in the system\n     b) IF topic does not exist, THEN return error: \"Topic not found\"\n   - Verify user existence:\n     a) Check if user with userId exists in the system\n     b) IF user does not exist, THEN return error: \"User not found\"\n   - Verify subscription existence:\n     a) Check if the user is currently subscribed to the topic\n     b) IF user is not subscribed, THEN return message: \"User is not subscribed to this topic\"\n\n4. Core Operation Execution:\n   - Remove subscription record:\n     a) Locate the subscription record that links the user to the topic\n     b) Delete the subscription record from the system\n     c) IF deletion fails, THEN:\n        i. Log the error details\n        ii. Return error: \"Failed to remove subscription\"\n   - Update subscription counters (if applicable):\n     a) Decrement the subscription count for the topic\n     b) Update any related subscription statistics\n\n5. Response Generation:\n   - Success response:\n     a) Generate confirmation message: \"Subscription successfully removed\"\n     b) Include topic information in the response\n   - Error response:\n     a) Include specific error message based on the failure point\n     b) Provide guidance on how to resolve the issue if applicable",
    "databaseEntities": [
      "jforum_topics",
      "jforum_users"
    ],
    "validationRules": [
      "Topic ID must be a valid positive integer",
      "User ID must be a valid positive integer",
      "Topic must exist in the system",
      "User must exist in the system",
      "User must be currently subscribed to the topic"
    ],
    "dbSeedingOperations": [],
    "schema": {}
  },
  {
    "featureName": "RemoveAllTopicSubscriptions",
    "description": "Removes all subscriptions for a specific topic.",
    "inputValues": [
      "topicId-number-Topic"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the topic ID (topicId) from the user input\n   - Validate that topicId is a mandatory field\n\n2. Data Validation:\n   - Validate that topicId is a positive integer\n   - Verify that topicId is not null or empty\n   - Check if the provided topicId exists in the system\n   - IF topicId is invalid or does not exist THEN\n     - Generate appropriate error message\n     - Terminate the operation\n\n3. Business Rule Processing:\n   - Check if the topic exists in the database\n   - Verify if the user has appropriate permissions to remove subscriptions\n   - IF topic does not exist THEN\n     - Generate a \"Topic not found\" error message\n     - Terminate the operation\n   - IF user does not have appropriate permissions THEN\n     - Generate a \"Permission denied\" error message\n     - Terminate the operation\n\n4. Core Operation Execution:\n   - Retrieve all subscription records associated with the specified topicId\n   - IF no subscriptions exist for the topic THEN\n     - Skip deletion process\n     - Proceed to response generation with appropriate message\n   - ELSE\n     - Begin transaction for data consistency\n     - Delete all subscription records for the specified topic\n     - Commit the transaction\n     - IF any error occurs during deletion THEN\n       - Rollback the transaction\n       - Log the error details\n       - Generate appropriate error message\n\n5. Response Generation:\n   - IF operation is successful THEN\n     - Generate success response indicating all subscriptions were removed\n     - Include the topic ID in the response\n     - Include the count of subscriptions that were removed (if available)\n   - ELSE\n     - Generate error response with appropriate error message\n     - Include error details for troubleshooting",
    "databaseEntities": [
      "jforum_topics",
      "jforum_users"
    ],
    "validationRules": [
      "Topic ID must be a positive integer",
      "Topic must exist in the system",
      "User must have appropriate permissions to remove subscriptions"
    ],
    "dbSeedingOperations": [],
    "schema": {}
  },
  {
    "featureName": "UpdateTopicReadStatus",
    "description": "Updates the read status of a topic for a specific user.",
    "inputValues": [
      "topicId-number-Topic",
      "userId-number-User",
      "readStatus-boolean-Topic"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the following required inputs:\n     a. topicId (number): The unique identifier of the topic to update\n     b. userId (number): The unique identifier of the user whose read status is being updated\n     c. readStatus (boolean): The new read status to set (true for read, false for unread)\n\n2. Data Validation:\n   - Validate topicId:\n     a. Verify topicId is a positive integer\n     b. IF topicId is missing or invalid, THEN generate an error message indicating invalid topic identifier\n   - Validate userId:\n     a. Verify userId is a positive integer\n     b. IF userId is missing or invalid, THEN generate an error message indicating invalid user identifier\n   - Validate readStatus:\n     a. Verify readStatus is a boolean value\n     b. IF readStatus is not a boolean, THEN generate an error message indicating invalid read status format\n\n3. Business Rule Processing:\n   - Verify topic existence:\n     a. Check if the topic with the provided topicId exists in the system\n     b. IF topic does not exist, THEN generate an error message indicating topic not found\n   - Verify user existence:\n     a. Check if the user with the provided userId exists in the system\n     b. IF user does not exist, THEN generate an error message indicating user not found\n   - Verify user access permissions:\n     a. Check if the user has permission to access the topic\n     b. IF user does not have access permissions, THEN generate an error message indicating insufficient permissions\n\n4. Core Operation Execution:\n   - Check for existing read status record:\n     a. Query the database to find if a read status record already exists for this topic-user combination\n     b. IF record exists, THEN update the existing record with the new read status\n     c. IF record does not exist, THEN create a new read status record with the provided information\n   - Update the read status:\n     a. Set the read status of the topic for the user to the provided readStatus value\n     b. Record the timestamp of when the status was updated\n   - Update related statistics if necessary:\n     a. IF changing from unread to read, THEN update user's unread topic count\n     b. Update any cached information related to user's topic read status\n\n5. Response Generation:\n   - For successful update:\n     a. Generate a success response indicating the topic read status was updated successfully\n     b. Include the updated topic information in the response\n     c. Include the timestamp of when the update occurred\n   - For failed update:\n     a. Generate an appropriate error response based on the failure reason\n     b. Include guidance on how to resolve the issue\n     c. Provide support information if necessary",
    "databaseEntities": [
      "jforum_topics",
      "jforum_users",
      "jforum_topic_read_status"
    ],
    "validationRules": [
      "Topic ID must be a positive integer",
      "User ID must be a positive integer",
      "Read status must be a boolean value",
      "Topic must exist in the system",
      "User must exist in the system",
      "User must have permission to access the topic"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Topic": {
        "id": "number",
        "title": "string",
        "forumId": "number",
        "lastPostId": "number",
        "firstPostId": "number",
        "status": "number",
        "totalViews": "number",
        "totalReplies": "number"
      },
      "User": {
        "id": "number",
        "username": "string",
        "email": "string"
      },
      "TopicReadStatus": {
        "topicId": "number",
        "userId": "number",
        "readStatus": "boolean",
        "lastUpdated": "date"
      }
    }
  },
  {
    "featureName": "LockUnlockTopics",
    "description": "Locks or unlocks topics to prevent or allow new replies.",
    "inputValues": [
      "topicIds-object-TopicIds",
      "status-number-LockStatus",
      "logDescription-string-LogDescription"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the following inputs:\n     a. topicIds (mandatory): Array of topic identifiers to be locked or unlocked\n     b. status (mandatory): Lock status value (locked or unlocked)\n     c. userId (system-generated): Identifier of the user performing the action\n     d. logDescription (optional): Description for the moderation log entry\n\n2. Data Validation:\n   - Validate topicIds:\n     a. Check if topicIds array is not empty\n     b. Verify each topicId is a valid positive integer\n     c. Return error if any topicId is invalid\n   - Validate status value:\n     a. Ensure status is one of the predefined values (locked or unlocked)\n     b. Return error if status value is invalid\n   - Validate user permissions:\n     a. Check if the current user has permission to lock/unlock topics\n     b. Verify if user has the specific lock/unlock permission\n     c. Return error if user lacks required permissions\n\n3. Business Rule Processing:\n   - Check topic existence:\n     a. Verify all specified topics exist in the system\n     b. Return error if any topic does not exist\n   - Check forum permissions:\n     a. Verify user has moderation rights for the forums containing these topics\n     b. Return error if user lacks permission for any of the forums\n   - Check current topic states:\n     a. Determine if any topics are already in the requested state\n     b. Skip processing for topics already in the target state\n   - Prepare moderation log:\n     a. Create log entry with user information\n     b. Include description of the action\n     c. Record original state information if needed\n\n4. Core Operation Execution:\n   - Update topic status:\n     a. Set the status field for all specified topics to the new value\n     b. Record the user who performed the action\n     c. Record the timestamp of the action\n   - Create moderation log entries:\n     a. For each topic being modified, create a log entry\n     b. Include topic ID, user ID, and action description\n     c. Store the log entries in the system\n   - Update related data:\n     a. Clear any cached topic information\n     b. Update forum statistics if necessary\n     c. Refresh topic repository data\n   - IF operation fails:\n     a. Revert any partial changes\n     b. Log the failure details\n     c. Return appropriate error message\n\n5. Response Generation:\n   - For successful operation:\n     a. Return success status\n     b. Include list of topics that were successfully updated\n     c. Redirect user to the appropriate page if a return URL was provided\n   - For partial success:\n     a. Return partial success status\n     b. Include list of topics successfully updated\n     c. Include list of topics that failed to update with reasons\n   - For failure:\n     a. Return failure status\n     b. Display access denied message\n     c. Include specific error message",
    "databaseEntities": [
      "jforum_topics",
      "jforum_forums",
      "jforum_users",
      "jforum_groups",
      "jforum_user_groups",
      "jforum_moderator_groups",
      "jforum_moderation_log"
    ],
    "validationRules": [
      "Topic IDs must be valid positive integers",
      "Status must be either locked or unlocked value",
      "User must have permission to lock/unlock topics",
      "All specified topics must exist in the system",
      "User must have moderation rights for the forums containing the topics",
      "User must have the PERM_MODERATION_TOPIC_LOCK_UNLOCK permission"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "TopicIds": {
        "type": "array",
        "items": {
          "type": "integer",
          "description": "Unique identifier for a topic"
        }
      },
      "LockStatus": {
        "type": "integer",
        "description": "Status value indicating whether topics should be locked or unlocked"
      },
      "LogDescription": {
        "type": "string",
        "description": "Description text for the moderation log entry"
      }
    }
  },
  {
    "featureName": "SelectRecentTopics",
    "description": "Retrieves the most recent topics with a specified limit.",
    "inputValues": [
      "limit-number-Topic"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the following inputs:\n     - limit (number, mandatory): The maximum number of recent topics to retrieve\n\n2. Data Validation:\n   - Validate the limit parameter:\n     - IF limit is null or undefined THEN\n       - Return error: \"Limit parameter is required\"\n     - IF limit is not a positive integer THEN\n       - Return error: \"Limit must be a positive integer\"\n     - IF limit exceeds system maximum allowed value THEN\n       - Set limit to system maximum allowed value\n\n3. Business Rule Processing:\n   - Check system state:\n     - IF system is in maintenance mode THEN\n       - Return appropriate maintenance message\n     - IF user does not have permission to view topics THEN\n       - Return permission denied message\n   - Determine topic visibility based on user permissions:\n     - IF user has restricted access THEN\n       - Prepare to filter topics based on user's allowed forums\n   - Check database connection availability:\n     - IF database connection cannot be established THEN\n       - Log connection error\n       - Return system unavailable message\n\n4. Core Operation Execution:\n   - Retrieve recent topics:\n     - Sort all available topics by creation date in descending order\n     - Apply any required visibility filters based on user permissions\n     - Select the top N topics where N equals the specified limit\n     - For each topic, include:\n       - Topic ID\n       - Topic title\n       - Creation date\n       - Last post date\n       - Forum ID the topic belongs to\n       - Creator user ID\n       - Last post user ID\n       - Total replies\n       - Total views\n       - Status information (locked, sticky, etc.)\n       - Attachment status (has attachments or not)\n   - Retrieve additional user information:\n     - For each topic, get information about:\n       - The user who created the topic (username)\n       - The user who made the last post (username)\n   - Format dates according to system date format settings\n   - IF no topics are found THEN\n     - Prepare empty result set\n   - IF an error occurs during data retrieval THEN\n     - Log the error details\n     - Return appropriate error message\n\n5. Response Generation:\n   - Format the retrieved topics into a structured collection\n   - Include metadata such as:\n     - Total number of topics returned\n     - Whether the result set was limited by permissions\n   - Return the formatted collection of recent topics\n   - IF an error occurred during processing THEN\n     - Generate appropriate error message\n     - Include error details and possible resolution steps",
    "databaseEntities": [
      "jforum_topics",
      "jforum_forums",
      "jforum_users",
      "jforum_posts"
    ],
    "validationRules": [
      "Limit parameter must be a positive integer",
      "User must have permission to view topics",
      "System must not be in maintenance mode",
      "Database connection must be available"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Topic": {
        "type": "object",
        "properties": {
          "id": {
            "type": "number",
            "description": "Unique identifier for the topic"
          },
          "title": {
            "type": "string",
            "description": "Title of the topic"
          },
          "creationDate": {
            "type": "date",
            "description": "Date when the topic was created"
          },
          "lastPostDate": {
            "type": "date",
            "description": "Date of the last post in the topic"
          },
          "forumId": {
            "type": "number",
            "description": "ID of the forum the topic belongs to"
          },
          "postedBy": {
            "type": "object",
            "description": "User who created the topic",
            "properties": {
              "id": {
                "type": "number",
                "description": "ID of the user"
              },
              "username": {
                "type": "string",
                "description": "Username of the user"
              }
            }
          },
          "lastPostBy": {
            "type": "object",
            "description": "User who made the last post",
            "properties": {
              "id": {
                "type": "number",
                "description": "ID of the user"
              },
              "username": {
                "type": "string",
                "description": "Username of the user"
              }
            }
          },
          "totalReplies": {
            "type": "number",
            "description": "Total number of replies in the topic"
          },
          "totalViews": {
            "type": "number",
            "description": "Total number of times the topic was viewed"
          },
          "status": {
            "type": "number",
            "description": "Status of the topic (locked, sticky, etc.)"
          },
          "hasAttach": {
            "type": "boolean",
            "description": "Whether the topic has attachments"
          },
          "firstPostTime": {
            "type": "string",
            "description": "Formatted time of the first post"
          },
          "lastPostTime": {
            "type": "string",
            "description": "Formatted time of the last post"
          }
        }
      }
    }
  },
  {
    "featureName": "SelectHottestTopics",
    "description": "Retrieves the most active/popular topics with a specified limit.",
    "inputValues": [
      "limit-number-Topic"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the following input:\n     - limit (number): The maximum number of topics to retrieve\n     - System will determine if limit is provided, otherwise use default value\n\n2. Data Validation:\n   - Validate the limit parameter:\n     - IF limit is provided:\n       - Verify limit is a positive integer\n       - IF limit is negative or zero:\n         - Set limit to default system value\n       - IF limit exceeds maximum allowed value:\n         - Cap limit to system-defined maximum value\n     - IF limit is not provided:\n       - Set limit to default system value\n\n3. Business Rule Processing:\n   - Determine topic hotness criteria:\n     - System checks configuration for hotness definition parameters\n     - Apply configured weighting factors for:\n       - Number of replies\n       - View count\n       - Recency of activity\n       - User engagement metrics\n   - Apply any forum-specific filtering rules:\n     - Exclude topics from restricted forums if user lacks permission\n     - Exclude topics marked as private or hidden\n     - Apply any category-level filtering rules\n\n4. Core Operation Execution:\n   - Calculate hotness score for eligible topics:\n     - Retrieve all active topics from database\n     - Apply hotness calculation formula to each topic\n     - Sort topics by hotness score in descending order\n   - Apply the limit parameter:\n     - Select top N topics based on the validated limit value\n   - Prepare topic data for response:\n     - For each selected topic:\n       - Include topic identifier\n       - Include topic title\n       - Include topic statistics (replies, views)\n       - Include last post information\n       - Include forum association\n       - Include topic starter information\n     - For each topic, collect additional user information:\n       - Retrieve user details for topic creator\n       - Retrieve user details for last poster\n       - Format timestamps according to system date format\n\n5. Response Generation:\n   - Format the list of hottest topics:\n     - Create a structured collection of topic objects\n     - Include total count of returned topics\n     - Include timestamp of when the list was generated\n   - Handle empty results case:\n     - IF no topics match the criteria:\n       - Return empty list with appropriate metadata\n       - Include suggestion for broadening search criteria\n   - Return the final response:\n     - Ordered list of hottest topics\n     - Response metadata",
    "databaseEntities": [
      "jforum_topics",
      "jforum_posts",
      "jforum_forums",
      "jforum_users"
    ],
    "validationRules": [
      "Limit must be a positive integer",
      "Limit cannot exceed system-defined maximum value",
      "User must have permission to view the returned topics",
      "Only topics from public forums should be included",
      "Topics must not be deleted or in moderation queue"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Topic": {
        "type": "object",
        "properties": {
          "id": {
            "type": "number",
            "description": "Unique identifier for the topic"
          },
          "title": {
            "type": "string",
            "description": "Title of the topic"
          },
          "forumId": {
            "type": "number",
            "description": "ID of the forum this topic belongs to"
          },
          "totalReplies": {
            "type": "number",
            "description": "Number of replies in the topic"
          },
          "totalViews": {
            "type": "number",
            "description": "Number of times the topic was viewed"
          },
          "lastPostId": {
            "type": "number",
            "description": "ID of the last post in the topic"
          },
          "lastPostDate": {
            "type": "date",
            "description": "Date and time of the last post"
          },
          "starterId": {
            "type": "number",
            "description": "ID of the user who created the topic"
          },
          "hotnessScore": {
            "type": "number",
            "description": "Calculated score determining topic popularity"
          },
          "postedBy": {
            "type": "object",
            "description": "Information about the user who created the topic",
            "properties": {
              "id": {
                "type": "number",
                "description": "User ID of the topic creator"
              },
              "username": {
                "type": "string",
                "description": "Username of the topic creator"
              }
            }
          },
          "lastPostBy": {
            "type": "object",
            "description": "Information about the user who made the last post",
            "properties": {
              "id": {
                "type": "number",
                "description": "User ID of the last poster"
              },
              "username": {
                "type": "string",
                "description": "Username of the last poster"
              }
            }
          },
          "hasAttachments": {
            "type": "boolean",
            "description": "Indicates if the topic has file attachments"
          },
          "firstPostTime": {
            "type": "string",
            "description": "Formatted date/time when the topic was created"
          },
          "lastPostTime": {
            "type": "string",
            "description": "Formatted date/time of the last post"
          }
        }
      }
    }
  },
  {
    "featureName": "SetTopicModerationStatus",
    "description": "Sets moderation status for topics in a forum or for a specific topic.",
    "inputValues": [
      "topicId-number-Topic",
      "forumId-number-Forum",
      "moderationStatus-boolean-Topic",
      "categoryId-number-Category"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the following inputs:\n     a. topicId (number, optional): The specific topic ID to update\n     b. forumId (number, optional): The forum ID to update all topics within\n     c. categoryId (number, optional): The category ID to update all forums and topics within\n     d. moderationStatus (boolean, mandatory): The new moderation status to set\n   - Note: Exactly one of topicId, forumId, or categoryId must be provided\n\n2. Data Validation:\n   - Validate input parameters:\n     a. IF topicId is provided:\n        i. Verify topicId is a positive integer\n        ii. Verify topicId exists in the system\n     b. IF forumId is provided:\n        i. Verify forumId is a positive integer\n        ii. Verify forumId exists in the system\n     c. IF categoryId is provided:\n        i. Verify categoryId is a positive integer\n        ii. Verify categoryId exists in the system\n     d. Verify moderationStatus is a valid boolean value\n     e. Verify that exactly one of topicId, forumId, or categoryId is provided\n   - IF any validation fails:\n     a. Generate appropriate error message\n     b. Abort the operation\n\n3. Business Rule Processing:\n   - Check user permissions:\n     a. Verify current user has moderation privileges for the specified topic, forum, or category\n     b. IF user lacks required permissions:\n        i. Generate \"Insufficient permissions\" error message\n        ii. Abort the operation\n   - Check system state:\n     a. Verify the forum or category is not locked or disabled\n     b. IF forum or category is locked or disabled:\n        i. Generate appropriate error message\n        ii. Abort the operation\n\n4. Core Operation Execution:\n   - Determine operation scope:\n     a. IF topicId is provided:\n        i. Retrieve the specific topic\n        ii. Update moderation status for the single topic\n        iii. Record the change in the moderation log\n     b. IF forumId is provided:\n        i. Retrieve all topics belonging to the specified forum\n        ii. Update moderation status for all retrieved topics\n        iii. Record the bulk change in the moderation log\n        iv. Update the forum's moderation status\n     c. IF categoryId is provided:\n        i. Retrieve the category and all its forums\n        ii. For each forum in the category:\n            1. Update the forum's moderation status\n            2. Update all topics within the forum to match the new moderation status\n        iii. Record the bulk change in the moderation log\n   - Apply status change:\n     a. Set the moderation flag to the provided moderationStatus value\n     b. Update the last modified timestamp\n     c. Update the modifier user information\n   - IF any error occurs during update:\n     a. Rollback all changes\n     b. Generate appropriate error message\n     c. Abort the operation\n\n5. Response Generation:\n   - Generate success response:\n     a. IF single topic was updated:\n        i. Include confirmation message with topic details\n        ii. Include new moderation status\n     b. IF multiple topics were updated via forum:\n        i. Include confirmation message with forum details\n        ii. Include count of topics updated\n        iii. Include new moderation status\n     c. IF multiple forums and topics were updated via category:\n        i. Include confirmation message with category details\n        ii. Include count of forums updated\n        iii. Include count of topics updated\n        iv. Include new moderation status\n   - Include any relevant next steps or related actions\n   - Return success response to the user",
    "databaseEntities": [
      "jforum_topics",
      "jforum_forums",
      "jforum_users",
      "jforum_posts",
      "jforum_categories"
    ],
    "validationRules": [
      "Exactly one of topicId, forumId, or categoryId must be provided",
      "TopicId must be a positive integer if provided",
      "ForumId must be a positive integer if provided",
      "CategoryId must be a positive integer if provided",
      "ModerationStatus must be a boolean value",
      "User must have moderation privileges for the specified topic, forum, or category",
      "The specified topic must exist if topicId is provided",
      "The specified forum must exist if forumId is provided",
      "The specified category must exist if categoryId is provided",
      "The forum or category must not be locked or disabled"
    ],
    "dbSeedingOperations": [],
    "schema": {}
  },
  {
    "featureName": "GetTopicPosters",
    "description": "Retrieves all unique users who posted in a specific topic.",
    "inputValues": [
      "topicId-number-Topic"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect topicId (mandatory) - a unique identifier for the topic\n\n2. Data Validation:\n   - Validate topicId:\n     a. Check if topicId is provided\n     b. Verify topicId is a positive integer\n     c. IF validation fails, THEN generate appropriate error message\n\n3. Business Rule Processing:\n   - Verify topic existence:\n     a. Check if topic with provided topicId exists in the system\n     b. IF topic does not exist, THEN return error indicating invalid topic\n   - Verify user access rights:\n     a. Check if current user has permission to view the topic\n     b. IF user lacks permission, THEN return access denied error\n\n4. Core Operation Execution:\n   - Retrieve all posts associated with the specified topic\n   - Extract unique user information from these posts:\n     a. Identify all distinct users who have posted in the topic\n     b. Remove duplicate user entries\n     c. For each unique user, collect comprehensive user information:\n        i. User identifier\n        ii. Username\n        iii. User registration date\n        iv. User karma status\n        v. Avatar information and settings\n        vi. Total post count across the system\n        vii. Location information\n        viii. Contact details (email, messaging handles)\n        ix. Signature settings and content\n        x. Website information\n        xi. Rank information\n   - Organize user information in a structured format\n   - Associate each user with their posting activity in the topic\n\n5. Response Generation:\n   - Success response:\n     a. Return collection of unique users who posted in the topic\n     b. Include comprehensive user profile details for each poster\n     c. Include user preferences and settings relevant for display\n     d. Structure data as a map with user IDs as keys\n   - Error response:\n     a. Return appropriate error message if topic doesn't exist\n     b. Return access denied message if user lacks permission\n     c. Return system error message if data retrieval fails\n     d. Include specific error codes for different failure scenarios",
    "databaseEntities": [
      "jforum_users",
      "jforum_topics",
      "jforum_posts",
      "jforum_karma"
    ],
    "validationRules": [
      "Topic ID must be a positive integer",
      "Topic must exist in the system",
      "User must have permission to view the topic"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "User": {
        "type": "object",
        "properties": {
          "id": {
            "type": "number",
            "description": "Unique identifier for the user"
          },
          "username": {
            "type": "string",
            "description": "User's display name"
          },
          "registrationDate": {
            "type": "date",
            "description": "Date when user registered"
          },
          "karma": {
            "type": "object",
            "description": "User's karma status information"
          },
          "avatar": {
            "type": "string",
            "description": "User's avatar image path"
          },
          "avatarEnabled": {
            "type": "boolean",
            "description": "Whether user has enabled avatar display"
          },
          "totalPosts": {
            "type": "number",
            "description": "Total number of posts by this user across the system"
          },
          "from": {
            "type": "string",
            "description": "User's location information"
          },
          "email": {
            "type": "string",
            "description": "User's email address"
          },
          "rankId": {
            "type": "number",
            "description": "User's rank identifier"
          },
          "viewEmailEnabled": {
            "type": "boolean",
            "description": "Whether user allows others to view their email"
          },
          "contactInfo": {
            "type": "object",
            "description": "User's contact information including messaging handles",
            "properties": {
              "icq": {
                "type": "string"
              },
              "msnm": {
                "type": "string"
              },
              "yim": {
                "type": "string"
              },
              "aim": {
                "type": "string"
              },
              "website": {
                "type": "string"
              }
            }
          },
          "signature": {
            "type": "string",
            "description": "User's signature content"
          },
          "attachSignatureEnabled": {
            "type": "boolean",
            "description": "Whether user has enabled signature attachment to posts"
          }
        }
      }
    }
  },
  {
    "featureName": "FindTopicsByDateRange",
    "description": "Searches for topics within a specified date range.",
    "inputValues": [
      "fromDate-date-Topic",
      "toDate-date-Topic",
      "startFrom-number-SearchArgs",
      "fetchCount-number-SearchArgs"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect fromDate (mandatory): The beginning of the date range to search for topics\n   - Collect toDate (mandatory): The end of the date range to search for topics\n   - Collect startFrom (optional): The starting index for pagination (default: 0)\n   - Collect fetchCount (optional): Maximum number of results to return per page (default: 10)\n\n2. Data Validation:\n   - Validate fromDate:\n     - Must be a valid date format\n     - Cannot be null or empty\n     - Error message if invalid: \"From date must be a valid date format\"\n   - Validate toDate:\n     - Must be a valid date format\n     - Cannot be null or empty\n     - Must be equal to or after fromDate\n     - Error message if invalid: \"To date must be a valid date format and must not be before from date\"\n   - Validate startFrom:\n     - Must be a non-negative integer\n     - Default to 0 if not provided\n     - Error message if invalid: \"Start index must be a non-negative number\"\n   - Validate fetchCount:\n     - Must be a positive integer\n     - Default to system-defined value if not provided\n     - Cannot exceed maximum allowed fetch limit\n     - Error message if invalid: \"Fetch count must be a positive number not exceeding system limits\"\n\n3. Business Rule Processing:\n   - Check user permissions:\n     - Verify current user has permission to search topics\n     - Verify current user has access to forums containing the topics\n   - Apply system constraints:\n     - Check if date range exceeds maximum allowed search period\n     - IF date range > maximum allowed period THEN\n       - Adjust date range to maximum allowed period\n       - Add warning message to response\n     - Check if system is under high load:\n       - IF system load > threshold THEN\n         - Apply more restrictive limits to search parameters\n         - Add notification to response\n\n4. Core Operation Execution:\n   - Prepare search parameters:\n     - Format dates to system standard format\n     - Prepare query parameters including date range\n   - Execute search operation:\n     - Search for topics where creation date is between fromDate and toDate\n     - Apply pagination using startFrom and fetchCount parameters\n   - Process search results:\n     - Retrieve topic IDs matching the date range criteria\n     - Count total matches before pagination\n     - Apply pagination to limit results based on startFrom and fetchCount\n     - Load complete topic information for the paginated results\n     - IF no results found THEN\n       - Prepare empty result set with appropriate message\n\n5. Response Generation:\n   - Prepare success response:\n     - Include list of matching topics with relevant metadata\n     - Include pagination information (total results, current page)\n     - Include any warnings about adjusted search parameters\n   - For each topic in results, include:\n     - Topic identifier\n     - Topic title\n     - Creation date\n     - Last update date\n     - Author information\n     - Reply count\n     - View count\n     - Forum information\n   - Add search metadata:\n     - Actual search parameters used\n     - Total count of matching records\n     - Current page information",
    "databaseEntities": [
      "jforum_topics",
      "jforum_forums",
      "jforum_posts",
      "jforum_users"
    ],
    "validationRules": [
      "From date must be a valid date format",
      "To date must be a valid date format",
      "To date must not be before from date",
      "Start index must be a non-negative number",
      "Fetch count must be a positive number",
      "Date range must not exceed maximum allowed search period",
      "User must have permission to search topics"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "SearchArgs": {
        "type": "object",
        "properties": {
          "fromDate": {
            "type": "date",
            "description": "Beginning of the date range to search for topics"
          },
          "toDate": {
            "type": "date",
            "description": "End of the date range to search for topics"
          },
          "startFrom": {
            "type": "number",
            "description": "Starting index for pagination"
          },
          "fetchCount": {
            "type": "number",
            "description": "Maximum number of results to return per page"
          }
        },
        "required": [
          "fromDate",
          "toDate"
        ]
      },
      "SearchResult": {
        "type": "object",
        "properties": {
          "results": {
            "type": "array",
            "description": "List of topics matching the search criteria"
          },
          "totalRecords": {
            "type": "number",
            "description": "Total number of records matching the search criteria"
          }
        }
      }
    }
  },
  {
    "featureName": "ManageTopicPostIds",
    "description": "Manages first and last post IDs for a topic to maintain proper thread navigation and display.",
    "inputValues": [
      "topicId-number-Topic",
      "postId-number-Post"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect topicId (mandatory): Numeric identifier for the topic\n   - Collect postId (mandatory): Numeric identifier for the post\n   - System will determine operation type (set first post or set last post)\n\n2. Data Validation:\n   - Validate topicId:\n      * Must be a positive integer\n      * Must refer to an existing topic in the system\n      * Error message if topic does not exist: \"Topic not found\"\n   - Validate postId:\n      * Must be a positive integer\n      * Must refer to an existing post in the system\n      * Post must belong to the specified topic\n      * Error message if post does not exist: \"Post not found\"\n      * Error message if post does not belong to topic: \"Post does not belong to the specified topic\"\n\n3. Business Rule Processing:\n   - Verify topic status:\n      * IF topic is locked and user is not a moderator, THEN reject operation\n      * IF topic is deleted, THEN reject operation\n   - Verify post status:\n      * IF post is deleted, THEN reject operation\n   - Determine operation type:\n      * IF setting first post ID:\n         - Verify this is the chronologically earliest post in the topic\n         - IF not earliest and not performed by moderator, THEN reject operation\n      * IF setting last post ID:\n         - Verify this is the chronologically latest post in the topic\n         - IF not latest and not performed by moderator, THEN reject operation\n\n4. Core Operation Execution:\n   - FOR setting first post ID:\n      * Update topic record with new first post ID\n      * Update topic metadata (creation date if necessary)\n      * IF operation fails, THEN rollback changes and report error\n   - FOR setting last post ID:\n      * Update topic record with new last post ID\n      * Update topic metadata (last updated date)\n      * Update forum last post information if necessary\n      * IF operation fails, THEN rollback changes and report error\n   - FOR fixing both first and last post IDs:\n      * Query for earliest post in topic to determine first post ID\n      * Query for latest post in topic to determine last post ID\n      * Update topic record with both IDs\n      * Update related metadata\n      * IF operation fails, THEN rollback changes and report error\n\n5. Response Generation:\n   - On success:\n      * Return confirmation message\n      * Include updated topic information\n   - On failure:\n      * Return appropriate error message\n      * Include error details for troubleshooting",
    "databaseEntities": [
      "jforum_topics",
      "jforum_posts",
      "jforum_forums"
    ],
    "validationRules": [
      "Topic ID must be a positive integer",
      "Post ID must be a positive integer",
      "Topic must exist in the system",
      "Post must exist in the system",
      "Post must belong to the specified topic",
      "User must have permission to modify topic metadata",
      "First post ID must be the earliest post in the topic unless modified by moderator",
      "Last post ID must be the latest post in the topic unless modified by moderator"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Topic": {
        "type": "object",
        "properties": {
          "id": {
            "type": "number"
          },
          "title": {
            "type": "string"
          },
          "firstPostId": {
            "type": "number"
          },
          "lastPostId": {
            "type": "number"
          },
          "forumId": {
            "type": "number"
          },
          "status": {
            "type": "number"
          },
          "totalReplies": {
            "type": "number"
          },
          "totalViews": {
            "type": "number"
          },
          "creationDate": {
            "type": "date"
          },
          "lastUpdated": {
            "type": "date"
          }
        },
        "required": [
          "id",
          "title",
          "forumId"
        ]
      },
      "Post": {
        "type": "object",
        "properties": {
          "id": {
            "type": "number"
          },
          "topicId": {
            "type": "number"
          },
          "userId": {
            "type": "number"
          },
          "text": {
            "type": "string"
          },
          "creationDate": {
            "type": "date"
          },
          "status": {
            "type": "number"
          }
        },
        "required": [
          "id",
          "topicId",
          "userId"
        ]
      }
    }
  },
  {
    "featureName": "FixTopicPostIds",
    "description": "Fixes the first and last post IDs for a topic.",
    "inputValues": [
      "topicId-number-Topic"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the topic ID (topicId) from the user or system request\n   - Validate that topicId is a required field\n   - No default values are provided for this operation\n\n2. Data Validation:\n   - Validate that topicId is a positive integer\n   - Verify that topicId exists in the system\n   - IF topicId is invalid or not found THEN\n     - Generate appropriate error message\n     - Terminate the operation\n   - END IF\n\n3. Business Rule Processing:\n   - Check if the topic has any posts\n   - IF topic has no posts THEN\n     - Set both first and last post IDs to null/zero\n     - Skip to Response Generation step\n   - END IF\n   - Verify that the topic is in a valid state for updating post IDs\n   - Check if the topic belongs to an active forum\n\n4. Core Operation Execution:\n   - Retrieve all posts associated with the specified topic\n   - Sort posts by creation date/time in ascending order\n   - Identify the first post in the topic (earliest created)\n     - Extract the ID of this post as firstPostId\n   - Identify the last post in the topic (most recently created)\n     - Extract the ID of this post as lastPostId\n   - Update the topic record with the correct firstPostId\n   - Update the topic record with the correct lastPostId\n   - IF any database operation fails THEN\n     - Roll back all changes\n     - Log the error details\n     - Prepare error response\n   - END IF\n\n5. Response Generation:\n   - IF operation completed successfully THEN\n     - Return success status\n     - Include the updated topic information with corrected post IDs\n   - ELSE\n     - Return error status\n     - Include specific error details and suggestions for resolution\n   - END IF",
    "databaseEntities": [
      "jforum_topics",
      "jforum_posts"
    ],
    "validationRules": [
      "Topic ID must be a positive integer",
      "Topic must exist in the system",
      "Topic must have at least one post to set valid IDs"
    ],
    "dbSeedingOperations": [],
    "schema": {}
  },
  {
    "featureName": "GetTopicNotificationUsers",
    "description": "Retrieves users to be notified about new posts in a topic.",
    "inputValues": [
      "topicId-number-Topic"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect topicId (mandatory) - Unique identifier for the topic\n\n2. Data Validation:\n   - Validate topicId:\n      a. Check if topicId is provided\n      b. Verify topicId is a positive integer\n      c. If validation fails, generate appropriate error message\n\n3. Business Rule Processing:\n   - Check topic existence:\n      a. Verify the topic with the provided topicId exists in the system\n      b. If topic does not exist, generate a \"Topic not found\" error\n   - Check notification settings:\n      a. Verify if the notification feature is enabled system-wide\n      b. If notifications are disabled, return empty user list with appropriate message\n\n4. Core Operation Execution:\n   - Retrieve subscription information:\n      a. Identify all users who have subscribed to the topic\n      b. Filter out users with disabled notification preferences\n      c. Filter out users who don't have permission to view the topic\n   - Compile user information:\n      a. For each subscribed user, gather necessary contact information\n      b. Include user preferences regarding notification format (if applicable)\n      c. Sort users based on appropriate criteria (e.g., username)\n\n5. Response Generation:\n   - Success response:\n      a. Return list of users to be notified with their relevant information\n      b. Include metadata about the notification (topic title, forum name)\n   - Error response:\n      a. Return appropriate error message if any step fails\n      b. Include error code and suggested resolution steps",
    "databaseEntities": [
      "jforum_users",
      "jforum_topics",
      "jforum_forums"
    ],
    "validationRules": [
      "Topic ID must be a positive integer",
      "Topic must exist in the system",
      "User must have an active subscription to the topic",
      "User must have permission to view the topic"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "User": {
        "type": "object",
        "properties": {
          "id": {
            "type": "number",
            "description": "Unique identifier for the user"
          },
          "username": {
            "type": "string",
            "description": "User's display name"
          },
          "email": {
            "type": "string",
            "description": "User's email address for notifications"
          },
          "notificationPreferences": {
            "type": "object",
            "description": "User's preferences for receiving notifications"
          }
        }
      },
      "Topic": {
        "type": "object",
        "properties": {
          "id": {
            "type": "number",
            "description": "Unique identifier for the topic"
          },
          "title": {
            "type": "string",
            "description": "Title of the topic"
          },
          "forumId": {
            "type": "number",
            "description": "ID of the forum containing this topic"
          }
        }
      }
    }
  },
  {
    "featureName": "SelectGroups",
    "description": "Retrieves a list of groups based on the specified parent ID.",
    "inputValues": [
      "parentId-number-Group"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect parentId (number, mandatory) to identify the parent group\n   - System will use this parentId to retrieve child groups\n\n2. Data Validation:\n   - Validate parentId:\n     a. Check if parentId is provided\n     b. Verify parentId is a valid number\n     c. Ensure parentId is not negative\n     d. IF validation fails, THEN generate appropriate error message\n\n3. Business Rule Processing:\n   - Verify system access permissions:\n     a. Check if current user has permission to view groups\n     b. Verify if the parent group exists in the system\n     c. IF parent group does not exist, THEN return appropriate error\n     d. IF user lacks permission, THEN return access denied error\n\n4. Core Operation Execution:\n   - Retrieve child groups:\n     a. Search for all groups where parent ID matches the provided parentId\n     b. Sort groups according to system-defined ordering (e.g., by name, by creation date)\n     c. Apply any system-defined filters to the results\n     d. IF no groups found, THEN prepare empty result list\n     e. IF error occurs during retrieval, THEN prepare error response\n     f. For each group found, create a GroupNode with name and ID information\n     g. Add each GroupNode to the result list\n\n5. Response Generation:\n   - Format group list response:\n     a. For each group found, include relevant group information (group ID and group name)\n     b. Include total count of groups found\n     c. IF operation successful, THEN return formatted group list\n     d. IF operation failed, THEN return error details with reason",
    "databaseEntities": [
      "jforum_groups",
      "jforum_user_groups"
    ],
    "validationRules": [
      "Parent ID must be a valid number",
      "Parent ID must not be negative",
      "User must have permission to view groups",
      "Parent group must exist in the system"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Group": {
        "type": "object",
        "properties": {
          "id": {
            "type": "number",
            "description": "Unique identifier for the group"
          },
          "name": {
            "type": "string",
            "description": "Name of the group"
          },
          "description": {
            "type": "string",
            "description": "Description of the group"
          },
          "parentId": {
            "type": "number",
            "description": "ID of the parent group"
          }
        }
      },
      "GroupNode": {
        "type": "object",
        "properties": {
          "id": {
            "type": "number",
            "description": "Unique identifier for the group"
          },
          "name": {
            "type": "string",
            "description": "Name of the group"
          }
        }
      }
    }
  },
  {
    "featureName": "GetUserById",
    "description": "Retrieves a specific user by their ID.",
    "inputValues": [
      "userId-number-User"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the userId (number, mandatory)\n   - No default values\n   - No optional fields\n\n2. Data Validation:\n   - Validate userId:\n     a. Check if userId is provided\n     b. Verify userId is a positive integer\n     c. Generate appropriate error message if validation fails\n\n3. Business Rule Processing:\n   - Check system access permissions:\n     a. Verify if the current user has permission to view user details\n     b. If permission check fails, generate appropriate error message\n   - Check if the requested user exists:\n     a. Verify if a user with the provided userId exists in the system\n     b. If user doesn't exist, prepare appropriate not-found message\n\n4. Core Operation Execution:\n   - Retrieve user data:\n     a. Fetch the user record matching the provided userId\n     b. Include all standard user information fields (username, email, etc.)\n     c. Include user status information (active/inactive)\n     d. Retrieve user's group memberships\n     e. Calculate and include private message count\n     f. If retrieval fails due to system error, prepare error response\n\n5. Response Generation:\n   - For successful retrieval:\n     a. Format user data into appropriate response structure\n     b. Include all relevant user information including:\n        - Basic profile (username, email, registration date)\n        - Preferences (theme, language, notification settings)\n        - Social information (website, biography, interests)\n        - System data (post count, karma, rank)\n        - Group memberships\n        - Private message count\n   - For failed retrieval:\n     a. Generate appropriate error response with reason\n     b. Include guidance for resolution if applicable",
    "databaseEntities": [
      "jforum_users",
      "jforum_user_groups",
      "jforum_groups"
    ],
    "validationRules": [
      "User ID must be a positive integer",
      "User with the specified ID must exist in the system",
      "Requesting user must have permission to view user details"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "User": {
        "id": "number",
        "username": "string",
        "email": "string",
        "registrationDate": "date",
        "active": "boolean",
        "posts": "number",
        "deleted": "boolean",
        "ranking": "number",
        "avatar": "string",
        "signature": "string",
        "website": "string",
        "biography": "string",
        "interests": "string",
        "from": "string",
        "icq": "string",
        "aim": "string",
        "yim": "string",
        "msnm": "string",
        "gender": "string",
        "themeId": "number",
        "lastVisit": "date",
        "karma": "number",
        "language": "string",
        "notificationPreferences": "object",
        "groups": "object"
      },
      "Group": {
        "id": "number",
        "name": "string"
      }
    }
  },
  {
    "featureName": "GetUserByName",
    "description": "Retrieves a specific user by their username.",
    "inputValues": [
      "username-string-User"
    ],
    "businessLogic": "1. Input Collection:\n   1.1. Collect the username (string) from the request.\n   1.2. Username is mandatory.\n\n2. Data Validation:\n   2.1. Validate username input:\n      2.1.1. Check if username is not empty or null.\n      2.1.2. IF username is empty or null, THEN:\n         2.1.2.1. Generate an error message indicating username is required.\n         2.1.2.2. Return error response.\n      2.1.3. Check if username format is valid according to system rules.\n      2.1.4. IF username format is invalid, THEN:\n         2.1.4.1. Generate an error message indicating invalid username format.\n         2.1.4.2. Return error response.\n\n3. Business Rule Processing:\n   3.1. Check if the system is in a valid state to process user retrieval requests:\n      3.1.1. Verify that the user database is accessible.\n      3.1.2. IF database is not accessible, THEN:\n         3.1.2.1. Log the system error.\n         3.1.2.2. Return appropriate error response.\n   3.2. Check if the requesting user has permission to view user information:\n      3.2.1. IF requesting user lacks permission, THEN:\n         3.2.1.1. Generate an access denied error message.\n         3.2.1.2. Return error response.\n\n4. Core Operation Execution:\n   4.1. Search for the user with the provided username:\n      4.1.1. Look up the user record in the user database.\n      4.1.2. IF user is not found, THEN:\n         4.1.2.1. Set result to null or empty.\n      4.1.3. IF user is found, THEN:\n         4.1.3.1. Retrieve the complete user information.\n         4.1.3.2. Check if the user account is active.\n         4.1.3.3. Check if the user account is deleted.\n         4.1.3.4. Prepare user data for response.\n\n5. Response Generation:\n   5.1. IF user was found, THEN:\n      5.1.1. Format the user data according to the response requirements.\n      5.1.2. Include user details such as ID, username, email, registration date, etc.\n      5.1.3. Return success response with user data.\n   5.2. IF user was not found, THEN:\n      5.2.1. Return appropriate response indicating user not found.\n   5.3. Include any additional information or next steps in the response.",
    "databaseEntities": [
      "jforum_users",
      "jforum_user_groups"
    ],
    "validationRules": [
      "Username must not be empty or null",
      "Username must follow the system's format requirements",
      "User database must be accessible",
      "Requesting user must have permission to view user information"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "User": {
        "type": "object",
        "properties": {
          "id": {
            "type": "integer",
            "description": "Unique identifier for the user"
          },
          "username": {
            "type": "string",
            "description": "User's login name"
          },
          "email": {
            "type": "string",
            "description": "User's email address"
          },
          "registrationDate": {
            "type": "date",
            "description": "Date when user registered"
          },
          "active": {
            "type": "boolean",
            "description": "Whether the user account is active"
          },
          "deleted": {
            "type": "boolean",
            "description": "Whether the user account is deleted"
          },
          "posts": {
            "type": "integer",
            "description": "Number of posts made by the user"
          },
          "groups": {
            "type": "array",
            "items": {
              "type": "integer"
            },
            "description": "Groups the user belongs to"
          }
        }
      }
    }
  },
  {
    "featureName": "ListAllUsers",
    "description": "Retrieves all users in the system.",
    "inputValues": [
      "startFrom-number-User",
      "count-number-User"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect optional pagination parameters:\n     - startFrom: The index position to start fetching users (optional, defaults to 0)\n     - count: The maximum number of users to retrieve (optional, defaults to system maximum)\n\n2. Data Validation:\n   - Validate pagination parameters:\n     - IF startFrom is provided THEN\n       - Verify startFrom is a non-negative integer\n       - IF startFrom is negative THEN\n         - Generate error message: \"Start index must be a non-negative value\"\n     - IF count is provided THEN\n       - Verify count is a positive integer\n       - IF count is not positive THEN\n         - Generate error message: \"Count must be a positive value\"\n       - IF count exceeds system maximum THEN\n         - Set count to system maximum\n\n3. Business Rule Processing:\n   - Check user access permissions:\n     - Verify current user has permission to list users\n     - IF user lacks permission THEN\n       - Generate error: \"Insufficient permissions to view user list\"\n   - Determine if additional user data should be included:\n     - Check if karma information is requested\n     - Check if group information is requested\n\n4. Core Operation Execution:\n   - Retrieve users from the system:\n     - IF no pagination parameters provided THEN\n       - Retrieve all users from the system\n     - ELSE\n       - Retrieve users starting from 'startFrom' index\n       - Limit results to 'count' number of records\n     - For each retrieved user:\n       - Include basic user information (id, username, email, registration date)\n       - IF karma information requested THEN\n         - Include karma status for each user\n       - IF group information requested THEN\n         - Include group memberships for each user\n   - Count total number of users in system for pagination information\n\n5. Response Generation:\n   - Prepare success response:\n     - Format list of user records with requested information\n     - Include pagination metadata:\n       - Total number of users in system\n       - Current page information\n       - Number of records returned\n   - IF no users found THEN\n     - Return empty list with appropriate metadata\n   - ELSE\n     - Return formatted user list with pagination metadata",
    "databaseEntities": [
      "jforum_users",
      "jforum_user_groups",
      "jforum_groups",
      "jforum_karma"
    ],
    "validationRules": [
      "Start index must be a non-negative integer",
      "Count must be a positive integer",
      "User must have permission to view user list"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "User": {
        "id": "number",
        "username": "string",
        "email": "string",
        "registrationDate": "date",
        "active": "boolean",
        "posts": "number",
        "karma": "object",
        "groups": "array"
      }
    }
  },
  {
    "featureName": "ListUsersWithKarma",
    "description": "Retrieves all users with their karma status.",
    "inputValues": [
      "startFrom-number-User",
      "count-number-User"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the following inputs:\n     - startFrom (number): The index position to start fetching users from (optional, defaults to 0)\n     - count (number): The maximum number of users to retrieve (optional, defaults to all users)\n\n2. Data Validation:\n   - Validate startFrom parameter:\n     - IF startFrom is provided THEN\n       - Ensure startFrom is a non-negative integer\n       - IF startFrom is negative THEN\n         - Set error message: \"Starting index cannot be negative\"\n         - Return error response\n     - ELSE\n       - Set startFrom to default value 0\n   - Validate count parameter:\n     - IF count is provided THEN\n       - Ensure count is a positive integer\n       - IF count is not positive THEN\n         - Set error message: \"Count must be a positive integer\"\n         - Return error response\n     - ELSE\n       - Set count to retrieve all available users\n\n3. Business Rule Processing:\n   - Check system access permissions:\n     - Verify current user has permission to view user list with karma\n     - IF user lacks required permissions THEN\n       - Set error message: \"Insufficient permissions to view user karma data\"\n       - Return error response\n   - Check system state:\n     - Verify the karma feature is enabled in the system\n     - IF karma feature is disabled THEN\n       - Set error message: \"Karma feature is currently disabled\"\n       - Return error response\n\n4. Core Operation Execution:\n   - Retrieve users with karma information:\n     - Query the user database starting from the specified index\n     - Limit results to the specified count if provided\n     - For each user retrieved:\n       - Fetch associated karma status information\n       - Calculate total karma points\n       - Determine karma level based on points\n       - Attach karma information to user data\n     - Sort users according to system default sorting preference\n     - IF no users are found THEN\n       - Set appropriate message: \"No users found\"\n       - Return empty result set with message\n\n5. Response Generation:\n   - Prepare success response:\n     - Include total count of all users with karma in the system\n     - Include the retrieved user list with:\n       - User basic information (id, username, registration date)\n       - Karma status information for each user\n       - Karma level classification\n     - Include pagination information:\n       - Current page/offset\n       - Total pages available\n       - Count per page\n   - Return formatted response to the requester",
    "databaseEntities": [
      "jforum_users",
      "jforum_karma",
      "jforum_user_groups"
    ],
    "validationRules": [
      "Starting index must be a non-negative integer",
      "Count must be a positive integer if provided",
      "User must have permission to view karma data",
      "Karma feature must be enabled in the system"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "User": {
        "id": "number",
        "username": "string",
        "registrationDate": "date",
        "karmaStatus": {
          "totalPoints": "number",
          "karmaLevel": "string",
          "receivedVotes": "number"
        }
      }
    }
  },
  {
    "featureName": "ListUsersByGroup",
    "description": "Retrieves users belonging to a specific group with pagination.",
    "inputValues": [
      "groupId-number-Group",
      "startIndex-number-Pagination",
      "count-number-Pagination"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the following required inputs:\n     a. groupId (number): The identifier of the group to retrieve users from\n     b. startIndex (number): The position to start retrieving users from\n     c. count (number): The maximum number of users to retrieve\n\n2. Data Validation:\n   - Validate groupId:\n     a. IF groupId is null or undefined THEN\n        i. Return error: \"Group ID is required\"\n     b. IF groupId is not a positive integer THEN\n        i. Return error: \"Group ID must be a positive integer\"\n   - Validate pagination parameters:\n     a. IF startIndex is null or undefined THEN\n        i. Set startIndex to default value (0)\n     b. IF startIndex is not a non-negative integer THEN\n        i. Return error: \"Start index must be a non-negative integer\"\n     c. IF count is null or undefined THEN\n        i. Set count to default value (10)\n     d. IF count is not a positive integer THEN\n        i. Return error: \"Count must be a positive integer\"\n     e. IF count exceeds maximum allowed page size THEN\n        i. Set count to maximum allowed page size\n\n3. Business Rule Processing:\n   - Verify group existence:\n     a. Check if the specified group exists\n     b. IF group does not exist THEN\n        i. Return error: \"Group not found\"\n   - Verify user access permissions:\n     a. Check if the current user has permission to view users in this group\n     b. IF user does not have permission THEN\n        i. Return error: \"Insufficient permissions to view users in this group\"\n\n4. Core Operation Execution:\n   - Retrieve total count of users in the group:\n     a. Query the total number of users belonging to the specified group\n     b. Store this count for pagination metadata\n   - Retrieve paginated user list:\n     a. Query users belonging to the specified group\n     b. Apply pagination using startIndex and count parameters\n     c. For each user retrieved:\n        i. Include basic user information (id, username, registration date)\n        ii. Exclude sensitive information (password, email, etc.)\n\n5. Response Generation:\n   - Prepare success response:\n     a. Include list of users with their information\n     b. Include pagination metadata:\n        i. Total number of users in the group\n        ii. Current page information\n        iii. Whether more users are available\n     c. Include group information summary\n   - Handle empty results:\n     a. IF no users found in the group THEN\n        i. Return empty list with appropriate metadata\n        ii. Include message: \"No users found in the specified group\"",
    "databaseEntities": [
      "jforum_users",
      "jforum_groups",
      "jforum_user_groups"
    ],
    "validationRules": [
      "Group ID must be a positive integer",
      "Start index must be a non-negative integer",
      "Count must be a positive integer",
      "Group must exist in the system",
      "User must have permission to view users in the specified group"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "User": {
        "type": "object",
        "properties": {
          "id": {
            "type": "number"
          },
          "username": {
            "type": "string"
          },
          "registrationDate": {
            "type": "date"
          },
          "active": {
            "type": "boolean"
          }
        }
      },
      "Group": {
        "type": "object",
        "properties": {
          "id": {
            "type": "number"
          },
          "name": {
            "type": "string"
          }
        }
      },
      "Pagination": {
        "type": "object",
        "properties": {
          "totalUsers": {
            "type": "number"
          },
          "startIndex": {
            "type": "number"
          },
          "count": {
            "type": "number"
          },
          "hasMore": {
            "type": "boolean"
          }
        }
      }
    }
  },
  {
    "featureName": "SearchUsersByName",
    "description": "Finds users by matching part or all of their username.",
    "inputValues": [
      "searchTerm-string-User",
      "exactMatch-boolean-User"
    ],
    "businessLogic": "1. Input Collection\n   - Collect the following inputs:\n     - searchTerm (string, mandatory): The text to search for in usernames\n     - exactMatch (boolean, mandatory): Whether to search for exact username match or partial match\n     - Default value for exactMatch is false if not specified\n\n2. Data Validation\n   - Validate searchTerm:\n     - IF searchTerm is empty or null THEN\n       - Return validation error: \"Search term cannot be empty\"\n     - IF searchTerm contains special characters THEN\n       - Return validation error: \"Search term contains invalid characters\"\n     - IF searchTerm length is less than minimum required characters (2) THEN\n       - Return validation error: \"Search term must be at least 2 characters long\"\n\n3. Business Rule Processing\n   - Check system state:\n     - IF user database is not accessible THEN\n       - Return system error: \"User database is currently unavailable\"\n   - Apply search restrictions:\n     - IF current user does not have permission to search users THEN\n       - Return permission error: \"You do not have permission to search users\"\n\n4. Core Operation Execution\n   - Prepare search parameters:\n     - Format searchTerm to handle case sensitivity\n     - Set search mode based on exactMatch parameter\n   - Execute user search:\n     - IF exactMatch is TRUE THEN\n       - Search for users where username exactly matches the searchTerm\n     - ELSE\n       - Search for users where username contains the searchTerm as a substring\n     - Limit results to maximum allowed number of results (e.g., 50)\n   - Process search results:\n     - For each matching user:\n       - Extract user ID and username\n       - Add to results collection\n     - IF no users found THEN\n       - Set empty result list\n\n5. Response Generation\n   - Format success response:\n     - Include total count of matching users\n     - Include list of matching users with their IDs and usernames\n     - Sort results alphabetically by username\n   - Handle potential errors:\n     - IF search execution failed THEN\n       - Return system error: \"Failed to complete user search\"\n     - IF results exceed maximum allowed THEN\n       - Include notification that results were truncated",
    "databaseEntities": [
      "jforum_users"
    ],
    "validationRules": [
      "Search term cannot be empty",
      "Search term must be at least 2 characters long",
      "Search term cannot contain special characters",
      "User must have permission to search users"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "User": {
        "id": "number",
        "username": "string"
      }
    }
  },
  {
    "featureName": "DeleteUser",
    "description": "Marks a user as deleted in the system.",
    "inputValues": [
      "userId-number-User"
    ],
    "businessLogic": "1. Input Collection\n   - Collect the following inputs:\n     a. userId (number, mandatory): The unique identifier of the user to be deleted\n\n2. Data Validation\n   - Validate the userId input:\n     a. Check if userId is provided\n        IF userId is missing or null THEN\n          RETURN error message \"User ID is required\"\n     b. Check if userId is a positive integer\n        IF userId is not a positive integer THEN\n          RETURN error message \"User ID must be a positive integer\"\n     c. Check if user exists in the system\n        IF user with userId does not exist THEN\n          RETURN error message \"User not found\"\n     d. Check if user is already deleted\n        IF user is already marked as deleted THEN\n          RETURN error message \"User is already deleted\"\n\n3. Business Rule Processing\n   - Verify system constraints:\n     a. Check if the user has any active dependencies\n        IF user has active dependencies that prevent deletion THEN\n          RETURN error message \"Cannot delete user with active dependencies\"\n     b. Check if current user has permission to delete users\n        IF current user lacks delete permissions THEN\n          RETURN error message \"Insufficient permissions to delete user\"\n\n4. Core Operation Execution\n   - Perform the user deletion process:\n     a. Mark the user as deleted in the database\n        - Update the user's deletion status flag to true\n        - Record the deletion timestamp\n     b. Handle user's active sessions\n        - Invalidate any active sessions for the user\n     c. Update related records\n        - Update any necessary counters or references\n     d. IF any operation fails during the deletion process THEN\n        - Rollback all changes\n        - Log the failure details\n        - RETURN error message \"Failed to delete user due to system error\"\n\n5. Response Generation\n   - Generate appropriate response:\n     a. IF deletion is successful THEN\n        - RETURN success message \"User successfully deleted\"\n        - Include user identifier in response\n     b. IF deletion fails THEN\n        - RETURN appropriate error message based on the failure reason\n        - Include guidance for resolving the issue if applicable",
    "databaseEntities": [
      "jforum_users",
      "jforum_sessions",
      "jforum_user_groups",
      "jforum_posts",
      "jforum_topics",
      "jforum_privmsgs"
    ],
    "validationRules": [
      "User ID must be provided",
      "User ID must be a positive integer",
      "User must exist in the system",
      "User must not already be deleted",
      "Current user must have permission to delete users"
    ],
    "dbSeedingOperations": [],
    "schema": {}
  },
  {
    "featureName": "UndeleteUser",
    "description": "Restores a previously deleted user account in the system.",
    "inputValues": [
      "userId-number-User"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect userId (number, mandatory) - The unique identifier of the deleted user to restore\n\n2. Data Validation:\n   - Validate userId:\n      a. Check if userId is provided\n         IF userId is missing or null THEN\n            Return error: \"User ID is required\"\n      b. Check if userId is a positive integer\n         IF userId is not a positive integer THEN\n            Return error: \"User ID must be a positive integer\"\n      c. Check if user exists in the system\n         IF user does not exist THEN\n            Return error: \"User not found in the system\"\n      d. Check if user is currently in deleted state\n         IF user is not in deleted state THEN\n            Return error: \"User is not in deleted state and cannot be undeleted\"\n\n3. Business Rule Processing:\n   - Verify system permissions:\n      a. Check if the current user has administrative privileges to undelete users\n         IF current user lacks required permissions THEN\n            Return error: \"Insufficient permissions to undelete users\"\n   - Verify system constraints:\n      a. Check if restoring the user would violate any system constraints\n         IF any system constraints would be violated THEN\n            Return error with specific constraint violation details\n\n4. Core Operation Execution:\n   - Restore user account:\n      a. Update user record to remove deleted status flag\n      b. Restore user's association with their groups\n         FOR EACH group the user belonged to before deletion DO\n            Reestablish user's membership in the group\n      c. Restore user's access permissions\n      d. Update any related records that may have been affected by deletion\n      e. IF any step fails during restoration THEN\n            Rollback all changes\n            Return error: \"Failed to restore user account\"\n\n5. Response Generation:\n   - On successful restoration:\n      a. Generate success response with restored user details\n      b. Include user ID and username in the response\n      c. Include timestamp of restoration\n      d. Return success message: \"User successfully restored\"\n   - On failure:\n      a. Generate detailed error response\n      b. Include specific reason for failure\n      c. Provide guidance on how to resolve the issue",
    "databaseEntities": [
      "jforum_users",
      "jforum_user_groups"
    ],
    "validationRules": [
      "User ID must be provided",
      "User ID must be a positive integer",
      "User must exist in the system",
      "User must be in deleted state to be undeleted",
      "Current user must have administrative privileges to undelete users"
    ],
    "dbSeedingOperations": [],
    "schema": {}
  },
  {
    "featureName": "UpdateUser",
    "description": "Updates user information in the system.",
    "inputValues": [
      "userId-number-User",
      "username-string-User",
      "email-string-User",
      "password-string-User",
      "signature-string-User",
      "avatar-string-User",
      "userDetails-object-UserDetails"
    ],
    "businessLogic": "1. Input Collection:\n   1.1. Collect user identifier:\n       1.1.1. Obtain userId (mandatory) to identify the user to update\n   1.2. Collect user profile information:\n       1.2.1. Obtain username (optional) for the user account\n       1.2.2. Obtain email (optional) for contact information\n       1.2.3. Obtain password (optional) if changing credentials\n       1.2.4. Obtain signature (optional) for forum posts\n       1.2.5. Obtain avatar (optional) for profile image\n       1.2.6. Obtain userDetails (optional) containing additional profile information\n   1.3. Set system-generated values:\n       1.3.1. Set modificationDate to current system time\n\n2. Data Validation:\n   2.1. Validate user identifier:\n       2.1.1. IF userId is not provided or invalid THEN\n           2.1.1.1. Generate error message \"Valid user ID is required\"\n           2.1.1.2. Terminate process\n   2.2. Validate username if provided:\n       2.2.1. IF username is provided THEN\n           2.2.2. Verify username is between 3 and 25 characters\n           2.2.3. Verify username contains only alphanumeric characters, underscores, or hyphens\n           2.2.4. IF username has changed from current value THEN\n               2.2.4.1. Check if new username already exists in system\n               2.2.4.2. IF username exists THEN generate error \"Username already taken\"\n   2.3. Validate email if provided:\n       2.3.1. IF email is provided THEN\n           2.3.2. Verify email follows valid format (contains @ and proper domain)\n           2.3.3. IF email has changed from current value THEN\n               2.3.3.1. Check if email already exists in system\n               2.3.3.2. IF email exists THEN generate error \"Email already registered\"\n   2.4. Validate password if provided:\n       2.4.1. IF password is provided THEN\n           2.4.2. Verify password meets minimum length requirement (8 characters)\n           2.4.3. Verify password meets complexity requirements\n\n3. Business Rule Processing:\n   3.1. Verify user exists:\n       3.1.1. Check if user with provided userId exists in the system\n       3.1.2. IF user not found THEN\n           3.1.2.1. Generate error message \"User not found\"\n           3.1.2.2. Terminate process\n   3.2. Verify user is not deleted:\n       3.2.1. Check if user account is marked as deleted\n       3.2.2. IF user is deleted THEN\n           3.2.2.1. Generate error message \"Cannot update deleted user account\"\n           3.2.2.2. Terminate process\n   3.3. Check update permissions:\n       3.3.1. Verify current user has permission to update the specified user\n       3.3.2. IF permission denied THEN\n           3.3.2.1. Generate error message \"Insufficient permissions to update user\"\n           3.3.2.2. Terminate process\n\n4. Core Operation Execution:\n   4.1. Retrieve current user data:\n       4.1.1. Load existing user record from database using userId\n       4.1.2. Store original values for comparison and audit purposes\n   4.2. Update user information:\n       4.2.1. IF username is provided and valid THEN update username\n       4.2.2. IF email is provided and valid THEN update email\n       4.2.3. IF password is provided and valid THEN\n           4.2.3.1. Generate password hash\n           4.2.3.2. Update password with hashed value\n       4.2.4. IF signature is provided THEN update signature\n       4.2.5. IF avatar is provided THEN update avatar\n       4.2.6. IF userDetails is provided THEN update user details\n       4.2.7. Set last modified timestamp to current time\n   4.3. Save updated user record:\n       4.3.1. Persist all changes to the database\n       4.3.2. IF database error occurs THEN\n           4.3.2.1. Rollback all changes\n           4.3.2.2. Generate error message \"Failed to update user information\"\n           4.3.2.3. Terminate process\n\n5. Response Generation:\n   5.1. Prepare success response:\n       5.1.1. Include userId of updated user\n       5.1.2. Include confirmation message \"User information updated successfully\"\n       5.1.3. Include timestamp of update\n   5.2. Handle error response if needed:\n       5.2.1. Include error code\n       5.2.2. Include descriptive error message\n       5.2.3. Include suggestions for resolution if applicable",
    "databaseEntities": [
      "jforum_users",
      "jforum_user_groups"
    ],
    "validationRules": [
      "User ID must be a valid identifier in the system",
      "Username must be between 3 and 25 characters if provided",
      "Username must contain only alphanumeric characters, underscores, or hyphens",
      "Username must be unique in the system if changed",
      "Email must follow valid format if provided",
      "Email must be unique in the system if changed",
      "Password must be at least 8 characters long if provided",
      "User must exist in the system",
      "User must not be marked as deleted",
      "Current user must have permission to update the specified user"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "UserDetails": {
        "type": "object",
        "properties": {
          "firstName": {
            "type": "string"
          },
          "lastName": {
            "type": "string"
          },
          "website": {
            "type": "string"
          },
          "location": {
            "type": "string"
          },
          "occupation": {
            "type": "string"
          },
          "interests": {
            "type": "string"
          },
          "biography": {
            "type": "string"
          },
          "language": {
            "type": "string"
          },
          "dateFormat": {
            "type": "string"
          },
          "timeZone": {
            "type": "string"
          }
        }
      }
    }
  },
  {
    "featureName": "CreateUserWithId",
    "description": "Adds a new user with a predefined ID for external login support.",
    "inputValues": [
      "user-object-User"
    ],
    "businessLogic": "1. Input Collection\n   - Collect User object with the following fields:\n     - userId (required, predefined): Unique identifier for the user\n     - username (required): User's login name\n     - password (required): User's authentication credential\n     - email (required): User's email address\n     - registrationDate (system-generated): Date and time of registration\n     - active (optional, default=false): Account activation status\n     - avatar (optional): User's profile image reference\n     - attachSignature (optional, default=false): Whether to attach signature to posts\n     - signature (optional): User's signature text\n\n2. Data Validation\n   - Validate userId:\n     - Must be a positive integer\n     - Must not already exist in the system\n     - Error message if validation fails: \"User ID already exists or is invalid\"\n   - Validate username:\n     - Must not be empty\n     - Must be between 3 and 30 characters\n     - Must not contain special characters except underscores\n     - Must not already exist in the system\n     - Error message if validation fails: \"Username is invalid or already registered\"\n   - Validate email:\n     - Must be in valid email format\n     - Must not already exist in the system\n     - Error message if validation fails: \"Email is invalid or already registered\"\n   - Validate password:\n     - Must be at least 6 characters long\n     - Error message if validation fails: \"Password must be at least 6 characters long\"\n\n3. Business Rule Processing\n   - Verify system can accept new users:\n     - Check if user registration is enabled\n     - Check if maximum user limit has not been reached\n     - IF registration is disabled OR user limit reached THEN\n       - Return error: \"User registration is currently not available\"\n   - Check external login system compatibility:\n     - Verify the provided user ID format matches external system requirements\n     - IF format incompatible THEN\n       - Return error: \"User ID format incompatible with external login system\"\n   - Prepare user data for creation:\n     - Set registration date to current system time\n     - Set default user preferences if not provided\n     - Set initial post count to zero\n     - Set default user rank\n\n4. Core Operation Execution\n   - Create new user record:\n     - Insert user record with predefined ID into user table\n     - Create associated user profile record\n     - IF insertion fails due to database constraints THEN\n       - Roll back all changes\n       - Return error: \"Failed to create user record\"\n   - Assign default user groups:\n     - Identify default groups for new users\n     - Associate user with these groups\n     - IF group assignment fails THEN\n       - Log warning but continue process\n   - Initialize user settings:\n     - Create default notification preferences\n     - Set default privacy settings\n     - IF settings initialization fails THEN\n       - Log warning but continue process\n\n5. Response Generation\n   - For successful creation:\n     - Return success status\n     - Include created user information (excluding sensitive data)\n     - Include activation instructions if account requires activation\n   - For failed creation:\n     - Return failure status\n     - Include specific error details\n     - Include suggestions for resolving the issue\n     - Provide support contact information if needed",
    "databaseEntities": [
      "jforum_users",
      "jforum_user_groups"
    ],
    "validationRules": [
      "User ID must be a positive integer",
      "User ID must not already exist in the system",
      "Username must not be empty",
      "Username must be between 3 and 30 characters",
      "Username must not contain special characters except underscores",
      "Username must not already exist in the system",
      "Email must be in valid email format",
      "Email must not already exist in the system",
      "Password must be at least 6 characters long"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "User": {
        "type": "object",
        "properties": {
          "userId": {
            "type": "integer",
            "description": "Predefined unique identifier for the user"
          },
          "username": {
            "type": "string",
            "description": "User's login name"
          },
          "password": {
            "type": "string",
            "description": "User's authentication credential"
          },
          "email": {
            "type": "string",
            "description": "User's email address"
          },
          "registrationDate": {
            "type": "date",
            "description": "Date and time of registration"
          },
          "active": {
            "type": "boolean",
            "description": "Account activation status"
          },
          "avatar": {
            "type": "string",
            "description": "User's profile image reference"
          },
          "attachSignature": {
            "type": "boolean",
            "description": "Whether to attach signature to posts"
          },
          "signature": {
            "type": "string",
            "description": "User's signature text"
          }
        },
        "required": [
          "userId",
          "username",
          "password",
          "email"
        ]
      }
    }
  },
  {
    "featureName": "SetUserActiveStatus",
    "description": "Changes the active status of a user in the system.",
    "inputValues": [
      "userId-number-User",
      "active-boolean-User"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect userId (number, mandatory) - Unique identifier of the user\n   - Collect active (boolean, mandatory) - The desired active status\n\n2. Data Validation:\n   - Validate userId:\n      a. Ensure userId is provided\n      b. Ensure userId is a positive integer\n      c. If validation fails, generate appropriate error message\n   - Validate active parameter:\n      a. Ensure active status is provided\n      b. Ensure active status is a boolean value\n      c. If validation fails, generate appropriate error message\n\n3. Business Rule Processing:\n   - Check if user exists:\n      a. Verify the userId corresponds to an existing user in the system\n      b. IF user does not exist, THEN generate error message and terminate process\n   - Check if user is deleted:\n      a. Verify if the user account is marked as deleted\n      b. IF user is deleted, THEN generate error message indicating operation cannot be performed on deleted accounts\n   - Check for permission:\n      a. Verify if the requesting entity has permission to change user status\n      b. IF permission check fails, THEN generate unauthorized access error\n\n4. Core Operation Execution:\n   - Update user active status:\n      a. Set the user's active status to the provided value (1 for active, 0 for inactive)\n      b. Record timestamp of status change\n      c. IF active status is being set to true:\n         i. Clear any pending activation requests\n         ii. Update user activation date\n      d. IF active status is being set to false:\n         i. Handle any active sessions for this user\n         ii. Log deactivation reason if provided\n      e. IF update operation fails, THEN generate system error and rollback changes\n\n5. Response Generation:\n   - For successful operation:\n      a. Generate success confirmation message\n      b. Include updated user status information\n      c. Include timestamp of the change\n   - For failed operation:\n      a. Generate appropriate error message based on failure reason\n      b. Include guidance on how to resolve the issue\n      c. Provide support contact information if needed",
    "databaseEntities": [
      "jforum_users",
      "jforum_sessions"
    ],
    "validationRules": [
      "User ID must be a positive integer",
      "User ID must correspond to an existing user",
      "Active status must be a boolean value",
      "User account must not be deleted",
      "Requesting entity must have permission to change user status"
    ],
    "dbSeedingOperations": [],
    "schema": {}
  },
  {
    "featureName": "SetUserRanking",
    "description": "Sets the ranking for a user in the system.",
    "inputValues": [
      "userId-number-User",
      "rankingId-number-Ranking"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect userId (number, mandatory) - Identifier of the user to update\n   - Collect rankingId (number, mandatory) - Identifier of the ranking to assign to the user\n   - System will not generate any values for this operation\n\n2. Data Validation:\n   - Validate userId:\n      a. Verify userId is a positive integer\n      b. Verify userId is not null or undefined\n      c. Return error message if validation fails: \"User ID must be a valid positive integer\"\n   - Validate rankingId:\n      a. Verify rankingId is a positive integer\n      b. Verify rankingId is not null or undefined\n      c. Return error message if validation fails: \"Ranking ID must be a valid positive integer\"\n\n3. Business Rule Processing:\n   - Verify user exists in the system:\n      a. Check if user with provided userId exists in the database\n      b. IF user does not exist, THEN return error: \"User not found\"\n   - Verify ranking exists in the system:\n      a. Check if ranking with provided rankingId exists in the database\n      b. IF ranking does not exist, THEN return error: \"Ranking not found\"\n   - Verify user is not deleted:\n      a. Check if user is marked as deleted in the system\n      b. IF user is deleted, THEN return error: \"Cannot set ranking for a deleted user\"\n\n4. Core Operation Execution:\n   - Update user record with new ranking:\n      a. Set the user's ranking field to the provided rankingId\n      b. Save the updated user information to the database\n      c. IF update fails, THEN rollback changes and return error: \"Failed to update user ranking\"\n   - Record ranking change in system logs:\n      a. Log the ranking change with timestamp, user ID, old ranking ID, and new ranking ID\n      b. IF logging fails, continue with operation (non-critical)\n\n5. Response Generation:\n   - Success response:\n      a. Return success status indicator\n      b. Include message: \"User ranking successfully updated\"\n      c. Include updated user information with new ranking details\n   - Error response:\n      a. Return error status indicator\n      b. Include specific error message from validation or processing steps\n      c. Include support reference information if needed",
    "databaseEntities": [
      "jforum_users"
    ],
    "validationRules": [
      "User ID must be a valid positive integer",
      "Ranking ID must be a valid positive integer",
      "User must exist in the system",
      "Ranking must exist in the system",
      "User must not be deleted"
    ],
    "dbSeedingOperations": [],
    "schema": {}
  },
  {
    "featureName": "IncrementUserPosts",
    "description": "Increases the post count for a user in the system.",
    "inputValues": [
      "userId-number-User"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the userId (number) of the user whose post count needs to be incremented\n   - Verify the userId is provided and not null\n   - System will not require any additional inputs for this operation\n\n2. Data Validation:\n   - Validate that userId is a positive integer\n      * IF userId is not a positive integer THEN\n        - Generate an error message indicating invalid user ID format\n        - Abort the operation\n   - Verify the user exists in the system\n      * Query the user record using the provided userId\n      * IF user not found THEN\n        - Generate an error message indicating user does not exist\n        - Abort the operation\n   - Verify the user account is active and not deleted\n      * IF user is marked as deleted THEN\n        - Generate an error message indicating operation cannot be performed on deleted accounts\n        - Abort the operation\n\n3. Business Rule Processing:\n   - Check if the user has permission to have their post count updated\n      * Verify user is not in a special group that is exempt from post counting\n      * IF user is in an exempt group THEN\n        - Log the attempt but do not increment the counter\n        - Skip to Response Generation with appropriate message\n   - Check if any post count limits apply to this user\n      * IF user has reached maximum allowed post count THEN\n        - Log the attempt\n        - Generate a notification for administrators\n        - Continue with the increment operation\n\n4. Core Operation Execution:\n   - Retrieve the current post count for the user\n   - Increment the post count by one\n   - Update the user record with the new post count\n      * IF update operation fails THEN\n        - Log the error details\n        - Attempt to rollback the operation\n        - Generate an error message about the failure\n        - Abort the operation\n   - Record the timestamp of this update in the user activity log\n   - IF the new post count reaches a threshold for rank promotion\n      * Update the user's rank accordingly\n      * Generate a notification for the user about their new rank\n\n5. Response Generation:\n   - Return success status indicating the post count was incremented\n   - Include the new post count value in the response\n   - Include any rank change information if applicable\n   - IF any warnings occurred during processing, include them in the response\n   - Provide information about the next rank threshold if applicable",
    "databaseEntities": [
      "jforum_users",
      "jforum_user_groups"
    ],
    "validationRules": [
      "User ID must be a positive integer",
      "User must exist in the system",
      "User account must not be deleted",
      "User must have permission to have their post count updated"
    ],
    "dbSeedingOperations": [],
    "schema": {}
  },
  {
    "featureName": "DecrementUserPosts",
    "description": "Decreases the post count for a user in the system.",
    "inputValues": [
      "userId-number-User"
    ],
    "businessLogic": "1. Input Collection\n   - Collect the userId (number) of the user whose post count needs to be decremented\n   - The userId is mandatory and must be provided by the system\n\n2. Data Validation\n   - Validate userId:\n     a. Check if userId is a positive integer\n     b. Verify userId is not null or zero\n     c. Generate appropriate error message if validation fails\n\n3. Business Rule Processing\n   - Check if the user exists in the system\n     a. IF user does not exist, THEN generate an error message\n     b. IF user exists, THEN proceed with the operation\n   - Check if the user's current post count is greater than zero\n     a. IF post count is zero, THEN generate a warning that post count cannot be negative\n     b. IF post count is greater than zero, THEN proceed with the operation\n\n4. Core Operation Execution\n   - Retrieve the current post count for the specified user\n   - Decrement the post count by one\n   - Update the user record with the new post count\n   - IF any errors occur during the update:\n     a. Roll back the operation\n     b. Log the error details\n     c. Generate appropriate error message\n\n5. Response Generation\n   - IF operation is successful:\n     a. Generate success response with updated post count\n     b. Include user information in the response\n   - IF operation fails:\n     a. Generate error response with appropriate error message\n     b. Include error details for troubleshooting",
    "databaseEntities": [
      "jforum_users"
    ],
    "validationRules": [
      "User ID must be a positive integer",
      "User must exist in the system",
      "User's post count should not become negative"
    ],
    "dbSeedingOperations": [],
    "schema": {}
  },
  {
    "featureName": "GetLastRegisteredUser",
    "description": "Retrieves information about the most recently registered user.",
    "inputValues": [],
    "businessLogic": "1. Input Collection:\n   - No user inputs required for this feature\n   - System will use internal state to determine the most recently registered user\n\n2. Data Validation:\n   - Verify system access permissions\n      - IF user does not have appropriate permissions THEN\n         - Generate permission denied error\n         - Exit process\n      - END IF\n\n3. Business Rule Processing:\n   - Check system state\n      - IF system is in maintenance mode THEN\n         - Generate system unavailable error\n         - Exit process\n      - END IF\n   - Verify cache availability\n      - IF cache system is unavailable THEN\n         - Generate cache access error\n         - Exit process\n      - END IF\n\n4. Core Operation Execution:\n   - Access system cache for last registered user information\n      - Retrieve user object from cache storage\n      - IF user information is not in cache THEN\n         - Query user database for most recently registered user\n         - Sort users by registration date in descending order\n         - Limit results to single most recent entry\n         - Store result in cache for future requests\n      - END IF\n      - Extract user information including:\n         - User ID\n         - Username\n         - Registration date\n         - Other relevant user profile information\n      - IF no users exist in system THEN\n         - Set empty result indicator\n      - END IF\n\n5. Response Generation:\n   - Format user information for display\n      - IF user found THEN\n         - Prepare success response with user details\n            - Include user ID\n            - Include username\n            - Include registration timestamp\n            - Include any other relevant user information\n      - ELSE\n         - Prepare response indicating no users are registered\n      - END IF\n   - Return formatted response to caller",
    "databaseEntities": [
      "jforum_users"
    ],
    "validationRules": [
      "System must have at least one registered user to return valid data",
      "User requesting this information must have appropriate permissions",
      "System must be in operational state, not maintenance mode",
      "Cache system must be operational to retrieve user information"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "User": {
        "type": "object",
        "properties": {
          "id": {
            "type": "integer",
            "description": "Unique identifier for the user"
          },
          "username": {
            "type": "string",
            "description": "User's display name in the system"
          },
          "registrationDate": {
            "type": "date",
            "description": "Date when user registered in the system"
          }
        },
        "required": [
          "id",
          "username"
        ]
      }
    }
  },
  {
    "featureName": "GetTotalUserCount",
    "description": "Counts the total number of users in the system.",
    "inputValues": [],
    "businessLogic": "1. Input Collection:\n   - No user inputs are required for this feature\n   - System will use existing database context\n\n2. Data Validation:\n   - No input validation required as there are no user inputs\n\n3. Business Rule Processing:\n   - Verify system has appropriate access to user data store\n   - Check if user has permission to view user count information\n   - IF user does not have permission THEN\n     - Generate appropriate access denied response\n     - Terminate process\n   - END IF\n\n4. Core Operation Execution:\n   - Access the user repository\n   - Count all user records in the system\n     - Include only non-deleted user accounts in the count\n     - IF system supports user account status THEN\n       - Determine whether to include inactive accounts based on system configuration\n     - END IF\n   - Store the count value for response\n\n5. Response Generation:\n   - Format the total user count for display\n   - Return the count value to the requesting system\n   - IF count operation failed THEN\n     - Generate appropriate error message\n     - Include troubleshooting information if appropriate\n   - END IF",
    "databaseEntities": [
      "jforum_users"
    ],
    "validationRules": [
      "User must have permission to view user statistics"
    ],
    "dbSeedingOperations": [],
    "schema": {}
  },
  {
    "featureName": "GetUserCountByGroup",
    "description": "Counts the total number of users in a specific group.",
    "inputValues": [
      "groupId-number-Group"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the required input:\n     1.1. groupId (number, mandatory): The unique identifier of the group to count users from\n\n2. Data Validation:\n   - Validate the input parameters:\n     2.1. Check if groupId is provided\n        IF groupId is null or undefined THEN\n           Return error message \"Group ID is required\"\n     2.2. Verify groupId is a positive integer\n        IF groupId is not a positive integer THEN\n           Return error message \"Group ID must be a positive integer\"\n     2.3. Verify the group exists\n        IF group with groupId does not exist THEN\n           Return error message \"Group not found\"\n\n3. Business Rule Processing:\n   - Check system state and permissions:\n     3.1. Verify the user has permission to view group information\n        IF user does not have permission THEN\n           Return error message \"Insufficient permissions to view group information\"\n     3.2. Verify the group is active\n        IF group is not active THEN\n           Return error message \"Cannot retrieve user count for inactive groups\"\n\n4. Core Operation Execution:\n   - Perform the count operation:\n     4.1. Access the user-group relationship records\n     4.2. Count all distinct users associated with the specified group\n     4.3. Store the count result\n     4.4. IF any error occurs during counting THEN\n           Log the error details\n           Return error message \"Unable to retrieve user count\"\n\n5. Response Generation:\n   - Prepare and return the response:\n     5.1. Format the success response with:\n        - Total count of users in the group\n        - Group identifier\n        - Group name (if available)\n     5.2. Return the formatted response to the caller",
    "databaseEntities": [
      "jforum_users",
      "jforum_groups",
      "jforum_user_groups"
    ],
    "validationRules": [
      "Group ID must be provided",
      "Group ID must be a positive integer",
      "Group must exist in the system",
      "User must have permission to view group information"
    ],
    "dbSeedingOperations": [],
    "schema": {}
  },
  {
    "featureName": "CheckUserDeletionStatus",
    "description": "Checks if a user has been marked as deleted in the system.",
    "inputValues": [
      "userId-number-User"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the userId (number, mandatory) from the request\n   - No optional fields required\n   - No default values needed\n\n2. Data Validation:\n   - Validate userId:\n     a. Ensure userId is provided\n     b. Ensure userId is a positive integer\n     c. If validation fails, prepare appropriate error message\n\n3. Business Rule Processing:\n   - Check system state:\n     a. Verify the system is operational\n     b. Verify the user management module is accessible\n   - Verify resource availability:\n     a. Ensure the user database is accessible\n     b. Ensure the user records can be queried\n\n4. Core Operation Execution:\n   - Query user deletion status:\n     a. Locate the user record using the provided userId\n     b. IF user record is not found THEN\n        i. Prepare \"User not found\" response\n        ii. End process\n     c. Extract the deletion status flag from the user record\n     d. IF any errors occur during retrieval THEN\n        i. Prepare system error response\n        ii. Log the error details\n        iii. End process\n\n5. Response Generation:\n   - Prepare success response:\n     a. Include the deletion status (boolean: true if deleted, false if not deleted)\n     b. Include the userId for reference\n   - IF user is deleted THEN\n     a. Include deletion timestamp if available\n   - Return the final response to the caller",
    "databaseEntities": [
      "jforum_users"
    ],
    "validationRules": [
      "User ID must be a positive integer",
      "User ID must reference an existing user in the system"
    ],
    "dbSeedingOperations": [],
    "schema": {}
  },
  {
    "featureName": "CheckUsernameExists",
    "description": "Verifies if a username is already registered in the system.",
    "inputValues": [
      "username-string-User"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the username (string) to be checked\n   - Username is a mandatory field\n   - No default values are provided\n\n2. Data Validation:\n   - Validate username format:\n     a. Check if username is not null or empty\n     b. Check if username meets minimum length requirements\n     c. Check if username contains only allowed characters\n   - IF any validation fails, THEN:\n     a. Generate appropriate error message\n     b. Return validation error response\n\n3. Business Rule Processing:\n   - Verify system state:\n     a. Check if the user database is accessible\n     b. Ensure the username lookup functionality is available\n   - IF system is not in proper state, THEN:\n     a. Generate system unavailable error\n     b. Return error response\n\n4. Core Operation Execution:\n   - Search for the username in the user database:\n     a. Perform case-insensitive search for exact username match\n     b. Determine if the username exists in the system\n   - Record the result of the search operation\n   - IF search operation fails, THEN:\n     a. Generate appropriate error message\n     b. Return error response with details\n\n5. Response Generation:\n   - Prepare response with existence status:\n     a. IF username exists, THEN:\n        i. Set existence flag to true\n        ii. Include appropriate message indicating username is already taken\n     b. IF username does not exist, THEN:\n        i. Set existence flag to false\n        ii. Include appropriate message indicating username is available\n   - Return the final response with existence status",
    "databaseEntities": [
      "jforum_users"
    ],
    "validationRules": [
      "Username must not be null or empty",
      "Username must meet minimum length requirements",
      "Username must contain only allowed characters",
      "System must be able to access user database"
    ],
    "dbSeedingOperations": [],
    "schema": {}
  },
  {
    "featureName": "ValidateUserLogin",
    "description": "Authenticates a user based on username and password.",
    "inputValues": [
      "username-string-User",
      "password-string-User",
      "autologin-boolean-User",
      "returnPath-string-User",
      "extraParams-object-ExtraParams"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the following required inputs:\n     a. username (string, mandatory): The user's login identifier\n     b. password (string, mandatory): The user's authentication credential\n     c. autologin (boolean, optional): Flag indicating if user wants to be remembered\n     d. returnPath (string, optional): Path to redirect user after successful login\n     e. extraParams (object, optional): Additional parameters that might be needed for authentication\n\n2. Data Validation:\n   - Validate username input:\n     a. Check if username is not empty\n     b. Check if username is properly formatted\n     c. IF username is invalid THEN prepare error message indicating invalid username format\n   - Validate password input:\n     a. Check if password is not empty\n     b. Check if password meets minimum length requirements\n     c. IF password is invalid THEN prepare error message indicating invalid password format\n   - Determine authentication method:\n     a. Check if basic authentication header is present\n     b. IF basic authentication is present THEN extract username and password from header\n     c. ELSE use standard form parameters for username and password\n\n3. Business Rule Processing:\n   - Check system availability:\n     a. Verify authentication system is operational\n     b. IF system is unavailable THEN prepare system unavailable error message\n   - Check account restrictions:\n     a. Verify if login attempts are within allowed limits\n     b. IF too many failed attempts detected THEN prepare account locked error message\n   - Verify authentication configuration:\n     a. Check if the system allows the requested authentication method\n     b. IF authentication method not allowed THEN prepare appropriate error message\n\n4. Core Operation Execution:\n   - Perform user lookup and authentication:\n     a. Search for user record matching the provided username and password\n     b. IF no matching record found THEN mark login as invalid\n     c. IF matching record found THEN:\n        i. Create a new user session\n        ii. Remove any existing guest session\n        iii. Associate user data with the session\n   - Handle existing user session:\n     a. Check if user already has an active session\n     b. IF existing session found THEN:\n        i. Store existing session data\n        ii. Remove old session\n        iii. Transfer relevant data to new session\n   - Process autologin request:\n     a. IF autologin is requested and system allows it THEN:\n        i. Generate a unique user hash\n        ii. Store the hash in the user record\n        iii. Set autologin cookies with appropriate expiration\n     b. ELSE remove any existing autologin cookies\n   - Update user's last visit information:\n     a. IF this is a new session THEN set last visit to current time\n     b. ELSE calculate last visit based on previous session data\n   - Finalize session setup:\n     a. Add the user session to the session repository\n     b. Initialize user's topic read tracking\n     c. Set user identification cookie\n     d. Load user security permissions\n\n5. Response Generation:\n   - For successful authentication:\n     a. Determine appropriate redirect location:\n        i. IF custom return path specified THEN use it\n        ii. ELSE redirect to default location (forums list)\n     b. Set session as logged in\n     c. Prepare success indicators\n   - For failed authentication:\n     a. Set invalid login indicator\n     b. Prepare login template with error message\n     c. Preserve return path if specified\n     d. Allow user to retry authentication",
    "databaseEntities": [
      "jforum_users",
      "jforum_user_groups",
      "jforum_groups",
      "jforum_sessions"
    ],
    "validationRules": [
      "Username must not be empty",
      "Password must not be empty",
      "User account must exist in the system",
      "User account must be active",
      "User account must not be deleted",
      "Password must match the stored password for the user"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "User": {
        "id": "number",
        "username": "string",
        "password": "string",
        "email": "string",
        "active": "boolean",
        "deleted": "boolean",
        "activationKey": "string",
        "groups": "array",
        "lang": "string",
        "lastVisit": "date"
      },
      "ExtraParams": {
        "properties": "object"
      },
      "UserSession": {
        "sessionId": "string",
        "userId": "number",
        "username": "string",
        "startTime": "date",
        "lastVisit": "date",
        "sessionTime": "number",
        "autoLogin": "boolean"
      }
    }
  },
  {
    "featureName": "AddUserToGroups",
    "description": "Associates a user with specified groups.",
    "inputValues": [
      "userId-number-User",
      "groupIds-object-GroupArray"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect userId (number, mandatory) - The identifier of the user to be added to groups\n   - Collect groupIds (array of numbers, mandatory) - The identifiers of the groups to associate with the user\n   - System will use current user context for authorization\n\n2. Data Validation:\n   - Validate userId:\n     a. Check if userId is provided and is a positive integer\n     b. If validation fails, generate error message: \"User ID must be a valid positive integer\"\n   - Validate groupIds:\n     a. Check if groupIds is provided and is a non-empty array\n     b. Verify each groupId is a positive integer\n     c. If validation fails, generate error message: \"Group IDs must be provided as a non-empty array of positive integers\"\n\n3. Business Rule Processing:\n   - Check if user exists:\n     a. Verify the user with the provided userId exists in the system\n     b. If user not found, generate error: \"User with ID {userId} does not exist\"\n   - Check if groups exist:\n     a. For each groupId in groupIds:\n        i. Verify the group exists in the system\n        ii. If any group not found, generate error: \"Group with ID {groupId} does not exist\"\n   - Check for authorization:\n     a. Verify the current user has permission to modify group memberships\n     b. If not authorized, generate error: \"Insufficient permissions to modify group memberships\"\n   - Check for existing memberships:\n     a. For each groupId in groupIds:\n        i. Check if the user is already a member of the group\n        ii. If already a member, skip this group in further processing\n\n4. Core Operation Execution:\n   - Prepare for group association:\n     a. Create a list of groups that the user is not already a member of\n     b. If list is empty (user is already in all specified groups), return success with appropriate message\n   - Associate user with groups:\n     a. For each valid groupId in the filtered list:\n        i. Create an association between the user and the group\n        ii. Record the association timestamp\n     b. If any association fails:\n        i. Roll back all associations made in this operation\n        ii. Generate error: \"Failed to associate user with groups\"\n\n5. Response Generation:\n   - On success:\n     a. Generate success message: \"User successfully added to specified groups\"\n     b. Include summary of groups the user was added to\n     c. Include any groups that were skipped (if user was already a member)\n   - On failure:\n     a. Return appropriate error message from validation or processing steps\n     b. Include guidance on how to resolve the issue",
    "databaseEntities": [
      "jforum_users",
      "jforum_groups",
      "jforum_user_groups"
    ],
    "validationRules": [
      "User ID must be a valid positive integer",
      "Group IDs must be provided as a non-empty array of positive integers",
      "User must exist in the system",
      "All specified groups must exist in the system",
      "Current user must have permission to modify group memberships"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "GroupArray": {
        "type": "array",
        "items": {
          "type": "number",
          "description": "Group identifier"
        },
        "minItems": 1,
        "description": "Array of group identifiers"
      }
    }
  },
  {
    "featureName": "RemoveUserFromGroups",
    "description": "Removes a user from specified groups.",
    "inputValues": [
      "userId-number-User",
      "groupIds-object-GroupIdArray"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect userId (number, mandatory): The unique identifier of the user to be removed from groups\n   - Collect groupIds (array of numbers, mandatory): The list of group identifiers from which the user will be removed\n   - System will use current authentication context to verify operation permissions\n\n2. Data Validation:\n   - Validate userId:\n      a. Verify userId is a positive integer\n      b. Verify userId is not null or empty\n      c. Return appropriate error message if validation fails\n   - Validate groupIds:\n      a. Verify groupIds is not null or empty\n      b. Verify each groupId in the array is a positive integer\n      c. Return appropriate error message if validation fails\n\n3. Business Rule Processing:\n   - Verify user exists:\n      a. Check if user with provided userId exists in the system\n      b. IF user does not exist, THEN return error message indicating user not found\n   - Verify groups exist:\n      a. For EACH groupId in groupIds:\n         i. Check if group with current groupId exists\n         ii. IF any group does not exist, THEN return error message with list of invalid group IDs\n   - Verify user membership:\n      a. For EACH groupId in groupIds:\n         i. Check if user is currently a member of the group\n         ii. IF user is not a member of any specified group, THEN remove that groupId from the list\n         iii. IF all groupIds are invalid (user not a member of any), THEN return appropriate message\n   - Verify removal permissions:\n      a. Check if current authenticated user has permission to remove users from groups\n      b. IF not authorized, THEN return permission denied error\n\n4. Core Operation Execution:\n   - Begin removal process:\n      a. Start a transaction to ensure data consistency\n      b. For EACH groupId in groupIds:\n         i. Remove association between user and current group\n         ii. Update user's group membership status\n         iii. Log the removal action for audit purposes\n      c. IF any removal operation fails:\n         i. Rollback all changes\n         ii. Return error message with details of the failure\n      d. Commit transaction if all removals are successful\n   - Update related data:\n      a. Recalculate user's permissions based on remaining group memberships\n      b. Update any cached user information to reflect new group memberships\n\n5. Response Generation:\n   - For successful operation:\n      a. Generate success response indicating user was removed from specified groups\n      b. Include list of groups from which the user was successfully removed\n      c. Include any warnings about groups where user was not a member\n   - For failed operation:\n      a. Generate error response with appropriate error code\n      b. Include detailed error message explaining the failure reason\n      c. Provide guidance on how to resolve the issue",
    "databaseEntities": [
      "jforum_users",
      "jforum_groups",
      "jforum_user_groups"
    ],
    "validationRules": [
      "User ID must be a positive integer",
      "Group IDs must be provided as an array of positive integers",
      "User must exist in the system",
      "All specified groups must exist in the system",
      "User must be a member of at least one of the specified groups",
      "Current user must have permission to remove users from groups"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "GroupIdArray": {
        "type": "array",
        "items": {
          "type": "number",
          "description": "Group identifier"
        },
        "minItems": 1,
        "description": "Array of group identifiers from which the user will be removed"
      }
    }
  },
  {
    "featureName": "StoreLostPasswordHash",
    "description": "Saves a security hash for password recovery in the system.",
    "inputValues": [
      "email-string-User",
      "hash-string-SecurityHash"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect email (string, mandatory) - User's registered email address\n   - Collect hash (string, mandatory) - System-generated security hash for password recovery\n\n2. Data Validation:\n   - Validate email:\n     a. Check if email is not empty\n     b. Verify email follows valid format (contains @ and domain)\n     c. If validation fails, generate appropriate error message\n   - Validate hash:\n     a. Check if hash is not empty\n     b. Verify hash meets required length and format\n     c. If validation fails, generate appropriate error message\n\n3. Business Rule Processing:\n   - Verify user existence:\n     a. Check if a user with the provided email exists in the system\n     b. IF user does not exist, THEN generate error message and stop processing\n   - Check system state:\n     a. Verify the password recovery system is active\n     b. Ensure no rate limiting or security blocks are in place for this email\n\n4. Core Operation Execution:\n   - Store password recovery information:\n     a. Associate the security hash with the user's email in the system\n     b. Set expiration time for the hash based on system configuration\n     c. IF storage operation fails, THEN generate error and attempt rollback\n     d. Log the password recovery request for security auditing\n\n5. Response Generation:\n   - Success response:\n     a. Generate confirmation of successful hash storage\n     b. Include information about next steps in recovery process\n   - Error response:\n     a. Provide clear error message if operation failed\n     b. Include support information if needed",
    "databaseEntities": [
      "jforum_users"
    ],
    "validationRules": [
      "Email must not be empty",
      "Email must be in valid format",
      "Hash must not be empty",
      "Hash must meet security requirements",
      "User with provided email must exist in the system"
    ],
    "dbSeedingOperations": [],
    "schema": {}
  },
  {
    "featureName": "ValidateLostPasswordHash",
    "description": "Verifies a password recovery security hash to ensure the authenticity of a password reset request.",
    "inputValues": [
      "email-string-User",
      "hash-string-User"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the following required inputs:\n     a. email (string): User's email address used for identification\n     b. hash (string): Security hash generated during password recovery request\n   - Both fields are mandatory for this operation\n\n2. Data Validation:\n   - Validate email format:\n     a. Check if email is not empty\n     b. Verify email follows standard email format (contains @ and domain)\n     c. IF email format is invalid, THEN return validation error\n   - Validate hash format:\n     a. Check if hash is not empty\n     b. Verify hash meets required length and character requirements\n     c. IF hash format is invalid, THEN return validation error\n\n3. Business Rule Processing:\n   - Check user existence:\n     a. Verify that a user account with the provided email exists in the system\n     b. IF no user account is found, THEN return error indicating invalid email\n   - Check hash expiration:\n     a. Verify if the password recovery request is still valid (not expired)\n     b. IF request has expired, THEN return error indicating expired request\n\n4. Core Operation Execution:\n   - Retrieve stored hash:\n     a. Fetch the stored security hash associated with the provided email\n     b. IF no hash is found, THEN return error indicating no active recovery request\n   - Compare hashes:\n     a. Compare the provided hash with the stored hash using secure comparison\n     b. IF hashes do not match, THEN return error indicating invalid hash\n     c. IF hashes match, THEN mark validation as successful\n   - Clear hash after successful validation:\n     a. IF validation is successful, THEN clear the stored hash for security\n     b. This prevents the hash from being reused for multiple password resets\n\n5. Response Generation:\n   - For successful validation:\n     a. Return success status indicating the hash is valid\n     b. Include information that user can proceed with password reset\n   - For failed validation:\n     a. Return failure status with appropriate error message\n     b. Include guidance on how to request a new password recovery if needed",
    "databaseEntities": [
      "jforum_users"
    ],
    "validationRules": [
      "Email must not be empty",
      "Email must be in valid format",
      "Hash must not be empty",
      "Hash must match the stored hash for the given email",
      "Password recovery request must not be expired",
      "User account must exist for the provided email"
    ],
    "dbSeedingOperations": [],
    "schema": {}
  },
  {
    "featureName": "ResetUserPassword",
    "description": "Sets a new password for a user.",
    "inputValues": [
      "email-string-User",
      "newPassword-string-User",
      "confirmPassword-string-User"
    ],
    "businessLogic": "1. Input Collection:\n   1.1. Collect user email (mandatory)\n   1.2. Collect new password (mandatory)\n   1.3. Collect password confirmation (mandatory)\n\n2. Data Validation:\n   2.1. Validate email format\n      2.1.1. Check if email follows standard format (contains @ and domain)\n      2.1.2. IF email format is invalid, THEN display error message\n   2.2. Validate password requirements\n      2.2.1. Check if password meets minimum length requirement\n      2.2.2. Check if password contains required character types (uppercase, lowercase, numbers, special characters)\n      2.2.3. IF password does not meet requirements, THEN display specific error message\n   2.3. Validate password confirmation\n      2.3.1. Check if new password and confirmation password match\n      2.3.2. IF passwords do not match, THEN display error message\n\n3. Business Rule Processing:\n   3.1. Verify user account exists\n      3.1.1. Check if email exists in the system\n      3.1.2. IF email not found, THEN display error message about invalid email\n   3.2. Check user account status\n      3.2.1. Verify user account is active\n      3.2.2. Verify user account is not deleted\n      3.2.3. IF account is inactive or deleted, THEN display appropriate error message\n\n4. Core Operation Execution:\n   4.1. Generate password hash\n      4.1.1. Apply secure hashing algorithm to the new password\n      4.1.2. IF hashing fails, THEN display system error message\n   4.2. Update user password\n      4.2.1. Store new hashed password in the user record\n      4.2.2. Record password change timestamp\n      4.2.3. IF password update fails, THEN display system error message and maintain old password\n   4.3. Clear any existing password reset tokens\n      4.3.1. Remove any stored lost password hash for this user\n      4.3.2. IF token removal fails, log the issue but continue\n\n5. Response Generation:\n   5.1. Generate success response\n      5.1.1. Display confirmation message that password was successfully changed\n      5.1.2. Provide instructions for using the new password\n   5.2. Notify user (optional)\n      5.2.1. Send confirmation email about password change\n      5.2.2. Include security information (time, date of change)\n      5.2.3. IF notification fails, log the issue but consider operation successful",
    "databaseEntities": [
      "jforum_users"
    ],
    "validationRules": [
      "Email must be in valid format",
      "Email must exist in the system",
      "New password must meet minimum security requirements",
      "New password and confirmation password must match",
      "User account must be active",
      "User account must not be deleted"
    ],
    "dbSeedingOperations": [],
    "schema": {}
  },
  {
    "featureName": "GetUsernameByEmail",
    "description": "Retrieves a username associated with an email address.",
    "inputValues": [
      "email-string-User"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect email address (string, mandatory)\n   - No default values\n   - No system-generated fields\n\n2. Data Validation:\n   - Validate email address:\n     a. Check if email is not null or empty\n     b. Verify email format contains '@' character and proper domain structure\n     c. If validation fails, prepare appropriate error message\n\n3. Business Rule Processing:\n   - Check system availability\n   - Verify user database access permissions\n   - IF email contains special characters that could be used for injection attacks, THEN sanitize the input\n\n4. Core Operation Execution:\n   - Search for user record in the system using the provided email address\n   - IF user record is found:\n     a. Extract the username from the user record\n     b. Prepare success response with the username\n   - ELSE IF user record is not found:\n     a. Prepare response indicating no matching user was found\n     b. Log the failed lookup attempt\n\n5. Response Generation:\n   - IF operation was successful:\n     a. Return the username as a string\n     b. Include operation status (success)\n   - ELSE:\n     a. Return empty string or null value\n     b. Include operation status (failed)\n     c. Include appropriate error message\n     d. Provide guidance on next steps (e.g., \"Check if email is registered\")",
    "databaseEntities": [
      "jforum_users"
    ],
    "validationRules": [
      "Email must not be empty",
      "Email must be in valid format",
      "Email must be properly sanitized to prevent injection attacks"
    ],
    "dbSeedingOperations": [],
    "schema": {}
  },
  {
    "featureName": "ValidateActivationKey",
    "description": "Verifies an account activation key against the stored hash to authenticate user activation requests.",
    "inputValues": [
      "userId-number-User",
      "activationKey-string-User"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect userId (number, mandatory) - The unique identifier of the user account\n   - Collect activationKey (string, mandatory) - The activation key provided by the user\n\n2. Data Validation:\n   - Validate userId:\n     a. Verify userId is not null or empty\n     b. Verify userId is a positive integer\n     c. If validation fails, return error message indicating invalid user identifier\n   - Validate activationKey:\n     a. Verify activationKey is not null or empty\n     b. Verify activationKey follows the expected format/pattern\n     c. If validation fails, return error message indicating invalid activation key\n\n3. Business Rule Processing:\n   - Verify user account exists:\n     a. Check if a user with the provided userId exists in the system\n     b. If user does not exist, return error message indicating user not found\n   - Verify user account status:\n     a. Check if the user account is pending activation\n     b. If account is already active, return message indicating account is already activated\n     c. If account is deleted or suspended, return appropriate error message\n\n4. Core Operation Execution:\n   - Compare activation keys:\n     a. Retrieve the stored activation key hash for the specified userId\n     b. Compare the provided activationKey with the stored hash\n     c. IF keys match:\n        i. Mark the validation as successful\n     d. ELSE:\n        i. Mark the validation as failed\n   - Handle validation result:\n     a. IF validation successful:\n        i. Update user account status to active\n        ii. Clear the activation key hash from the system\n     b. ELSE:\n        i. Log failed activation attempt\n        ii. Increment failed attempt counter if applicable\n\n5. Response Generation:\n   - Generate success response:\n     a. IF validation successful:\n        i. Return success status\n        ii. Include message confirming account activation\n        iii. Include any next steps for the user\n     b. ELSE:\n        i. Return failure status\n        ii. Include error message explaining the validation failure\n        iii. Include guidance on how to proceed (request new activation key, contact support)",
    "databaseEntities": [
      "jforum_users"
    ],
    "validationRules": [
      "User ID must be a valid positive integer",
      "Activation key must not be empty",
      "User must exist in the system",
      "User account must be pending activation",
      "Provided activation key must match the stored hash"
    ],
    "dbSeedingOperations": [],
    "schema": {}
  },
  {
    "featureName": "ActivateUserAccount",
    "description": "Sets a user account to active status.",
    "inputValues": [
      "userId-number-User",
      "activationKey-string-User"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect userId (number, mandatory) - The unique identifier of the user account to activate\n   - Collect activationKey (string, mandatory) - The activation key provided to the user\n   - System will use current timestamp (system-generated) for activation date\n\n2. Data Validation:\n   - Validate userId:\n      * Ensure userId is a positive integer\n      * Verify userId exists in the system\n      * If validation fails, generate appropriate error message\n   - Validate activationKey:\n      * Ensure activationKey is not empty\n      * Ensure activationKey follows the required format\n      * If validation fails, generate appropriate error message\n\n3. Business Rule Processing:\n   - Check if user account exists:\n      * IF user account does not exist, THEN return error message\n   - Check if user account is already active:\n      * IF user account is already active, THEN return appropriate message\n   - Validate activation key against stored hash:\n      * Retrieve stored activation key hash for the user\n      * Compare provided activationKey with stored hash\n      * IF keys do not match, THEN return error message about invalid activation key\n\n4. Core Operation Execution:\n   - Set user account status to active:\n      * Update user record to mark account as active\n      * Set activation date to current timestamp\n      * Clear activation key hash from user record (optional security measure)\n   - Update related user permissions:\n      * Apply default active user permissions if applicable\n   - IF any operation fails:\n      * Revert any partial changes\n      * Log the failure details\n      * Return appropriate error message\n\n5. Response Generation:\n   - For successful activation:\n      * Generate success message confirming account activation\n      * Include next steps for the user (e.g., login instructions)\n      * Provide support contact information if needed\n   - For failed activation:\n      * Return specific error message based on the failure reason\n      * Provide guidance on how to resolve the issue\n      * Include support contact information",
    "databaseEntities": [
      "jforum_users",
      "jforum_user_groups"
    ],
    "validationRules": [
      "User ID must exist in the system",
      "Activation key must match the stored hash for the user",
      "User account must not be already active"
    ],
    "dbSeedingOperations": [],
    "schema": {}
  },
  {
    "featureName": "UpdateUsername",
    "description": "Changes the username for an existing user.",
    "inputValues": [
      "userId-number-User",
      "username-string-User"
    ],
    "businessLogic": "1. Input Collection\n   - Collect the following inputs:\n     a. userId (number, mandatory): The unique identifier of the user whose username needs to be updated\n     b. username (string, mandatory): The new username to be assigned to the user\n     c. currentUsername (string, system-generated): The existing username of the user\n\n2. Data Validation\n   - Validate userId:\n     a. Verify userId is a positive integer\n     b. IF userId is not a positive integer, THEN\n        i. Generate error message: \"User ID must be a positive integer\"\n        ii. Return validation error\n   - Validate new username:\n     a. Verify username is not empty\n     b. IF username is empty, THEN\n        i. Generate error message: \"Username cannot be empty\"\n        ii. Return validation error\n     c. Verify username length is between 3 and 25 characters\n     d. IF username length is invalid, THEN\n        i. Generate error message: \"Username must be between 3 and 25 characters long\"\n        ii. Return validation error\n     e. Verify username contains only allowed characters (alphanumeric, underscore)\n     f. IF username contains invalid characters, THEN\n        i. Generate error message: \"Username can only contain letters, numbers, and underscores\"\n        ii. Return validation error\n\n3. Business Rule Processing\n   - Verify user exists:\n     a. Check if a user with the provided userId exists in the system\n     b. IF user does not exist, THEN\n        i. Generate error message: \"User not found\"\n        ii. Return business rule error\n   - Verify username uniqueness:\n     a. Check if the new username is already registered in the system\n     b. IF username is already registered (by another user), THEN\n        i. Generate error message: \"Username already taken\"\n        ii. Return business rule error\n   - Verify username change:\n     a. Retrieve current username for the user\n     b. Compare new username with current username\n     c. IF usernames are identical, THEN\n        i. Generate notification: \"No changes detected - new username is the same as current username\"\n        ii. Return early with no changes made\n\n4. Core Operation Execution\n   - Update username:\n     a. Store the previous username for audit purposes\n     b. Update the user record with the new username\n     c. IF update operation fails, THEN\n        i. Generate error message: \"Failed to update username\"\n        ii. Revert any partial changes\n        iii. Return operation error\n   - Update related records:\n     a. Identify any system records that reference the username directly\n     b. Update those references to maintain system integrity\n     c. IF related updates fail, THEN\n        i. Generate error message: \"Failed to update username references\"\n        ii. Revert all changes\n        iii. Return operation error\n\n5. Response Generation\n   - Success response:\n     a. Generate success message: \"Username successfully updated from [oldUsername] to [newUsername]\"\n     b. Include user identifier in response\n     c. Include timestamp of the update\n   - Error response:\n     a. Include specific error message from the failed step\n     b. Include error code for tracking\n     c. Include suggestions for resolving common errors",
    "databaseEntities": [
      "jforum_users",
      "jforum_posts",
      "jforum_topics",
      "jforum_privmsgs"
    ],
    "validationRules": [
      "User ID must be a positive integer",
      "Username cannot be empty",
      "Username must be between 3 and 25 characters long",
      "Username can only contain letters, numbers, and underscores",
      "Username must not already be registered by another user",
      "User must exist in the system"
    ],
    "dbSeedingOperations": [],
    "schema": {}
  },
  {
    "featureName": "CheckUsernameChanged",
    "description": "Verifies if a username differs from the one in the database.",
    "inputValues": [
      "userId-number-User",
      "usernameToCheck-string-User"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the following inputs:\n     a. userId (number, mandatory): The unique identifier of the user\n     b. usernameToCheck (string, mandatory): The username to compare against the database\n\n2. Data Validation:\n   - Validate userId:\n     a. Ensure userId is a positive integer\n     b. Ensure userId is not null or undefined\n     c. Return appropriate error message if validation fails\n   - Validate usernameToCheck:\n     a. Ensure usernameToCheck is not null or empty\n     b. Ensure usernameToCheck follows username format rules (alphanumeric with allowed special characters)\n     c. Return appropriate error message if validation fails\n\n3. Business Rule Processing:\n   - Check system state:\n     a. Verify the system is operational and database is accessible\n     b. Verify the user has appropriate permissions to perform this check\n   - Verify dependencies:\n     a. Ensure the user record exists in the database\n     b. IF user record does not exist, THEN return appropriate error message\n\n4. Core Operation Execution:\n   - Retrieve current username:\n     a. Fetch the current username from the database using the provided userId\n     b. IF retrieval fails, THEN log the error and return appropriate error message\n   - Compare usernames:\n     a. Compare the retrieved username with the usernameToCheck parameter\n     b. IF usernames are identical (case-sensitive comparison), THEN set result to false\n     c. IF usernames are different, THEN set result to true\n   - Handle edge cases:\n     a. IF retrieved username is null or empty, THEN log warning and return appropriate error message\n\n5. Response Generation:\n   - Success response:\n     a. Return boolean result indicating whether username has changed\n     b. Include status code indicating successful operation\n   - Error response:\n     a. Include appropriate error code and message\n     b. Include guidance on how to resolve the issue\n     c. Log detailed error information for system administrators",
    "databaseEntities": [
      "jforum_users"
    ],
    "validationRules": [
      "User ID must be a positive integer",
      "Username to check must not be empty",
      "Username to check must follow username format rules",
      "User must exist in the database"
    ],
    "dbSeedingOperations": [],
    "schema": {}
  },
  {
    "featureName": "SaveUserAuthHash",
    "description": "Stores a user-specific security hash in the system.",
    "inputValues": [
      "userId-number-User",
      "hash-string-User"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect userId (number, mandatory)\n   - Collect hash (string, mandatory)\n   - No default values are provided\n\n2. Data Validation:\n   - Validate userId:\n      * Verify userId is a positive integer\n      * Verify userId exists in the system\n      * If validation fails, generate appropriate error message\n   - Validate hash:\n      * Verify hash is not empty\n      * Verify hash meets security requirements (proper format and length)\n      * If validation fails, generate appropriate error message\n\n3. Business Rule Processing:\n   - Verify system is in a valid state for updating user security information\n   - Check if user account is active\n   - Verify user has appropriate permissions for security hash updates\n   - IF user is deleted or inactive THEN\n      * Generate appropriate error message\n      * Abort operation\n   - END IF\n\n4. Core Operation Execution:\n   - Locate user record using userId\n   - Update the security hash field for the specified user\n   - IF update operation fails THEN\n      * Log the failure reason\n      * Revert any partial changes\n      * Generate appropriate error message\n   - END IF\n   - Commit the changes to the database\n\n5. Response Generation:\n   - IF operation is successful THEN\n      * Generate success response indicating hash was saved\n      * Include confirmation of the operation\n   - ELSE\n      * Generate error response with appropriate details\n      * Include guidance on resolving the issue\n   - END IF",
    "databaseEntities": [
      "jforum_users"
    ],
    "validationRules": [
      "User ID must be a positive integer",
      "User ID must exist in the system",
      "Security hash must not be empty",
      "Security hash must meet security format requirements",
      "User account must be active"
    ],
    "dbSeedingOperations": [],
    "schema": {}
  },
  {
    "featureName": "GetUserAuthHash",
    "description": "Retrieves a user's security hash from the system.",
    "inputValues": [
      "userId-number-User"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the userId (number) - mandatory\n\n2. Data Validation:\n   - Validate userId:\n     a. Check if userId is provided\n     b. Verify userId is a positive integer\n     c. If validation fails, generate appropriate error message\n\n3. Business Rule Processing:\n   - Verify user exists in the system:\n     a. Check if a user record exists with the provided userId\n     b. If user does not exist, prepare error response\n     c. If user exists, proceed to next step\n\n4. Core Operation Execution:\n   - Retrieve user authentication hash:\n     a. Access user security information storage\n     b. Locate the authentication hash associated with the provided userId\n     c. If hash is not found, set result to empty or null value\n     d. If hash is found, prepare it for return\n\n5. Response Generation:\n   - Success response:\n     a. Return the retrieved authentication hash\n     b. Include status indicating successful operation\n   - Error response:\n     a. Return appropriate error message based on failure point\n     b. Include error code and description\n     c. Provide guidance for resolution if applicable",
    "databaseEntities": [
      "jforum_users"
    ],
    "validationRules": [
      "User ID must be a positive integer",
      "User ID must correspond to an existing user in the system"
    ],
    "dbSeedingOperations": [],
    "schema": {}
  },
  {
    "featureName": "ListPendingActivations",
    "description": "Retrieves users who haven't activated their accounts.",
    "inputValues": [],
    "businessLogic": "1. Input Collection:\n   - No user inputs required for this feature\n   - System will use current system state to determine pending activations\n\n2. Data Validation:\n   - Verify system has proper access to user data\n   - Validate that user activation status is properly tracked in the system\n   - IF access validation fails, THEN\n     - Generate appropriate system error\n     - Log access failure\n     - End process\n\n3. Business Rule Processing:\n   - Check system configuration for activation requirements\n   - Determine if any activation expiration rules should be applied\n   - IF activation feature is disabled in system settings, THEN\n     - Return empty result set\n     - Log feature usage attempt\n     - End process\n\n4. Core Operation Execution:\n   - Retrieve all user records from the system\n   - Filter users based on activation status\n     - Include only users where activation status is pending/false\n     - Exclude deleted or disabled accounts\n   - Sort results by registration date (newest first)\n   - Apply any system-defined limits on result set size\n   - IF no pending activations found, THEN\n     - Return empty result set\n   - ELSE\n     - Prepare user records for display\n     - Include only necessary user information fields\n     - Mask sensitive data according to system security policies\n\n5. Response Generation:\n   - Format list of pending activation users\n   - Include relevant user details for each entry:\n     - User identifier\n     - Username\n     - Registration date\n     - Email address (if permitted by security settings)\n     - Days pending since registration\n   - Return formatted list to requesting system\n   - Log successful retrieval of pending activations",
    "databaseEntities": [
      "jforum_users",
      "jforum_user_groups"
    ],
    "validationRules": [
      "System must have proper access permissions to user data",
      "Only non-activated user accounts should be included in results",
      "Deleted users must be excluded from results",
      "User activation status must be properly tracked in the system"
    ],
    "dbSeedingOperations": [],
    "schema": {}
  },
  {
    "featureName": "FindUserByEmail",
    "description": "Locates a user by their email address.",
    "inputValues": [
      "email-string-User"
    ],
    "businessLogic": "1. Input Collection\n   - Collect the email address (string) from the user\n   - Email is a mandatory field\n\n2. Data Validation\n   - Validate email format\n     - Check if the email follows standard email format (contains @ and domain)\n     - Ensure email is not empty\n     - Ensure email length is within acceptable limits\n   - IF validation fails THEN\n     - Generate appropriate error message indicating invalid email format\n     - Return error response\n\n3. Business Rule Processing\n   - Check system access permissions\n     - Verify if the current user has permission to search for users by email\n   - IF user lacks permission THEN\n     - Generate access denied error\n     - Return error response\n\n4. Core Operation Execution\n   - Search for user with the provided email address\n     - Look up user records matching the exact email address (case-insensitive)\n     - IF user is found THEN\n       - Retrieve complete user information including:\n         * User ID\n         * Username\n         * Email address\n         * Account status (active/deleted)\n         * Registration information\n     - ELSE\n       - Set user as null\n\n5. Response Generation\n   - IF user was found THEN\n     - Return success response with user information\n       - Include user ID, username, email, and other non-sensitive user details\n   - ELSE\n     - Return appropriate response indicating no user was found with the provided email\n     - Include suggestion to verify the email address and try again",
    "databaseEntities": [
      "jforum_users"
    ],
    "validationRules": [
      "Email must not be empty",
      "Email must follow standard email format",
      "User must have permission to search users by email"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "User": {
        "id": "number",
        "username": "string",
        "email": "string",
        "registrationDate": "date",
        "active": "boolean",
        "deleted": "number"
      }
    }
  },
  {
    "featureName": "UpdateUserSession",
    "description": "Updates an existing user session information in the database.",
    "inputValues": [
      "userSession-object-UserSession",
      "connection-object-Connection"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect UserSession object with session data\n     - Session ID (mandatory)\n     - User ID (mandatory)\n     - Start time (mandatory)\n     - Session time (system calculated)\n   - Collect database Connection object (mandatory)\n\n2. Data Validation:\n   - Validate UserSession object\n     - Verify Session ID is not null or empty\n     - Verify User ID is a valid positive integer\n     - Verify Start time is a valid date/time value\n   - Validate Connection object is active and valid\n   - IF any validation fails THEN\n     - Generate appropriate validation error message\n     - Terminate the update process\n\n3. Business Rule Processing:\n   - Check if session exists in the system\n     - Query the database using User ID to find existing session\n     - IF session does not exist THEN\n       - Create a new session record instead\n       - Skip to step 4b (Add Operation)\n     - ELSE\n       - Proceed with update operation\n   - Verify session data integrity\n     - Ensure timestamps are logically consistent\n     - Verify session belongs to the specified user\n\n4. Core Operation Execution:\n   - Prepare session data for update\n     - Format timestamp for database storage\n     - Calculate session duration if needed\n   - Update session record in database\n     - Use prepared statement with session parameters\n     - Set updated start time\n     - Set updated session time\n     - Filter by session ID and user ID\n     - Execute update operation\n     - IF update operation fails THEN\n       - Attempt to rollback changes if applicable\n       - Generate update failure error\n       - Terminate the update process\n   - 4b. Add Operation (if session doesn't exist)\n     - Create new session record with provided data\n     - Execute insert operation\n     - IF insert operation fails THEN\n       - Generate insert failure error\n       - Terminate the process\n\n5. Response Generation:\n   - IF update/insert successful THEN\n     - Return success status\n     - Include updated session information if needed\n   - ELSE\n     - Include detailed error information\n     - Provide error code and message",
    "databaseEntities": [
      "jforum_sessions"
    ],
    "validationRules": [
      "Session ID must not be empty",
      "User ID must be a valid positive integer",
      "Start time must be a valid date/time value",
      "Database connection must be valid and active",
      "Session time must be a non-negative value"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "UserSession": {
        "type": "object",
        "properties": {
          "sessionId": {
            "type": "string",
            "description": "Unique identifier for the session"
          },
          "userId": {
            "type": "integer",
            "description": "ID of the user associated with this session"
          },
          "startTime": {
            "type": "string",
            "format": "date-time",
            "description": "Timestamp when the session started"
          },
          "sessionTime": {
            "type": "integer",
            "description": "Duration of the session in milliseconds"
          }
        },
        "required": [
          "sessionId",
          "userId",
          "startTime"
        ]
      },
      "Connection": {
        "type": "object",
        "description": "Database connection object"
      }
    }
  },
  {
    "featureName": "GetUserSessionById",
    "description": "Retrieves a user session from the database by user ID.",
    "inputValues": [
      "userId-number-UserSession"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect userId (mandatory) - The unique identifier of the user whose session is being retrieved\n   - System will determine the connection context for database access\n\n2. Data Validation:\n   - Validate userId:\n     a. Check if userId is provided\n     b. Verify userId is a valid positive number\n     c. IF validation fails, THEN prepare appropriate error message\n\n3. Business Rule Processing:\n   - Check system state:\n     a. Verify system is operational and database is accessible\n     b. Check if user sessions are currently being tracked by the system\n     c. IF system is in maintenance mode, THEN return appropriate notification\n\n4. Core Operation Execution:\n   - Create a session query context:\n     a. Prepare session lookup parameters using the provided userId\n     b. Access the session storage mechanism\n     c. Retrieve session data associated with the userId\n     d. IF no session exists for the userId, THEN record the absence of session data\n\n5. Response Generation:\n   - Process the retrieved session data:\n     a. IF session data was found:\n        i. Format the session information for return\n        ii. Include session metadata (creation time, last activity)\n     b. IF session data was not found:\n        i. Prepare a \"no active session\" response\n   - Return the session information or appropriate notification",
    "databaseEntities": [
      "jforum_sessions",
      "jforum_users"
    ],
    "validationRules": [
      "User ID must be a positive number",
      "User ID must reference an existing user",
      "Session must be associated with the specified user ID"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "UserSession": {
        "userId": "number",
        "sessionId": "string",
        "creationTime": "date",
        "lastAccessTime": "date",
        "isActive": "boolean",
        "ipAddress": "string"
      }
    }
  },
  {
    "featureName": "ExecuteAutoKeysQuery",
    "description": "Executes SQL queries with support for auto-generated keys and retrieves the generated ID.",
    "inputValues": [
      "sqlQuery-string-Query",
      "connection-object-DatabaseConnection",
      "preparedStatement-object-PreparedStatement"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the SQL query to be executed (mandatory)\n   - Obtain database connection (mandatory)\n   - Prepare statement with appropriate configuration (mandatory)\n   - Check auto-generated keys support configuration (system-generated)\n   - Retrieve auto-generated keys query if needed (system-generated or pre-configured)\n\n2. Data Validation:\n   - Validate SQL query is not empty\n     * IF query is empty or null THEN return error\n     * Error message: \"SQL query cannot be empty\"\n   - Validate database connection is active\n     * IF connection is null or closed THEN return error\n     * Error message: \"Valid database connection required\"\n   - Validate prepared statement is properly initialized\n     * IF prepared statement is null THEN return error\n     * Error message: \"Prepared statement must be initialized\"\n\n3. Business Rule Processing:\n   - Determine if system supports auto-generated keys\n     * Check system configuration for auto keys support\n     * IF auto keys are supported THEN use native database key generation\n     * ELSE use custom query to retrieve last generated key\n   - Verify appropriate permissions for query execution\n     * Ensure current user has permission to execute the query\n     * IF permissions are insufficient THEN return error\n     * Error message: \"Insufficient permissions to execute this query\"\n\n4. Core Operation Execution:\n   - Execute the prepared statement\n     * Execute the update operation on the database\n     * IF execution fails THEN handle database exception\n     * Error message: Include specific database error details\n   - Retrieve the generated key\n     * IF auto keys are supported THEN\n       * Get generated keys from the statement\n       * Extract the first key value\n     * ELSE\n       * Execute the auto-generated keys query\n       * Extract the key value from result\n   - Validate key retrieval success\n     * IF key value is invalid (-1) THEN throw exception\n     * Error message: \"Could not obtain the latest generated key\"\n   - Clean up database resources\n     * Close result sets\n     * Close statements if not managed externally\n\n5. Response Generation:\n   - Return the generated key value\n     * Format: Integer representing the new record's ID\n   - IF operation was successful THEN\n     * Return the generated key with success status\n   - ELSE\n     * Return error details with failure status\n     * Include specific error message and suggestion for resolution",
    "databaseEntities": [
      "jforum_users",
      "jforum_groups",
      "jforum_categories",
      "jforum_forums",
      "jforum_topics",
      "jforum_posts",
      "jforum_posts_text",
      "jforum_attachments",
      "jforum_privmsgs",
      "jforum_privmsgs_text",
      "jforum_moderator_groups",
      "jforum_user_groups",
      "jforum_sessions",
      "jforum_smilies",
      "jforum_words",
      "jforum_karma",
      "jforum_bookmarks",
      "jforum_quota_limit",
      "jforum_extension_groups"
    ],
    "validationRules": [
      "SQL query must not be empty",
      "Database connection must be active",
      "Prepared statement must be properly initialized",
      "User must have sufficient permissions to execute the query",
      "Generated key must be a valid positive integer",
      "Database resources must be properly released after operation"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "DatabaseConnection": {
        "type": "object",
        "properties": {
          "status": {
            "type": "string",
            "description": "Connection status (active/closed)"
          },
          "autoCommit": {
            "type": "boolean",
            "description": "Auto-commit setting for the connection"
          }
        }
      },
      "PreparedStatement": {
        "type": "object",
        "properties": {
          "sql": {
            "type": "string",
            "description": "SQL query text"
          },
          "parameters": {
            "type": "array",
            "description": "Query parameters"
          },
          "options": {
            "type": "object",
            "description": "Statement configuration options"
          }
        }
      }
    }
  },
  {
    "featureName": "GetStatementForAutoKeys",
    "description": "Creates prepared statements configured for auto-generated keys based on system configuration.",
    "inputValues": [
      "queryName-string-Query",
      "connection-object-DatabaseConnection"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the following inputs:\n     a. queryName (mandatory): The name of the SQL query to be executed\n     b. connection (optional): The database connection to use\n     c. System configuration (system-generated): Auto-keys support configuration\n\n2. Data Validation:\n   - Validate queryName:\n     a. Check if queryName is not empty or null\n     b. Verify queryName exists in the system's SQL registry\n     c. IF validation fails, THEN return appropriate error message\n   - Validate connection:\n     a. IF connection is not provided, THEN use default system connection\n     b. Check if connection is valid and open\n     c. IF connection is invalid, THEN return appropriate error message\n\n3. Business Rule Processing:\n   - Check system configuration for auto-generated keys support:\n     a. Retrieve auto-keys configuration from system settings\n     b. Determine if the current database supports auto-generated keys\n     c. IF auto-keys are supported, THEN prepare for retrieving generated keys\n     d. IF auto-keys are not supported, THEN prepare for using custom key retrieval query\n\n4. Core Operation Execution:\n   - Create prepared statement based on configuration:\n     a. IF auto-generated keys are supported:\n        i. Create prepared statement with RETURN_GENERATED_KEYS flag\n     b. ELSE:\n        i. Create standard prepared statement\n        ii. Ensure auto-generated keys query is properly configured for later use\n   - Configure the prepared statement:\n     a. Apply the SQL query from system registry using queryName\n     b. Set any additional statement properties as needed\n\n5. Response Generation:\n   - Return the properly configured prepared statement:\n     a. Include information about whether auto-keys are supported\n     b. Include connection information for statement execution\n     c. IF any errors occurred during preparation, THEN provide detailed error information\n     d. Return the prepared statement object for further use",
    "databaseEntities": [],
    "validationRules": [
      "Query name must not be empty or null",
      "Query name must exist in the system's SQL registry",
      "Database connection must be valid and open",
      "System configuration for auto-generated keys must be properly set"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "DatabaseConnection": {
        "type": "object",
        "properties": {
          "isOpen": {
            "type": "boolean",
            "description": "Indicates if the connection is open"
          },
          "isValid": {
            "type": "boolean",
            "description": "Indicates if the connection is valid"
          }
        }
      }
    }
  },
  {
    "featureName": "AddQuotaLimit",
    "description": "Adds a new quota limit for attachments with description, size and type.",
    "inputValues": [
      "description-string-QuotaLimit",
      "size-number-QuotaLimit",
      "type-number-QuotaLimit"
    ],
    "businessLogic": "1. Input Collection\n   - Collect the following required inputs:\n     1.1. description (string): A descriptive name for the quota limit\n     1.2. size (number): The maximum size allowed for attachments in this quota\n     1.3. type (number): The type identifier for this quota limit\n   - All fields are mandatory\n   - No default values are provided\n\n2. Data Validation\n   2.1. Validate description\n       - Check if description is not empty\n       - Check if description length is within acceptable range (3-100 characters)\n       - IF validation fails, THEN return appropriate error message\n   \n   2.2. Validate size\n       - Check if size is a positive number\n       - Check if size is within acceptable range (minimum 1, maximum system-defined limit)\n       - IF validation fails, THEN return appropriate error message\n   \n   2.3. Validate type\n       - Check if type is a valid quota type identifier\n       - Check if type exists in the system\n       - IF validation fails, THEN return appropriate error message\n\n3. Business Rule Processing\n   3.1. Check system state\n       - Verify the system allows creation of new quota limits\n       - Check if user has permission to create quota limits\n       - IF any check fails, THEN return appropriate error message\n   \n   3.2. Check for duplicates\n       - Check if a quota limit with identical description already exists\n       - IF duplicate found, THEN return error indicating duplicate quota limit\n\n4. Core Operation Execution\n   4.1. Create new quota limit record\n       - Prepare the quota limit data with provided inputs\n       - Create a new quota limit record in the system\n       - IF creation fails, THEN handle the error and return appropriate message\n   \n   4.2. Associate with default groups if applicable\n       - IF system is configured to associate new quotas with default groups, THEN\n         - Identify default groups\n         - Create associations between the new quota limit and default groups\n       - IF association fails, THEN log the error but continue\n\n5. Response Generation\n   5.1. Generate success response\n       - Include confirmation message that quota limit was created successfully\n       - Include the details of the created quota limit (id, description, size, type)\n       - Include any relevant next steps or related actions\n   \n   5.2. IF any errors occurred during the process, THEN\n       - Generate appropriate error response\n       - Include specific error details and suggestions for resolution\n       - Provide support information if needed",
    "databaseEntities": [
      "jforum_quota_limit",
      "jforum_extension_groups"
    ],
    "validationRules": [
      "Description must not be empty",
      "Description must be within acceptable length range",
      "Size must be a positive number",
      "Size must be within acceptable range",
      "Type must be a valid quota type identifier",
      "Quota limit description must be unique"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "QuotaLimit": {
        "id": "number",
        "description": "string",
        "size": "number",
        "type": "number"
      }
    }
  },
  {
    "featureName": "UpdateQuotaLimit",
    "description": "Updates an existing quota limit with new description, size and type.",
    "inputValues": [
      "id-number-QuotaLimit",
      "description-string-QuotaLimit",
      "size-number-QuotaLimit",
      "type-number-QuotaLimit"
    ],
    "businessLogic": "1. Input Collection\n   - Collect the following inputs:\n     a) id (mandatory): Unique identifier for the quota limit to be updated\n     b) description (mandatory): New description for the quota limit\n     c) size (mandatory): New size value for the quota limit\n     d) type (mandatory): New type value for the quota limit\n\n2. Data Validation\n   - Validate quota limit ID:\n     a) Verify that ID is a positive integer\n     b) IF ID is missing or invalid THEN\n        - Return error message \"Invalid quota limit ID provided\"\n   - Validate description:\n     a) Verify description is not empty\n     b) Verify description length is within acceptable limits (1-255 characters)\n     c) IF description is invalid THEN\n        - Return error message \"Description must be provided and within 1-255 characters\"\n   - Validate size:\n     a) Verify size is a positive integer\n     b) Verify size is within acceptable range\n     c) IF size is invalid THEN\n        - Return error message \"Size must be a positive number within acceptable range\"\n   - Validate type:\n     a) Verify type is a valid integer representing a supported quota type\n     b) Verify type exists in the system's predefined quota types\n     c) IF type is invalid THEN\n        - Return error message \"Invalid quota type provided\"\n\n3. Business Rule Processing\n   - Verify quota limit existence:\n     a) Check if a quota limit with the provided ID exists in the system\n     b) IF quota limit does not exist THEN\n        - Return error message \"Quota limit with specified ID does not exist\"\n   - Verify system constraints:\n     a) Check if updating this quota limit would conflict with system constraints\n     b) Verify that the quota limit is not currently in use in a way that would make updates problematic\n     c) IF any constraints are violated THEN\n        - Return appropriate error message detailing the constraint violation\n\n4. Core Operation Execution\n   - Update quota limit record:\n     a) Locate the quota limit record using the provided ID\n     b) Update the description field with the new value\n     c) Update the size field with the new value\n     d) Update the type field with the new value\n     e) Save the updated record to the database\n     f) IF update operation fails THEN\n        - Revert any partial changes\n        - Return error message \"Failed to update quota limit\"\n\n5. Response Generation\n   - Generate success response:\n     a) Include confirmation message \"Quota limit updated successfully\"\n     b) Include the updated quota limit details (ID, description, size, type)\n   - Return response to the caller",
    "databaseEntities": [
      "jforum_quota_limit"
    ],
    "validationRules": [
      "Quota limit ID must be a positive integer",
      "Quota limit description must not be empty",
      "Quota limit description must be within 1-255 characters",
      "Quota limit size must be a positive integer",
      "Quota limit type must be a valid quota type identifier",
      "Quota limit with specified ID must exist in the system"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "QuotaLimit": {
        "id": "number",
        "description": "string",
        "size": "number",
        "type": "number"
      }
    }
  },
  {
    "featureName": "CleanGroupQuota",
    "description": "Removes all group quota associations from the database.",
    "inputValues": [],
    "businessLogic": "1. Input Collection:\n   - No user inputs required for this operation\n   - This is a system-level operation that does not require external parameters\n\n2. Data Validation:\n   - Verify system user has appropriate permissions to perform quota management operations\n   - Confirm the operation is being executed in an appropriate system context\n   - Validate that the system is in a state where quota cleaning is allowed\n\n3. Business Rule Processing:\n   - Check if there are any active processes that depend on group quota associations\n   - Verify that removing all group quota associations will not cause system inconsistencies\n   - Determine if any notifications should be generated for affected groups\n\n4. Core Operation Execution:\n   - Begin transaction for data consistency\n   - Execute the group quota cleaning operation:\n     a. Identify all existing group quota associations in the system\n     b. Remove all associations between groups and quota limits\n     c. Ensure all references to group quotas are properly cleared\n   - If any errors occur during the operation:\n     a. Roll back the transaction\n     b. Log the failure details\n     c. Prepare error information for response\n   - If successful, commit the transaction\n\n5. Response Generation:\n   - If operation was successful:\n     a. Generate success confirmation\n     b. Include summary of removed associations (if applicable)\n     c. Provide information about the system's new state\n   - If operation failed:\n     a. Generate appropriate error message\n     b. Include details about what caused the failure\n     c. Provide guidance on how to resolve the issue",
    "databaseEntities": [
      "jforum_quota_limit",
      "jforum_groups"
    ],
    "validationRules": [
      "User must have administrator privileges to clean group quotas",
      "System must not have any operations in progress that depend on group quota associations",
      "Database connection must be available and operational"
    ],
    "dbSeedingOperations": [],
    "schema": {}
  },
  {
    "featureName": "SetGroupQuota",
    "description": "Associates a specific quota limit with a user group.",
    "inputValues": [
      "groupId-number-Group",
      "quotaId-number-QuotaLimit"
    ],
    "businessLogic": "1. Input Collection\n   - Collect the following inputs:\n     1.1. groupId (mandatory): Numeric identifier for the user group\n     1.2. quotaId (mandatory): Numeric identifier for the quota limit to be applied\n\n2. Data Validation\n   - Validate all input fields:\n     2.1. Validate groupId:\n         - Check if groupId is provided\n         - Verify groupId is a positive integer\n         - Verify groupId represents an existing group\n     2.2. Validate quotaId:\n         - Check if quotaId is provided\n         - Verify quotaId is a positive integer\n         - Verify quotaId represents an existing quota limit\n\n3. Business Rule Processing\n   - Check system constraints and conditions:\n     3.1. Verify system permissions:\n         - Confirm the current user has administrative rights to modify group quotas\n     3.2. Check for existing quota assignments:\n         - Determine if the group already has a quota limit assigned\n         - IF a quota is already assigned, prepare to update the existing assignment\n         - ELSE prepare to create a new assignment\n\n4. Core Operation Execution\n   - Process the quota assignment:\n     4.1. IF updating an existing assignment:\n         - Update the group's quota limit with the new quotaId\n     4.2. ELSE creating a new assignment:\n         - Create a new association between the group and quota limit\n     4.3. Record the change in the system:\n         - Update the last modified timestamp\n         - Log the quota assignment action\n     4.4. Handle operation failures:\n         - IF any database operation fails, rollback changes\n         - Generate appropriate error information\n\n5. Response Generation\n   - Generate appropriate response:\n     5.1. For successful operation:\n         - Return success status\n         - Include confirmation message\n         - Include details of the assigned quota (size limit, type)\n     5.2. For failed operation:\n         - Return error status\n         - Include specific error message\n         - Provide guidance on resolving the issue",
    "databaseEntities": [
      "jforum_groups",
      "jforum_quota_limit"
    ],
    "validationRules": [
      "Group ID must be a positive integer",
      "Group ID must reference an existing group",
      "Quota ID must be a positive integer",
      "Quota ID must reference an existing quota limit",
      "User must have administrative permissions to set group quotas"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Group": {
        "id": "number",
        "name": "string",
        "description": "string"
      },
      "QuotaLimit": {
        "id": "number",
        "description": "string",
        "size": "number",
        "type": "number"
      }
    }
  },
  {
    "featureName": "RemoveQuotaLimit",
    "description": "Deletes one or more quota limits from the system.",
    "inputValues": [
      "quotaLimitIds-object-QuotaLimitIds"
    ],
    "businessLogic": "1. Input Collection\n   - Collect the following inputs:\n     - quotaLimitIds (mandatory): Array of quota limit identifiers to be removed\n   - System will process these identifiers to locate and remove the corresponding quota limits\n\n2. Data Validation\n   - Validate quotaLimitIds input:\n     - VERIFY that quotaLimitIds is not null or empty\n     - VERIFY that each ID in quotaLimitIds is a valid numeric value\n     - VERIFY that each ID represents an existing quota limit in the system\n     - IF any validation fails, THEN generate appropriate error message indicating which IDs are invalid\n\n3. Business Rule Processing\n   - Check system constraints:\n     - VERIFY that none of the quota limits to be removed are currently in use by any group\n     - IF any quota limit is in use, THEN generate warning message listing the affected groups\n     - VERIFY that removing these quota limits will not leave the system without any quota limits\n     - IF system would be left without quota limits, THEN generate warning message about potential unlimited uploads\n\n4. Core Operation Execution\n   - Process each quota limit ID:\n     - FOR each ID in the quotaLimitIds array:\n       - Locate the quota limit record with the matching ID\n       - Remove any associations between this quota limit and user groups\n       - Delete the quota limit record from the system\n       - Track successful deletions for reporting\n     - IF any deletion fails:\n       - Record the failure reason\n       - Continue processing remaining IDs\n       - Prepare partial success/failure message\n\n5. Response Generation\n   - Generate appropriate response:\n     - IF all quota limits were successfully removed:\n       - Generate success message indicating the number of quota limits removed\n     - IF some quota limits were removed but others failed:\n       - Generate partial success message indicating which were removed and which failed\n     - IF no quota limits could be removed:\n       - Generate failure message with reasons\n     - Include recommendation for next steps (e.g., view remaining quota limits)",
    "databaseEntities": [
      "jforum_quota_limit"
    ],
    "validationRules": [
      "Quota limit IDs must be valid numeric values",
      "Quota limit IDs must exist in the system",
      "At least one quota limit ID must be provided",
      "Quota limits in use by groups should trigger a warning before removal"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "QuotaLimitIds": {
        "type": "array",
        "items": {
          "type": "string",
          "description": "String representation of quota limit ID"
        }
      }
    }
  },
  {
    "featureName": "SelectQuotaLimit",
    "description": "Retrieves all quota limits configured in the system.",
    "inputValues": [],
    "businessLogic": "1. Input Collection\n   - No user inputs required for this operation\n   - System will retrieve all quota limits from the data store\n\n2. Data Validation\n   - No input validation required as there are no user inputs\n   - System will verify database connection is available\n   - IF database connection is unavailable THEN\n     - Generate appropriate error response\n     - End process\n\n3. Business Rule Processing\n   - Verify user has appropriate permissions to view quota limits\n   - IF user lacks required permissions THEN\n     - Generate access denied error\n     - End process\n   - Prepare data retrieval operation\n\n4. Core Operation Execution\n   - Retrieve all quota limit records from the system\n   - For each quota limit record:\n     - Extract quota limit ID\n     - Extract quota description\n     - Extract quota size value\n     - Extract quota type information\n     - Create quota limit object with extracted data\n     - Add quota limit object to result collection\n   - IF no quota limits exist THEN\n     - Return empty collection\n   - IF error occurs during retrieval THEN\n     - Log error details\n     - Generate appropriate error response\n     - End process\n\n5. Response Generation\n   - Compile list of all quota limit objects\n   - Format response with all quota limits\n   - Return formatted response to caller\n   - IF operation was successful THEN\n     - Include success status in response\n   - ELSE\n     - Include error details in response",
    "databaseEntities": [
      "jforum_quota_limit"
    ],
    "validationRules": [
      "User must have permission to view quota limits",
      "Database connection must be available"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "QuotaLimit": {
        "id": "number",
        "description": "string",
        "size": "number",
        "type": "number"
      }
    }
  },
  {
    "featureName": "SelectQuotaLimitByGroup",
    "description": "Retrieves the quota limit associated with a specific group.",
    "inputValues": [
      "groupId-number-Group"
    ],
    "businessLogic": "1. Input Collection\n   - Collect the following inputs:\n     a. groupId (number, mandatory): The unique identifier of the group\n\n2. Data Validation\n   - Validate the groupId input:\n     a. Check if groupId is provided\n        IF groupId is missing or null THEN\n           Generate an error message: \"Group ID is required\"\n           Exit process\n     b. Verify groupId is a positive integer\n        IF groupId is not a positive integer THEN\n           Generate an error message: \"Group ID must be a positive integer\"\n           Exit process\n\n3. Business Rule Processing\n   - Verify system state requirements:\n     a. Check if the quota limit system is active\n        IF quota limit system is not active THEN\n           Generate a message: \"Quota limit system is not active\"\n           Exit process\n     b. Verify the group exists\n        IF group with provided groupId does not exist THEN\n           Generate an error message: \"Group not found\"\n           Exit process\n\n4. Core Operation Execution\n   - Retrieve quota limit information:\n     a. Search for quota limit record associated with the specified group ID\n     b. IF quota limit record is found THEN\n          Extract quota limit details including:\n          - Quota limit ID\n          - Description\n          - Size limit\n          - Quota type\n     c. IF no quota limit record is found THEN\n          Set quota limit result to null/empty\n\n5. Response Generation\n   - Prepare the response:\n     a. IF quota limit was found THEN\n          Return quota limit information including:\n          - Quota limit ID\n          - Description\n          - Size limit\n          - Quota type\n     b. IF quota limit was not found THEN\n          Return appropriate indication that no quota limit exists for the group\n     c. IF any errors occurred during processing THEN\n          Return error details with appropriate message",
    "databaseEntities": [
      "jforum_quota_limit",
      "jforum_groups"
    ],
    "validationRules": [
      "Group ID must be provided",
      "Group ID must be a positive integer",
      "Group must exist in the system",
      "Quota limit system must be active"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "QuotaLimit": {
        "type": "object",
        "properties": {
          "id": {
            "type": "integer",
            "description": "Unique identifier for the quota limit"
          },
          "description": {
            "type": "string",
            "description": "Description of the quota limit"
          },
          "size": {
            "type": "integer",
            "description": "Size limit value"
          },
          "type": {
            "type": "integer",
            "description": "Type of quota limit"
          }
        }
      }
    }
  },
  {
    "featureName": "SelectGroupsQuotaLimits",
    "description": "Retrieves all group-to-quota-limit mappings in the system.",
    "inputValues": [],
    "businessLogic": "1. Input Collection\n   - No user inputs required for this feature\n   - System will use existing database connection\n\n2. Data Validation\n   - Verify database connection is available\n   - IF database connection is not available THEN\n     - Generate appropriate error message\n     - Terminate process\n   - END IF\n\n3. Business Rule Processing\n   - Verify user has appropriate permissions to view quota limits\n   - IF user lacks required permissions THEN\n     - Generate access denied message\n     - Log access attempt\n     - Terminate process\n   - END IF\n   - Prepare to retrieve group-to-quota-limit mappings\n\n4. Core Operation Execution\n   - Initialize empty collection to store group-quota mappings\n   - Execute query to retrieve all group-to-quota-limit mappings\n   - FOR each record in the query results\n     - Extract group identifier\n     - Extract quota limit identifier\n     - Create mapping between group and quota limit\n     - Add mapping to collection\n   - END FOR\n   - IF no mappings are found THEN\n     - Return empty collection\n   - END IF\n\n5. Response Generation\n   - Format the group-to-quota-limit mappings for presentation\n   - Return the complete collection of mappings\n   - IF any errors occurred during processing THEN\n     - Generate appropriate error message\n     - Include error details for troubleshooting\n   - END IF",
    "databaseEntities": [
      "jforum_groups",
      "jforum_quota_limit"
    ],
    "validationRules": [
      "User must have permission to view quota limits",
      "Database connection must be available",
      "Group IDs must be valid existing groups",
      "Quota limit IDs must be valid existing quota limits"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "GroupQuotaMapping": {
        "type": "object",
        "properties": {
          "groupId": {
            "type": "integer",
            "description": "Identifier for the group"
          },
          "quotaLimitId": {
            "type": "integer",
            "description": "Identifier for the quota limit applied to the group"
          }
        },
        "required": [
          "groupId",
          "quotaLimitId"
        ]
      }
    }
  },
  {
    "featureName": "AddExtensionGroup",
    "description": "Creates a new attachment extension group with permissions and display settings.",
    "inputValues": [
      "name-string-ExtensionGroup",
      "allowFlag-boolean-ExtensionGroup",
      "uploadIcon-string-ExtensionGroup",
      "downloadMode-number-ExtensionGroup"
    ],
    "businessLogic": "1. Input Collection\n   1.1. Collect the following required inputs:\n       - name: The name of the extension group (mandatory)\n       - allowFlag: Boolean indicating if the extension group is allowed (mandatory)\n       - uploadIcon: The icon to display for uploads of this type (optional)\n       - downloadMode: Integer representing the download mode for this extension group (mandatory)\n\n2. Data Validation\n   2.1. Validate extension group name\n       2.1.1. Check if name is not empty\n       2.1.2. Check if name length is within acceptable limits (3-50 characters)\n       2.1.3. IF validation fails, THEN return appropriate error message\n   2.2. Validate allowFlag\n       2.2.1. Ensure allowFlag is a valid boolean value\n       2.2.2. IF validation fails, THEN return appropriate error message\n   2.3. Validate uploadIcon\n       2.3.1. IF uploadIcon is provided, THEN check if it's a valid icon reference\n       2.3.2. IF validation fails, THEN return appropriate error message\n   2.4. Validate downloadMode\n       2.4.1. Check if downloadMode is a valid integer within the allowed range (typically 0-2)\n       2.4.2. IF validation fails, THEN return appropriate error message\n\n3. Business Rule Processing\n   3.1. Check for duplicate extension group names\n       3.1.1. Check if an extension group with the same name already exists\n       3.1.2. IF duplicate found, THEN return error message indicating name must be unique\n   3.2. Verify system permissions\n       3.2.1. Check if the current user has administrator privileges\n       3.2.2. IF user lacks required permissions, THEN return access denied error\n   3.3. Validate icon availability\n       3.3.1. IF uploadIcon is specified, THEN verify the icon exists in the system\n       3.3.2. IF icon not found, THEN return error message or use default icon\n\n4. Core Operation Execution\n   4.1. Create new extension group record\n       4.1.1. Prepare the extension group data structure\n       4.1.2. Set the name field to the provided name\n       4.1.3. Convert allowFlag boolean to appropriate storage format\n       4.1.4. Set the uploadIcon field to the provided icon or default if not specified\n       4.1.5. Set the downloadMode field to the provided value\n       4.1.6. Save the new extension group to the system\n       4.1.7. IF save operation fails, THEN handle the error and provide appropriate message\n   4.2. Generate unique identifier\n       4.2.1. Assign a unique identifier to the newly created extension group\n       4.2.2. Store the identifier with the extension group record\n\n5. Response Generation\n   5.1. Prepare success response\n       5.1.1. Include the newly created extension group ID\n       5.1.2. Include confirmation message that the extension group was created successfully\n       5.1.3. Include any relevant next steps or related actions\n   5.2. Handle error scenarios\n       5.2.1. IF any step in the process failed, THEN include detailed error information\n       5.2.2. Provide guidance on how to resolve common errors\n   5.3. Return final response\n       5.3.1. Return either success response or error response based on operation outcome",
    "databaseEntities": [
      "jforum_extension_groups"
    ],
    "validationRules": [
      "Extension group name must not be empty",
      "Extension group name must be unique",
      "Extension group name must be between 3 and 50 characters",
      "Download mode must be a valid integer within the allowed range",
      "User must have administrator privileges to create extension groups"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "ExtensionGroup": {
        "type": "object",
        "properties": {
          "id": {
            "type": "integer",
            "description": "Unique identifier for the extension group"
          },
          "name": {
            "type": "string",
            "description": "Name of the extension group"
          },
          "allowFlag": {
            "type": "boolean",
            "description": "Flag indicating if the extension group is allowed"
          },
          "uploadIcon": {
            "type": "string",
            "description": "Icon to display for uploads of this type"
          },
          "downloadMode": {
            "type": "integer",
            "description": "Download mode for this extension group"
          }
        },
        "required": [
          "name",
          "allowFlag",
          "downloadMode"
        ]
      }
    }
  },
  {
    "featureName": "RemoveExtensionGroups",
    "description": "Deletes one or more attachment extension groups from the system.",
    "inputValues": [
      "extensionGroupIds-object-StringArray"
    ],
    "businessLogic": "1. Input Collection\n   - Collect the following inputs:\n     a. extensionGroupIds (mandatory): Array of string identifiers for extension groups to be deleted\n\n2. Data Validation\n   - Validate extensionGroupIds input:\n     a. Check if extensionGroupIds is not null\n        IF extensionGroupIds is null THEN\n          Return error: \"Extension group IDs cannot be null\"\n     b. Check if extensionGroupIds array is not empty\n        IF extensionGroupIds array is empty THEN\n          Return error: \"At least one extension group ID must be provided\"\n     c. For each ID in extensionGroupIds:\n        i. Verify the ID is a valid numeric string\n           IF ID is not numeric THEN\n             Return error: \"Invalid extension group ID format: [ID]\"\n        ii. Verify the ID corresponds to an existing extension group\n            IF extension group with ID does not exist THEN\n              Return error: \"Extension group with ID [ID] does not exist\"\n\n3. Business Rule Processing\n   - Check for dependencies:\n     a. For each extension group ID:\n        i. Check if there are any extensions associated with this group\n           IF extensions exist for this group THEN\n             Return warning: \"Extension group [ID] has associated extensions that will also be removed\"\n     b. Check if removing these groups would leave the system without any valid extension groups\n        IF all extension groups would be removed AND no groups would remain THEN\n          Return error: \"Cannot remove all extension groups from the system\"\n\n4. Core Operation Execution\n   - Process deletion of extension groups:\n     a. Begin transaction\n     b. For each ID in extensionGroupIds:\n        i. Delete the extension group record\n        ii. Log the deletion operation with group details\n     c. If any deletion fails:\n        i. Rollback the transaction\n        ii. Return error: \"Failed to delete one or more extension groups\"\n     d. Commit the transaction\n\n5. Response Generation\n   - Generate success response:\n     a. Include count of successfully deleted extension groups\n     b. Include list of deleted extension group IDs\n     c. Include any warnings about associated extensions that were affected\n     d. Return success message: \"Successfully removed [count] extension groups\"",
    "databaseEntities": [
      "jforum_extension_groups"
    ],
    "validationRules": [
      "Extension group IDs must not be null or empty",
      "Extension group IDs must be valid numeric strings",
      "Extension groups to be deleted must exist in the system",
      "System must maintain at least one extension group after deletion"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "StringArray": {
        "type": "array",
        "items": {
          "type": "string"
        },
        "description": "Array of string identifiers for extension groups to be deleted"
      }
    }
  },
  {
    "featureName": "SelectExtensionGroups",
    "description": "Retrieves all attachment extension groups configured in the system.",
    "inputValues": [],
    "businessLogic": "1. Input Collection:\n   - No user inputs required for this operation\n   - System will retrieve all extension groups from the data store\n\n2. Data Validation:\n   - No input validation required as this is a read-only operation\n   - System will verify database connection is available\n   - IF database connection is unavailable THEN\n     - Generate appropriate error message\n     - Terminate operation\n\n3. Business Rule Processing:\n   - Verify user has appropriate permissions to view extension groups\n   - IF user lacks required permissions THEN\n     - Generate access denied message\n     - Log access attempt\n     - Terminate operation\n   - Prepare query parameters for retrieving extension groups\n\n4. Core Operation Execution:\n   - Execute query to retrieve all extension groups\n   - For each extension group record:\n     - Extract group information (ID, name, allow status, upload icon, download mode)\n     - Create extension group object with extracted information\n     - Add extension group object to result collection\n   - IF query execution fails THEN\n     - Generate appropriate error message\n     - Log the failure with relevant details\n     - Terminate operation with failure status\n\n5. Response Generation:\n   - Format the collection of extension groups for presentation\n   - Return the formatted collection to the requester\n   - IF collection is empty THEN\n     - Include appropriate message indicating no extension groups are configured\n   - Include operation status (success)\n   - Include timestamp of retrieval",
    "databaseEntities": [
      "jforum_extension_groups"
    ],
    "validationRules": [
      "User must have permission to view attachment extension groups",
      "Database connection must be available",
      "Extension groups must be properly formatted before returning"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "AttachmentExtensionGroup": {
        "id": "number",
        "name": "string",
        "allow": "boolean",
        "uploadIcon": "string",
        "downloadMode": "number"
      }
    }
  },
  {
    "featureName": "ExtensionsForSecurity",
    "description": "Retrieves file extensions with their security permissions for attachment validation.",
    "inputValues": [],
    "businessLogic": "1. Input Collection:\n   - No user inputs required for this feature\n   - System will use internal database configuration\n\n2. Data Validation:\n   - No input validation required as this is a system query operation\n\n3. Business Rule Processing:\n   3.1. Verify database connection is available\n      - IF database connection is not available THEN\n         - Generate appropriate error message\n         - Exit process\n      - END IF\n\n4. Core Operation Execution:\n   4.1. Retrieve extension security settings\n      - Access extension configuration data from database\n      - For each extension record:\n         - Extract the extension name\n         - Extract the group permission setting\n         - Extract the extension's allow status\n         - Determine final permission status by combining group and extension permissions\n         - IF group permission is restrictive (allow = 0) THEN\n            - Use group permission regardless of extension permission\n         - ELSE\n            - Use extension's own permission setting\n         - END IF\n      - Map each extension to its final permission status (allowed or disallowed)\n\n5. Response Generation:\n   5.1. Format security permissions map\n      - Create a mapping structure with extension names as keys\n      - Set boolean permission values as the corresponding values\n      - Return the complete mapping of extensions to their security permissions\n   5.2. Handle error conditions\n      - IF any database errors occur during processing THEN\n         - Generate appropriate error message\n         - Include relevant error details\n      - END IF",
    "databaseEntities": [
      "jforum_extension_groups",
      "jforum_attachments"
    ],
    "validationRules": [
      "Database connection must be available",
      "Extension records must contain valid permission settings",
      "Extension names must be stored in lowercase format"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "ExtensionSecurity": {
        "type": "object",
        "properties": {
          "extension": {
            "type": "string",
            "description": "The file extension name"
          },
          "allowed": {
            "type": "boolean",
            "description": "Whether the extension is allowed for upload"
          }
        }
      }
    }
  },
  {
    "featureName": "UpdateExtensionGroup",
    "description": "Updates an existing attachment extension group with new settings.",
    "inputValues": [
      "extensionGroupId-number-AttachmentExtensionGroup",
      "name-string-AttachmentExtensionGroup",
      "allow-boolean-AttachmentExtensionGroup",
      "uploadIcon-string-AttachmentExtensionGroup",
      "downloadMode-number-AttachmentExtensionGroup"
    ],
    "businessLogic": "1. Input Collection\n   - Collect the following required inputs:\n     a. Extension group ID (number, mandatory)\n     b. Group name (string, mandatory)\n     c. Allow flag (boolean, mandatory)\n     d. Upload icon path (string, optional)\n     e. Download mode (number, mandatory)\n   - System will retrieve the current extension group data for comparison\n\n2. Data Validation\n   - Validate extension group ID\n     a. Verify the ID is a positive integer\n     b. IF ID is missing or invalid, THEN return error message \"Valid extension group ID is required\"\n   - Validate group name\n     a. Verify name is not empty\n     b. Verify name length is between 3 and 50 characters\n     c. IF name validation fails, THEN return error message \"Group name must be between 3 and 50 characters\"\n   - Validate upload icon\n     a. IF upload icon is provided, THEN verify it follows valid path format\n     b. IF upload icon validation fails, THEN return error message \"Invalid upload icon format\"\n   - Validate download mode\n     a. Verify download mode is a valid option (0, 1, or 2)\n     b. IF download mode is invalid, THEN return error message \"Invalid download mode selected\"\n\n3. Business Rule Processing\n   - Verify extension group exists\n     a. Check if the provided extension group ID exists in the system\n     b. IF extension group does not exist, THEN return error message \"Extension group not found\"\n   - Check for name conflicts\n     a. IF name has changed from original, THEN verify no other extension group has the same name\n     b. IF name conflict exists, THEN return error message \"An extension group with this name already exists\"\n   - Verify user has permission to update extension groups\n     a. Check if current user has administrator privileges\n     b. IF user lacks permission, THEN return error message \"Insufficient permissions to update extension groups\"\n\n4. Core Operation Execution\n   - Prepare extension group data for update\n     a. Create update object with all provided fields\n     b. Format boolean values appropriately (convert to 0/1 if needed)\n   - Update the extension group record\n     a. Update the extension group with new values\n     b. IF update operation fails, THEN log error details and return error message \"Failed to update extension group\"\n   - Update related extensions if necessary\n     a. IF allow status has changed, THEN update affected extensions accordingly\n     b. IF download mode has changed, THEN update related configurations\n\n5. Response Generation\n   - Generate success response\n     a. Include confirmation message \"Extension group updated successfully\"\n     b. Include updated extension group details\n     c. Include timestamp of the update\n   - IF any errors occurred during the process, THEN\n     a. Generate appropriate error response with specific error details\n     b. Include suggestions for resolving the issue\n     c. Provide reference to support resources if needed",
    "databaseEntities": [
      "jforum_extension_groups"
    ],
    "validationRules": [
      "Extension group ID must be a positive integer",
      "Group name must not be empty",
      "Group name must be between 3 and 50 characters",
      "Download mode must be a valid option (0, 1, or 2)",
      "Extension group must exist in the system",
      "Group name must be unique across all extension groups",
      "User must have administrator privileges to update extension groups"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "AttachmentExtensionGroup": {
        "type": "object",
        "properties": {
          "id": {
            "type": "number",
            "description": "Unique identifier for the extension group"
          },
          "name": {
            "type": "string",
            "description": "Name of the extension group"
          },
          "allow": {
            "type": "boolean",
            "description": "Flag indicating if the extension group is allowed"
          },
          "uploadIcon": {
            "type": "string",
            "description": "Path to the upload icon for the extension group"
          },
          "downloadMode": {
            "type": "number",
            "description": "Mode for downloading attachments in this group"
          }
        },
        "required": [
          "id",
          "name",
          "allow",
          "downloadMode"
        ]
      }
    }
  },
  {
    "featureName": "AddExtension",
    "description": "Adds a new file extension with its associated group and permissions.",
    "inputValues": [
      "extension-string-AttachmentExtension",
      "extensionGroupId-number-AttachmentExtensionGroup",
      "comment-string-AttachmentExtension",
      "uploadIcon-string-AttachmentExtension",
      "isAllow-boolean-AttachmentExtension"
    ],
    "businessLogic": "1. Input Collection\n   - Collect the following required inputs:\n     a) extension: The file extension to be added (string, mandatory)\n     b) extensionGroupId: The ID of the extension group to associate with (number, mandatory)\n     c) comment: Description or comment about the extension (string, optional)\n     d) uploadIcon: Icon to display for this extension type (string, optional)\n     e) isAllow: Permission flag to allow/disallow this extension (boolean, mandatory, default: false)\n\n2. Data Validation\n   - Validate extension input:\n     a) IF extension is empty or null THEN\n        - Generate error message: \"Extension name cannot be empty\"\n     b) IF extension does not start with a period THEN\n        - Add a period at the beginning\n     c) Convert extension to lowercase for consistency\n   - Validate extensionGroupId:\n     a) IF extensionGroupId is not provided or invalid THEN\n        - Generate error message: \"A valid extension group must be selected\"\n     b) Verify the extension group exists in the system\n        - IF extension group not found THEN\n           - Generate error message: \"The selected extension group does not exist\"\n   - Validate comment:\n     a) IF comment exceeds maximum length THEN\n        - Truncate or generate error based on system configuration\n   - Validate uploadIcon:\n     a) IF uploadIcon is provided THEN\n        - Verify the icon file exists in the system\n        - IF icon file not found THEN\n           - Use default icon or generate warning\n\n3. Business Rule Processing\n   - Check for extension uniqueness:\n     a) Verify if the extension already exists in the system\n        - IF extension already exists THEN\n           - Generate error message: \"This extension is already registered\"\n   - Check extension group compatibility:\n     a) Verify if the extension is compatible with the selected group\n        - IF incompatible THEN\n           - Generate warning message but allow to proceed\n   - Check system permissions:\n     a) Verify if the current user has permission to add extensions\n        - IF user lacks permission THEN\n           - Generate error message: \"Insufficient permissions to add extensions\"\n\n4. Core Operation Execution\n   - Create new extension record:\n     a) Prepare extension data object with all validated inputs\n     b) Set extension name (converted to lowercase)\n     c) Associate with specified extension group ID\n     d) Set comment/description\n     e) Set upload icon path\n     f) Set permission flag (allow/disallow)\n   - Save extension to database:\n     a) Insert new record in extension storage\n     b) IF insertion fails THEN\n        - Log detailed error information\n        - Generate error message: \"Failed to add extension\"\n        - Roll back any partial changes\n   - Update related security settings:\n     a) Update extension security mappings based on allow flag\n     b) IF security update fails THEN\n        - Log warning but continue process\n\n5. Response Generation\n   - On success:\n     a) Generate success message: \"Extension [extension] has been successfully added\"\n     b) Return the newly created extension details\n     c) Provide link or option to manage extensions\n   - On failure:\n     a) Return appropriate error message from validation or execution steps\n     b) Provide guidance on how to resolve the issue\n     c) Maintain any valid input data for correction attempts",
    "databaseEntities": [
      "jforum_extension_groups",
      "jforum_attachments"
    ],
    "validationRules": [
      "Extension name must not be empty",
      "Extension must be converted to lowercase",
      "Extension group ID must be valid and exist in the system",
      "Extension must be unique in the system",
      "User must have permission to add extensions"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "AttachmentExtension": {
        "type": "object",
        "properties": {
          "extension": {
            "type": "string",
            "description": "The file extension (e.g., .jpg, .pdf)"
          },
          "extensionGroupId": {
            "type": "number",
            "description": "ID of the extension group this extension belongs to"
          },
          "comment": {
            "type": "string",
            "description": "Description or comment about this extension"
          },
          "uploadIcon": {
            "type": "string",
            "description": "Path to the icon representing this extension type"
          },
          "isAllow": {
            "type": "boolean",
            "description": "Flag indicating if this extension is allowed"
          }
        },
        "required": [
          "extension",
          "extensionGroupId",
          "isAllow"
        ]
      },
      "AttachmentExtensionGroup": {
        "type": "object",
        "properties": {
          "id": {
            "type": "number",
            "description": "Unique identifier for the extension group"
          },
          "name": {
            "type": "string",
            "description": "Name of the extension group"
          },
          "allow": {
            "type": "boolean",
            "description": "Flag indicating if this group is allowed"
          },
          "uploadIcon": {
            "type": "string",
            "description": "Default icon for this extension group"
          },
          "downloadMode": {
            "type": "number",
            "description": "Mode for downloading files of this extension group"
          }
        },
        "required": [
          "name",
          "allow"
        ]
      }
    }
  },
  {
    "featureName": "RemoveExtensions",
    "description": "Deletes one or more file extensions from the system.",
    "inputValues": [
      "extensionIds-string-Extension"
    ],
    "businessLogic": "1. Input Collection\n   - Collect the following inputs:\n     - extensionIds: A comma-separated list of extension IDs to be removed (mandatory)\n\n2. Data Validation\n   - Validate the extensionIds input:\n     - Check if extensionIds is not empty\n       IF extensionIds is empty THEN\n         Return error message: \"No extension IDs provided for removal\"\n     - Parse the comma-separated string into an array of IDs\n     - For each ID in the array:\n       - Verify it contains only numeric characters\n       - IF any ID is non-numeric THEN\n         Return error message: \"Invalid extension ID format. All IDs must be numeric\"\n\n3. Business Rule Processing\n   - Check if the extensions exist in the system:\n     - For each extension ID:\n       - Verify the extension exists in the database\n       - IF any extension does not exist THEN\n         Return error message: \"One or more extensions do not exist\"\n   - Check if any extensions are currently in use:\n     - For each extension ID:\n       - Verify the extension is not associated with any attachments\n       - IF any extension is in use THEN\n         Return error message: \"Cannot remove extensions that are currently in use\"\n\n4. Core Operation Execution\n   - Begin removal process:\n     - Start a transaction to ensure data integrity\n     - For each extension ID in the array:\n       - Remove the extension from the system\n       - Log the removal operation with extension details\n     - Commit the transaction if all removals are successful\n     - IF any removal operation fails THEN\n       - Roll back the transaction\n       - Log the failure details\n       - Return error message: \"Failed to remove one or more extensions\"\n\n5. Response Generation\n   - On successful removal:\n     - Generate success response with count of removed extensions\n     - Include list of removed extension IDs\n     - Return success message: \"Successfully removed [count] extensions\"\n   - On failure:\n     - Include detailed error information\n     - Suggest troubleshooting steps\n     - Provide contact information for support if needed",
    "databaseEntities": [
      "jforum_extension_groups"
    ],
    "validationRules": [
      "Extension IDs must not be empty",
      "Extension IDs must be numeric",
      "Extensions must exist in the system before removal",
      "Extensions in use by attachments cannot be removed"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Extension": {
        "id": "number",
        "extension": "string",
        "extensionGroupId": "number",
        "comment": "string",
        "uploadIcon": "string",
        "allow": "boolean"
      }
    }
  },
  {
    "featureName": "SelectExtensions",
    "description": "Retrieves all file extensions configured in the system.",
    "inputValues": [],
    "businessLogic": "1. Input Collection:\n   - No user inputs required for this operation\n   - System will retrieve all configured extensions from the database\n\n2. Data Validation:\n   - Verify database connection is available\n   - Validate that the user has appropriate permissions to view extension data\n   - IF connection is unavailable THEN generate appropriate error\n   - IF user lacks permissions THEN return access denied message\n\n3. Business Rule Processing:\n   - Check if extension data should be filtered based on user role\n   - Determine if additional extension metadata should be included in results\n   - Verify system state allows extension data retrieval\n\n4. Core Operation Execution:\n   - Retrieve all extension records from the database\n   - For each extension record:\n     a. Extract extension details (ID, name, group, comment, icon, etc.)\n     b. Format extension information into appropriate structure\n     c. Add to result collection\n   - IF no extensions are found THEN prepare empty result set\n   - IF error occurs during retrieval THEN prepare error response\n\n5. Response Generation:\n   - Format the complete list of extensions\n   - Include relevant metadata for each extension\n   - Return the formatted extension list to the requester\n   - IF operation failed THEN return appropriate error message with reason",
    "databaseEntities": [
      "jforum_extension_groups",
      "jforum_attachments"
    ],
    "validationRules": [
      "User must have permission to view extension data",
      "Database connection must be available",
      "System must be in operational state"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Extension": {
        "id": "number",
        "extension": "string",
        "extensionGroupId": "number",
        "comment": "string",
        "uploadIcon": "string",
        "allow": "boolean"
      },
      "AttachmentExtension": {
        "id": "number",
        "extension": "string",
        "extensionGroupId": "number",
        "comment": "string",
        "uploadIcon": "string",
        "allow": "boolean",
        "unknown": "boolean"
      }
    }
  },
  {
    "featureName": "UpdateExtension",
    "description": "Updates an existing attachment extension's properties and settings.",
    "inputValues": [
      "extensionId-number-AttachmentExtension",
      "extensionGroupId-number-AttachmentExtension",
      "extension-string-AttachmentExtension",
      "comment-string-AttachmentExtension",
      "uploadIcon-string-AttachmentExtension",
      "allow-boolean-AttachmentExtension"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the following inputs:\n     a) extensionId (mandatory): Unique identifier for the extension to update\n     b) extensionGroupId (mandatory): Group identifier the extension belongs to\n     c) extension (mandatory): File extension string (e.g., \"pdf\", \"jpg\")\n     d) comment (optional): Description of the extension\n     e) uploadIcon (optional): Icon associated with the extension\n     f) allow (mandatory): Boolean flag indicating if the extension is allowed\n\n2. Data Validation:\n   a) Extension ID Validation:\n      - Verify extensionId is provided and is a positive integer\n      - IF extensionId is missing or invalid THEN\n        - Generate error message: \"Valid extension ID is required\"\n      - Verify extension with provided ID exists in the system\n      - IF extension does not exist THEN\n        - Generate error message: \"Extension with specified ID does not exist\"\n   \n   b) Extension String Validation:\n      - Verify extension string is provided and not empty\n      - IF extension string is empty THEN\n        - Generate error message: \"Extension string cannot be empty\"\n      - Verify extension string contains only valid characters (letters, numbers, no spaces)\n      - IF extension contains invalid characters THEN\n        - Generate error message: \"Extension can only contain letters and numbers\"\n      - Convert extension string to lowercase for consistency\n   \n   c) Extension Group Validation:\n      - Verify extensionGroupId is a positive integer\n      - IF extensionGroupId is invalid THEN\n        - Generate error message: \"Valid extension group ID is required\"\n      - Verify the specified extension group exists in the system\n      - IF extension group does not exist THEN\n        - Generate error message: \"Specified extension group does not exist\"\n\n3. Business Rule Processing:\n   a) Extension Uniqueness Check:\n      - Check if another extension with the same name already exists (excluding current extension)\n      - IF duplicate extension exists THEN\n        - Generate error message: \"Another extension with this name already exists\"\n   \n   b) Extension Group Compatibility:\n      - Verify the extension is compatible with the selected extension group\n      - IF extension is incompatible with group THEN\n        - Generate error message: \"This extension type is not compatible with the selected group\"\n   \n   c) System State Validation:\n      - Check if the extension is currently in use by any attachments\n      - IF extension is in use AND allow is being set to false THEN\n        - Generate warning message: \"This extension is currently in use. Disabling it may affect existing attachments\"\n\n4. Core Operation Execution:\n   a) Prepare Extension Update:\n      - Create updated extension object with the following properties:\n        - ID: extensionId\n        - Extension Group ID: extensionGroupId\n        - Extension: lowercase extension string\n        - Comment: provided comment\n        - Upload Icon: provided uploadIcon\n        - Allow: provided allow boolean value\n   \n   b) Update Extension Record:\n      - Update the extension record in the database\n      - IF update operation fails THEN\n        - Generate error message: \"Failed to update extension\"\n        - Log detailed error information\n        - Abort operation\n   \n   c) Update Related Records:\n      - IF extension name has changed THEN\n        - Update any references to this extension in the system\n\n5. Response Generation:\n   a) Success Response:\n      - Generate success message: \"Extension updated successfully\"\n      - Include updated extension details in the response\n   \n   b) Error Response:\n      - IF any errors occurred during the process THEN\n        - Return appropriate error message from validation or execution steps\n        - Include information about which fields need correction",
    "databaseEntities": [
      "jforum_extension_groups",
      "jforum_attachments"
    ],
    "validationRules": [
      "Extension ID must be a positive integer",
      "Extension ID must reference an existing extension",
      "Extension string must not be empty",
      "Extension string must contain only valid characters",
      "Extension group ID must be a positive integer",
      "Extension group ID must reference an existing extension group",
      "Extension name must be unique across the system",
      "Extension must be compatible with the selected extension group"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "AttachmentExtension": {
        "id": "number",
        "extensionGroupId": "number",
        "extension": "string",
        "comment": "string",
        "uploadIcon": "string",
        "allow": "boolean"
      }
    }
  },
  {
    "featureName": "SelectExtensionByName",
    "description": "Retrieves extension information by its name from the system.",
    "inputValues": [
      "extensionName-string-AttachmentExtension"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the extension name (extensionName) as a string\n   - The extension name is mandatory\n   - No default values are provided\n\n2. Data Validation:\n   - Validate the extension name:\n     a. Check if extensionName is not null or empty\n     b. Check if extensionName contains only valid characters\n     c. If validation fails, prepare appropriate error message\n\n3. Business Rule Processing:\n   - Check if the system is configured to handle file extensions\n   - Verify that the extension management feature is enabled\n   - Ensure the user has appropriate permissions to view extension information\n\n4. Core Operation Execution:\n   - Search for the extension in the system database:\n     a. Prepare search parameters using the extension name\n     b. Query the extension repository using the extension name as the search parameter\n     c. IF extension is found:\n        i. Retrieve all extension details including:\n           - Extension ID\n           - Extension name\n           - Associated group ID\n           - Description/comment\n           - Upload icon information\n           - Permission status (allowed/disallowed)\n     d. IF extension is not found:\n        i. Mark the extension as unknown\n        ii. Prepare appropriate response indicating extension was not found\n\n5. Response Generation:\n   - For successful retrieval:\n     a. Format the extension information into a structured response\n     b. Include all extension attributes in the response\n   - For failed retrieval:\n     a. Generate appropriate error message\n     b. Include suggestion for valid extension names if possible\n   - Return the extension information or error message to the caller",
    "databaseEntities": [
      "jforum_extension_groups",
      "jforum_attachments"
    ],
    "validationRules": [
      "Extension name must not be empty",
      "Extension name must contain only valid characters",
      "Extension management feature must be enabled",
      "User must have permission to view extension information"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "AttachmentExtension": {
        "id": "number",
        "extension": "string",
        "extensionGroupId": "number",
        "comment": "string",
        "uploadIcon": "string",
        "allow": "boolean",
        "unknown": "boolean"
      }
    }
  },
  {
    "featureName": "SelectAttachmentsByPostId",
    "description": "Retrieves all attachments associated with a specific post.",
    "inputValues": [
      "postId-number-Post"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect postId (number, mandatory) to identify the post whose attachments need to be retrieved\n   - System will use this postId to query the database\n\n2. Data Validation:\n   - Validate postId:\n     a. Check if postId is provided\n     b. Verify postId is a positive integer\n     c. Generate appropriate error message if validation fails\n\n3. Business Rule Processing:\n   - Verify post existence:\n     a. Check if a post with the given postId exists in the system\n     b. If post doesn't exist, prepare error response indicating invalid post\n   - Verify user permissions:\n     a. Check if the current user has permission to view the post's attachments\n     b. If permission is denied, prepare access denied error response\n\n4. Core Operation Execution:\n   - Retrieve attachments:\n     a. Query the database for all attachments linked to the specified postId\n     b. For each attachment found:\n        i. Retrieve basic attachment information (ID, post ID, private message ID)\n        ii. Retrieve detailed attachment information (filename, size, type, etc.)\n        iii. Retrieve extension information for the attachment\n        iv. Combine all information into a complete attachment record\n     c. If no attachments are found, prepare an empty result list\n     d. If database error occurs during retrieval, prepare appropriate error response\n\n5. Response Generation:\n   - Success scenario:\n     a. Return the list of attachment objects with all their details\n     b. Include metadata such as total count of attachments found\n   - Error scenarios:\n     a. Return appropriate error message for invalid postId\n     b. Return appropriate error message for non-existent post\n     c. Return appropriate error message for permission issues\n     d. Return appropriate error message for database errors",
    "databaseEntities": [
      "jforum_posts",
      "jforum_attachments"
    ],
    "validationRules": [
      "Post ID must be a positive integer",
      "Post must exist in the system",
      "User must have permission to view the post's attachments"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Attachment": {
        "id": "number",
        "postId": "number",
        "privmsgsId": "number",
        "userId": "number",
        "info": {
          "physicalFilename": "string",
          "realFilename": "string",
          "comment": "string",
          "mimetype": "string",
          "filesize": "number",
          "uploadTime": "date",
          "downloadCount": "number",
          "extension": {
            "id": "number",
            "extension": "string",
            "comment": "string",
            "uploadIcon": "string",
            "allow": "boolean",
            "extensionGroupId": "number"
          }
        }
      }
    }
  },
  {
    "featureName": "SelectAttachmentById",
    "description": "Retrieves a specific attachment by its ID from the system.",
    "inputValues": [
      "attachId-number-Attachment"
    ],
    "businessLogic": "1. Input Collection\n   - Collect the attachment ID (attachId) as a numeric value\n   - The attachment ID is mandatory for this operation\n   - No default values are provided; a valid ID must be supplied\n\n2. Data Validation\n   - Validate the attachment ID:\n     a. Verify the attachment ID is not null\n     b. Verify the attachment ID is a positive integer\n     c. Generate appropriate error message if validation fails\n\n3. Business Rule Processing\n   - Verify system access permissions:\n     a. Check if the current user has permission to access attachments\n     b. Verify the attachment exists in the system\n     c. IF attachment does not exist, THEN prepare not-found response\n\n4. Core Operation Execution\n   - Retrieve attachment record:\n     a. Search for the attachment using the provided ID\n     b. IF attachment is found, THEN:\n        i. Retrieve all attachment metadata (file information, comments, etc.)\n        ii. Retrieve associated extension information\n        iii. Combine attachment data with its extension information\n     c. IF attachment is not found, THEN:\n        i. Prepare null or empty result\n\n5. Response Generation\n   - Prepare attachment response:\n     a. IF attachment was found, THEN:\n        i. Format complete attachment information including:\n           - Basic attachment properties (ID, post ID, private message ID)\n           - File information (filename, physical location, size, mimetype)\n           - Extension information\n           - Upload timestamp and download count\n     b. IF attachment was not found, THEN:\n        i. Return null or empty result\n        ii. Include appropriate status information\n     c. Return the formatted attachment data to the caller",
    "databaseEntities": [
      "jforum_attachments",
      "jforum_extension_groups"
    ],
    "validationRules": [
      "Attachment ID must be a valid positive integer",
      "Attachment must exist in the system",
      "User must have permission to access the requested attachment"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Attachment": {
        "id": "number",
        "postId": "number",
        "privmsgsId": "number",
        "info": {
          "comment": "string",
          "downloadCount": "number",
          "filesize": "number",
          "mimetype": "string",
          "physicalFilename": "string",
          "realFilename": "string",
          "uploadTime": "date",
          "extension": {
            "id": "number",
            "extension": "string",
            "comment": "string",
            "uploadIcon": "string",
            "allow": "boolean",
            "extensionGroupId": "number"
          }
        }
      }
    }
  },
  {
    "featureName": "CheckPhysicalDownloadMode",
    "description": "Determines if an extension group uses physical download mode.",
    "inputValues": [
      "extensionGroupId-number-ExtensionGroup"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect extensionGroupId (mandatory, number)\n   - No optional fields or default values required\n   - System will use the extensionGroupId to query the database\n\n2. Data Validation:\n   - Validate extensionGroupId:\n      * Ensure extensionGroupId is a valid integer\n      * Verify extensionGroupId is greater than zero\n      * IF extensionGroupId is invalid or missing THEN\n         - Generate validation error message \"Extension group ID must be a valid positive integer\"\n         - Halt processing and return error\n\n3. Business Rule Processing:\n   - Verify extension group existence:\n      * Check if the provided extensionGroupId exists in the system\n      * IF extension group does not exist THEN\n         - Generate error message \"Extension group not found\"\n         - Halt processing and return error\n\n4. Core Operation Execution:\n   - Query database for download mode setting:\n      * Retrieve download_mode value for the specified extensionGroupId\n      * IF database error occurs during query THEN\n         - Log error details\n         - Generate system error message\n         - Halt processing and return error\n      * Process download mode value:\n         - IF download_mode equals 2 THEN\n            * Set result to TRUE (physical download mode)\n         - ELSE\n            * Set result to FALSE (not physical download mode)\n\n5. Response Generation:\n   - Success response:\n      * Return boolean result indicating if physical download mode is used\n      * Include extensionGroupId in response for reference\n   - Error response:\n      * Return appropriate error message based on failure point\n      * Include error type and description",
    "databaseEntities": [
      "jforum_extension_groups"
    ],
    "validationRules": [
      "Extension group ID must be a valid positive integer",
      "Extension group must exist in the system",
      "Download mode value of 2 indicates physical download mode is used"
    ],
    "dbSeedingOperations": [],
    "schema": {}
  },
  {
    "featureName": "CheckBannerDeletability",
    "description": "Checks if a banner can be deleted based on its ID.",
    "inputValues": [
      "bannerId-number-Banner"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the banner ID (bannerId) as a required numeric input\n   - System will use this ID to check if the banner can be deleted\n\n2. Data Validation:\n   - Validate that bannerId is provided\n     - IF bannerId is missing or null THEN\n       - Return an error message indicating that banner ID is required\n     - END IF\n   - Validate that bannerId is a positive integer\n     - IF bannerId is not a positive integer THEN\n       - Return an error message indicating that banner ID must be a positive integer\n     - END IF\n\n3. Business Rule Processing:\n   - Check if the banner exists in the system\n     - Retrieve banner information using the provided bannerId\n     - IF banner does not exist THEN\n       - Return an error message indicating that the banner was not found\n     - END IF\n   - Check if the banner is referenced by other system components\n     - Verify if the banner is currently in use by any active campaigns\n     - Verify if the banner is referenced in any scheduled promotions\n     - Verify if the banner is part of any active content placement\n     - IF banner is referenced by any system component THEN\n       - Set deletable status to false\n     - ELSE\n       - Set deletable status to true\n     - END IF\n\n4. Core Operation Execution:\n   - Prepare the deletion status result\n     - Create a result object containing:\n       - Banner ID\n       - Deletion status (true if banner can be deleted, false otherwise)\n       - If not deletable, include references to where the banner is being used\n\n5. Response Generation:\n   - Return the deletion status result\n     - IF banner can be deleted THEN\n       - Return success response with deletable status set to true\n     - ELSE\n       - Return success response with deletable status set to false\n       - Include information about where the banner is being used\n     - END IF",
    "databaseEntities": [
      "jforum_banners"
    ],
    "validationRules": [
      "Banner ID must be provided",
      "Banner ID must be a positive integer",
      "Banner must exist in the system to check its deletability",
      "A banner cannot be deleted if it is referenced by other system components"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Banner": {
        "id": "number",
        "name": "string",
        "placement": "number",
        "description": "string",
        "clicks": "number",
        "views": "number",
        "url": "string",
        "weight": "number",
        "active": "boolean",
        "comment": "string",
        "type": "number",
        "width": "number",
        "height": "number"
      }
    }
  },
  {
    "featureName": "AddBookmark",
    "description": "Creates a new bookmark for a user with specified relation and visibility settings.",
    "inputValues": [
      "userId-number-User",
      "relationId-number-Relation",
      "relationType-number-BookmarkType",
      "isPublicVisible-boolean-Bookmark",
      "title-string-Bookmark",
      "description-string-Bookmark"
    ],
    "businessLogic": "1. Input Collection:\n   1.1. Collect the following required inputs:\n       - userId: Identifier of the user creating the bookmark (mandatory)\n       - relationId: Identifier of the item being bookmarked (mandatory)\n       - relationType: Type of bookmark (mandatory) - must be one of the valid bookmark types (forum, topic, or user)\n       - isPublicVisible: Boolean flag indicating if bookmark is visible to other users (mandatory, default: false)\n       - title: Custom title for the bookmark (optional)\n       - description: Custom description for the bookmark (optional)\n\n2. Data Validation:\n   2.1. Validate userId:\n       - IF userId is empty or not a positive integer THEN\n           - Return error: \"Valid user ID is required\"\n   2.2. Validate relationId:\n       - IF relationId is empty or not a positive integer THEN\n           - Return error: \"Valid relation ID is required\"\n   2.3. Validate relationType:\n       - IF relationType is not one of the valid bookmark types (forum, topic, or user) THEN\n           - Return error: \"Invalid bookmark type specified\"\n   2.4. Validate title and description:\n       - IF title exceeds maximum allowed length THEN\n           - Return error: \"Title exceeds maximum allowed length\"\n       - IF description exceeds maximum allowed length THEN\n           - Return error: \"Description exceeds maximum allowed length\"\n\n3. Business Rule Processing:\n   3.1. Check if user exists:\n       - IF user with userId does not exist THEN\n           - Return error: \"User not found\"\n   3.2. Check if relation exists based on relationType:\n       - IF relationType is forum THEN\n           - Verify forum with relationId exists\n           - IF forum does not exist THEN\n               - Return error: \"Forum not found\"\n       - ELSE IF relationType is topic THEN\n           - Verify topic with relationId exists\n           - IF topic does not exist THEN\n               - Return error: \"Topic not found\"\n       - ELSE IF relationType is user THEN\n           - Verify user with relationId exists\n           - IF user does not exist THEN\n               - Return error: \"Referenced user not found\"\n   3.3. Check for duplicate bookmarks:\n       - IF bookmark already exists for this user with same relationId and relationType THEN\n           - Return error: \"Bookmark already exists\"\n\n4. Core Operation Execution:\n   4.1. Create new bookmark record:\n       - Generate new bookmark entry with provided information\n       - Set default values for any missing optional fields:\n           - IF title is empty AND relationType is forum THEN\n               - Use forum name as title\n           - ELSE IF title is empty AND relationType is topic THEN\n               - Use topic title as title\n           - ELSE IF title is empty AND relationType is user THEN\n               - Use username as title\n   4.2. Store bookmark in the system:\n       - Save bookmark record with all provided and default values\n       - IF save operation fails THEN\n           - Rollback any changes\n           - Return error: \"Failed to create bookmark\"\n\n5. Response Generation:\n   5.1. Prepare success response:\n       - Include bookmark ID of newly created bookmark\n       - Include confirmation message: \"Bookmark created successfully\"\n   5.2. Return success response to user",
    "databaseEntities": [
      "jforum_bookmarks",
      "jforum_users",
      "jforum_forums",
      "jforum_topics"
    ],
    "validationRules": [
      "User ID must be a valid positive integer",
      "Relation ID must be a valid positive integer",
      "Relation type must be one of the valid bookmark types (forum, topic, or user)",
      "Title must not exceed maximum allowed length",
      "Description must not exceed maximum allowed length",
      "User must exist in the system",
      "Referenced relation (forum, topic, or user) must exist in the system",
      "Duplicate bookmarks for the same user, relation ID, and relation type are not allowed"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Bookmark": {
        "id": "number",
        "userId": "number",
        "relationId": "number",
        "relationType": "number",
        "isPublicVisible": "boolean",
        "title": "string",
        "description": "string"
      },
      "BookmarkType": {
        "FORUM": "number",
        "TOPIC": "number",
        "USER": "number"
      }
    }
  },
  {
    "featureName": "UpdateBookmark",
    "description": "Updates an existing bookmark's visibility, title and description.",
    "inputValues": [
      "bookmarkId-number-Bookmark",
      "isPublicVisible-boolean-Bookmark",
      "title-string-Bookmark",
      "description-string-Bookmark"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the following inputs:\n     a. bookmarkId (mandatory): Unique identifier of the bookmark to update\n     b. isPublicVisible (mandatory): Boolean flag indicating if bookmark should be visible to other users\n     c. title (mandatory): New title for the bookmark\n     d. description (optional): New description for the bookmark\n\n2. Data Validation:\n   - Validate bookmarkId:\n     a. Check if bookmarkId is provided\n     b. Verify bookmarkId is a positive integer\n     c. IF validation fails, THEN return error message \"Invalid bookmark identifier\"\n   - Validate isPublicVisible:\n     a. Ensure isPublicVisible is a boolean value\n     b. IF validation fails, THEN return error message \"Visibility setting must be true or false\"\n   - Validate title:\n     a. Check if title is provided\n     b. IF title is not provided, THEN return error message \"Title is required\"\n     c. Check title doesn't exceed maximum allowed length\n     d. IF validation fails, THEN return error message \"Title exceeds maximum length\"\n   - Validate description:\n     a. IF description is provided, THEN check it doesn't exceed maximum allowed length\n     b. IF validation fails, THEN return error message \"Description exceeds maximum length\"\n\n3. Business Rule Processing:\n   - Verify bookmark exists:\n     a. Check if a bookmark with the provided bookmarkId exists in the system\n     b. IF bookmark doesn't exist, THEN return error message \"Bookmark not found\"\n   - Verify user permissions:\n     a. Retrieve the user ID associated with the bookmark\n     b. Compare with the ID of the current user\n     c. IF current user is not the owner of the bookmark, THEN return error message \"Not authorized to update this bookmark\"\n   - Check system state:\n     a. Verify the bookmarks feature is enabled in the system\n     b. Verify the user is not anonymous (guest user)\n     c. IF bookmarks feature is disabled, THEN return error message \"Bookmark feature is currently disabled\"\n     d. IF user is anonymous, THEN return error message \"Anonymous users cannot update bookmarks\"\n\n4. Core Operation Execution:\n   - Retrieve the existing bookmark:\n     a. Load the current bookmark data using the bookmarkId\n     b. Verify the bookmark belongs to the current user\n   - Prepare update operation:\n     a. Create update parameters with the provided values\n     b. Sanitize the title and description inputs to prevent security issues\n   - Execute bookmark update:\n     a. Update the bookmark record with new values\n     b. Set public visibility flag based on isPublicVisible input\n     c. Update title with the sanitized title input\n     d. Update description with the sanitized description input\n   - Handle potential failures:\n     a. IF update operation fails, THEN log error details\n     b. Roll back any partial changes\n     c. Return error message \"Failed to update bookmark\"\n\n5. Response Generation:\n   - For successful update:\n     a. Generate success response with confirmation message\n     b. Include updated bookmark details in the response\n     c. Return success message \"Bookmark updated successfully\"\n   - For failed update:\n     a. Include specific error details in the response\n     b. Provide guidance on how to resolve the issue\n     c. Return appropriate error message",
    "databaseEntities": [
      "jforum_bookmarks",
      "jforum_users"
    ],
    "validationRules": [
      "Bookmark ID must be a positive integer",
      "Bookmark must exist in the system",
      "User must be the owner of the bookmark",
      "Public visibility must be a boolean value",
      "Title must not be empty",
      "Title must not exceed maximum allowed length",
      "Description must not exceed maximum allowed length",
      "User must be logged in (not anonymous)",
      "Bookmarks feature must be enabled in the system"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Bookmark": {
        "id": "number",
        "userId": "number",
        "relationId": "number",
        "relationType": "number",
        "isPublicVisible": "boolean",
        "title": "string",
        "description": "string"
      }
    }
  },
  {
    "featureName": "RemoveBookmark",
    "description": "Deletes a bookmark by its ID from the system.",
    "inputValues": [
      "bookmarkId-number-Bookmark"
    ],
    "businessLogic": "1. Input Collection\n   - Collect the following input:\n     1.1. bookmarkId (mandatory): Unique identifier of the bookmark to be removed\n\n2. Data Validation\n   - Validate the bookmark ID:\n     2.1. Check if bookmarkId is provided\n        IF bookmarkId is missing or null THEN\n          Return error message: \"Bookmark ID is required\"\n     2.2. Check if bookmarkId is a valid number\n        IF bookmarkId is not a valid number THEN\n          Return error message: \"Invalid bookmark ID format\"\n     2.3. Check if bookmarkId is positive\n        IF bookmarkId is not positive THEN\n          Return error message: \"Bookmark ID must be a positive number\"\n\n3. Business Rule Processing\n   - Verify bookmark existence and access rights:\n     3.1. Check if the bookmark exists in the system\n        IF bookmark does not exist THEN\n          Return error message: \"Bookmark not found\"\n     3.2. Verify the current user has permission to delete this bookmark\n        IF current user is not the owner of the bookmark AND not an administrator THEN\n          Return error message: \"You do not have permission to delete this bookmark\"\n\n4. Core Operation Execution\n   - Remove the bookmark from the system:\n     4.1. Locate the bookmark record using the provided bookmarkId\n     4.2. Delete the bookmark record from the database\n        IF deletion fails THEN\n          Log the error details\n          Return error message: \"Failed to remove bookmark. Please try again later.\"\n\n5. Response Generation\n   - Generate appropriate response:\n     5.1. IF deletion is successful THEN\n          Return success message: \"Bookmark successfully removed\"\n     5.2. Include information about the deleted bookmark (ID)\n     5.3. Provide navigation options to return to bookmark list",
    "databaseEntities": [
      "jforum_bookmarks"
    ],
    "validationRules": [
      "Bookmark ID must be provided",
      "Bookmark ID must be a valid positive number",
      "Bookmark must exist in the system",
      "User must have permission to delete the bookmark"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Bookmark": {
        "id": "number",
        "userId": "number",
        "relationId": "number",
        "relationType": "number",
        "publicVisible": "boolean",
        "title": "string",
        "description": "string"
      }
    }
  },
  {
    "featureName": "SelectBookmarksByUser",
    "description": "Retrieves all bookmarks for a specific user filtered by relation type.",
    "inputValues": [
      "userId-number-User",
      "relationType-number-BookmarkType"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect userId (mandatory, number): The unique identifier of the user whose bookmarks are being retrieved\n   - Collect relationType (mandatory, number): The type of bookmark relationship to filter by\n     - Valid values are defined in BookmarkType (FORUM, TOPIC, USER)\n\n2. Data Validation:\n   - Validate userId:\n     - IF userId is not provided or not a positive integer THEN\n       - Return error message \"Valid user ID is required\"\n   - Validate relationType:\n     - IF relationType is not provided THEN\n       - Return error message \"Bookmark relation type is required\"\n     - IF relationType is not a valid BookmarkType value THEN\n       - Return error message \"Invalid bookmark relation type\"\n\n3. Business Rule Processing:\n   - Check user existence:\n     - IF user with userId does not exist in the system THEN\n       - Return error message \"User not found\"\n   - Check bookmark type validity:\n     - IF relationType is not one of the defined bookmark types THEN\n       - Return error message \"The specified bookmark type is not supported\"\n\n4. Core Operation Execution:\n   - Determine bookmark retrieval strategy based on relationType:\n     - IF relationType is FORUM THEN\n       - Retrieve forum bookmarks for the specified user\n       - For each bookmark:\n         - If title is empty, use forum_name as title\n         - If description is empty, use forum_desc as description\n     - ELSE IF relationType is TOPIC THEN\n       - Retrieve topic bookmarks for the specified user\n       - For each bookmark:\n         - If title is empty, use topic_title as title\n     - ELSE IF relationType is USER THEN\n       - Retrieve user bookmarks for the specified user\n       - For each bookmark:\n         - If title is empty, use username as title\n     - ELSE\n       - Return error message \"Invalid bookmark type\"\n   - For each bookmark retrieved:\n     - Populate bookmark object with data from database\n     - Add bookmark to result list\n\n5. Response Generation:\n   - IF operation is successful THEN\n     - Return list of bookmarks with the following information for each:\n       - Bookmark ID\n       - Title\n       - Description\n       - Relation ID (the ID of the bookmarked entity)\n       - Relation Type\n       - Public visibility flag\n       - User ID (owner of the bookmark)\n   - IF operation fails THEN\n     - Return appropriate error message based on failure reason",
    "databaseEntities": [
      "jforum_bookmarks",
      "jforum_users",
      "jforum_forums",
      "jforum_topics"
    ],
    "validationRules": [
      "User ID must be a positive integer",
      "Relation type must be a valid bookmark type (FORUM, TOPIC, or USER)",
      "User must exist in the system",
      "Bookmark relation type must be supported by the system"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Bookmark": {
        "id": "number",
        "userId": "number",
        "relationId": "number",
        "relationType": "number",
        "publicVisible": "boolean",
        "title": "string",
        "description": "string"
      },
      "BookmarkType": {
        "FORUM": "number",
        "TOPIC": "number",
        "USER": "number"
      }
    }
  },
  {
    "featureName": "SelectAllUserBookmarks",
    "description": "Retrieves all bookmarks belonging to a specific user regardless of type.",
    "inputValues": [
      "userId-number-User"
    ],
    "businessLogic": "1. Input Collection\n   - Collect userId (mandatory, number) to identify the user whose bookmarks will be retrieved\n\n2. Data Validation\n   - Validate userId:\n     a. Verify userId is not null\n     b. Verify userId is a positive integer\n     c. IF validation fails, THEN generate appropriate error message\n\n3. Business Rule Processing\n   - Verify user exists in the system\n     a. IF user does not exist, THEN return error indicating invalid user\n   - Verify user has permission to access bookmarks\n     a. IF user lacks permission, THEN return access denied error\n\n4. Core Operation Execution\n   - Retrieve all bookmarks associated with the specified userId\n     a. Search for bookmarks where the owner is the specified user\n     b. Include all bookmark types (forum bookmarks, topic bookmarks, user bookmarks)\n     c. For each bookmark found:\n        i. Extract bookmark details (id, title, description, relation type, relation id, etc.)\n        ii. Add to collection of results\n     d. IF no bookmarks are found, THEN return empty collection\n     e. IF error occurs during retrieval, THEN handle exception and return appropriate error\n\n5. Response Generation\n   - Format the bookmark collection for response\n     a. For each bookmark in the collection:\n       i. Include bookmark ID\n       ii. Include bookmark title\n       iii. Include bookmark description\n       iv. Include relation type (forum, topic, or user)\n       v. Include relation ID\n       vi. Include visibility status (public or private)\n   - Return the formatted collection of bookmarks\n   - IF operation was successful but no bookmarks found, THEN return empty collection with success status\n   - IF operation failed, THEN return error details with failure status",
    "databaseEntities": [
      "jforum_bookmarks",
      "jforum_users",
      "jforum_forums",
      "jforum_topics"
    ],
    "validationRules": [
      "User ID must be a positive integer",
      "User must exist in the system",
      "User must have permission to access bookmarks"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Bookmark": {
        "id": "number",
        "userId": "number",
        "relationId": "number",
        "relationType": "number",
        "title": "string",
        "description": "string",
        "publicVisible": "boolean"
      }
    }
  },
  {
    "featureName": "SelectBookmarkById",
    "description": "Retrieves a specific bookmark by its ID.",
    "inputValues": [
      "bookmarkId-number-Bookmark"
    ],
    "businessLogic": "1. Input Collection\n   - Collect the bookmark ID (bookmarkId) as a numeric identifier\n   - The bookmark ID is mandatory and must be provided by the user\n\n2. Data Validation\n   - Validate the bookmark ID\n     - Ensure the bookmark ID is a positive integer\n     - Verify the bookmark ID is not null\n     - IF the bookmark ID is invalid or missing THEN\n       - Generate an appropriate error message\n       - Terminate the process\n\n3. Business Rule Processing\n   - Check system access permissions\n     - Verify the current user has permission to view bookmarks\n     - IF the user lacks necessary permissions THEN\n       - Generate an access denied error\n       - Terminate the process\n   - Verify system availability\n     - Ensure the bookmark service is operational\n     - IF the service is unavailable THEN\n       - Generate a service unavailable error\n       - Terminate the process\n\n4. Core Operation Execution\n   - Query the bookmark repository\n     - Search for a bookmark with the specified ID\n     - IF no bookmark is found with the given ID THEN\n       - Set the result to null or empty\n     - ELSE\n       - Retrieve the complete bookmark information including:\n         - Bookmark ID\n         - User ID (owner)\n         - Relation ID (referenced item)\n         - Relation type (forum, topic, or user)\n         - Title\n         - Description\n         - Public visibility flag\n   - Process the retrieved bookmark\n     - Format the bookmark data for presentation\n     - Prepare any additional context information needed\n\n5. Response Generation\n   - Prepare the response\n     - IF the bookmark was found THEN\n       - Include the complete bookmark details in the response\n       - Include any related metadata needed for display\n     - ELSE\n       - Include appropriate not-found status in the response\n   - Return the response to the caller\n     - Format the response according to the system's requirements\n     - Include any necessary status information",
    "databaseEntities": [
      "jforum_bookmarks",
      "jforum_users",
      "jforum_forums",
      "jforum_topics"
    ],
    "validationRules": [
      "Bookmark ID must be a positive integer",
      "Bookmark ID must exist in the system",
      "User must have permission to view the requested bookmark"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Bookmark": {
        "id": "number",
        "userId": "number",
        "relationId": "number",
        "relationType": "number",
        "title": "string",
        "description": "string",
        "publicVisible": "boolean"
      }
    }
  },
  {
    "featureName": "SelectBookmarkForUpdate",
    "description": "Finds a bookmark by relation ID, type and user ID for updating.",
    "inputValues": [
      "relationId-number-Bookmark",
      "relationType-number-BookmarkType",
      "userId-number-User"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the following required inputs:\n     a. relationId (number): The identifier of the related entity (forum, topic, or user)\n     b. relationType (number): The type of bookmark (forum, topic, or user)\n     c. userId (number): The identifier of the user who owns the bookmark\n\n2. Data Validation:\n   - Validate relationId:\n     a. Verify relationId is a positive integer\n     b. IF relationId is missing or invalid, THEN return an error message\n   - Validate relationType:\n     a. Verify relationType is a valid bookmark type value\n     b. IF relationType is not a recognized type, THEN return an error message\n   - Validate userId:\n     a. Verify userId is a positive integer\n     b. IF userId is missing or invalid, THEN return an error message\n\n3. Business Rule Processing:\n   - Verify system access permissions:\n     a. Confirm the current user has permission to access bookmark data\n     b. IF user lacks permission, THEN return an access denied error\n   - Verify bookmark type validity:\n     a. Check if the provided relationType corresponds to a valid bookmark category\n     b. IF relationType is invalid, THEN return an invalid bookmark type error\n\n4. Core Operation Execution:\n   - Search for bookmark record:\n     a. Query the bookmark repository using the three parameters (relationId, relationType, userId)\n     b. Retrieve the matching bookmark record if it exists\n     c. IF no matching bookmark is found, THEN return a null or not found response\n     d. IF multiple records are found (data integrity issue), THEN log an error and return the first record\n   - Prepare bookmark data for update:\n     a. Retrieve all bookmark attributes including id, title, description, and visibility settings\n     b. Format the data in a structure suitable for updating\n\n5. Response Generation:\n   - Success response:\n     a. Return the complete bookmark object with all attributes populated\n     b. Include metadata such as creation date and last update timestamp if available\n   - Error response:\n     a. For validation errors, return specific error messages indicating which parameter failed\n     b. For permission errors, return appropriate access denied message\n     c. For not found scenario, return clear indication that the bookmark does not exist",
    "databaseEntities": [
      "jforum_bookmarks",
      "jforum_users",
      "jforum_topics",
      "jforum_forums"
    ],
    "validationRules": [
      "Relation ID must be a positive integer",
      "Relation type must be a valid bookmark type (forum, topic, or user)",
      "User ID must be a positive integer and correspond to an existing user",
      "The combination of relation ID, relation type, and user ID must identify a unique bookmark"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Bookmark": {
        "id": "number",
        "userId": "number",
        "relationId": "number",
        "relationType": "number",
        "title": "string",
        "description": "string",
        "publicVisible": "boolean"
      },
      "BookmarkType": {
        "FORUM": "number",
        "TOPIC": "number",
        "USER": "number"
      }
    }
  },
  {
    "featureName": "SelectCategoryById",
    "description": "Retrieves a forum category by its unique identifier.",
    "inputValues": [
      "categoryId-number-Category"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the categoryId (number) - mandatory\n   - No default values or special formats required\n\n2. Data Validation:\n   - Validate categoryId:\n     a. Check if categoryId is provided\n     b. Verify categoryId is a valid number\n     c. Ensure categoryId is positive\n   - If validation fails, prepare appropriate error message\n\n3. Business Rule Processing:\n   - Check system state to ensure database connection is available\n   - Verify user has permission to access category information\n   - If any checks fail, prepare appropriate error message\n\n4. Core Operation Execution:\n   - Prepare to retrieve category data:\n     a. Create a new Category object to store results\n     b. Set up query parameters using the provided categoryId\n     c. Execute the category retrieval operation\n     d. If category exists in the database:\n        i. Extract category details (id, name, display order, moderation status)\n        ii. Populate the Category object with retrieved data\n     e. If category doesn't exist:\n        i. Return an empty Category object\n     f. If any errors occur during retrieval:\n        i. Log the error details\n        ii. Prepare appropriate error message\n        iii. Handle the exception according to system guidelines\n\n5. Response Generation:\n   - For successful retrieval:\n     a. Return the populated Category object with all details\n     b. Include category id, name, display order, and moderation status\n   - For failed retrieval:\n     a. Return appropriate error information\n     b. Include error code and descriptive message\n     c. Provide guidance for resolving the issue if applicable",
    "databaseEntities": [
      "jforum_categories"
    ],
    "validationRules": [
      "Category ID must be provided",
      "Category ID must be a valid positive number",
      "User must have permission to view categories"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Category": {
        "id": "number",
        "name": "string",
        "order": "number",
        "moderated": "boolean"
      }
    }
  },
  {
    "featureName": "SelectAllCategories",
    "description": "Retrieves all forum categories in the system.",
    "inputValues": [],
    "businessLogic": "1. Input Collection:\n   - No user inputs required for this feature\n   - System will retrieve all categories regardless of user context\n\n2. Data Validation:\n   - No input validation required as there are no user inputs\n   - System will verify database connection is available\n   - IF database connection is not available THEN\n     - Generate appropriate error message\n     - End process\n   - END IF\n\n3. Business Rule Processing:\n   - Verify user has permission to view categories\n   - IF user does not have permission THEN\n     - Return empty list or appropriate error message\n     - End process\n   - END IF\n   - Determine if any category filtering should be applied based on user role\n   - Prepare query parameters for category retrieval\n\n4. Core Operation Execution:\n   - Initialize empty category collection\n   - Retrieve all categories from the database\n   - FOR each category record found:\n     - Create category object with the following attributes:\n       * Category ID\n       * Category title/name\n       * Display order\n       * Moderation status\n     - Add category to collection\n   - END FOR\n   - Sort categories by display order if needed\n\n5. Response Generation:\n   - IF no categories found THEN\n     - Return empty collection\n   - ELSE\n     - Return collection of categories\n   - END IF\n   - Include total count of categories retrieved\n   - Include timestamp of when categories were retrieved",
    "databaseEntities": [
      "jforum_categories"
    ],
    "validationRules": [
      "User must have permission to view categories",
      "Database connection must be available",
      "Categories must be returned in display order"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Category": {
        "type": "object",
        "properties": {
          "id": {
            "type": "number",
            "description": "Unique identifier for the category"
          },
          "name": {
            "type": "string",
            "description": "Title of the category"
          },
          "order": {
            "type": "number",
            "description": "Display order of the category"
          },
          "moderated": {
            "type": "boolean",
            "description": "Whether the category is moderated"
          }
        }
      }
    }
  },
  {
    "featureName": "AddNewCategory",
    "description": "Creates a new forum category with automatic ordering.",
    "inputValues": [
      "name-string-Category",
      "moderated-boolean-Category"
    ],
    "businessLogic": "1. Input Collection:\n   1.1. Collect the category name (mandatory string).\n   1.2. Collect the moderation status (boolean indicating if the category is moderated).\n\n2. Data Validation:\n   2.1. Validate category name:\n      2.1.1. Check if the category name is not empty.\n      2.1.2. Check if the category name length is within acceptable limits.\n      2.1.3. IF validation fails, THEN return appropriate error message.\n   2.2. Validate moderation status:\n      2.2.1. Ensure the moderation status is a valid boolean value.\n      2.2.2. IF validation fails, THEN return appropriate error message.\n\n3. Business Rule Processing:\n   3.1. Check system state:\n      3.1.1. Verify the system allows creation of new categories.\n      3.1.2. Check if the user has permission to create categories.\n      3.1.3. IF any check fails, THEN return appropriate error message.\n\n4. Core Operation Execution:\n   4.1. Determine the display order for the new category:\n      4.1.1. Retrieve the maximum display order value from existing categories.\n      4.1.2. Set the new category's display order to (maximum + 1).\n      4.1.3. IF no existing categories are found, THEN set display order to 1.\n   4.2. Create the new category record:\n      4.2.1. Create a new category with the provided name.\n      4.2.2. Set the calculated display order.\n      4.2.3. Set the moderation status based on input.\n      4.2.4. Generate a unique identifier for the new category.\n      4.2.5. IF creation fails, THEN handle the error and return appropriate message.\n   4.3. Update related records:\n      4.3.1. Update any system counters or indexes that track categories.\n      4.3.2. IF updates fail, THEN attempt to rollback the category creation.\n\n5. Response Generation:\n   5.1. Prepare success response:\n      5.1.1. Include the newly created category ID.\n      5.1.2. Include the category name.\n      5.1.3. Include the assigned display order.\n      5.1.4. Include the moderation status.\n   5.2. Return success message with the category details.\n   5.3. IF any errors occurred, THEN return appropriate error message with details.",
    "databaseEntities": [
      "jforum_categories"
    ],
    "validationRules": [
      "Category name must not be empty",
      "Category name must be within acceptable length limits",
      "Moderation status must be a valid boolean value",
      "User must have permission to create categories"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Category": {
        "id": "number",
        "name": "string",
        "order": "number",
        "moderated": "boolean"
      }
    }
  },
  {
    "featureName": "SetCategoryOrder",
    "description": "Changes the display order of forum categories.",
    "inputValues": [
      "category-object-Category",
      "relatedCategory-object-Category"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the following inputs:\n     - category (mandatory): The Category object to be reordered\n     - relatedCategory (mandatory): The Category object to swap order with\n     - Both objects must contain valid category IDs and current display order values\n\n2. Data Validation:\n   - Validate Category objects:\n     - Verify both category and relatedCategory objects are not null\n     - Verify both category and relatedCategory have valid IDs (greater than 0)\n     - Verify both category and relatedCategory have valid order values (greater than or equal to 1)\n     - Verify the categories are different (have different IDs)\n   - IF any validation fails, THEN:\n     - Generate appropriate error message\n     - Abort the operation\n\n3. Business Rule Processing:\n   - Verify both categories exist in the system\n   - Verify user has permission to modify category order\n   - Check if the system allows reordering of categories\n   - IF any business rule fails, THEN:\n     - Generate appropriate error message\n     - Abort the operation\n\n4. Core Operation Execution:\n   - Store the current order value of the relatedCategory\n   - Assign the category's order value to the relatedCategory\n   - Assign the stored order value (from relatedCategory) to the category\n   - Update the display_order field for both categories in the database\n   - IF any update operation fails, THEN:\n     - Rollback all changes\n     - Generate error message\n     - Abort the operation\n\n5. Response Generation:\n   - IF all operations completed successfully, THEN:\n     - Generate success response indicating categories were reordered\n     - Include updated category information in response\n   - ELSE:\n     - Generate error response with details about what went wrong\n     - Include support information if needed",
    "databaseEntities": [
      "jforum_categories"
    ],
    "validationRules": [
      "Category objects must not be null",
      "Category IDs must be greater than 0",
      "Category order values must be greater than or equal to 1",
      "Categories must be different (have different IDs)",
      "Both categories must exist in the system",
      "User must have permission to modify category order"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Category": {
        "type": "object",
        "properties": {
          "id": {
            "type": "integer",
            "description": "Unique identifier for the category"
          },
          "name": {
            "type": "string",
            "description": "Name of the category"
          },
          "order": {
            "type": "integer",
            "description": "Display order of the category"
          },
          "moderated": {
            "type": "boolean",
            "description": "Whether the category is moderated"
          }
        },
        "required": [
          "id",
          "order"
        ]
      }
    }
  },
  {
    "featureName": "SelectAllConfigs",
    "description": "Retrieves all configuration entries from the database.",
    "inputValues": [],
    "businessLogic": "1. Input Collection:\n   - No user inputs required for this operation\n   - System will use database connection parameters (internally managed)\n\n2. Data Validation:\n   - Verify database connection is available\n   - IF connection is not available THEN\n     - Generate appropriate error message\n     - Exit process\n   - END IF\n\n3. Business Rule Processing:\n   - Verify user has appropriate permissions to view configuration data\n   - IF user lacks required permissions THEN\n     - Generate access denied message\n     - Log access attempt\n     - Exit process\n   - END IF\n   - Verify system state allows configuration retrieval\n   - IF system is in maintenance mode THEN\n     - Check if user has override privileges\n     - IF no override privileges THEN\n       - Generate maintenance mode message\n       - Exit process\n     - END IF\n   - END IF\n\n4. Core Operation Execution:\n   - Prepare to retrieve all configuration entries\n   - Create empty collection to store configuration entries\n   - Execute database query to select all configuration records\n   - FOR each record retrieved from database\n     - Create new configuration object\n     - Extract configuration ID from record\n     - Extract configuration name from record\n     - Extract configuration value from record\n     - Add populated configuration object to collection\n   - END FOR\n   - IF no configuration entries found THEN\n     - Note empty result set in system log\n   - END IF\n\n5. Response Generation:\n   - Return collection of configuration objects\n   - IF operation successful THEN\n     - Include count of retrieved configuration entries\n     - Format configuration data according to display requirements\n   - ELSE\n     - Generate error message with appropriate details\n     - Include troubleshooting information\n     - Log error details for system administrators\n   - END IF",
    "databaseEntities": [
      "Config"
    ],
    "validationRules": [
      "Database connection must be available",
      "User must have appropriate permissions to view configurations",
      "System must not be in maintenance mode unless user has override privileges"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Config": {
        "id": "number",
        "name": "string",
        "value": "string"
      }
    }
  },
  {
    "featureName": "SelectConfigByName",
    "description": "Retrieves a specific configuration entry by its name.",
    "inputValues": [
      "name-string-Config"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the configuration name (name-string-Config) from the user\n   - The configuration name is mandatory\n   - No default values are provided\n\n2. Data Validation:\n   - Validate the configuration name:\n     a. Check if the name is not null or empty\n     b. Check if the name follows the system's naming conventions\n     c. If validation fails, prepare appropriate error message\n\n3. Business Rule Processing:\n   - Verify system state is ready for configuration retrieval\n   - Check if the user has appropriate permissions to access configuration data\n   - Verify the configuration system is initialized\n\n4. Core Operation Execution:\n   - Search for the configuration entry in the system using the provided name\n   - IF configuration entry is found:\n     a. Retrieve the configuration ID, name, and value\n     b. Prepare the configuration data for return\n   - ELSE IF configuration entry is not found:\n     a. Record that no matching configuration was found\n     b. Prepare null or empty response\n\n5. Response Generation:\n   - IF configuration was found:\n     a. Return the complete configuration object with ID, name, and value\n     b. Include success status in the response\n   - ELSE:\n     a. Return appropriate indication that no configuration was found\n     b. Include relevant status information in the response",
    "databaseEntities": [
      "Config"
    ],
    "validationRules": [
      "Configuration name must not be empty",
      "Configuration name must follow system naming conventions",
      "User must have appropriate permissions to access configuration data"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Config": {
        "type": "object",
        "properties": {
          "id": {
            "type": "integer",
            "description": "Unique identifier for the configuration"
          },
          "name": {
            "type": "string",
            "description": "Name of the configuration entry"
          },
          "value": {
            "type": "string",
            "description": "Value of the configuration entry"
          }
        },
        "required": [
          "name"
        ]
      }
    }
  },
  {
    "featureName": "SelectForumById",
    "description": "Retrieves a forum by its ID with all associated details.",
    "inputValues": [
      "forumId-number-Forum"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the forum ID (forumId) as a numeric identifier\n   - The forum ID must be provided and cannot be null\n   - No default values are applicable for this operation\n\n2. Data Validation:\n   - Validate forum ID:\n     a. Check if forum ID is provided\n     b. Verify forum ID is a positive integer\n     c. Generate appropriate error message if validation fails\n\n3. Business Rule Processing:\n   - Verify system state:\n     a. Check if the database connection is available\n     b. Verify the user has permission to view forum information\n   - Verify dependencies:\n     a. Ensure the forum data access components are properly initialized\n\n4. Core Operation Execution:\n   - Retrieve forum record:\n     a. Search for forum with matching ID in the forum repository\n     b. IF forum is found THEN:\n        i. Retrieve basic forum information (ID, name, description, etc.)\n        ii. Retrieve forum category association\n        iii. Retrieve forum statistics (total topics, total posts)\n        iv. Retrieve last post information\n        v. Determine if forum is moderated\n     c. IF forum is not found THEN:\n        i. Return an empty forum object\n   - Handle any exceptions during retrieval:\n     a. Log the error details\n     b. Prepare appropriate error response\n     c. Release any acquired resources\n\n5. Response Generation:\n   - Success response:\n     a. Return forum object with all populated details:\n        i. Forum ID\n        ii. Category ID\n        iii. Forum name\n        iv. Forum description\n        v. Forum order\n        vi. Total topics count\n        vii. Total posts count\n        viii. Last post ID\n        ix. Moderation status\n   - Error response:\n     a. Return appropriate error message\n     b. Include error code and description\n     c. Provide guidance for resolving the issue",
    "databaseEntities": [
      "jforum_forums",
      "jforum_categories",
      "jforum_topics",
      "jforum_posts"
    ],
    "validationRules": [
      "Forum ID must be a positive integer",
      "Forum ID must exist in the database",
      "User must have permission to view the forum"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Forum": {
        "id": "number",
        "categoryId": "number",
        "name": "string",
        "description": "string",
        "order": "number",
        "totalTopics": "number",
        "totalPosts": "number",
        "lastPostId": "number",
        "moderated": "boolean"
      }
    }
  },
  {
    "featureName": "SelectAllForums",
    "description": "Retrieves all forums with their complete details.",
    "inputValues": [],
    "businessLogic": "1. Input Collection:\n   - No user inputs required for this feature\n   - System will retrieve all forum records without filtering\n\n2. Data Validation:\n   - Verify database connection is available\n   - Verify user has appropriate permissions to view forums\n   - IF connection is unavailable THEN\n     - Generate appropriate error message\n     - Terminate process\n   - IF user lacks permissions THEN\n     - Generate access denied message\n     - Terminate process\n\n3. Business Rule Processing:\n   - Check system state to ensure forum data can be accessed\n   - Verify forum table exists and is accessible\n   - IF system is in maintenance mode THEN\n     - Generate maintenance notification\n     - Terminate process\n   - IF forum table is inaccessible THEN\n     - Log database access error\n     - Generate system error message\n     - Terminate process\n\n4. Core Operation Execution:\n   - Retrieve all forum records from the database\n   - FOR each forum record DO\n     - Extract basic forum information (ID, name, description, etc.)\n     - Calculate and include total post count for the forum\n     - Determine if forum is moderated\n     - Include category association information\n     - Include forum ordering information\n     - Include last post information\n   - END FOR\n   - Organize forums in the correct display order\n   - IF no forums exist THEN\n     - Prepare empty result set\n\n5. Response Generation:\n   - Compile complete list of forums with all details\n   - Format response according to system requirements\n   - Include total count of forums retrieved\n   - Return formatted forum list to caller\n   - IF any errors occurred during processing THEN\n     - Include error details in response\n     - Provide guidance for resolving the issue",
    "databaseEntities": [
      "jforum_forums",
      "jforum_categories",
      "jforum_posts",
      "jforum_topics"
    ],
    "validationRules": [
      "User must have permission to view forums",
      "Database connection must be available",
      "System must not be in maintenance mode"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Forum": {
        "type": "object",
        "properties": {
          "id": {
            "type": "number",
            "description": "Unique identifier for the forum"
          },
          "categoryId": {
            "type": "number",
            "description": "ID of the category this forum belongs to"
          },
          "name": {
            "type": "string",
            "description": "Name of the forum"
          },
          "description": {
            "type": "string",
            "description": "Description of the forum"
          },
          "order": {
            "type": "number",
            "description": "Display order of the forum"
          },
          "totalTopics": {
            "type": "number",
            "description": "Total number of topics in the forum"
          },
          "totalPosts": {
            "type": "number",
            "description": "Total number of posts in the forum"
          },
          "lastPostId": {
            "type": "number",
            "description": "ID of the last post in the forum"
          },
          "moderated": {
            "type": "boolean",
            "description": "Whether the forum is moderated"
          }
        }
      }
    }
  },
  {
    "featureName": "SetForumOrderUp",
    "description": "Moves a forum up in the display order relative to another forum.",
    "inputValues": [
      "currentForum-object-Forum",
      "relatedForum-object-Forum"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the current forum object with its ID and current order position\n   - Collect the related forum object with its ID and current order position\n   - Both forums must be valid and exist in the system\n\n2. Data Validation:\n   - Verify that currentForum is not null and has a valid ID\n     * IF currentForum is null or has invalid ID THEN return error message\n   - Verify that relatedForum is not null and has a valid ID\n     * IF relatedForum is null or has invalid ID THEN return error message\n   - Verify that both forums belong to the same category\n     * IF forums are in different categories THEN return error message\n   - Verify that the currentForum's order is higher than relatedForum's order (numerically larger value means lower position)\n     * IF currentForum's order is already lower than or equal to relatedForum's order THEN return error message\n\n3. Business Rule Processing:\n   - Verify that the system allows reordering of forums\n     * IF forum reordering is disabled THEN return error message\n   - Check if user has permission to modify forum order\n     * IF user lacks permission THEN return error message\n   - Verify that both forums are active and not marked for deletion\n     * IF either forum is inactive or pending deletion THEN return error message\n\n4. Core Operation Execution:\n   - Store the current order value of the relatedForum\n   - Update the relatedForum's order value to the currentForum's order value\n   - Update the currentForum's order value to the stored order value of relatedForum\n   - Save both forum changes to ensure persistence\n   - IF any update operation fails THEN:\n     * Revert any changes made\n     * Log the failure details\n     * Return error message\n\n5. Response Generation:\n   - Retrieve the updated currentForum with its new order position\n   - Return success message with the updated forum information\n   - Include the new display order of the forum\n   - Provide information about the related forum that was affected",
    "databaseEntities": [
      "jforum_forums",
      "jforum_categories"
    ],
    "validationRules": [
      "Current forum must exist in the system",
      "Related forum must exist in the system",
      "Both forums must belong to the same category",
      "Current forum's order must be higher than related forum's order",
      "User must have permission to modify forum order",
      "Both forums must be active and not marked for deletion"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Forum": {
        "type": "object",
        "properties": {
          "id": {
            "type": "integer",
            "description": "Unique identifier for the forum"
          },
          "categoryId": {
            "type": "integer",
            "description": "ID of the category this forum belongs to"
          },
          "name": {
            "type": "string",
            "description": "Name of the forum"
          },
          "description": {
            "type": "string",
            "description": "Description of the forum"
          },
          "order": {
            "type": "integer",
            "description": "Display order position of the forum"
          },
          "totalTopics": {
            "type": "integer",
            "description": "Total number of topics in the forum"
          },
          "lastPostId": {
            "type": "integer",
            "description": "ID of the last post in the forum"
          },
          "moderated": {
            "type": "boolean",
            "description": "Whether the forum is moderated"
          }
        },
        "required": [
          "id",
          "categoryId",
          "name",
          "order"
        ]
      }
    }
  },
  {
    "featureName": "SetForumOrderDown",
    "description": "Moves a forum down in the display order relative to another forum.",
    "inputValues": [
      "currentForum-object-Forum",
      "relatedForum-object-Forum"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the current forum object with the following properties:\n     * forum ID (mandatory)\n     * current order position (mandatory)\n     * name (mandatory)\n     * description (optional)\n     * category ID (mandatory)\n   - Collect the related forum object (the forum below the current one) with the following properties:\n     * forum ID (mandatory)\n     * current order position (mandatory)\n     * name (mandatory)\n     * description (optional)\n     * category ID (mandatory)\n\n2. Data Validation:\n   - Validate current forum:\n     * Verify forum ID is a positive integer\n     * Verify forum exists in the system\n     * Verify forum order is a positive integer\n   - Validate related forum:\n     * Verify forum ID is a positive integer\n     * Verify forum exists in the system\n     * Verify forum order is a positive integer\n   - Validate relationship:\n     * Verify current forum and related forum are different entities\n     * Verify both forums belong to the same category\n     * Verify the related forum has a higher order number than the current forum\n\n3. Business Rule Processing:\n   - Check if the current forum is already at the bottom of the list\n     * IF current forum has the highest order value in its category THEN\n       - Return error message indicating forum cannot be moved down further\n     * END IF\n   - Check if the related forum is the next forum in order sequence\n     * IF related forum order is not exactly current forum order + 1 THEN\n       - Identify the correct related forum with the next higher order value\n     * END IF\n   - Verify system state allows for reordering\n     * Check if any other forum operations are in progress\n     * Ensure category structure is not being modified simultaneously\n\n4. Core Operation Execution:\n   - Swap the order values between current forum and related forum:\n     * Store the related forum's order value in a temporary variable\n     * Set related forum's order to current forum's order value\n     * Set current forum's order to the temporary variable (related forum's original order)\n   - Update the current forum record with new order value\n     * Save changes to the current forum\n   - Update the related forum record with new order value\n     * Save changes to the related forum\n   - IF any update operation fails THEN\n     * Rollback all changes\n     * Log the error details\n     * Return error message indicating order change failed\n   - END IF\n   - Refresh the current forum data from the system\n\n5. Response Generation:\n   - Prepare success response:\n     * Include updated current forum with new order value\n     * Include status message indicating successful reordering\n     * Include new position information\n   - IF any errors occurred during processing THEN\n     * Generate error response with specific details about what went wrong\n     * Include suggestions for resolving the issue\n   - END IF",
    "databaseEntities": [
      "jforum_forums",
      "jforum_categories"
    ],
    "validationRules": [
      "Current forum must exist in the system",
      "Related forum must exist in the system",
      "Current forum and related forum must be different entities",
      "Both forums must belong to the same category",
      "Current forum must not already be at the bottom of the list",
      "Related forum must have a higher order number than the current forum"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Forum": {
        "type": "object",
        "properties": {
          "id": {
            "type": "integer",
            "description": "Unique identifier for the forum"
          },
          "categoryId": {
            "type": "integer",
            "description": "ID of the category this forum belongs to"
          },
          "name": {
            "type": "string",
            "description": "Name of the forum"
          },
          "description": {
            "type": "string",
            "description": "Description of the forum"
          },
          "order": {
            "type": "integer",
            "description": "Display order position of the forum within its category"
          },
          "totalTopics": {
            "type": "integer",
            "description": "Total number of topics in the forum"
          },
          "lastPostId": {
            "type": "integer",
            "description": "ID of the last post made in this forum"
          },
          "moderated": {
            "type": "boolean",
            "description": "Whether the forum is moderated"
          }
        },
        "required": [
          "id",
          "categoryId",
          "name",
          "order"
        ]
      }
    }
  },
  {
    "featureName": "DeleteForum",
    "description": "Removes a forum and its associated security roles from the system.",
    "inputValues": [
      "forumId-number-Forum"
    ],
    "businessLogic": "1. Input Collection\n   - Collect the following required input:\n     a. forumId (number): Unique identifier of the forum to be deleted\n   - No optional inputs are required\n   - No default values are provided\n\n2. Data Validation\n   - Validate forumId:\n     a. Check if forumId is provided\n        IF forumId is missing or null THEN\n          Return error message: \"Forum ID is required\"\n     b. Check if forumId is a valid number\n        IF forumId is not a valid number THEN\n          Return error message: \"Forum ID must be a valid number\"\n     c. Check if forumId is positive\n        IF forumId is not positive THEN\n          Return error message: \"Forum ID must be a positive number\"\n\n3. Business Rule Processing\n   - Verify forum existence:\n     a. Check if the forum with the provided ID exists in the system\n        IF forum does not exist THEN\n          Return error message: \"Forum not found\"\n   - Check for dependencies:\n     a. Determine if there are active topics in the forum\n        IF active topics exist THEN\n          Display warning message: \"This forum contains topics that will also be deleted\"\n     b. Check if users have bookmarked this forum\n        IF bookmarks exist THEN\n          Display warning message: \"Users have bookmarked this forum\"\n   - Verify user permissions:\n     a. Check if the current user has permission to delete forums\n        IF user does not have permission THEN\n          Return error message: \"Insufficient permissions to delete forum\"\n\n4. Core Operation Execution\n   - Begin deletion process:\n     a. Start a transaction to ensure data integrity\n     b. Delete all security roles associated with the forum\n        FOR EACH security role related to the forum\n          Remove the role from the system\n     c. Delete the forum record from the database\n     d. IF any step fails THEN\n          Rollback the transaction\n          Return error message: \"Failed to delete forum. Please try again.\"\n     e. Commit the transaction if all operations succeed\n\n5. Response Generation\n   - Generate success response:\n     a. Create a confirmation message: \"Forum successfully deleted\"\n     b. Include the ID of the deleted forum in the response\n     c. Include timestamp of when the deletion occurred\n   - Provide next steps information:\n     a. Suggest returning to the forum list\n     b. Offer option to create a new forum\n   - Log the deletion event for audit purposes",
    "databaseEntities": [
      "jforum_forums",
      "jforum_topics",
      "jforum_posts",
      "jforum_user_groups",
      "jforum_moderator_groups",
      "jforum_bookmarks"
    ],
    "validationRules": [
      "Forum ID must be provided",
      "Forum ID must be a valid positive number",
      "Forum must exist in the system",
      "User must have permission to delete forums",
      "All associated security roles must be removed"
    ],
    "dbSeedingOperations": [],
    "schema": {}
  },
  {
    "featureName": "UpdateForum",
    "description": "Updates forum details including name, description, and moderation status.",
    "inputValues": [
      "forumId-number-Forum",
      "categoryId-number-Category",
      "name-string-Forum",
      "description-string-Forum",
      "moderated-boolean-Forum"
    ],
    "businessLogic": "1. Input Collection\n   - Collect the following inputs:\n     a. forumId (mandatory): Unique identifier of the forum to update\n     b. categoryId (mandatory): Identifier of the category this forum belongs to\n     c. name (mandatory): New name for the forum\n     d. description (mandatory): New description for the forum\n     e. moderated (mandatory): Boolean flag indicating if the forum is moderated\n\n2. Data Validation\n   - Validate forumId:\n     a. Check if forumId is provided\n     b. Verify forumId is a positive integer\n     c. IF validation fails, THEN return error message \"Invalid forum ID\"\n   - Validate categoryId:\n     a. Check if categoryId is provided\n     b. Verify categoryId is a positive integer\n     c. IF validation fails, THEN return error message \"Invalid category ID\"\n   - Validate name:\n     a. Check if name is provided\n     b. Verify name is not empty\n     c. Verify name length is between 1 and 150 characters\n     d. IF validation fails, THEN return error message \"Forum name is required and must be between 1 and 150 characters\"\n   - Validate description:\n     a. Check if description is provided\n     b. Verify description length does not exceed 1000 characters\n     c. IF validation fails, THEN return error message \"Forum description must not exceed 1000 characters\"\n   - Validate moderated:\n     a. Check if moderated flag is provided\n     b. Verify moderated is a boolean value\n     c. IF validation fails, THEN return error message \"Moderation status must be specified\"\n\n3. Business Rule Processing\n   - Check forum existence:\n     a. Verify that a forum with the provided forumId exists in the system\n     b. IF forum does not exist, THEN return error message \"Forum not found\"\n   - Check category existence:\n     a. Verify that a category with the provided categoryId exists in the system\n     b. IF category does not exist, THEN return error message \"Category not found\"\n   - Check user permissions:\n     a. Verify current user has administrator privileges or is a forum moderator\n     b. IF user lacks permissions, THEN return error message \"Insufficient permissions to update forum\"\n   - Check for duplicate forum name:\n     a. Verify no other forum in the same category has the same name (excluding the current forum)\n     b. IF duplicate name exists, THEN return error message \"Another forum with this name already exists in the selected category\"\n\n4. Core Operation Execution\n   - Retrieve current forum data:\n     a. Load existing forum information based on forumId\n     b. Store original values for comparison and potential rollback\n   - Update forum record:\n     a. Set the new categoryId for the forum\n     b. Set the new name for the forum\n     c. Set the new description for the forum\n     d. Set the new moderation status for the forum\n     e. Preserve all other forum attributes (order, topic count, etc.)\n   - Save changes to the forum record\n   - IF any database operation fails:\n     a. Rollback all changes\n     b. Log the error details\n     c. Return error message \"Failed to update forum details\"\n\n5. Response Generation\n   - On success:\n     a. Generate success message \"Forum updated successfully\"\n     b. Include updated forum details in the response\n     c. Include category information the forum belongs to\n   - On failure:\n     a. Return appropriate error message from previous steps\n     b. Include error details for troubleshooting\n     c. Preserve user input for form repopulation",
    "databaseEntities": [
      "jforum_forums",
      "jforum_categories"
    ],
    "validationRules": [
      "Forum ID must be a positive integer",
      "Category ID must be a positive integer",
      "Forum name must not be empty",
      "Forum name must be between 1 and 150 characters",
      "Forum description must not exceed 1000 characters",
      "Moderation status must be specified as a boolean value",
      "Forum must exist in the system",
      "Category must exist in the system",
      "User must have administrator privileges or be a forum moderator",
      "No other forum in the same category can have the same name"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Forum": {
        "id": "number",
        "categoryId": "number",
        "name": "string",
        "description": "string",
        "order": "number",
        "totalTopics": "number",
        "lastPostId": "number",
        "moderated": "boolean",
        "totalPosts": "number"
      },
      "Category": {
        "id": "number",
        "name": "string",
        "order": "number"
      }
    }
  },
  {
    "featureName": "AddNewForum",
    "description": "Creates a new forum with specified details and assigns it an order position.",
    "inputValues": [
      "name-string-Forum",
      "description-string-Forum",
      "categoryId-number-Category",
      "isModerated-boolean-Forum"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the following required inputs:\n     a. name (string): The name of the forum to be created\n     b. description (string): A detailed description of the forum's purpose\n     c. categoryId (number): The ID of the category to which this forum belongs\n     d. isModerated (boolean): Whether the forum requires moderation\n\n2. Data Validation:\n   - Validate forum name:\n     a. Check if name is not empty\n     b. Check if name length is within acceptable limits\n     c. IF validation fails, THEN return appropriate error message\n   - Validate forum description:\n     a. Check if description is not empty\n     b. Check if description length is within acceptable limits\n     c. IF validation fails, THEN return appropriate error message\n   - Validate category ID:\n     a. Check if categoryId is a positive number\n     b. Check if the specified category exists in the system\n     c. IF validation fails, THEN return appropriate error message\n\n3. Business Rule Processing:\n   - Verify user permissions:\n     a. Check if the current user has administrator privileges\n     b. IF user lacks required permissions, THEN return access denied error\n   - Verify category status:\n     a. Check if the selected category is active and available\n     b. IF category is not available, THEN return appropriate error message\n\n4. Core Operation Execution:\n   - Determine forum order position:\n     a. Retrieve the maximum order value from existing forums\n     b. Set the new forum's order to (maximum order + 1)\n   - Create forum record:\n     a. Create a new forum object with the provided information\n     b. Set initial values for forum statistics (topics count = 0, posts count = 0)\n     c. Set last post ID to 0 (no posts yet)\n     d. Save the forum record to the database\n     e. Retrieve and store the generated forum ID\n   - Set up forum permissions:\n     a. Apply default permission settings for the new forum\n     b. IF forum is moderated, THEN set up moderation flags\n\n5. Response Generation:\n   - Prepare success response:\n     a. Include the newly created forum ID\n     b. Include confirmation message about successful forum creation\n     c. Include the assigned order position\n   - IF any errors occurred during the process:\n     a. Generate appropriate error message\n     b. Include information about which step failed\n     c. Provide guidance on how to resolve the issue",
    "databaseEntities": [
      "jforum_forums",
      "jforum_categories"
    ],
    "validationRules": [
      "Forum name must not be empty",
      "Forum description must not be empty",
      "Category ID must reference an existing category",
      "User must have administrator privileges to create a forum"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Forum": {
        "id": "number",
        "name": "string",
        "description": "string",
        "categoryId": "number",
        "order": "number",
        "totalTopics": "number",
        "totalPosts": "number",
        "lastPostId": "number",
        "isModerated": "boolean"
      },
      "Category": {
        "id": "number",
        "name": "string",
        "order": "number"
      }
    }
  },
  {
    "featureName": "SetLastPost",
    "description": "Updates the last post reference for a forum.",
    "inputValues": [
      "forumId-number-Forum",
      "postId-number-Post"
    ],
    "businessLogic": "1. Input Collection\n   - Collect forumId (mandatory): Identifier of the forum to update\n   - Collect postId (mandatory): Identifier of the post to set as the last post\n\n2. Data Validation\n   - Validate forumId:\n     a. Check if forumId is provided\n     b. Verify forumId is a positive integer\n     c. IF validation fails, THEN generate appropriate error message\n   - Validate postId:\n     a. Check if postId is provided\n     b. Verify postId is a non-negative integer (0 is allowed to clear last post)\n     c. IF validation fails, THEN generate appropriate error message\n\n3. Business Rule Processing\n   - Verify forum existence:\n     a. Check if forum with forumId exists in the system\n     b. IF forum does not exist, THEN return error indicating invalid forum\n   - Verify post existence (when postId > 0):\n     a. IF postId > 0, THEN check if post with postId exists in the system\n     b. IF post does not exist, THEN return error indicating invalid post\n   - Verify post belongs to forum (when postId > 0):\n     a. IF postId > 0, THEN check if post belongs to the specified forum\n     b. IF post does not belong to forum, THEN return error indicating post-forum mismatch\n\n4. Core Operation Execution\n   - Update forum record:\n     a. Set the last_post_id field of the forum to the provided postId\n     b. IF update operation fails, THEN:\n        i. Log the error details\n        ii. Revert any partial changes\n        iii. Return appropriate error message\n   - Update related data (if necessary):\n     a. IF postId > 0, THEN update forum's last activity timestamp\n     b. IF postId = 0, THEN this indicates clearing the last post reference\n\n5. Response Generation\n   - Generate success response:\n     a. Indicate successful update of forum's last post reference\n     b. Include forum identifier in response\n   - IF any errors occurred during processing:\n     a. Generate error response with appropriate error code\n     b. Include descriptive error message\n     c. Provide guidance for resolving the issue",
    "databaseEntities": [
      "jforum_forums",
      "jforum_posts"
    ],
    "validationRules": [
      "Forum ID must be a positive integer",
      "Post ID must be a non-negative integer",
      "Forum must exist in the system",
      "Post must exist in the system when postId > 0",
      "Post must belong to the specified forum when postId > 0"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Forum": {
        "id": "number",
        "categoryId": "number",
        "name": "string",
        "description": "string",
        "order": "number",
        "totalTopics": "number",
        "lastPostId": "number",
        "moderated": "boolean",
        "totalPosts": "number"
      },
      "Post": {
        "id": "number",
        "topicId": "number",
        "forumId": "number",
        "userId": "number",
        "postTime": "date",
        "text": "string"
      }
    }
  },
  {
    "featureName": "IncrementTotalTopics",
    "description": "Increases the topic count for a forum by a specified amount.",
    "inputValues": [
      "forumId-number-Forum",
      "count-number-Forum"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect forumId (mandatory): Unique identifier of the forum\n   - Collect count (mandatory): Number of topics to add to the forum's total\n   - Both inputs must be provided by the caller\n\n2. Data Validation:\n   - Validate forumId:\n     a. Check if forumId is a positive integer\n     b. Check if forumId is not null\n     c. If validation fails, generate appropriate error message\n   - Validate count:\n     a. Check if count is a non-negative integer\n     b. Check if count is not null\n     c. If validation fails, generate appropriate error message\n\n3. Business Rule Processing:\n   - Verify forum existence:\n     a. Check if a forum with the provided forumId exists in the system\n     b. IF forum does not exist, THEN generate error message and stop processing\n   - Verify system state:\n     a. Check if the system is in a state that allows topic count updates\n     b. IF system is in maintenance mode or read-only mode, THEN generate error message and stop processing\n\n4. Core Operation Execution:\n   - Retrieve current topic count for the forum\n   - Calculate new topic count by adding the provided count to the current count\n   - Update the forum record with the new topic count\n   - IF update operation fails:\n     a. Log the failure details\n     b. Revert any partial changes\n     c. Generate appropriate error message\n\n5. Response Generation:\n   - IF operation is successful:\n     a. Generate success response with updated forum information\n     b. Include the new total topic count in the response\n   - IF operation fails:\n     a. Generate error response with appropriate error code\n     b. Include error details and suggestions for resolution\n     c. Provide support information if needed",
    "databaseEntities": [
      "jforum_forums",
      "jforum_topics"
    ],
    "validationRules": [
      "Forum ID must be a positive integer",
      "Count must be a non-negative integer",
      "Forum with the specified ID must exist in the system",
      "System must not be in maintenance or read-only mode"
    ],
    "dbSeedingOperations": [],
    "schema": {}
  },
  {
    "featureName": "DecrementTotalTopics",
    "description": "Decreases the topic count for a forum by a specified amount.",
    "inputValues": [
      "forumId-number-Forum",
      "count-number-Forum"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect forumId (mandatory): Unique identifier for the forum\n   - Collect count (mandatory): Number of topics to decrement\n   - System will use database connection from context\n\n2. Data Validation:\n   - Validate forumId:\n     a. Check if forumId is a positive integer\n     b. Check if forumId is not null\n     c. IF validation fails, THEN generate appropriate error message\n   - Validate count:\n     a. Check if count is a positive integer\n     b. Check if count is not null\n     c. IF validation fails, THEN generate appropriate error message\n\n3. Business Rule Processing:\n   - Check forum existence:\n     a. Verify the forum with the provided forumId exists in the system\n     b. IF forum does not exist, THEN generate error message indicating invalid forum\n   - Check current topic count:\n     a. Retrieve current topic count for the forum\n     b. Verify that decrementing by count will not result in negative topic count\n     c. IF resulting count would be negative, THEN adjust count to match current topic count\n\n4. Core Operation Execution:\n   - Update forum record:\n     a. Decrement the total topics count by the specified amount\n     b. Save the updated forum information\n   - Check if topics remain:\n     a. Retrieve the updated total topics count\n     b. IF total topics count is less than 1, THEN:\n        i. Reset the last post information for the forum\n        ii. Set last post ID to 0\n\n5. Response Generation:\n   - Success response:\n     a. Indicate successful topic count update\n     b. Include the new topic count in the response\n   - Error response:\n     a. Provide detailed error message based on the specific validation or processing failure\n     b. Include error code and suggested resolution steps",
    "databaseEntities": [
      "jforum_forums",
      "jforum_topics"
    ],
    "validationRules": [
      "Forum ID must be a positive integer",
      "Count must be a positive integer",
      "Forum must exist in the system",
      "Resulting topic count must not be negative"
    ],
    "dbSeedingOperations": [],
    "schema": {}
  },
  {
    "featureName": "GetLastPostInfo",
    "description": "Retrieves information about the most recent post in a forum.",
    "inputValues": [
      "forumId-number-Forum",
      "tryFix-boolean-System"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect forumId (number, mandatory) to identify the forum\n   - Collect tryFix (boolean, optional) to determine if the system should attempt to fix inconsistent data\n     a. Default value is true if not provided\n   - System will generate a LastPostInfo object to hold the results\n\n2. Data Validation:\n   - Validate forumId:\n     a. Check if forumId is provided\n     b. Verify forumId is a positive integer\n     c. Return error message if validation fails\n   - Validate tryFix parameter:\n     a. If provided, ensure it's a boolean value\n     b. If not provided, use default value (true)\n\n3. Business Rule Processing:\n   - Check if forum exists:\n     a. IF forum with provided forumId does not exist THEN\n        i. Return empty LastPostInfo object\n     b. Check if forum has any posts:\n        i. IF forum has no posts THEN\n           1. Return empty LastPostInfo object\n   - Check forum accessibility:\n     a. IF forum is not accessible to current user THEN\n        i. Return empty LastPostInfo object\n   - Check cache status:\n     a. IF forum's last post information is already cached THEN\n        i. Verify if cached information is valid and complete\n        ii. IF cached information is valid THEN\n            1. Return cached LastPostInfo object\n\n4. Core Operation Execution:\n   - Retrieve last post information:\n     a. Query for the most recent post in the specified forum\n     b. IF post information is found THEN\n        i. Populate LastPostInfo object with:\n           1. Username of post author\n           2. User ID of post author\n           3. Post date (formatted according to system settings)\n           4. Post ID\n           5. Topic ID\n           6. Post timestamp\n           7. Topic reply count\n           8. Set hasInfo flag to true\n        ii. Verify topic consistency:\n            1. Retrieve topic by ID\n            2. IF topic is invalid or inconsistent THEN\n               a. IF tryFix is true THEN\n                  i. Attempt to fix the topic data\n                  ii. Recursively call the function with tryFix set to false to prevent infinite loops\n               b. ELSE\n                  i. Return the potentially inconsistent LastPostInfo object\n     c. ELSE IF no post information is found THEN\n        i. Attempt data recovery:\n           1. Find maximum post ID for the forum\n           2. Find latest topic ID for the forum\n           3. IF recovery data is found THEN\n              a. Update topic with correct latest post information\n              b. Update forum with correct latest post information\n              c. Retry retrieving last post information\n           4. ELSE\n              a. Return empty LastPostInfo object\n     d. Update forum cache with the retrieved last post information\n\n5. Response Generation:\n   - Return populated LastPostInfo object containing:\n     a. Username of post author\n     b. User ID\n     c. Formatted post date\n     d. Post ID\n     e. Topic ID\n     f. Post timestamp\n     g. Topic reply count\n     h. hasInfo flag indicating if information was found\n   - In case of errors during database operations:\n     a. Log the error details\n     b. Return appropriate error information to the caller",
    "databaseEntities": [
      "jforum_forums",
      "jforum_posts",
      "jforum_topics",
      "jforum_users",
      "jforum_categories"
    ],
    "validationRules": [
      "Forum ID must be a positive integer",
      "Forum must exist in the system",
      "Post information must be consistent with topic data",
      "tryFix parameter must be a boolean value if provided",
      "User must have access permissions to view the forum",
      "Forum must belong to an accessible category"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "LastPostInfo": {
        "type": "object",
        "properties": {
          "username": {
            "type": "string",
            "description": "Username of the post author"
          },
          "userId": {
            "type": "number",
            "description": "ID of the user who created the post"
          },
          "postDate": {
            "type": "string",
            "description": "Formatted date of the post"
          },
          "postId": {
            "type": "number",
            "description": "ID of the post"
          },
          "topicId": {
            "type": "number",
            "description": "ID of the topic containing the post"
          },
          "postTimeMillis": {
            "type": "number",
            "description": "Post timestamp in milliseconds"
          },
          "topicReplies": {
            "type": "number",
            "description": "Number of replies in the topic"
          },
          "hasInfo": {
            "type": "boolean",
            "description": "Indicates if post information was found"
          }
        }
      }
    }
  },
  {
    "featureName": "GetModeratorList",
    "description": "Retrieves the list of moderators for a specific forum.",
    "inputValues": [
      "forumId-number-Forum"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect forumId (number, mandatory) - The unique identifier of the forum\n\n2. Data Validation:\n   - Validate forumId:\n     a. Check if forumId is provided\n     b. Verify forumId is a positive integer\n     c. If validation fails, prepare appropriate error message\n\n3. Business Rule Processing:\n   - Verify forum existence:\n     a. Check if a forum with the provided forumId exists in the system\n     b. If forum does not exist, prepare a \"Forum not found\" error message\n   - Verify user permissions:\n     a. Check if the current user has permission to view moderator information\n     b. If permission check fails, prepare an \"Access denied\" error message\n\n4. Core Operation Execution:\n   - Check cache for moderator information:\n     a. Look up moderator list in the cache using forumId as the key\n     b. IF moderator list is found in cache:\n        i. Return the cached moderator list\n     c. IF moderator list is not found in cache:\n        i. Acquire synchronization lock to prevent duplicate database queries\n        ii. Query the database for all moderators associated with the specified forum\n        iii. For each moderator found:\n            - Collect moderator's user information (id, name)\n            - Create a moderator info object with the collected data\n            - Add moderator info to the result list\n        iv. Store the moderator list in cache for future requests\n        v. Release synchronization lock\n     d. If no moderators are found, return an empty list\n     e. If an error occurs during retrieval, prepare appropriate error message and handle the exception\n\n5. Response Generation:\n   - Prepare success response:\n     a. Return the list of moderator information objects\n     b. Each moderator info object contains id and name\n   - Prepare error response if any validation or processing step failed:\n     a. Include specific error message\n     b. Include error code if applicable\n     c. Provide guidance on how to resolve the issue",
    "databaseEntities": [
      "jforum_forums",
      "jforum_users",
      "jforum_groups",
      "jforum_moderator_groups",
      "jforum_user_groups"
    ],
    "validationRules": [
      "Forum ID must be a positive integer",
      "Forum must exist in the system",
      "User must have permission to view moderator information"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "ModeratorInfo": {
        "type": "object",
        "properties": {
          "id": {
            "type": "number",
            "description": "Unique identifier for the moderator"
          },
          "name": {
            "type": "string",
            "description": "Name of the moderator"
          }
        }
      },
      "Forum": {
        "type": "object",
        "properties": {
          "id": {
            "type": "number",
            "description": "Unique identifier for the forum"
          },
          "name": {
            "type": "string",
            "description": "Name of the forum"
          },
          "description": {
            "type": "string",
            "description": "Description of the forum"
          },
          "categoryId": {
            "type": "number",
            "description": "Category ID the forum belongs to"
          },
          "isModerated": {
            "type": "boolean",
            "description": "Whether the forum is moderated"
          }
        }
      }
    }
  },
  {
    "featureName": "GetTotalMessages",
    "description": "Retrieves the total count of messages across the forum system.",
    "inputValues": [
      "fromDb-boolean-System"
    ],
    "businessLogic": "1. Input Collection:\n   - fromDb (boolean): Determines whether to fetch from database or cache\n     - If true: Data will be retrieved directly from the database\n     - If false: Data will be retrieved from cache if available\n   - No other user inputs required\n\n2. Data Validation:\n   - Verify system access permissions\n   - Validate that the database connection is available\n   - Check if the user has appropriate viewing rights\n   - Validate the fromDb parameter:\n     - IF fromDb is null, THEN use default value (false)\n     - Ensure fromDb is a valid boolean value\n\n3. Business Rule Processing:\n   - Verify that the forum system is operational\n   - Check if message counting is enabled in system settings\n   - Determine cache validity:\n     - IF fromDb is true, THEN bypass cache check\n     - IF fromDb is false, THEN check if cache contains valid count\n   - Check if count should include all message types or only specific categories\n   - Determine if any message filtering rules should be applied:\n     - IF message filtering is enabled, THEN prepare to apply filters\n     - ELSE proceed with total count retrieval\n\n4. Core Operation Execution:\n   - Access the message repository\n   - Check cache status:\n     - Attempt to retrieve cached message count\n     - IF cached count exists AND is greater than zero AND fromDb is false:\n       - Use the cached count value\n     - ELSE:\n       - Query the database for total message count across all forums\n       - Store the retrieved count in cache for future use\n   - IF counting operation fails:\n     - Log the failure reason\n     - Prepare error response\n     - Attempt recovery if possible\n   - ELSE:\n     - Ensure the count is properly stored for future reference\n     - Prepare success response\n\n5. Response Generation:\n   - Format the total message count for display\n   - IF operation was successful:\n     - Return the total message count as an integer\n     - Include timestamp of when count was generated\n   - ELSE:\n     - Return appropriate error message\n     - Include troubleshooting information\n     - Suggest alternative actions",
    "databaseEntities": [
      "jforum_posts",
      "jforum_forums",
      "jforum_topics"
    ],
    "validationRules": [
      "User must have permission to view forum statistics",
      "Database connection must be available",
      "Forum system must be operational",
      "Cache must be properly initialized before use"
    ],
    "dbSeedingOperations": [],
    "schema": {}
  },
  {
    "featureName": "GetTotalTopics",
    "description": "Retrieves the total count of topics for a specific forum.",
    "inputValues": [
      "forumId-number-Forum"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect forumId (mandatory, number) to identify the forum\n\n2. Data Validation:\n   - Validate forumId:\n     a. Check if forumId is provided\n     b. Verify forumId is a positive integer\n     c. If validation fails, prepare appropriate error message\n\n3. Business Rule Processing:\n   - Verify forum exists:\n     a. Check if the provided forumId corresponds to an existing forum\n     b. If forum doesn't exist, prepare error response\n   - Verify user has access rights to the forum:\n     a. Check if the current user has permission to view the forum\n     b. If access is denied, prepare permission error response\n\n4. Core Operation Execution:\n   - Retrieve topic count:\n     a. Access forum data storage\n     b. Count all topics associated with the specified forumId\n     c. IF any error occurs during retrieval:\n        i. Log the error details\n        ii. Prepare system error response\n     d. Store the count value for response\n\n5. Response Generation:\n   - IF operation was successful:\n     a. Format response with total topic count\n     b. Include forum identifier in response\n     c. Return success status with count data\n   - ELSE IF operation failed:\n     a. Include appropriate error message\n     b. Include error code based on failure reason\n     c. Return error status",
    "databaseEntities": [
      "jforum_forums",
      "jforum_topics"
    ],
    "validationRules": [
      "Forum ID must be a positive integer",
      "Forum must exist in the system",
      "User must have permission to view the forum"
    ],
    "dbSeedingOperations": [],
    "schema": {}
  },
  {
    "featureName": "GetMaxPostId",
    "description": "Retrieves the maximum post ID in a specific topic.",
    "inputValues": [
      "topicId-number-Topic"
    ],
    "businessLogic": "1. Input Collection\n   - Collect the topicId (number) from the user request\n   - The topicId is mandatory and must be a positive integer\n\n2. Data Validation\n   - Validate that topicId is provided\n     - IF topicId is missing or null THEN\n       - Generate an error message: \"Topic ID is required\"\n       - Return error response\n     - END IF\n   - Validate that topicId is a positive integer\n     - IF topicId is not a positive integer THEN\n       - Generate an error message: \"Topic ID must be a positive integer\"\n       - Return error response\n     - END IF\n   - Validate that the topic exists in the system\n     - IF topic with topicId does not exist THEN\n       - Generate an error message: \"Topic not found\"\n       - Return error response\n     - END IF\n\n3. Business Rule Processing\n   - Check if the user has permission to view the topic\n     - IF user does not have view permission for the topic THEN\n       - Generate an error message: \"You do not have permission to view this topic\"\n       - Return error response\n     - END IF\n   - Check if the topic has any posts\n     - IF topic has no posts THEN\n       - Set maxPostId to -1 (default value for topics with no posts)\n       - Skip to Response Generation step\n     - END IF\n\n4. Core Operation Execution\n   - Query the database to find the maximum post ID in the specified topic\n     - Search through all posts associated with the given topicId\n     - Find the highest post_id value among all posts in the topic\n     - IF an error occurs during the database operation THEN\n       - Log the error details\n       - Generate an error message: \"Unable to retrieve maximum post ID\"\n       - Return error response\n     - END IF\n     - Store the retrieved maximum post ID value as 'id'\n     - IF no posts are found THEN\n       - Set id to -1\n     - END IF\n\n5. Response Generation\n   - Prepare the success response\n     - Include the maximum post ID value\n     - IF no posts were found (id = -1) THEN\n       - Include a message indicating the topic has no posts\n     - END IF\n   - Return the response with the maximum post ID",
    "databaseEntities": [
      "jforum_topics",
      "jforum_posts"
    ],
    "validationRules": [
      "Topic ID must be provided",
      "Topic ID must be a positive integer",
      "Topic must exist in the system",
      "User must have permission to view the topic"
    ],
    "dbSeedingOperations": [],
    "schema": {}
  },
  {
    "featureName": "MoveTopics",
    "description": "Moves topics from one forum to another with proper count adjustments.",
    "inputValues": [
      "topics-object-TopicList",
      "fromForumId-number-Forum",
      "toForumId-number-Forum",
      "logDescription-string-ModerationLog"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the following inputs:\n     * topics: List of topic IDs to be moved (mandatory)\n     * fromForumId: Source forum ID (mandatory)\n     * toForumId: Destination forum ID (mandatory)\n     * logDescription: Description for the moderation log (optional)\n\n2. Data Validation:\n   - Validate topic list:\n     * Ensure the topic list is not empty\n     * Verify all topic IDs are valid numbers\n     * Check that all topics exist in the system\n   - Validate forum IDs:\n     * Ensure fromForumId is a valid number and exists\n     * Ensure toForumId is a valid number and exists\n     * Verify fromForumId and toForumId are different\n   - Validate user permissions:\n     * Verify the current user has permission to move topics\n     * Ensure user has access to both source and destination forums\n\n3. Business Rule Processing:\n   - Check system state:\n     * Verify both forums are active and not locked\n     * Ensure the destination forum allows new topics\n   - Verify dependencies:\n     * Check if any of the topics are sticky or announcement topics that may have special handling\n     * Determine if the destination forum is moderated\n   - Prepare moderation log:\n     * Create a new moderation log entry with current user information\n     * Include the description of the action being performed\n     * Record the original forum information for audit purposes\n\n4. Core Operation Execution:\n   - Update topic records:\n     * For each topic in the list:\n       * Change the forum ID from source to destination\n       * Update moderation status based on destination forum settings\n       * Create individual moderation log entries for each topic moved\n   - Update associated post records:\n     * Update forum ID for all posts belonging to the moved topics\n   - Update forum statistics:\n     * Decrement total topic count in the source forum\n     * Increment total topic count in the destination forum\n     * Recalculate and update the last post information for both forums\n   - Update caches:\n     * Clear topic cache for both source and destination forums\n     * Reload forum information for both forums\n     * Update most recent topics list\n     * Update hottest topics list if applicable\n   - Handle forum subscriptions:\n     * Notify subscribed users about topic movement if applicable\n\n5. Response Generation:\n   - Success response:\n     * Return confirmation of successful topic movement\n     * Include the number of topics moved\n     * Provide updated forum information for both source and destination\n     * Display a moderation completion message with a redirect URL\n   - Error response:\n     * Return appropriate error messages for any failures\n     * Include specific details about which topics could not be moved and why\n     * Display a permission denied message if user lacks required permissions",
    "databaseEntities": [
      "jforum_forums",
      "jforum_topics",
      "jforum_posts",
      "jforum_moderation_log"
    ],
    "validationRules": [
      "Topic list must not be empty",
      "All topic IDs must be valid and exist in the system",
      "Source forum ID must be valid and exist",
      "Destination forum ID must be valid and exist",
      "Source and destination forums must be different",
      "User must have permission to move topics",
      "Both forums must be active and not locked",
      "User must have PERM_MODERATION_TOPIC_MOVE permission"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "TopicList": {
        "type": "array",
        "items": {
          "type": "string",
          "description": "Topic ID"
        }
      },
      "Forum": {
        "type": "object",
        "properties": {
          "id": {
            "type": "number",
            "description": "Forum identifier"
          },
          "name": {
            "type": "string",
            "description": "Forum name"
          },
          "isModerated": {
            "type": "boolean",
            "description": "Indicates if the forum is moderated"
          }
        }
      },
      "ModerationLog": {
        "type": "object",
        "properties": {
          "description": {
            "type": "string",
            "description": "Description of the moderation action"
          },
          "type": {
            "type": "number",
            "description": "Type of moderation action"
          },
          "userId": {
            "type": "number",
            "description": "ID of the user performing the moderation"
          }
        }
      }
    }
  },
  {
    "featureName": "CheckUnreadTopics",
    "description": "Identifies unread topics in a forum based on user's last visit timestamp.",
    "inputValues": [
      "forumId-number-Forum",
      "lastVisit-date-User"
    ],
    "businessLogic": "1. Input Collection\n   - Collect the following inputs:\n     a. forumId (mandatory): Numeric identifier of the forum to check\n     b. lastVisit (mandatory): Timestamp of user's last visit to the forum\n\n2. Data Validation\n   - Validate forumId:\n     a. Check if forumId is provided\n     b. Verify forumId is a positive integer\n     c. IF forumId is invalid or missing, THEN return error message \"Invalid forum identifier\"\n   - Validate lastVisit timestamp:\n     a. Check if lastVisit is provided\n     b. Verify lastVisit is a valid date format\n     c. IF lastVisit is invalid or missing, THEN return error message \"Invalid last visit timestamp\"\n\n3. Business Rule Processing\n   - Verify forum existence:\n     a. Check if the specified forum exists in the system\n     b. IF forum does not exist, THEN return error message \"Forum not found\"\n   - Verify user access permissions:\n     a. Check if the current user has permission to view the specified forum\n     b. IF user lacks permission, THEN return error message \"Access denied to this forum\"\n\n4. Core Operation Execution\n   - Retrieve unread topics:\n     a. Query for all topics in the specified forum\n     b. Filter topics where the last post time is greater than the user's last visit timestamp\n     c. For each matching topic:\n        i. Create a topic object with topic identifier and timestamp\n        ii. Add the topic to the results list\n   - Process results:\n     a. IF no unread topics are found, THEN prepare empty result list\n     b. IF system error occurs during retrieval, THEN prepare for error handling\n\n5. Response Generation\n   - Format the response:\n     a. Create a list of unread topics with their identifiers and timestamps\n     b. IF operation was successful, THEN return the list of unread topics\n     c. IF operation failed, THEN return appropriate error message with details\n   - Provide additional information:\n     a. Include total count of unread topics\n     b. Include forum information for context",
    "databaseEntities": [
      "jforum_forums",
      "jforum_topics",
      "jforum_posts",
      "jforum_users",
      "jforum_sessions"
    ],
    "validationRules": [
      "Forum ID must be a positive integer",
      "Last visit timestamp must be a valid date",
      "User must have permission to access the forum",
      "Forum must exist in the system"
    ],
    "dbSeedingOperations": [],
    "schema": {}
  },
  {
    "featureName": "SetModerated",
    "description": "Sets the moderation status for a forum category.",
    "inputValues": [
      "categoryId-number-Category",
      "status-boolean-Forum"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect categoryId (mandatory, number): The identifier of the category to modify\n   - Collect status (mandatory, boolean): The new moderation status to set\n   - System will use current user session for authorization\n\n2. Data Validation:\n   - Validate categoryId:\n     a. Verify categoryId is a positive integer\n     b. Verify categoryId exists in the system\n     c. IF categoryId is invalid or not found, THEN return error message \"Invalid category identifier\"\n   - Validate status:\n     a. Verify status is a boolean value\n     b. IF status is not a valid boolean, THEN return error message \"Invalid moderation status value\"\n   - Validate user permissions:\n     a. Verify current user has administrator privileges\n     b. IF user lacks required permissions, THEN return error message \"Insufficient permissions to modify forum moderation settings\"\n\n3. Business Rule Processing:\n   - Check if the category is available for moderation changes:\n     a. Verify the category is active in the system\n     b. IF category is not active, THEN return error message \"Cannot modify moderation settings for inactive category\"\n   - Check if the moderation status is already set to the requested value:\n     a. Retrieve current moderation status for the category\n     b. IF current status equals requested status, THEN return message \"Category already has the requested moderation status\"\n\n4. Core Operation Execution:\n   - Update moderation status:\n     a. Set the moderation flag for the specified category to the new status value\n     b. IF status is set to true, THEN:\n        i. All new topics in this category will require approval before becoming visible\n        ii. Update related forum settings to reflect moderation requirements\n     c. IF status is set to false, THEN:\n        i. All new topics in this category will be automatically approved\n        ii. Update related forum settings to reflect automatic approval\n   - Update affected topics:\n     a. IF configuration requires it, update moderation status for existing topics in the category\n     b. Record the change in the system activity log\n     c. IF any error occurs during update, THEN:\n        i. Revert any partial changes\n        ii. Return error message \"Failed to update moderation status\"\n\n5. Response Generation:\n   - On success:\n     a. Return confirmation message \"Moderation status for category [categoryId] has been updated successfully\"\n     b. Include summary of affected forums and topics\n     c. Provide information about next steps for moderators\n   - On failure:\n     a. Return appropriate error message\n     b. Include troubleshooting information\n     c. Suggest alternative actions if applicable",
    "databaseEntities": [
      "jforum_categories",
      "jforum_forums",
      "jforum_topics"
    ],
    "validationRules": [
      "Category ID must be a positive integer",
      "Category ID must exist in the system",
      "Moderation status must be a boolean value",
      "User must have administrator privileges to change moderation settings",
      "Category must be active to modify its moderation settings"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Category": {
        "id": "number",
        "name": "string",
        "description": "string",
        "order": "number",
        "moderated": "boolean"
      },
      "Forum": {
        "id": "number",
        "categoryId": "number",
        "name": "string",
        "description": "string",
        "order": "number",
        "moderated": "boolean",
        "totalTopics": "number",
        "totalPosts": "number"
      }
    }
  },
  {
    "featureName": "GetBoardStatus",
    "description": "Retrieves forum statistics including posts, users, topics, and activity metrics.",
    "inputValues": [],
    "businessLogic": "1. Input Collection:\n   - No user inputs required for this feature\n   - System will use current date for calculations\n\n2. Data Validation:\n   - Verify system connection is available\n   - Ensure database is accessible\n   - Validate that required tables exist and are accessible\n\n3. Business Rule Processing:\n   - Check user permissions to access board statistics\n   - Verify if statistics caching is enabled\n   - IF statistics are cached AND cache is valid\n     THEN retrieve statistics from cache\n     ELSE proceed with database queries\n\n4. Core Operation Execution:\n   4.1. Retrieve Total Posts Count\n       - Count all messages in the system\n       - Store the count for statistics\n   \n   4.2. Retrieve Total Users Count\n       - Count all registered users in the system\n       - Store the count for statistics\n   \n   4.3. Retrieve Total Topics Count\n       - Count all discussion topics in the system\n       - Store the count for statistics\n   \n   4.4. Calculate Posts Per Day\n       - Retrieve timestamp of first post in the system\n       - IF first post timestamp exists\n         THEN calculate days between first post and current date\n         THEN divide total posts by number of days\n         IF result is less than 1 AND posts exist\n           THEN set posts per day to 1\n         ELSE use calculated value\n       ELSE set posts per day to 0\n   \n   4.5. Calculate Topics Per Day\n       - Use first post timestamp from previous step\n       - IF first post timestamp exists\n         THEN calculate days between first post and current date\n         THEN divide total topics by number of days\n       ELSE set topics per day to 0\n   \n   4.6. Calculate Users Per Day\n       - Retrieve timestamp of first registered user\n       - IF first user timestamp exists\n         THEN calculate days between first registration and current date\n         THEN divide total users by number of days\n       ELSE set users per day to 0\n   \n   4.7. Compile Statistics\n       - Create statistics object with all calculated values\n       - Package data for response\n\n5. Response Generation:\n   - Return compiled statistics object containing:\n     * Total number of posts\n     * Total number of users\n     * Total number of topics\n     * Posts per day average\n     * Topics per day average\n     * Users per day average\n   - IF any errors occurred during processing\n     THEN return appropriate error message\n     ELSE return complete statistics object",
    "databaseEntities": [
      "jforum_users",
      "jforum_topics",
      "jforum_posts"
    ],
    "validationRules": [
      "User must have permission to view board statistics",
      "Database connection must be available",
      "First post timestamp must be valid for per-day calculations",
      "First user registration timestamp must be valid for per-day calculations"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "ForumStats": {
        "type": "object",
        "properties": {
          "posts": {
            "type": "integer",
            "description": "Total number of posts in the forum"
          },
          "users": {
            "type": "integer",
            "description": "Total number of registered users"
          },
          "topics": {
            "type": "integer",
            "description": "Total number of discussion topics"
          },
          "postsPerDay": {
            "type": "number",
            "description": "Average number of posts per day"
          },
          "topicsPerDay": {
            "type": "number",
            "description": "Average number of topics per day"
          },
          "usersPerDay": {
            "type": "number",
            "description": "Average number of new users per day"
          }
        }
      }
    }
  },
  {
    "featureName": "NotifyUsers",
    "description": "Gets list of users to notify about forum updates.",
    "inputValues": [
      "forum-object-Forum",
      "topic-object-Topic",
      "post-object-Post"
    ],
    "businessLogic": "1. Input Collection\n   - Collect the Forum object containing forum information\n   - Collect the Topic object containing topic information\n   - Collect the Post object containing the new message details\n   - System retrieves notification configuration setting from system preferences\n\n2. Data Validation\n   - Validate that the provided Forum object is not null\n   - Validate that the provided Topic object is not null\n   - Validate that the provided Post object is not null\n   - Verify that the Forum ID is valid (positive integer)\n   - Verify that the Topic ID is valid (positive integer)\n   - Verify that the Post ID is valid (positive integer)\n   - Check if mail notification for answers is enabled in system configuration\n     - IF notification setting is disabled, exit the process\n\n3. Business Rule Processing\n   - Verify that the forum allows notifications\n   - Check if there are any system-wide notification restrictions in place\n   - Determine if the current operation should trigger notifications\n   - Verify that the post contains valid content for notification\n\n4. Core Operation Execution\n   - Retrieve data access object for forum operations\n   - Query the database for all users who have subscribed to the forum\n     - Exclude users who have opted out of notifications\n     - Exclude users without valid email addresses\n   - IF no users are subscribed to the forum:\n     - Log information that no notifications are needed\n     - Exit the process without sending notifications\n   - IF users are found for notification:\n     - Create a notification task with the following information:\n       * Forum details (name, ID, description)\n       * Topic details (title, ID, content)\n       * Post details (content, author, timestamp)\n       * List of users to notify with their contact information\n     - Submit the notification task to the system's task executor\n     - Ensure the task runs asynchronously to avoid blocking the main process\n   - IF any errors occur during the notification process:\n     - Log the error details for system administrators\n     - Continue normal operation without notification\n     - Ensure the error doesn't affect the main forum functionality\n\n5. Response Generation\n   - No direct response is returned as this is an asynchronous notification process\n   - System logs successful submission of the notification task\n   - IF an error occurred during processing:\n     - System logs appropriate warning message with error details",
    "databaseEntities": [
      "jforum_users",
      "jforum_forums",
      "jforum_topics",
      "jforum_posts",
      "jforum_posts_text"
    ],
    "validationRules": [
      "Forum object must not be null",
      "Topic object must not be null",
      "Post object must not be null",
      "Forum ID must be a positive integer",
      "Topic ID must be a positive integer",
      "Post ID must be a positive integer",
      "Mail notification setting must be enabled in system configuration"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Forum": {
        "type": "object",
        "properties": {
          "id": {
            "type": "integer",
            "description": "Unique identifier for the forum"
          },
          "name": {
            "type": "string",
            "description": "Name of the forum"
          },
          "description": {
            "type": "string",
            "description": "Description of the forum"
          },
          "lastPostInfo": {
            "type": "object",
            "description": "Information about the last post in this forum"
          }
        },
        "required": [
          "id"
        ]
      },
      "Topic": {
        "type": "object",
        "properties": {
          "id": {
            "type": "integer",
            "description": "Unique identifier for the topic"
          },
          "title": {
            "type": "string",
            "description": "Title of the topic"
          },
          "forumId": {
            "type": "integer",
            "description": "ID of the forum this topic belongs to"
          }
        },
        "required": [
          "id"
        ]
      },
      "Post": {
        "type": "object",
        "properties": {
          "id": {
            "type": "integer",
            "description": "Unique identifier for the post"
          },
          "text": {
            "type": "string",
            "description": "Content of the post"
          },
          "userId": {
            "type": "integer",
            "description": "ID of the user who created the post"
          },
          "time": {
            "type": "date",
            "description": "Timestamp when the post was created"
          }
        },
        "required": [
          "id"
        ]
      },
      "User": {
        "type": "object",
        "properties": {
          "id": {
            "type": "integer",
            "description": "Unique identifier for the user"
          },
          "email": {
            "type": "string",
            "description": "Email address of the user"
          },
          "username": {
            "type": "string",
            "description": "Username of the user"
          },
          "lang": {
            "type": "string",
            "description": "Language preference of the user"
          },
          "notifyText": {
            "type": "boolean",
            "description": "Flag indicating if the user prefers text notifications"
          }
        }
      }
    }
  },
  {
    "featureName": "SubscribeUser",
    "description": "Subscribes a user to a topic for receiving notifications about new posts and activities.",
    "inputValues": [
      "topicId-number-Topic",
      "userId-number-User"
    ],
    "businessLogic": "1. Input Collection\n   - Collect the following required inputs:\n     a. topicId (mandatory): Identifier of the topic to subscribe to\n     b. userId (mandatory): Identifier of the user who wants to subscribe\n\n2. Data Validation\n   - Validate topic identifier:\n     a. Check if topicId is provided\n     b. Verify topicId is a positive integer\n     c. IF validation fails, THEN generate appropriate error message\n   - Validate user identifier:\n     a. Check if userId is provided\n     b. Verify userId is a positive integer\n     c. IF validation fails, THEN generate appropriate error message\n\n3. Business Rule Processing\n   - Check system state requirements:\n     a. Verify the topic exists in the system\n        i. IF topic does not exist, THEN return error message\n     b. Verify the user exists in the system\n        i. IF user does not exist, THEN return error message\n     c. Check if user is already subscribed to this topic\n        i. IF user is already subscribed, THEN return notification message\n        ii. ELSE continue with subscription process\n   - Verify user permissions:\n     a. Check if user has permission to subscribe to topics\n        i. IF user is anonymous, THEN return error message\n        ii. IF user lacks permission, THEN return error message\n\n4. Core Operation Execution\n   - Process the subscription:\n     a. Create a new subscription record linking the user to the topic\n     b. Set the subscription status to active\n     c. Set the initial read status for the subscription\n     d. IF any operation fails:\n        i. Rollback any partial changes\n        ii. Generate appropriate error message\n\n5. Response Generation\n   - For successful subscription:\n     a. Generate success message confirming the subscription\n     b. Include topic title in confirmation message\n     c. Provide information about how notifications will be delivered\n     d. Include instructions on how to unsubscribe if needed\n   - For failed subscription:\n     a. Return specific error message based on the failure reason\n     b. Provide guidance on how to resolve the issue",
    "databaseEntities": [
      "jforum_topics",
      "jforum_users",
      "jforum_topics_watch"
    ],
    "validationRules": [
      "Topic ID must be a valid positive integer",
      "User ID must be a valid positive integer",
      "Topic must exist in the system",
      "User must exist in the system",
      "User must not be anonymous",
      "User must not already be subscribed to the topic",
      "User must have permission to subscribe to topics"
    ],
    "dbSeedingOperations": [],
    "schema": {}
  },
  {
    "featureName": "IsUserSubscribed",
    "description": "Checks if a user is subscribed to a specific forum.",
    "inputValues": [
      "forumId-number-Forum",
      "userId-number-User"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect forumId (mandatory, number): The unique identifier of the forum\n   - Collect userId (mandatory, number): The unique identifier of the user\n\n2. Data Validation:\n   - Validate forumId:\n      a. Check if forumId is provided\n      b. Verify forumId is a positive integer\n      c. IF forumId is invalid, THEN return error message \"Invalid forum identifier\"\n   - Validate userId:\n      a. Check if userId is provided\n      b. Verify userId is a positive integer\n      c. IF userId is invalid, THEN return error message \"Invalid user identifier\"\n\n3. Business Rule Processing:\n   - Verify forum existence:\n      a. Check if the forum with the given forumId exists in the system\n      b. IF forum does not exist, THEN return error message \"Forum not found\"\n   - Verify user existence:\n      a. Check if the user with the given userId exists in the system\n      b. IF user does not exist, THEN return error message \"User not found\"\n   - Check user permissions:\n      a. Verify if the user has permission to view the specified forum\n      b. IF user does not have permission, THEN return error message \"User does not have permission to access this forum\"\n\n4. Core Operation Execution:\n   - Query subscription records:\n      a. Search for a subscription record that matches both the forumId and userId\n      b. IF a matching record is found, THEN set isSubscribed to true\n      c. IF no matching record is found, THEN set isSubscribed to false\n\n5. Response Generation:\n   - Prepare the response:\n      a. Include the subscription status (isSubscribed: true/false)\n      b. Include the forumId and userId in the response\n   - Return the response to the caller",
    "databaseEntities": [
      "jforum_forums",
      "jforum_users"
    ],
    "validationRules": [
      "Forum ID must be a positive integer",
      "User ID must be a positive integer",
      "Forum must exist in the system",
      "User must exist in the system",
      "User must have permission to access the forum"
    ],
    "dbSeedingOperations": [],
    "schema": {}
  },
  {
    "featureName": "RemoveSubscription",
    "description": "Removes a user's subscription from a topic.",
    "inputValues": [
      "topicId-number-Topic",
      "userId-number-User"
    ],
    "businessLogic": "1. Input Collection\n   - Collect the following required inputs:\n     a. topicId (number): Identifier of the topic to unsubscribe from\n     b. userId (number): Identifier of the user who wants to unsubscribe\n   - Both inputs are mandatory and must be provided by the system\n\n2. Data Validation\n   - Validate topicId:\n     a. Check if topicId is a positive integer\n     b. Check if topicId exists in the system\n     c. IF topicId is invalid or not found, THEN return an error message indicating invalid topic\n   - Validate userId:\n     a. Check if userId is a positive integer\n     b. Check if userId exists in the system\n     c. IF userId is invalid or not found, THEN return an error message indicating invalid user\n\n3. Business Rule Processing\n   - Check if the user is currently subscribed to the topic:\n     a. Verify if a subscription record exists for the given userId and topicId\n     b. IF no subscription exists, THEN return a message indicating the user is not subscribed to this topic\n   - Check user permissions:\n     a. Verify if the user has permission to manage their subscriptions\n     b. IF user lacks permission, THEN return an access denied error message\n\n4. Core Operation Execution\n   - Remove the subscription record:\n     a. Locate the subscription record matching the topicId and userId\n     b. Delete the subscription record from the system\n     c. IF deletion fails, THEN log the error and return a system error message\n     d. Update any related notification settings or cached information about topic subscriptions\n\n5. Response Generation\n   - Generate success response:\n     a. Create a confirmation message indicating successful unsubscription\n     b. Include the topic title in the confirmation message\n     c. Provide information about how to resubscribe if needed\n   - IF any errors occurred during the process:\n     a. Generate appropriate error message based on the specific error\n     b. Include guidance on how to resolve the issue or contact support",
    "databaseEntities": [
      "jforum_topics",
      "jforum_users"
    ],
    "validationRules": [
      "Topic ID must be a positive integer",
      "User ID must be a positive integer",
      "Topic must exist in the system",
      "User must exist in the system",
      "User must be currently subscribed to the topic"
    ],
    "dbSeedingOperations": [],
    "schema": {}
  },
  {
    "featureName": "CheckUserForumSubscription",
    "description": "Verifies if a user is subscribed to a specific forum.",
    "inputValues": [
      "forumId-number-Forum",
      "userId-number-User"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect forumId (mandatory, number): The unique identifier of the forum to check\n   - Collect userId (mandatory, number): The unique identifier of the user to check\n   - System will use these identifiers to verify subscription status\n\n2. Data Validation:\n   - Validate forumId:\n     a. Check if forumId is provided\n     b. Verify forumId is a positive integer\n     c. IF forumId is invalid or missing, THEN return error message indicating invalid forum identifier\n   - Validate userId:\n     a. Check if userId is provided\n     b. Verify userId is a positive integer\n     c. IF userId is invalid or missing, THEN return error message indicating invalid user identifier\n\n3. Business Rule Processing:\n   - Verify forum existence:\n     a. Check if the specified forum exists in the system\n     b. IF forum does not exist, THEN return error message indicating forum not found\n   - Verify user existence:\n     a. Check if the specified user exists in the system\n     b. IF user does not exist, THEN return error message indicating user not found\n   - Verify user access permissions:\n     a. Check if the user has permission to access the specified forum\n     b. IF user lacks access permissions, THEN return error message indicating insufficient permissions\n\n4. Core Operation Execution:\n   - Query subscription records:\n     a. Search for subscription record matching both forumId and userId\n     b. Determine if a matching subscription record exists\n     c. IF record exists, THEN set subscription status to true\n     d. IF record does not exist, THEN set subscription status to false\n\n5. Response Generation:\n   - Success response:\n     a. Return subscription status (true/false)\n     b. Include forum information (name, category)\n     c. Include subscription details if subscribed (date subscribed)\n   - Error response:\n     a. Return appropriate error message based on validation or processing failures\n     b. Include error code and suggested resolution steps",
    "databaseEntities": [
      "jforum_users",
      "jforum_forums"
    ],
    "validationRules": [
      "Forum ID must be a positive integer",
      "User ID must be a positive integer",
      "Forum must exist in the system",
      "User must exist in the system",
      "User must have permission to access the forum"
    ],
    "dbSeedingOperations": [],
    "schema": {}
  },
  {
    "featureName": "RemoveForumSubscription",
    "description": "Removes a user's subscription from a specific forum.",
    "inputValues": [
      "forumId-number-Forum",
      "userId-number-User"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect forumId (mandatory): Numeric identifier of the forum\n   - Collect userId (mandatory): Numeric identifier of the user\n   - No default values are provided for these fields\n   - Both fields are required to identify the specific subscription to remove\n\n2. Data Validation:\n   - Validate forumId:\n      a. Check if forumId is provided\n      b. Verify forumId is a positive integer\n      c. Return error if validation fails: \"Forum identifier must be a valid positive number\"\n   - Validate userId:\n      a. Check if userId is provided\n      b. Verify userId is a positive integer\n      c. Return error if validation fails: \"User identifier must be a valid positive number\"\n\n3. Business Rule Processing:\n   - Verify forum existence:\n      a. Check if forum with forumId exists in the system\n      b. IF forum does not exist, THEN return error: \"Forum not found\"\n   - Verify user existence:\n      a. Check if user with userId exists in the system\n      b. IF user does not exist, THEN return error: \"User not found\"\n   - Verify subscription existence:\n      a. Check if the user is currently subscribed to the forum\n      b. IF user is not subscribed, THEN return notification: \"User is not subscribed to this forum\"\n      c. IF user is subscribed, THEN proceed to next step\n\n4. Core Operation Execution:\n   - Remove subscription record:\n      a. Locate the subscription record matching the forumId and userId\n      b. Remove the subscription record from the system\n      c. IF removal fails, THEN:\n         i. Log the failure details\n         ii. Return error: \"Failed to remove subscription\"\n      d. IF removal succeeds, THEN proceed to next step\n   - Update user subscription status:\n      a. Update user's subscription list to reflect the removal\n      b. Update forum's subscriber count if applicable\n\n5. Response Generation:\n   - Success response:\n      a. Generate confirmation message: \"Subscription successfully removed\"\n      b. Include details of the forum name in the confirmation\n      c. Provide option to resubscribe if needed\n   - Error response:\n      a. Include specific error message based on the failure point\n      b. Provide guidance on how to resolve the issue\n      c. Include support contact information if needed",
    "databaseEntities": [
      "jforum_users",
      "jforum_forums"
    ],
    "validationRules": [
      "Forum ID must be a valid positive integer",
      "User ID must be a valid positive integer",
      "Forum must exist in the system",
      "User must exist in the system",
      "User must be currently subscribed to the forum"
    ],
    "dbSeedingOperations": [],
    "schema": {}
  },
  {
    "featureName": "RemoveAllForumSubscriptions",
    "description": "Removes all user subscriptions from a specific forum.",
    "inputValues": [
      "forumId-number-Forum"
    ],
    "businessLogic": "1. Input Collection\n   1.1. Collect the forum identifier (forumId) from the user request\n       1.1.1. forumId is mandatory and must be provided\n       1.1.2. No default value is available for forumId\n\n2. Data Validation\n   2.1. Validate forum identifier\n       2.1.1. Check if forumId is a positive integer\n       2.1.2. IF forumId is not a positive integer, THEN\n              - Generate an error message: \"Invalid forum identifier provided\"\n              - Terminate the process\n   2.2. Verify forum existence\n       2.2.1. Check if the forum with the provided forumId exists in the system\n       2.2.2. IF forum does not exist, THEN\n              - Generate an error message: \"Forum not found\"\n              - Terminate the process\n\n3. Business Rule Processing\n   3.1. Check forum status\n       3.1.1. Verify if the forum is active and available for subscription management\n       3.1.2. IF forum is inactive or unavailable, THEN\n              - Generate an error message: \"Forum is not available for subscription management\"\n              - Terminate the process\n   3.2. Check subscription existence\n       3.2.1. Verify if there are any subscriptions for the specified forum\n       3.2.2. IF no subscriptions exist, THEN\n              - Generate an informational message: \"No subscriptions found for this forum\"\n              - Skip to Response Generation step\n\n4. Core Operation Execution\n   4.1. Remove all subscriptions\n       4.1.1. Identify all user subscriptions associated with the specified forum\n       4.1.2. Remove all identified subscriptions from the system\n       4.1.3. IF any error occurs during removal, THEN\n              - Log the error details\n              - Attempt to rollback any partial changes\n              - Generate an error message: \"Failed to remove all subscriptions\"\n              - Terminate the process\n   4.2. Update forum subscription status\n       4.2.1. Update any relevant counters or indicators related to forum subscriptions\n       4.2.2. Record the subscription removal action in the system logs\n\n5. Response Generation\n   5.1. Generate success response\n       5.1.1. Create a confirmation message indicating all subscriptions were removed\n       5.1.2. Include the forum name and identifier in the confirmation message\n       5.1.3. Return success status with the confirmation message\n   5.2. In case of failure\n       5.2.1. Return appropriate error status with detailed error message\n       5.2.2. Include suggestions for resolving the issue if applicable",
    "databaseEntities": [
      "jforum_forums",
      "jforum_users"
    ],
    "validationRules": [
      "Forum ID must be a positive integer",
      "Forum must exist in the system",
      "Forum must be active and available for subscription management"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Forum": {
        "id": "number",
        "name": "string",
        "description": "string",
        "isActive": "boolean"
      }
    }
  },
  {
    "featureName": "DiscoverForumIdByEmail",
    "description": "Retrieves a forum's ID based on its associated email address.",
    "inputValues": [
      "listEmail-string-Forum"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the forum's email address (listEmail) as a string\n   - This input is mandatory\n   - No default values are provided\n\n2. Data Validation:\n   - Validate the listEmail input:\n     a. Check if listEmail is not null or empty\n        IF listEmail is null or empty THEN\n          Return an error message indicating email is required\n     b. Verify the listEmail has a valid email format\n        IF listEmail format is invalid THEN\n          Return an error message indicating invalid email format\n\n3. Business Rule Processing:\n   - Verify system state:\n     a. Check if the database connection is available\n        IF database connection is unavailable THEN\n          Return an error indicating system unavailability\n     b. Verify user has permission to access forum information\n        IF user lacks permission THEN\n          Return an error indicating insufficient privileges\n\n4. Core Operation Execution:\n   - Search for forum with matching email address:\n     a. Query the forum database using the provided listEmail\n     b. Extract the forum ID if a match is found\n     c. IF no matching forum is found THEN\n          Set forumId to 0 (indicating no match)\n     d. IF database error occurs during search THEN\n          Handle the error gracefully\n          Log the error details\n          Return appropriate error message\n\n5. Response Generation:\n   - Success response:\n     a. IF forumId > 0 THEN\n          Return the found forum ID\n          Include forum ID in the response\n     b. IF forumId = 0 THEN\n          Return indication that no forum was found with the given email\n   - Error response:\n     a. For validation errors, return specific validation failure messages\n     b. For system errors, return appropriate error code and message\n     c. Include support information for unresolved issues",
    "databaseEntities": [
      "jforum_forums"
    ],
    "validationRules": [
      "Forum email must not be empty",
      "Forum email must be in valid format",
      "User must have permission to access forum information"
    ],
    "dbSeedingOperations": [],
    "schema": {}
  },
  {
    "featureName": "UpdateGroupInformation",
    "description": "Modifies an existing group's name, parent, and description.",
    "inputValues": [
      "groupId-number-Group",
      "name-string-Group",
      "parentId-number-Group",
      "description-string-Group"
    ],
    "businessLogic": "1. Input Collection\n   1.1. Collect the following required inputs:\n       - groupId (number): Unique identifier of the group to update\n       - name (string): New name for the group\n       - parentId (number): Identifier of the parent group\n       - description (string): New description for the group\n   1.2. Validate that groupId is provided and is a positive integer\n\n2. Data Validation\n   2.1. Validate group identifier\n       2.1.1. Check if groupId is a valid positive integer\n       2.1.2. IF groupId is invalid or missing, THEN generate an error message indicating invalid group identifier\n   2.2. Validate group name\n       2.2.1. Check if name is provided and not empty\n       2.2.2. Check if name length is within acceptable limits (1-50 characters)\n       2.2.3. IF name validation fails, THEN generate an error message indicating invalid group name\n   2.3. Validate parent group identifier\n       2.3.1. Check if parentId is a valid non-negative integer\n       2.3.2. IF parentId equals groupId, THEN generate an error message indicating a group cannot be its own parent\n       2.3.3. IF parentId is invalid, THEN generate an error message indicating invalid parent group\n   2.4. Validate description\n       2.4.1. Check if description is provided\n       2.4.2. Check if description length is within acceptable limits (0-255 characters)\n       2.4.3. IF description validation fails, THEN generate an error message indicating invalid description\n\n3. Business Rule Processing\n   3.1. Verify group existence\n       3.1.1. Check if a group with the provided groupId exists in the system\n       3.1.2. IF group does not exist, THEN generate an error message indicating group not found\n   3.2. Verify parent group existence (if parentId is provided and not zero)\n       3.2.1. Check if a group with the provided parentId exists in the system\n       3.2.2. IF parent group does not exist, THEN generate an error message indicating parent group not found\n   3.3. Check for circular parent references\n       3.3.1. IF parentId is not zero, THEN verify that setting this parent would not create a circular reference\n       3.3.2. IF circular reference would be created, THEN generate an error message indicating invalid parent relationship\n   3.4. Check for name uniqueness\n       3.4.1. Verify that no other group (except the current one) has the same name\n       3.4.2. IF name is already taken, THEN generate an error message indicating duplicate group name\n\n4. Core Operation Execution\n   4.1. Prepare group update operation\n       4.1.1. Create a group object with the updated information\n       4.1.2. Set the group's ID to the provided groupId\n       4.1.3. Set the group's name to the provided name\n       4.1.4. Set the group's parent ID to the provided parentId\n       4.1.5. Set the group's description to the provided description\n   4.2. Execute group update\n       4.2.1. Update the group record in the database\n       4.2.2. IF update operation fails, THEN generate an error message and roll back any changes\n   4.3. Update related records if necessary\n       4.3.1. IF any related records need to be updated based on group changes, THEN update them\n       4.3.2. IF any related update fails, THEN generate an error message and roll back all changes\n\n5. Response Generation\n   5.1. Generate success response\n       5.1.1. Create a response indicating successful group update\n       5.1.2. Include the updated group information in the response\n       5.1.3. Include any relevant messages or notifications\n   5.2. Handle error responses\n       5.2.1. IF any errors occurred during the process, THEN include detailed error information\n       5.2.2. Provide guidance on how to resolve the error if applicable",
    "databaseEntities": [
      "jforum_groups"
    ],
    "validationRules": [
      "Group ID must be a valid positive integer",
      "Group name must not be empty",
      "Group name must be between 1 and 50 characters",
      "Group description must not exceed 255 characters",
      "Parent ID must be a valid non-negative integer",
      "A group cannot be its own parent",
      "Parent group must exist in the system if specified",
      "Group name must be unique across all groups",
      "No circular parent references are allowed"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Group": {
        "id": "number",
        "name": "string",
        "description": "string",
        "parentId": "number"
      }
    }
  },
  {
    "featureName": "CreateNewGroup",
    "description": "Adds a new user group to the system with specified attributes.",
    "inputValues": [
      "name-string-Group",
      "description-string-Group",
      "parentId-number-Group"
    ],
    "businessLogic": "1. Input Collection\n   1.1. Collect the following required inputs:\n       - name: String (mandatory) - The name of the group to be created\n       - description: String (mandatory) - A detailed description of the group\n       - parentId: Number (mandatory) - The ID of the parent group\n\n2. Data Validation\n   2.1. Validate group name\n       2.1.1. Check if name is provided\n             IF name is empty or null THEN\n                 Return error message \"Group name cannot be empty\"\n       2.1.2. Check if name length is appropriate\n             IF name length < 3 or name length > 50 THEN\n                 Return error message \"Group name must be between 3 and 50 characters\"\n       2.1.3. Check if name is unique\n             IF a group with the same name already exists THEN\n                 Return error message \"A group with this name already exists\"\n   \n   2.2. Validate group description\n       2.2.1. Check if description is provided\n             IF description is empty or null THEN\n                 Return error message \"Group description cannot be empty\"\n       2.2.2. Check if description length is appropriate\n             IF description length > 255 THEN\n                 Return error message \"Group description must be less than 255 characters\"\n   \n   2.3. Validate parent ID\n       2.3.1. Check if parent ID is valid\n             IF parentId < 0 THEN\n                 Return error message \"Parent ID must be a non-negative number\"\n       2.3.2. Check if parent group exists (if parentId > 0)\n             IF parentId > 0 THEN\n                 Check if parent group exists\n                 IF parent group does not exist THEN\n                     Return error message \"The specified parent group does not exist\"\n       2.3.3. Check for self-reference\n             IF parentId equals the ID of the group being created THEN\n                 Set parentId to 0 (no parent)\n\n3. Business Rule Processing\n   3.1. Check system constraints\n       3.1.1. Verify maximum group limit has not been reached\n             IF current number of groups >= maximum allowed groups THEN\n                 Return error message \"Maximum number of groups has been reached\"\n       3.1.2. Check for circular parent references\n             IF parentId creates a circular reference in group hierarchy THEN\n                 Return error message \"Cannot create circular reference in group hierarchy\"\n   \n   3.2. Check user permissions\n       3.2.1. Verify current user has permission to create groups\n             IF user does not have group creation permission THEN\n                 Return error message \"You do not have permission to create groups\"\n\n4. Core Operation Execution\n   4.1. Prepare group data\n       4.1.1. Create a new Group object\n       4.1.2. Set the group name to the provided name\n       4.1.3. Set the group description to the provided description\n       4.1.4. Set the parent ID to the provided parentId\n   \n   4.2. Save group to database\n       4.2.1. Insert the new group record into the database\n       4.2.2. IF insertion fails THEN\n                 Log the error details\n                 Return error message \"Failed to create the group due to a system error\"\n   \n   4.3. Set up default permissions\n       4.3.1. Assign default security roles to the new group\n       4.3.2. IF assigning default roles fails THEN\n                 Rollback group creation\n                 Return error message \"Failed to assign default permissions to the group\"\n\n5. Response Generation\n   5.1. Generate success response\n       5.1.1. Include the newly created group ID\n       5.1.2. Include confirmation message \"Group created successfully\"\n       5.1.3. Include group details (name, description, parentId)\n   \n   5.2. Return response to user\n       5.2.1. Display confirmation message\n       5.2.2. Provide options for next actions (e.g., edit group permissions, add users to group, view group list)",
    "databaseEntities": [
      "jforum_groups",
      "jforum_user_groups",
      "jforum_moderator_groups"
    ],
    "validationRules": [
      "Group name must not be empty",
      "Group name must be between 3 and 50 characters",
      "Group name must be unique",
      "Group description must not be empty",
      "Group description must be less than 255 characters",
      "Parent ID must be a non-negative number",
      "Parent group must exist if parent ID is greater than 0",
      "Group hierarchy must not contain circular references",
      "Self-referencing parent IDs are automatically set to 0"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Group": {
        "id": "number",
        "name": "string",
        "description": "string",
        "parentId": "number"
      }
    }
  },
  {
    "featureName": "GetGroupMembers",
    "description": "Retrieves the list of user IDs belonging to a specific group.",
    "inputValues": [
      "groupId-number-Group"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the group ID (mandatory) from the request\n   - System will use the current database connection (system-generated)\n\n2. Data Validation:\n   - Validate group ID:\n     a. Check if group ID is provided\n     b. Verify group ID is a positive integer\n     c. Return appropriate error message if validation fails\n\n3. Business Rule Processing:\n   - Verify group existence:\n     a. Check if the specified group exists in the system\n     b. IF group does not exist, THEN return an empty list\n     c. IF group exists, THEN proceed with member retrieval\n\n4. Core Operation Execution:\n   - Retrieve group members:\n     a. Access the user-group relationship records for the specified group ID\n     b. Extract all user IDs associated with the group\n     c. Compile the list of user IDs into a collection\n     d. IF any database error occurs during retrieval:\n        i. Log the error details\n        ii. Handle the exception appropriately\n        iii. Return error response\n\n5. Response Generation:\n   - Format the response:\n     a. Return the list of user IDs as integers in a collection\n     b. IF the operation was successful but no members found, return an empty list\n     c. IF an error occurred during processing, return appropriate error information",
    "databaseEntities": [
      "jforum_groups",
      "jforum_user_groups",
      "jforum_users"
    ],
    "validationRules": [
      "Group ID must be a positive integer",
      "Group ID must reference an existing group"
    ],
    "dbSeedingOperations": [],
    "schema": {}
  },
  {
    "featureName": "ListAllGroups",
    "description": "Retrieves all user groups from the database.",
    "inputValues": [],
    "businessLogic": "1. Input Collection:\n   - No user inputs required for this feature\n   - System will retrieve all groups without filtering parameters\n\n2. Data Validation:\n   - No input validation required as there are no user inputs\n   - System validates database connection availability\n     a. IF database connection is unavailable THEN\n        i. Generate appropriate error message\n        ii. Terminate operation\n     b. ELSE continue to next step\n\n3. Business Rule Processing:\n   - Verify user has appropriate permissions to view groups\n     a. IF user lacks required permissions THEN\n        i. Generate access denied message\n        ii. Terminate operation\n     b. ELSE continue to next step\n   - Check system state for any maintenance or read-only conditions\n     a. IF system is in maintenance mode THEN\n        i. Generate maintenance notification\n        ii. Terminate operation\n     b. ELSE continue to next step\n\n4. Core Operation Execution:\n   - Retrieve all group records from the database\n     a. Prepare group collection container\n     b. Query the database for all group records\n     c. FOR each group record found:\n        i. Extract group information (ID, name, description, parent ID)\n        ii. Create group object with extracted information\n        iii. Add group object to collection container\n     d. IF no groups are found THEN\n        i. Return empty collection\n     e. ELSE continue with populated collection\n\n5. Response Generation:\n   - Prepare response with group collection\n     a. Format group data for presentation\n     b. Include total count of groups retrieved\n     c. Return formatted group collection to caller\n   - Handle any exceptions that occurred during processing\n     a. IF exceptions occurred THEN\n        i. Generate appropriate error message\n        ii. Include error details for troubleshooting\n        iii. Return error response\n     b. ELSE return success response with group data",
    "databaseEntities": [
      "jforum_groups"
    ],
    "validationRules": [
      "User must have permission to view groups",
      "Database connection must be available",
      "System must not be in maintenance mode"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Group": {
        "type": "object",
        "properties": {
          "id": {
            "type": "integer",
            "description": "Unique identifier for the group"
          },
          "name": {
            "type": "string",
            "description": "Name of the group"
          },
          "description": {
            "type": "string",
            "description": "Description of the group"
          },
          "parentId": {
            "type": "integer",
            "description": "ID of the parent group if applicable"
          }
        },
        "required": [
          "id",
          "name"
        ]
      }
    }
  },
  {
    "featureName": "CheckUserCanAddKarma",
    "description": "Verifies if a user is eligible to add karma to a specific post.",
    "inputValues": [
      "userId-number-User",
      "postId-number-Post"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect userId (mandatory): The identifier of the user attempting to add karma\n   - Collect postId (mandatory): The identifier of the post to which karma would be added\n\n2. Data Validation:\n   - Validate userId:\n      a. Verify userId is a positive integer\n      b. Verify userId corresponds to an existing user in the system\n      c. IF userId is invalid or non-existent, THEN return error message indicating invalid user\n   - Validate postId:\n      a. Verify postId is a positive integer\n      b. Verify postId corresponds to an existing post in the system\n      c. IF postId is invalid or non-existent, THEN return error message indicating invalid post\n\n3. Business Rule Processing:\n   - Check system karma configuration:\n      a. Verify karma functionality is enabled in the system\n      b. IF karma functionality is disabled, THEN return error message indicating feature unavailability\n   - Check user permissions:\n      a. Verify user has sufficient privileges to add karma\n      b. IF user lacks karma privileges, THEN return error message indicating insufficient permissions\n   - Check for previous karma contributions:\n      a. Query karma records to determine if the user has already added karma to this specific post\n      b. IF user has previously added karma to this post, THEN user cannot add karma again\n\n4. Core Operation Execution:\n   - Determine karma eligibility status:\n      a. IF all validations pass AND user has not previously added karma to this post, THEN\n         i. Set eligibility status to true (user can add karma)\n      b. ELSE\n         i. Set eligibility status to false (user cannot add karma)\n   - Record eligibility check event in system logs (optional):\n      a. Log the user ID, post ID, and eligibility result\n      b. Include timestamp of the eligibility check\n\n5. Response Generation:\n   - Generate response with eligibility status:\n      a. Return boolean result indicating whether user can add karma (true) or not (false)\n      b. IF eligibility status is false, THEN include reason code/message explaining why\n   - Include additional context information:\n      a. IF eligible, include information about karma point range allowed\n      b. IF not eligible, include when the user might be able to add karma again (if applicable)",
    "databaseEntities": [
      "jforum_users",
      "jforum_posts",
      "jforum_karma"
    ],
    "validationRules": [
      "User ID must be a valid positive integer",
      "Post ID must be a valid positive integer",
      "User must exist in the system",
      "Post must exist in the system",
      "User must have permission to add karma",
      "User must not have previously added karma to the same post"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "User": {
        "id": "number",
        "username": "string",
        "karma": "object"
      },
      "Post": {
        "id": "number",
        "userId": "number",
        "topicId": "number"
      },
      "Karma": {
        "id": "number",
        "postId": "number",
        "postUserId": "number",
        "fromUserId": "number",
        "points": "number",
        "topicId": "number",
        "rateDate": "date"
      }
    }
  },
  {
    "featureName": "GetMostRatedUserByPeriod",
    "description": "Retrieves users with highest karma ratings within a specified time period.",
    "inputValues": [
      "startIndex-number-Pagination",
      "firstPeriod-date-DateRange",
      "lastPeriod-date-DateRange",
      "orderField-string-SortOption"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the following inputs:\n     a. startIndex (number): Starting position for pagination results\n     b. firstPeriod (date): Beginning date of the time period\n     c. lastPeriod (date): Ending date of the time period\n     d. orderField (string): Field to sort results by\n\n2. Data Validation:\n   - Validate date range parameters:\n     a. Verify firstPeriod is not null\n     b. Verify lastPeriod is not null\n     c. Verify firstPeriod is before lastPeriod\n        i. IF firstPeriod is after lastPeriod THEN\n           - Generate an error message indicating invalid date range\n           - Halt processing and return error\n   - Validate startIndex parameter:\n     a. Verify startIndex is a non-negative integer\n        i. IF startIndex is negative THEN\n           - Set startIndex to default value (0)\n   - Validate orderField parameter:\n     a. Verify orderField is one of the allowed sorting fields\n        i. IF orderField is invalid or empty THEN\n           - Set orderField to default value (\"user_karma\")\n\n3. Business Rule Processing:\n   - Check system state:\n     a. Verify karma tracking is enabled in the system\n        i. IF karma tracking is disabled THEN\n           - Return empty result set with appropriate message\n   - Prepare query parameters:\n     a. Format date parameters to system standard\n     b. Sanitize orderField to prevent injection\n     c. Determine result limit based on system configuration\n\n4. Core Operation Execution:\n   - Retrieve user karma data:\n     a. Query the karma records within the specified date range\n     b. Apply pagination starting from startIndex\n     c. Sort results according to orderField in descending order\n     d. For each qualifying user record:\n        i. Calculate total karma points received\n        ii. Calculate total number of votes received\n        iii. Calculate average karma rating\n        iv. Calculate total votes given by the user\n   - Compile user information:\n     a. For each user with karma data:\n        i. Retrieve basic user information (ID, username)\n        ii. Associate karma statistics with user\n        iii. Add to result collection\n\n5. Response Generation:\n   - Format the result set:\n     a. Create a list of user objects with their karma information\n     b. Include for each user:\n        i. User identifier and username\n        ii. Total karma points received\n        iii. Number of votes received\n        iv. Average karma rating\n        v. Number of votes given\n   - Return the formatted list of users ordered by the specified field\n   - Include metadata:\n     a. Total number of matching users\n     b. Period start and end dates\n     c. Sort field used",
    "databaseEntities": [
      "jforum_users",
      "jforum_karma"
    ],
    "validationRules": [
      "First period date must be before last period date",
      "Start index must be a non-negative integer",
      "Order field must be a valid sortable field",
      "Date range must be within allowed system limits"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "User": {
        "id": "number",
        "username": "string",
        "karma": {
          "totalPoints": "number",
          "votesReceived": "number",
          "karmaPoints": "number",
          "votesGiven": "number"
        }
      },
      "DateRange": {
        "date": "date"
      },
      "Pagination": {
        "index": "number"
      },
      "SortOption": {
        "field": "string"
      }
    }
  },
  {
    "featureName": "GetFirstPostId",
    "description": "Retrieves the ID of the first post in the system.",
    "inputValues": [],
    "businessLogic": "1. Input Collection:\n   - No user inputs required for this feature\n   - System will handle the operation internally\n\n2. Data Validation:\n   - Verify database connection is available\n   - IF connection is not available THEN\n     - Generate appropriate error message\n     - Exit process\n   - END IF\n\n3. Business Rule Processing:\n   - Verify post table exists and is accessible\n   - IF table does not exist or is not accessible THEN\n     - Generate appropriate error message\n     - Exit process\n   - END IF\n   - Verify user has appropriate permissions to access post data\n   - IF user lacks required permissions THEN\n     - Generate appropriate error message\n     - Exit process\n   - END IF\n\n4. Core Operation Execution:\n   - Initialize post ID variable to 0\n   - Prepare query to find the first post ID in the system\n   - Execute query against the database\n   - IF query execution fails THEN\n     - Handle database exception\n     - Log error details\n     - Exit process with error status\n   - END IF\n   - IF result set contains data THEN\n     - Extract post ID from the first row\n     - Store post ID in the initialized variable\n   - ELSE\n     - Keep post ID as 0 (indicating no posts found)\n   - END IF\n   - Release database resources\n\n5. Response Generation:\n   - IF post ID is greater than 0 THEN\n     - Return the post ID to the caller\n     - Operation successful\n   - ELSE\n     - Return 0 indicating no posts exist in the system\n   - END IF",
    "databaseEntities": [
      "jforum_posts"
    ],
    "validationRules": [
      "Database connection must be available",
      "Post table must exist and be accessible",
      "User must have appropriate permissions to access post data"
    ],
    "dbSeedingOperations": [],
    "schema": {}
  },
  {
    "featureName": "GetFirstPostIdByDate",
    "description": "Finds the ID of the first post created after a specific date.",
    "inputValues": [
      "date-date-Post"
    ],
    "businessLogic": "1. Input Collection\n   - Collect the following inputs:\n     a. date (mandatory): The reference date to find posts created after\n\n2. Data Validation\n   - Validate the date input:\n     a. Check if date is not null\n        IF date is null THEN\n          Return error message indicating date is required\n     b. Check if date is a valid date format\n        IF date format is invalid THEN\n          Return error message indicating invalid date format\n     c. Check if date is within acceptable range\n        IF date is in the future THEN\n          Return error message indicating date cannot be in the future\n\n3. Business Rule Processing\n   - Verify system state requirements:\n     a. Check if the post repository is accessible\n        IF repository is not accessible THEN\n          Return error message indicating system unavailability\n     b. Check if search functionality is enabled\n        IF search functionality is disabled THEN\n          Return error message indicating feature unavailability\n\n4. Core Operation Execution\n   - Process the search operation:\n     a. Format the input date to system standard format\n     b. Query the post repository for posts created after the specified date\n     c. Sort the matching posts by creation date in ascending order\n     d. Select the post with the earliest creation date after the input date\n     e. Extract the ID of the selected post\n        IF no posts are found after the specified date THEN\n          Return 0 or appropriate null indicator\n        ELSE\n          Return the ID of the first post\n\n5. Response Generation\n   - Generate appropriate response:\n     a. IF operation was successful THEN\n        Return the post ID as an integer value\n     b. IF operation failed THEN\n        Return error details with appropriate message\n        Include suggestion for troubleshooting if applicable",
    "databaseEntities": [
      "jforum_posts"
    ],
    "validationRules": [
      "Date input must not be null",
      "Date must be in a valid format",
      "Date should not be in the future",
      "System must have access to post repository",
      "Search functionality must be enabled"
    ],
    "dbSeedingOperations": [],
    "schema": {}
  },
  {
    "featureName": "GetLastPostIdByDate",
    "description": "Finds the ID of the last post created before a specific date.",
    "inputValues": [
      "targetDate-date-Post"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect targetDate (date): The date before which to find the last post\n   - Validate that targetDate is provided and is a valid date format\n   - System will use this date as a cutoff point for the search\n\n2. Data Validation:\n   - Validate targetDate format:\n     a. Ensure targetDate is not null\n     b. Verify targetDate is a valid date format\n     c. IF targetDate is invalid THEN generate appropriate error message\n   - Validate targetDate value:\n     a. Ensure targetDate is not in the future\n     b. IF targetDate is in the future THEN generate error message indicating invalid date range\n\n3. Business Rule Processing:\n   - Check system state:\n     a. Verify the post repository is accessible\n     b. IF repository is not accessible THEN generate system error message\n   - Verify post data exists:\n     a. Check if any posts exist in the system\n     b. IF no posts exist THEN return appropriate message indicating no posts found\n\n4. Core Operation Execution:\n   - Search for posts with creation date earlier than targetDate:\n     a. Query the post repository for posts with timestamp less than or equal to targetDate\n     b. Order results by post date in descending order (newest first)\n     c. Limit results to retrieve only the top record\n   - Extract post information:\n     a. IF matching post found THEN extract the post ID\n     b. IF no matching post found THEN set post ID to 0 or appropriate null value\n   - Handle potential errors:\n     a. IF database error occurs during query THEN capture error details\n     b. Prepare for appropriate error response\n\n5. Response Generation:\n   - Success response:\n     a. IF post found THEN return the post ID\n     b. Include timestamp of the found post for verification purposes\n   - Error response:\n     a. IF no post found THEN return appropriate indicator (0 or null)\n     b. IF system error occurred THEN return error details\n     c. Include appropriate message explaining the result",
    "databaseEntities": [
      "jforum_posts"
    ],
    "validationRules": [
      "Target date must be a valid date format",
      "Target date should not be in the future",
      "System must have access to post repository",
      "Return value must be an integer representing post ID or 0 if not found"
    ],
    "dbSeedingOperations": [],
    "schema": {}
  },
  {
    "featureName": "AddMailIntegration",
    "description": "Creates a new mail integration configuration for a forum.",
    "inputValues": [
      "forumId-number-Forum",
      "forumEmail-string-MailIntegration",
      "popHost-string-MailIntegration",
      "popUsername-string-MailIntegration",
      "popPassword-string-MailIntegration",
      "popPort-number-MailIntegration",
      "ssl-boolean-MailIntegration"
    ],
    "businessLogic": "1. Input Collection\n   - Collect the following required inputs:\n     1.1. forumId (number): Identifier of the forum to configure mail integration for\n     1.2. forumEmail (string): Email address associated with the forum\n     1.3. popHost (string): POP3 server hostname\n     1.4. popUsername (string): Username for POP3 authentication\n     1.5. popPassword (string): Password for POP3 authentication\n     1.6. popPort (number): Port number for POP3 server connection\n     1.7. ssl (boolean): Whether to use SSL for the connection\n\n2. Data Validation\n   2.1. Validate forumId:\n      - Check if forumId is provided and is a positive integer\n      - Verify that the forum exists in the system\n      - IF forum does not exist, THEN return error message \"Forum not found\"\n   \n   2.2. Validate forumEmail:\n      - Check if forumEmail is provided and not empty\n      - Verify forumEmail follows valid email format (contains @ and domain)\n      - IF invalid format, THEN return error message \"Invalid email format\"\n   \n   2.3. Validate POP3 server details:\n      - Check if popHost is provided and not empty\n      - Verify popUsername is provided and not empty\n      - Verify popPassword is provided\n      - Check if popPort is a valid port number (between 1 and 65535)\n      - IF any validation fails, THEN return appropriate error message\n\n3. Business Rule Processing\n   3.1. Check for existing mail integration:\n      - Verify if mail integration already exists for the specified forum\n      - IF exists, THEN return error message \"Mail integration already configured for this forum\"\n   \n   3.2. Check forum permissions:\n      - Verify that the current user has administrator privileges\n      - IF user lacks permissions, THEN return error message \"Insufficient permissions to configure mail integration\"\n\n4. Core Operation Execution\n   4.1. Create mail integration object:\n      - Initialize a new MailIntegration object\n      - Set all provided parameters to the object:\n        - Set forumId\n        - Set forumEmail\n        - Set popHost\n        - Set popUsername\n        - Set popPassword\n        - Set popPort\n        - Set ssl flag\n   \n   4.2. Persist mail integration configuration:\n      - Save the mail integration configuration to the database\n      - IF save operation fails, THEN:\n        - Log the error details\n        - Return error message \"Failed to save mail integration configuration\"\n        - Roll back any partial changes\n\n5. Response Generation\n   5.1. On success:\n      - Return success status\n      - Include confirmation message \"Mail integration successfully configured for forum\"\n      - Include the forumId and forumEmail in the response\n   \n   5.2. On failure:\n      - Return error status\n      - Include specific error message based on the failure point\n      - Provide guidance on how to resolve the issue",
    "databaseEntities": [
      "jforum_forums"
    ],
    "validationRules": [
      "Forum ID must exist in the system",
      "Forum email must be in valid email format",
      "POP host must not be empty",
      "POP username must not be empty",
      "POP password must not be empty",
      "POP port must be between 1 and 65535",
      "SSL flag must be a boolean value"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "MailIntegration": {
        "forumId": "number",
        "forumEmail": "string",
        "popHost": "string",
        "popUsername": "string",
        "popPassword": "string",
        "popPort": "number",
        "ssl": "boolean"
      }
    }
  },
  {
    "featureName": "DeleteMailIntegration",
    "description": "Removes mail integration configuration for a specific forum.",
    "inputValues": [
      "forumId-number-Forum"
    ],
    "businessLogic": "1. Input Collection\n   - Collect the following input:\n     1.1. forumId (number, mandatory): The unique identifier of the forum whose mail integration will be deleted\n\n2. Data Validation\n   - Validate all input data:\n     2.1. Validate forumId\n         2.1.1. Check if forumId is provided\n         2.1.2. Verify forumId is a positive integer\n         2.1.3. IF forumId is missing or invalid, THEN\n               - Generate appropriate error message\n               - Terminate the process\n\n3. Business Rule Processing\n   - Verify system state and dependencies:\n     3.1. Check if forum exists\n         3.1.1. Verify that a forum with the provided forumId exists in the system\n         3.1.2. IF forum does not exist, THEN\n               - Generate error message indicating forum not found\n               - Terminate the process\n     3.2. Check if mail integration exists for the forum\n         3.2.1. Verify that mail integration configuration exists for the specified forum\n         3.2.2. IF mail integration does not exist, THEN\n               - Generate notification that no mail integration exists for this forum\n               - Terminate the process as successful (nothing to delete)\n\n4. Core Operation Execution\n   - Execute the deletion process:\n     4.1. Remove mail integration configuration\n         4.1.1. Delete the mail integration record associated with the specified forumId\n         4.1.2. IF deletion fails due to system error, THEN\n               - Log the error details\n               - Attempt to rollback any partial changes\n               - Generate error message about deletion failure\n               - Terminate the process\n\n5. Response Generation\n   - Generate appropriate response:\n     5.1. For successful deletion\n         5.1.1. Create success message indicating mail integration was successfully removed\n         5.1.2. Include the forumId in the success message for reference\n     5.2. For unsuccessful deletion\n         5.2.1. Include specific error message explaining the failure reason\n         5.2.2. Provide guidance on how to resolve the issue if applicable",
    "databaseEntities": [
      "jforum_forums"
    ],
    "validationRules": [
      "Forum ID must be a positive integer",
      "Forum must exist in the system",
      "Mail integration configuration must exist for the specified forum"
    ],
    "dbSeedingOperations": [],
    "schema": {}
  },
  {
    "featureName": "FindMailIntegration",
    "description": "Retrieves mail integration configuration for a specific forum.",
    "inputValues": [
      "forumId-number-Forum"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect forumId (number, mandatory) - Identifier of the forum to retrieve mail integration for\n   - No default values or special formats required\n\n2. Data Validation:\n   - Validate forumId:\n     a. Check if forumId is provided\n     b. Verify forumId is a positive integer\n     c. Return appropriate error message if validation fails\n\n3. Business Rule Processing:\n   - Verify forum existence:\n     a. Check if a forum with the provided forumId exists in the system\n     b. IF forum does not exist, THEN return appropriate error message\n   - Verify user permissions:\n     a. Check if the current user has permission to view mail integration settings\n     b. IF user lacks permission, THEN return access denied error\n\n4. Core Operation Execution:\n   - Retrieve mail integration configuration:\n     a. Search for mail integration configuration associated with the provided forumId\n     b. IF configuration is found, THEN prepare complete configuration details including:\n        i. Forum email address\n        ii. POP server host\n        iii. POP username\n        iv. POP password (secured/masked)\n        v. POP port number\n        vi. SSL configuration status\n     c. IF no configuration is found, THEN prepare empty/null result\n\n5. Response Generation:\n   - Success scenario:\n     a. Return the complete mail integration configuration if found\n     b. Include forum identifier in the response for reference\n   - Error scenarios:\n     a. Return appropriate error message if forum does not exist\n     b. Return access denied message if user lacks permission\n     c. Return system error message if retrieval operation fails",
    "databaseEntities": [
      "jforum_forums"
    ],
    "validationRules": [
      "Forum ID must be a positive integer",
      "Forum must exist in the system",
      "User must have permission to view mail integration settings"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "MailIntegration": {
        "forumId": "number",
        "forumEmail": "string",
        "popHost": "string",
        "popUsername": "string",
        "popPassword": "string",
        "popPort": "number",
        "ssl": "boolean"
      }
    }
  },
  {
    "featureName": "FindAllMailIntegrations",
    "description": "Retrieves all mail integration configurations in the system.",
    "inputValues": [],
    "businessLogic": "1. Input Collection\n   - No user inputs required for this feature\n   - System will retrieve all mail integration configurations\n\n2. Data Validation\n   - No input validation required as there are no user inputs\n   - System will validate database connection availability\n     - IF database connection is unavailable THEN\n       - Generate appropriate error message\n       - Terminate process\n\n3. Business Rule Processing\n   - Verify user has appropriate permissions to view mail integration configurations\n     - IF user does not have required permissions THEN\n       - Generate access denied error\n       - Log unauthorized access attempt\n       - Terminate process\n   - Check system state for any maintenance activities\n     - IF system is in maintenance mode THEN\n       - Notify user of temporary unavailability\n       - Terminate process\n\n4. Core Operation Execution\n   - Retrieve all mail integration records from the database\n     - Prepare query to select all mail integration configurations\n     - Execute query against the database\n     - FOR each record found in the database DO\n       - Create a mail integration object\n       - Populate object with data from database record:\n         - Forum ID\n         - Forum email address\n         - POP host server address\n         - POP username\n         - POP password (secured)\n         - POP port number\n         - SSL flag status\n       - Add populated object to result collection\n     - IF no records are found THEN\n       - Return empty collection\n       - Note: Empty result is not considered an error condition\n\n5. Response Generation\n   - Prepare response with collection of mail integration configurations\n     - Format each configuration with appropriate structure\n     - Ensure sensitive data (like passwords) is properly secured/masked\n   - Return the complete collection to the caller\n   - IF any exceptions occurred during processing THEN\n     - Generate appropriate error response\n     - Include error details for troubleshooting\n     - Log the error in system logs",
    "databaseEntities": [
      "jforum_forums"
    ],
    "validationRules": [
      "User must have appropriate permissions to view mail integration configurations",
      "Database connection must be available",
      "System must not be in maintenance mode"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "MailIntegration": {
        "forumId": "number",
        "forumEmail": "string",
        "popHost": "string",
        "popUsername": "string",
        "popPassword": "string",
        "popPort": "number",
        "ssl": "boolean"
      }
    }
  },
  {
    "featureName": "UpdateMailIntegration",
    "description": "Updates an existing mail integration configuration for a forum.",
    "inputValues": [
      "forumId-number-MailIntegration",
      "forumEmail-string-MailIntegration",
      "popHost-string-MailIntegration",
      "popUsername-string-MailIntegration",
      "popPassword-string-MailIntegration",
      "popPort-number-MailIntegration",
      "ssl-boolean-MailIntegration"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the following required inputs:\n     1.1. forumId (number, mandatory): The unique identifier of the forum\n     1.2. forumEmail (string, mandatory): The email address associated with the forum\n     1.3. popHost (string, mandatory): The POP server hostname\n     1.4. popUsername (string, mandatory): Username for POP server authentication\n     1.5. popPassword (string, mandatory): Password for POP server authentication\n     1.6. popPort (number, mandatory): Port number for the POP server\n     1.7. ssl (boolean, mandatory): Flag indicating whether SSL should be used\n\n2. Data Validation:\n   2.1. Validate forumId:\n      - Ensure forumId is a positive integer\n      - Verify that forumId corresponds to an existing forum\n      - IF forumId is invalid or not found, THEN return an error message\n   2.2. Validate forumEmail:\n      - Ensure forumEmail is not empty\n      - Verify forumEmail follows valid email format (contains @ and domain)\n      - IF forumEmail is invalid, THEN return an error message\n   2.3. Validate popHost:\n      - Ensure popHost is not empty\n      - Verify popHost contains valid hostname format\n      - IF popHost is invalid, THEN return an error message\n   2.4. Validate popUsername:\n      - Ensure popUsername is not empty\n      - IF popUsername is empty, THEN return an error message\n   2.5. Validate popPassword:\n      - Ensure popPassword is not empty\n      - IF popPassword is empty, THEN return an error message\n   2.6. Validate popPort:\n      - Ensure popPort is a positive integer\n      - Verify popPort is within valid range (1-65535)\n      - IF popPort is invalid, THEN return an error message\n   2.7. Validate ssl:\n      - Ensure ssl is a boolean value\n      - IF ssl is not a boolean, THEN return an error message\n\n3. Business Rule Processing:\n   3.1. Check if mail integration exists for the forum:\n      - Verify that a mail integration record exists for the specified forumId\n      - IF no record exists, THEN return an error message indicating that the mail integration must be created first\n   3.2. Check forum permissions:\n      - Verify that the current user has permission to update mail integration settings\n      - IF user lacks permission, THEN return an access denied error\n   3.3. Validate POP server connection details:\n      - Check if the combination of popHost, popPort, and ssl flag represents a valid configuration\n      - IF the configuration appears invalid, THEN generate a warning message\n\n4. Core Operation Execution:\n   4.1. Prepare mail integration data:\n      - Create a mail integration object with the provided input values\n      - Format the data according to system requirements\n   4.2. Update the mail integration record:\n      - Update the existing mail integration record for the specified forum\n      - Set all fields with the new values (forumEmail, popHost, popUsername, popPassword, popPort, ssl)\n      - IF update operation fails, THEN:\n        * Roll back any partial changes\n        * Log the error details\n        * Return an error message\n   4.3. Record the update event:\n      - Log the successful update of mail integration settings\n      - Include timestamp and user who performed the update\n\n5. Response Generation:\n   5.1. For successful update:\n      - Generate a success message indicating the mail integration was updated\n      - Include the forum name in the success message\n      - Provide a summary of the updated configuration (excluding sensitive data like password)\n   5.2. For failed update:\n      - Generate an appropriate error message based on the failure reason\n      - Include troubleshooting information if applicable\n      - Suggest next steps to resolve the issue",
    "databaseEntities": [
      "jforum_forums"
    ],
    "validationRules": [
      "Forum ID must exist in the system",
      "Forum email must be in valid email format",
      "POP host must not be empty",
      "POP username must not be empty",
      "POP password must not be empty",
      "POP port must be a positive integer between 1 and 65535",
      "SSL flag must be a boolean value"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "MailIntegration": {
        "forumId": "number",
        "forumEmail": "string",
        "popHost": "string",
        "popUsername": "string",
        "popPassword": "string",
        "popPort": "number",
        "ssl": "boolean"
      }
    }
  },
  {
    "featureName": "SelectAllModerationLogs",
    "description": "Retrieves a paginated list of moderation log entries with user and post details.",
    "inputValues": [
      "start-number-ModerationLog",
      "count-number-ModerationLog"
    ],
    "businessLogic": "1. Input Collection\n   - Collect the following inputs:\n     - start: The starting index for pagination (mandatory, number)\n     - count: The maximum number of records to retrieve (mandatory, number)\n   - System will use these parameters to determine which portion of the moderation logs to retrieve\n\n2. Data Validation\n   - Validate pagination parameters:\n     - IF start is negative THEN return error message \"Starting index cannot be negative\"\n     - IF count is less than or equal to zero THEN return error message \"Count must be greater than zero\"\n     - IF count exceeds system-defined maximum page size THEN set count to maximum allowed value\n\n3. Business Rule Processing\n   - Check user permissions:\n     - IF current user does not have moderation privileges THEN return access denied error\n     - IF system is in maintenance mode THEN verify user has administrative access\n   - Verify database connection is available\n     - IF connection is unavailable THEN return system unavailable error\n\n4. Core Operation Execution\n   - Calculate total number of moderation log entries in the system\n     - Query the database for total count of moderation log records\n     - Store this value for pagination metadata\n   - Retrieve moderation log entries:\n     - Query the database for moderation logs with the following information:\n       - Log ID and timestamp\n       - Log description and original message\n       - Log type and associated post/topic IDs\n       - Moderator user information (ID, username)\n       - Post author user information (ID, username)\n     - Apply pagination using start and count parameters\n     - Sort results by timestamp in descending order (newest first)\n   - For each retrieved log entry:\n     - Create a moderation log object with all retrieved data\n     - Format timestamp to system standard format\n     - Add the log entry to the result collection\n\n5. Response Generation\n   - Prepare the response with:\n     - Collection of moderation log entries\n     - Pagination metadata:\n       - Total number of records\n       - Current page information\n       - More pages indicator\n     - IF no records found THEN include appropriate empty result indicator\n     - IF error occurred during processing THEN include error details and suggestions\n   - Return the complete response to the caller",
    "databaseEntities": [
      "jforum_users",
      "jforum_posts",
      "jforum_topics",
      "jforum_moderation_log"
    ],
    "validationRules": [
      "Pagination start index must be zero or positive",
      "Pagination count must be greater than zero",
      "User must have moderation privileges to view logs",
      "Database connection must be available"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "ModerationLog": {
        "id": "number",
        "description": "string",
        "originalMessage": "string",
        "type": "number",
        "date": "date",
        "postId": "number",
        "topicId": "number",
        "user": {
          "id": "number",
          "username": "string"
        },
        "posterUser": {
          "id": "number",
          "username": "string"
        }
      }
    }
  },
  {
    "featureName": "CountTotalModerationLogs",
    "description": "Calculates the total number of moderation log records in the system.",
    "inputValues": [],
    "businessLogic": "1. Input Collection:\n   - No user inputs required for this feature\n   - System will use existing database connection for query execution\n\n2. Data Validation:\n   - Verify system has proper access to the moderation log records\n   - Ensure database connection is active and valid\n   - IF connection is not available or invalid THEN\n     - Generate appropriate error message\n     - Exit process\n   - END IF\n\n3. Business Rule Processing:\n   - Verify user has appropriate permissions to view moderation logs\n   - IF user lacks required permissions THEN\n     - Generate access denied message\n     - Log unauthorized access attempt\n     - Exit process\n   - END IF\n   - Check if moderation log table exists in the system\n   - IF table does not exist THEN\n     - Generate appropriate error message\n     - Log system configuration issue\n     - Exit process\n   - END IF\n\n4. Core Operation Execution:\n   - Prepare query to count all records in the moderation log table\n   - Execute count query against the database\n   - Handle any exceptions during query execution:\n     - IF database error occurs THEN\n       - Capture error details\n       - Generate appropriate error message\n       - Log the exception\n       - Exit process with error status\n     - END IF\n   - Retrieve the count result from the query\n   - Store the total count value for response generation\n\n5. Response Generation:\n   - Format the total count value for display\n   - IF count retrieval was successful THEN\n     - Return success status with total count value\n     - Include timestamp of when count was performed\n   - ELSE\n     - Return error status with appropriate message\n     - Include error details for troubleshooting\n   - END IF",
    "databaseEntities": [
      "jforum_moderation_log"
    ],
    "validationRules": [
      "User must have permission to access moderation log data",
      "Database connection must be active and valid",
      "Moderation log table must exist in the system"
    ],
    "dbSeedingOperations": [],
    "schema": {}
  },
  {
    "featureName": "AddNewPoll",
    "description": "Creates a new poll with options for a topic.",
    "inputValues": [
      "topicId-number-Topic",
      "label-string-Poll",
      "length-number-Poll",
      "options-object-PollOptions"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the following required inputs:\n     a. topicId (number): The identifier of the topic to which the poll belongs\n     b. label (string): The text description or question for the poll\n     c. length (number): The duration in days for which the poll remains active\n     d. options (array): List of poll options for voting\n       - Each option must contain text (string) describing the choice\n\n2. Data Validation:\n   a. Topic Validation:\n      - Verify topicId exists in the system\n      - Verify topic is active and available for polls\n      - IF topic does not exist or is not active THEN\n         - Return error message \"Invalid or inactive topic\"\n   \n   b. Poll Content Validation:\n      - Verify label is not empty\n      - Verify label length is within acceptable limits (5-255 characters)\n      - Verify length is a positive number\n      - IF any validation fails THEN\n         - Return appropriate error message\n   \n   c. Options Validation:\n      - Verify at least 2 options are provided\n      - Verify each option has non-empty text\n      - Verify each option text is within acceptable limits (1-255 characters)\n      - Verify no duplicate option texts exist\n      - IF any validation fails THEN\n         - Return appropriate error message\n\n3. Business Rule Processing:\n   a. Topic Poll Eligibility Check:\n      - Verify topic does not already have an active poll\n      - IF topic already has a poll THEN\n         - Return error message \"Topic already has an active poll\"\n   \n   b. User Permission Check:\n      - Verify current user has permission to create polls\n      - IF user lacks permission THEN\n         - Return error message \"Insufficient permissions to create poll\"\n\n4. Core Operation Execution:\n   a. Poll Creation:\n      - Create new poll record with:\n         - Provided topicId\n         - Provided label\n         - Current system date as start time\n         - Provided length (duration)\n      - Generate and assign unique identifier for the poll\n   \n   b. Options Creation:\n      - FOR EACH option in the options list:\n         - Create new poll option record with:\n            - Generated poll identifier\n            - Sequential option identifier\n            - Option text\n            - Initialize vote count to zero\n      - Link all options to the created poll\n\n5. Response Generation:\n   a. Success Response:\n      - Return success status\n      - Include created poll identifier\n      - Include confirmation message \"Poll successfully created\"\n      - Include summary of poll details (topic, question, number of options)\n   \n   b. Error Response:\n      - IF any operation fails during creation THEN\n         - Return error status\n         - Include specific error message\n         - Include guidance for resolving the issue",
    "databaseEntities": [
      "jforum_topics",
      "jforum_polls",
      "jforum_poll_options",
      "jforum_poll_voters"
    ],
    "validationRules": [
      "Topic must exist and be active",
      "Poll label must not be empty",
      "Poll label must be between 5 and 255 characters",
      "Poll length must be a positive number",
      "Poll must have at least 2 options",
      "Each poll option must have non-empty text",
      "Each poll option text must be unique",
      "Each poll option text must be between 1 and 255 characters",
      "Topic must not already have an active poll",
      "User must have permission to create polls"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "PollOptions": {
        "type": "array",
        "items": {
          "type": "object",
          "properties": {
            "text": {
              "type": "string",
              "description": "The text description of the poll option"
            }
          },
          "required": [
            "text"
          ]
        },
        "minItems": 2
      }
    }
  },
  {
    "featureName": "SelectPollById",
    "description": "Retrieves a poll and its options by poll ID.",
    "inputValues": [
      "pollId-number-Poll"
    ],
    "businessLogic": "1. Input Collection\n   - Collect the following required input:\n     a. pollId (number): The unique identifier of the poll to retrieve\n\n2. Data Validation\n   - Validate the poll ID input:\n     a. Check if pollId is provided\n        IF pollId is missing or null THEN\n           Return error message: \"Poll ID is required\"\n     b. Check if pollId is a valid number\n        IF pollId is not a valid number THEN\n           Return error message: \"Poll ID must be a valid number\"\n     c. Check if pollId is positive\n        IF pollId is not positive THEN\n           Return error message: \"Poll ID must be a positive number\"\n\n3. Business Rule Processing\n   - Verify poll existence:\n     a. Check if a poll with the provided ID exists in the system\n        IF poll does not exist THEN\n           Return error message: \"Poll not found with the provided ID\"\n\n4. Core Operation Execution\n   - Retrieve poll data:\n     a. Fetch the basic poll information using the provided pollId\n        - Retrieve poll ID, topic ID, poll label, start time, and length\n   - Retrieve poll options:\n     a. Fetch all options associated with the poll\n        - For each option, retrieve:\n          i. Option ID\n          ii. Option text\n          iii. Vote count\n   - Assemble complete poll data:\n     a. Create a poll object with the retrieved basic information\n     b. Add all retrieved options to the poll object\n\n5. Response Generation\n   - Prepare success response:\n     a. Include the complete poll object with all its properties:\n        - Poll ID\n        - Topic ID\n        - Poll label/question\n        - Start time\n        - Length (duration)\n        - List of all poll options with their respective:\n          i. Option ID\n          ii. Option text\n          iii. Vote count\n   - Handle potential errors:\n     a. If any database errors occur during retrieval:\n        - Log the error details\n        - Return appropriate error message: \"Unable to retrieve poll data\"\n        - Include support information if needed",
    "databaseEntities": [
      "jforum_topics",
      "jforum_polls",
      "jforum_poll_options",
      "jforum_poll_votes"
    ],
    "validationRules": [
      "Poll ID must be provided",
      "Poll ID must be a valid positive number",
      "Poll must exist in the system"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Poll": {
        "id": "number",
        "topicId": "number",
        "label": "string",
        "startTime": "date",
        "length": "number",
        "options": [
          {
            "id": "number",
            "pollId": "number",
            "text": "string",
            "voteCount": "number"
          }
        ]
      }
    }
  },
  {
    "featureName": "CheckUserVoteStatus",
    "description": "Verifies if a user has already voted on a specific poll.",
    "inputValues": [
      "pollId-number-Poll",
      "userId-number-User",
      "ipAddress-string-User"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the following inputs:\n     a. pollId (mandatory): Unique identifier of the poll to check\n     b. userId (optional): Unique identifier of the user\n     c. ipAddress (optional): IP address of the user\n   - Note: Either userId OR ipAddress must be provided\n\n2. Data Validation:\n   - Validate pollId:\n     a. Check if pollId is provided\n     b. Verify pollId is a positive integer\n     c. IF validation fails, THEN return appropriate error message\n   - Validate user identification:\n     a. IF userId is provided:\n        i. Verify userId is a positive integer\n        ii. IF validation fails, THEN return appropriate error message\n     b. ELSE IF ipAddress is provided:\n        i. Verify ipAddress is in valid format\n        ii. IF validation fails, THEN return appropriate error message\n     c. ELSE:\n        i. Return error indicating either userId or ipAddress must be provided\n\n3. Business Rule Processing:\n   - Verify poll existence:\n     a. Check if poll with given pollId exists in the system\n     b. IF poll does not exist, THEN return appropriate error message\n   - Determine verification method:\n     a. IF userId is provided and greater than 0:\n        i. Set verification method to user-based verification\n     b. ELSE:\n        i. Set verification method to IP-based verification\n\n4. Core Operation Execution:\n   - Check voting status:\n     a. IF using user-based verification:\n        i. Search for voting record matching both pollId and userId\n     b. ELSE IF using IP-based verification:\n        i. Search for voting record matching both pollId and ipAddress\n     c. Determine if matching record exists:\n        i. IF record found, THEN user has voted\n        ii. ELSE user has not voted\n\n5. Response Generation:\n   - Prepare response with voting status:\n     a. Include boolean result indicating whether user has voted\n     b. Include pollId in response\n     c. Include timestamp of verification\n   - Return formatted response to caller",
    "databaseEntities": [
      "jforum_topics",
      "jforum_users"
    ],
    "validationRules": [
      "Poll ID must be a positive integer",
      "Either User ID or IP address must be provided",
      "User ID must be a positive integer when provided",
      "IP address must be in valid format when provided",
      "Poll must exist in the system"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Poll": {
        "id": "number",
        "topicId": "number",
        "label": "string",
        "startTime": "date",
        "length": "number",
        "options": "array"
      },
      "User": {
        "id": "number",
        "ipAddress": "string"
      }
    }
  },
  {
    "featureName": "SelectPostById",
    "description": "Retrieves a post by its ID with all associated data.",
    "inputValues": [
      "postId-number-Post"
    ],
    "businessLogic": "1. Input Collection\n   - Collect the post ID (postId) as a required input\n   - The post ID must be a positive integer\n\n2. Data Validation\n   - Validate that the post ID is provided\n     - IF post ID is missing or null THEN\n       - Generate an error message: \"Post ID is required\"\n       - Return error response\n     - END IF\n   - Validate that the post ID is a positive integer\n     - IF post ID is not a positive integer THEN\n       - Generate an error message: \"Post ID must be a positive integer\"\n       - Return error response\n     - END IF\n\n3. Business Rule Processing\n   - Check if the user has permission to view the post\n     - IF user does not have permission to view the post THEN\n       - Generate an error message: \"Insufficient permissions to view this post\"\n       - Return error response\n     - END IF\n   - Check if the post exists in the system\n     - IF post does not exist THEN\n       - Generate an error message: \"Post not found\"\n       - Return error response\n     - END IF\n   - Prepare the database connection for retrieving the post\n     - IF connection preparation fails THEN\n       - Generate an error message: \"Database connection error\"\n       - Return error response\n     - END IF\n\n4. Core Operation Execution\n   - Retrieve the post record using the provided post ID\n     - Fetch the basic post information (ID, topic ID, forum ID, user ID)\n     - Fetch the post metadata (creation time, IP address, formatting options)\n     - Fetch the post content (subject, text)\n     - Fetch the post author information (username)\n     - Fetch attachment information (has attachments flag)\n     - Fetch moderation status\n   - Format the post timestamp according to system date/time format\n   - Retrieve karma information for the post\n   - Assemble all post data into a complete post object\n     - IF any error occurs during data retrieval THEN\n       - Log the error details for system administrators\n       - Generate an error message: \"Error retrieving post data\"\n       - Return error response\n     - END IF\n   - Release database resources after retrieval\n     - Ensure all connections and resources are properly closed\n     - IF resource cleanup fails THEN\n       - Log the cleanup failure\n     - END IF\n\n5. Response Generation\n   - Prepare the success response with the complete post object\n     - Include all post details (ID, topic ID, forum ID, user ID)\n     - Include post metadata (creation time, IP address, formatting options)\n     - Include post content (subject, text)\n     - Include post author information (username)\n     - Include attachment information\n     - Include moderation status\n     - Include formatted timestamp\n     - Include karma information\n   - Return the complete post object to the caller\n   - IF post was not found (empty post object) THEN\n     - Return an empty post object\n   - END IF",
    "databaseEntities": [
      "jforum_posts",
      "jforum_posts_text",
      "jforum_karma",
      "jforum_users",
      "jforum_topics",
      "jforum_forums"
    ],
    "validationRules": [
      "Post ID must be provided",
      "Post ID must be a positive integer",
      "User must have permission to view the post",
      "Post must exist in the system",
      "Database connection must be available",
      "Database resources must be properly released after use"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Post": {
        "id": "number",
        "topicId": "number",
        "forumId": "number",
        "userId": "number",
        "time": "date",
        "userIp": "string",
        "bbCodeEnabled": "boolean",
        "htmlEnabled": "boolean",
        "smiliesEnabled": "boolean",
        "signatureEnabled": "boolean",
        "editCount": "number",
        "editTime": "date",
        "subject": "string",
        "text": "string",
        "postUsername": "string",
        "hasAttachments": "boolean",
        "moderate": "boolean",
        "formatedTime": "string",
        "karma": "object"
      }
    }
  },
  {
    "featureName": "DeletePost",
    "description": "Removes a post from the system including its text content.",
    "inputValues": [
      "postId-number-Post"
    ],
    "businessLogic": "1. Input Collection\n   - Collect the following inputs:\n     1.1. postId (number, mandatory): The unique identifier of the post to be deleted\n\n2. Data Validation\n   - Validate the provided input:\n     2.1. Check if postId is provided\n        IF postId is missing or null THEN\n           RETURN error message \"Post ID is required\"\n     2.2. Verify postId is a valid number\n        IF postId is not a valid number THEN\n           RETURN error message \"Post ID must be a valid number\"\n     2.3. Verify postId is positive\n        IF postId is not positive THEN\n           RETURN error message \"Post ID must be a positive number\"\n\n3. Business Rule Processing\n   - Verify post existence and access permissions:\n     3.1. Check if the post exists in the system\n        IF post does not exist THEN\n           RETURN error message \"Post not found\"\n     3.2. Check if the current user has permission to delete the post\n        IF user is not the post owner AND user is not a moderator AND user is not an administrator THEN\n           RETURN error message \"You do not have permission to delete this post\"\n     3.3. Check if the post is part of a locked topic\n        IF topic is locked AND user is not a moderator AND user is not an administrator THEN\n           RETURN error message \"Cannot delete post from a locked topic\"\n     3.4. Check if the topic is accessible to the current user\n        IF topic is not accessible THEN\n           RETURN error message \"You do not have access to this topic\"\n\n4. Core Operation Execution\n   - Perform the post deletion process:\n     4.1. Begin transaction to ensure data consistency\n     4.2. Remove the post content from the system\n        4.2.1. Delete the post text entry\n        4.2.2. Delete the post entry\n     4.3. Update search indexes to remove the deleted post\n     4.4. Check if the post has attachments\n        IF post has attachments THEN\n           4.4.1. Delete all associated attachments\n     4.5. Decrement the post count for the post author\n     4.6. Update karma records associated with the post\n     4.7. Check if this is the last remaining post in the topic\n        IF this is the last post in the topic THEN\n           4.7.1. Delete the entire topic\n           4.7.2. Redirect user to the forum view\n        ELSE\n           4.7.3. Update topic statistics (post count, last post ID, first post ID)\n           4.7.4. Update forum statistics (last post information)\n           4.7.5. Redirect user back to the topic view at the appropriate page\n     4.8. Create a moderation log entry recording the deletion\n        4.8.1. Store the original post text in the log\n        4.8.2. Record the user who performed the deletion\n     4.9. Update system caches\n        4.9.1. Remove post from post repository\n        4.9.2. Update topic repository with most recent topics\n        4.9.3. Update topic repository with hottest topics\n        4.9.4. Reload forum data\n     4.10. Commit transaction\n        IF any operation fails THEN\n           4.10.1. Rollback all changes\n           4.10.2. RETURN error message \"Failed to delete post due to system error\"\n\n5. Response Generation\n   - Generate appropriate response:\n     5.1. Create success response\n        5.1.1. Include confirmation message \"Post successfully deleted\"\n        5.1.2. Redirect user to appropriate location based on deletion outcome:\n           IF topic was deleted THEN\n              Redirect to forum view\n           ELSE\n              Redirect to topic view at the appropriate page\n     5.2. IF any errors occurred during the process THEN\n        5.2.1. Include detailed error information\n        5.2.2. Include guidance on how to resolve the issue",
    "databaseEntities": [
      "jforum_posts",
      "jforum_posts_text",
      "jforum_topics",
      "jforum_forums",
      "jforum_users",
      "jforum_attachments",
      "jforum_karma"
    ],
    "validationRules": [
      "Post ID must be provided",
      "Post ID must be a valid positive number",
      "Post must exist in the system",
      "User must have permission to delete the post",
      "Post cannot be deleted from a locked topic unless user is moderator or administrator",
      "Topic must be accessible to the current user"
    ],
    "dbSeedingOperations": [],
    "schema": {}
  },
  {
    "featureName": "DeletePostsByTopic",
    "description": "Removes all posts associated with a specific topic.",
    "inputValues": [
      "topicId-number-Topic"
    ],
    "businessLogic": "1. Input Collection\n   - Collect the following required inputs:\n     a. topicId (number): The unique identifier of the topic whose posts will be deleted\n\n2. Data Validation\n   - Validate the topicId input:\n     a. Check if topicId is provided\n        IF topicId is missing or null THEN\n          Return error message: \"Topic ID is required\"\n     b. Verify topicId is a positive integer\n        IF topicId is not a positive integer THEN\n          Return error message: \"Topic ID must be a positive integer\"\n     c. Verify the topic exists in the system\n        IF topic with topicId does not exist THEN\n          Return error message: \"Topic not found\"\n\n3. Business Rule Processing\n   - Check user permissions:\n     a. Verify the current user has permission to delete posts in this topic\n        IF user does not have delete permission THEN\n          Return error message: \"Insufficient permissions to delete posts\"\n   - Check topic state:\n     a. Verify the topic is in a state that allows post deletion\n        IF topic is locked or in a protected state THEN\n          Return error message: \"Cannot delete posts from a locked or protected topic\"\n\n4. Core Operation Execution\n   - Retrieve all posts associated with the topic:\n     a. Query the database to get all posts belonging to the specified topic\n     b. For each post found:\n        i. Store the post ID and user ID for reference\n   - Delete the posts:\n     a. For each post in the collection:\n        i. Remove the post content from the posts text storage\n        ii. Remove the post entry from the posts storage\n        iii. Remove any search indexes related to the post\n        iv. Update user post count statistics if necessary\n   - Update topic statistics:\n     a. Update the post count for the topic\n     b. If all posts are removed, mark the topic for potential cleanup\n   - Update forum statistics:\n     a. Decrease the post count in the parent forum\n\n5. Response Generation\n   - On successful deletion:\n     a. Return success status\n     b. Include the number of posts deleted\n     c. Include the topic ID that was processed\n   - On failure:\n     a. Return error status\n     b. Include specific error message explaining the failure reason\n     c. Include any partial results if some posts were deleted before the error occurred",
    "databaseEntities": [
      "jforum_topics",
      "jforum_posts",
      "jforum_posts_text",
      "jforum_forums"
    ],
    "validationRules": [
      "Topic ID must be provided",
      "Topic ID must be a positive integer",
      "Topic must exist in the system",
      "User must have permission to delete posts",
      "Topic must not be in a locked or protected state"
    ],
    "dbSeedingOperations": [],
    "schema": {}
  },
  {
    "featureName": "UpdatePost",
    "description": "Updates an existing post's content and metadata in the forum system.",
    "inputValues": [
      "postId-number-Post",
      "topicId-number-Post",
      "forumId-number-Post",
      "subject-string-Post",
      "text-string-Post",
      "userIp-string-Post",
      "bbCodeEnabled-boolean-Post",
      "htmlEnabled-boolean-Post",
      "smiliesEnabled-boolean-Post",
      "signatureEnabled-boolean-Post"
    ],
    "businessLogic": "1. Input Collection\n   - Collect the following required inputs:\n     a. postId (mandatory): Unique identifier of the post to update\n     b. subject (mandatory): Updated subject line for the post\n     c. text (mandatory): Updated content text for the post\n     d. topicId (mandatory): Topic identifier the post belongs to\n     e. forumId (mandatory): Forum identifier the post belongs to\n     f. userIp (mandatory): IP address of the user making the update\n     g. bbCodeEnabled (optional): Flag indicating if BBCode is enabled, default is current setting\n     h. htmlEnabled (optional): Flag indicating if HTML is enabled, default is current setting\n     i. smiliesEnabled (optional): Flag indicating if smilies are enabled, default is current setting\n     j. signatureEnabled (optional): Flag indicating if signature is enabled, default is current setting\n\n2. Data Validation\n   - Validate post existence:\n     a. Check if postId corresponds to an existing post\n     b. IF post does not exist, THEN\n        i. Generate error message: \"Post not found\"\n        ii. Terminate the operation\n   - Validate subject field:\n     a. Check if subject is not empty\n     b. Check if subject length is within allowed limits (1-255 characters)\n     c. IF validation fails, THEN\n        i. Generate appropriate error message\n        ii. Terminate the operation\n   - Validate text field:\n     a. Check if text is not empty\n     b. Check if text length is within allowed limits\n     c. IF validation fails, THEN\n        i. Generate appropriate error message\n        ii. Terminate the operation\n   - Validate topic and forum consistency:\n     a. Verify that the provided topicId and forumId are valid\n     b. Verify that the topic belongs to the specified forum\n     c. IF validation fails, THEN\n        i. Generate error message: \"Invalid topic or forum information\"\n        ii. Terminate the operation\n\n3. Business Rule Processing\n   - Check user permissions:\n     a. Verify if the current user has permission to edit this post\n     b. IF user is not the post creator and not a moderator/administrator, THEN\n        i. Generate error message: \"Insufficient permissions to edit this post\"\n        ii. Terminate the operation\n   - Check edit time restrictions:\n     a. Determine if there are time limitations for editing posts\n     b. IF time limit exists and has been exceeded, THEN\n        i. Generate error message: \"Edit time limit exceeded\"\n        ii. Terminate the operation\n   - Handle moderation requirements:\n     a. Determine if the edited post requires moderation based on forum settings\n     b. IF moderation is required, THEN\n        i. Set moderation flag for the post\n   - Check cache status:\n     a. Determine if the post is currently cached in the system\n     b. IF post is cached, THEN\n        i. Mark for cache update after successful edit\n\n4. Core Operation Execution\n   - Update post metadata:\n     a. Increment the edit count by 1\n     b. Set the edit timestamp to current time\n     c. Update the user IP address\n     d. Update forum and topic IDs if changed\n     e. Update formatting preferences (BBCode, HTML, smilies, signature)\n   - Update post content:\n     a. Update the post subject\n     b. Update the post text content\n   - Update cache if necessary:\n     a. IF post is in cache, THEN\n        i. Update the cached post with new content\n        ii. Ensure cache consistency for the associated topic\n   - Handle search indexing:\n     a. Update the post in the search index to reflect new content\n   - Process notifications:\n     a. Determine if notifications should be sent for post edits\n     b. IF notifications are enabled, THEN\n        i. Queue notifications for relevant users\n\n5. Response Generation\n   - Generate success response:\n     a. Include confirmation message: \"Post successfully updated\"\n     b. Include post identifier\n     c. Include timestamp of the update\n     d. Include new edit count\n   - Generate navigation information:\n     a. Include link to view the updated post\n     b. Include link to return to the topic\n     c. Include link to return to the forum",
    "databaseEntities": [
      "jforum_posts",
      "jforum_posts_text",
      "jforum_topics",
      "jforum_forums",
      "jforum_sessions"
    ],
    "validationRules": [
      "Post ID must correspond to an existing post",
      "Subject must not be empty",
      "Subject must be between 1 and 255 characters",
      "Post text must not be empty",
      "Topic ID must be valid and match the post's topic",
      "Forum ID must be valid and match the topic's forum",
      "User must have permission to edit the post",
      "Edit time limit must not be exceeded if applicable",
      "Post must be properly prepared for display after update"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Post": {
        "id": "number",
        "topicId": "number",
        "forumId": "number",
        "userId": "number",
        "subject": "string",
        "text": "string",
        "time": "date",
        "editTime": "date",
        "editCount": "number",
        "userIp": "string",
        "bbCodeEnabled": "boolean",
        "htmlEnabled": "boolean",
        "smiliesEnabled": "boolean",
        "signatureEnabled": "boolean",
        "moderate": "boolean"
      }
    }
  },
  {
    "featureName": "CreatePost",
    "description": "Creates a new post with text content and associates it with a topic.",
    "inputValues": [
      "topicId-number-Post",
      "forumId-number-Post",
      "userId-number-Post",
      "text-string-Post",
      "subject-string-Post",
      "userIp-string-Post",
      "bbCodeEnabled-boolean-Post",
      "htmlEnabled-boolean-Post",
      "smiliesEnabled-boolean-Post",
      "signatureEnabled-boolean-Post",
      "moderationNeeded-boolean-Post"
    ],
    "businessLogic": "1. Input Collection\n   - Collect the following required inputs:\n     a. topicId: The identifier of the topic this post belongs to\n     b. forumId: The identifier of the forum this post belongs to\n     c. userId: The identifier of the user creating the post\n     d. text: The main content of the post\n     e. subject: The title or subject of the post\n   - Collect the following optional inputs:\n     a. userIp: The IP address of the user creating the post (system-generated if not provided)\n     b. bbCodeEnabled: Whether BBCode formatting is enabled (default: true)\n     c. htmlEnabled: Whether HTML formatting is enabled (default: false)\n     d. smiliesEnabled: Whether emoticons are enabled (default: true)\n     e. signatureEnabled: Whether user signature is enabled (default: true)\n     f. moderationNeeded: Whether the post requires moderation (default: false)\n   - System will automatically generate:\n     a. postTime: Current timestamp when the post is created\n     b. editCount: Initial value set to 0\n\n2. Data Validation\n   - Validate topicId:\n     a. Must be a positive integer\n     b. Must reference an existing topic\n     c. Return error \"Invalid topic selected\" if validation fails\n   - Validate forumId:\n     a. Must be a positive integer\n     b. Must reference an existing forum\n     c. Return error \"Invalid forum selected\" if validation fails\n   - Validate userId:\n     a. Must be a positive integer\n     b. Must reference an existing user\n     c. Return error \"Invalid user\" if validation fails\n   - Validate text content:\n     a. Must not be empty\n     b. Must not exceed maximum allowed length\n     c. Return error \"Post content cannot be empty\" or \"Post content too long\" if validation fails\n   - Validate subject:\n     a. Must not be empty\n     b. Must not exceed maximum allowed length\n     c. Return error \"Subject cannot be empty\" or \"Subject too long\" if validation fails\n\n3. Business Rule Processing\n   - Check user permissions:\n     a. Verify user has permission to post in the specified forum\n     b. IF user does not have permission, THEN\n        i. Return error \"You do not have permission to post in this forum\"\n   - Check forum status:\n     a. Verify the forum is not locked or archived\n     b. IF forum is locked, THEN\n        i. Return error \"This forum is locked and does not accept new posts\"\n   - Check topic status:\n     a. Verify the topic is not locked\n     b. IF topic is locked, THEN\n        i. Return error \"This topic is locked and does not accept new replies\"\n   - Check moderation requirements:\n     a. Determine if post requires moderation based on forum settings and user permissions\n     b. Set moderationNeeded flag accordingly\n\n4. Core Operation Execution\n   - Create new post record:\n     a. Generate a new post ID\n     b. Set the current timestamp as post creation time\n     c. Set initial edit count to 0\n     d. Store all post metadata (topicId, forumId, userId, timestamp, userIp, formatting flags)\n   - Store post content:\n     a. Create a new post text record with the post ID\n     b. Store the text content and subject\n   - Update related records:\n     a. Increment post count for the topic\n     b. Update last post information in the topic record\n     c. Update last post information in the forum record\n     d. Increment user's post count\n   - Handle search indexing:\n     a. Add the new post to the search index\n   - IF any operation fails, THEN\n     a. Roll back all database changes\n     b. Return appropriate error message\n\n5. Response Generation\n   - On successful post creation:\n     a. Return success status\n     b. Include the newly created post ID\n     c. Include information about moderation status if applicable\n   - On failure:\n     a. Return error status\n     b. Include specific error message\n     c. Include any validation errors that occurred",
    "databaseEntities": [
      "jforum_posts",
      "jforum_posts_text",
      "jforum_topics",
      "jforum_forums",
      "jforum_users"
    ],
    "validationRules": [
      "Topic ID must reference an existing topic",
      "Forum ID must reference an existing forum",
      "User ID must reference an existing user",
      "Post text content cannot be empty",
      "Post subject cannot be empty",
      "User must have permission to post in the specified forum",
      "Forum must not be locked or archived",
      "Topic must not be locked"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Post": {
        "id": "number",
        "topicId": "number",
        "forumId": "number",
        "userId": "number",
        "time": "date",
        "userIp": "string",
        "bbCodeEnabled": "boolean",
        "htmlEnabled": "boolean",
        "smiliesEnabled": "boolean",
        "signatureEnabled": "boolean",
        "editCount": "number",
        "editTime": "date",
        "subject": "string",
        "text": "string",
        "postUsername": "string",
        "hasAttachments": "boolean",
        "moderationNeeded": "boolean"
      }
    }
  },
  {
    "featureName": "GetPostsByTopic",
    "description": "Retrieves all posts for a specific topic.",
    "inputValues": [
      "topicId-number-Topic"
    ],
    "businessLogic": "1. Input Collection\n   - Collect the topicId (mandatory) to identify the topic for which posts should be retrieved\n   - System will use this identifier to locate all related posts\n\n2. Data Validation\n   - Validate topicId\n     - Ensure topicId is provided\n     - Verify topicId is a positive integer\n     - Confirm topicId exists in the system\n     - IF topicId is invalid or not found THEN\n       - Generate appropriate error message\n       - Terminate process and return error\n\n3. Business Rule Processing\n   - Check user permissions\n     - Verify current user has access rights to view the requested topic\n     - IF user lacks permission THEN\n       - Generate access denied error\n       - Terminate process and return error\n   - Check topic status\n     - Verify topic is not deleted or in a restricted state\n     - IF topic is unavailable THEN\n       - Generate appropriate status message\n       - Terminate process and return error\n\n4. Core Operation Execution\n   - Retrieve posts for the specified topic\n     - Query all posts associated with the provided topicId\n     - Sort posts by chronological order (oldest to newest)\n     - For each post, collect:\n       - Post identifier\n       - Post content/text\n       - Author information\n       - Creation timestamp\n       - Edit information (if applicable)\n       - Formatting settings (HTML enabled, BBCode enabled, etc.)\n       - Attachment indicators\n   - Process post metadata\n     - Format timestamps according to system settings\n     - Prepare user display information\n     - Process any special content indicators\n\n5. Response Generation\n   - Prepare success response\n     - Include list of all retrieved posts with complete information\n     - Include topic information (title, creation date, etc.)\n     - Include pagination information if applicable\n     - Return formatted post collection to the caller\n   - Handle empty results\n     - IF no posts found for valid topic THEN\n       - Return empty collection with appropriate indicator\n       - Include topic information for context",
    "databaseEntities": [
      "jforum_topics",
      "jforum_posts",
      "jforum_posts_text",
      "jforum_users",
      "jforum_forums"
    ],
    "validationRules": [
      "Topic ID must be a positive integer",
      "Topic must exist in the system",
      "User must have permission to view the topic",
      "Topic must not be deleted or restricted"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Post": {
        "id": "number",
        "topicId": "number",
        "forumId": "number",
        "userId": "number",
        "time": "date",
        "userIp": "string",
        "bbCodeEnabled": "boolean",
        "htmlEnabled": "boolean",
        "smiliesEnabled": "boolean",
        "signatureEnabled": "boolean",
        "editCount": "number",
        "editTime": "date",
        "subject": "string",
        "text": "string",
        "postUsername": "string",
        "hasAttachments": "boolean",
        "moderate": "boolean",
        "formatedTime": "string",
        "karma": "number"
      }
    }
  },
  {
    "featureName": "GetPostsByTopicWithPagination",
    "description": "Retrieves posts for a specific topic with pagination support to display content in manageable chunks.",
    "inputValues": [
      "topicId-number-Topic",
      "startFrom-number-Pagination",
      "count-number-Pagination"
    ],
    "businessLogic": "1. Input Collection\n   - Collect the following required inputs:\n     a. topicId (number): Identifier of the topic to retrieve posts from\n     b. startFrom (number): Starting position for pagination (zero-based index)\n     c. count (number): Maximum number of posts to retrieve\n   - All fields are mandatory\n   - System will use default values if not specified:\n     a. startFrom: 0 (first post)\n     b. count: Maximum allowed value\n\n2. Data Validation\n   - Validate topicId:\n     a. Check if topicId is a positive integer\n     b. IF topicId is missing or invalid, THEN return error message \"Valid topic identifier required\"\n   - Validate pagination parameters:\n     a. Check if startFrom is a non-negative integer\n     b. Check if count is a positive integer\n     c. IF startFrom is negative, THEN set to 0\n     d. IF count is negative or zero, THEN set to default maximum value\n\n3. Business Rule Processing\n   - Check topic existence and access permissions:\n     a. Verify that the topic with the given topicId exists\n     b. IF topic does not exist, THEN return error message \"Topic not found\"\n     c. Verify that the current user has permission to view the topic\n     d. IF user lacks permission, THEN return error message \"Insufficient permissions to view this topic\"\n   - Check forum status:\n     a. Verify that the forum containing the topic is not locked or disabled\n     b. IF forum is locked or disabled, THEN return error message \"Forum is currently unavailable\"\n\n4. Core Operation Execution\n   - Retrieve posts for the specified topic:\n     a. Query the database for posts matching the topicId\n     b. Apply pagination parameters (startFrom and count) to limit results\n     c. For each post retrieved:\n        i. Load the post content and metadata\n        ii. Format timestamps according to system settings\n        iii. Check if post has attachments\n        iv. Load user information for the post author\n        v. Apply any content formatting rules (BBCode, HTML, smilies)\n     d. IF no posts are found, THEN return an empty collection\n     e. IF database error occurs during retrieval, THEN log error and return error message \"Unable to retrieve posts at this time\"\n\n5. Response Generation\n   - Prepare the paginated posts response:\n     a. Create a collection of formatted post objects\n     b. Include pagination metadata:\n        i. Total number of posts in the topic\n        ii. Current page information\n        iii. Whether more posts are available\n     c. Include topic information:\n        i. Topic title\n        ii. Forum identifier\n        iii. Category information\n     d. Return the formatted response with posts and pagination details\n     e. IF any errors occurred during processing, THEN return appropriate error message with error details",
    "databaseEntities": [
      "jforum_topics",
      "jforum_posts",
      "jforum_posts_text",
      "jforum_forums",
      "jforum_users",
      "jforum_attachments"
    ],
    "validationRules": [
      "Topic ID must be a positive integer",
      "Start position must be a non-negative integer",
      "Count must be a positive integer",
      "User must have permission to view the topic",
      "Topic must exist in the system",
      "Forum containing the topic must be active and accessible"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Post": {
        "id": "number",
        "topicId": "number",
        "forumId": "number",
        "userId": "number",
        "time": "date",
        "userIp": "string",
        "bbCodeEnabled": "boolean",
        "htmlEnabled": "boolean",
        "smiliesEnabled": "boolean",
        "signatureEnabled": "boolean",
        "editCount": "number",
        "editTime": "date",
        "subject": "string",
        "text": "string",
        "postUsername": "string",
        "hasAttachments": "boolean",
        "isModerated": "boolean",
        "formattedTime": "string",
        "karma": "number"
      },
      "Topic": {
        "id": "number",
        "forumId": "number",
        "title": "string",
        "totalPosts": "number",
        "status": "string"
      },
      "Pagination": {
        "startFrom": "number",
        "count": "number",
        "totalItems": "number",
        "hasMore": "boolean"
      }
    }
  },
  {
    "featureName": "GetUserPostsWithPagination",
    "description": "Retrieves posts created by a specific user with pagination support.",
    "inputValues": [
      "userId-number-User",
      "startFrom-number-Pagination",
      "count-number-Pagination"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect userId (mandatory): Numeric identifier of the user whose posts are being retrieved\n   - Collect startFrom (mandatory): Numeric value indicating the starting position for pagination\n   - Collect count (mandatory): Numeric value indicating the maximum number of posts to retrieve\n   - System will use forum permissions from the current context\n\n2. Data Validation:\n   - Validate userId:\n      * Ensure userId is a positive integer\n      * Verify userId exists in the system\n      * IF userId is invalid or not found, THEN return appropriate error message\n   - Validate pagination parameters:\n      * Ensure startFrom is a non-negative integer\n      * Ensure count is a positive integer\n      * IF either parameter is invalid, THEN use default values (startFrom = 0, count = system default)\n\n3. Business Rule Processing:\n   - Check user access permissions:\n      * Retrieve list of forums the current user has access to\n      * IF no accessible forums exist, THEN return empty result with appropriate message\n   - Verify system state:\n      * Ensure database connection is available\n      * IF connection is unavailable, THEN return system unavailable error\n\n4. Core Operation Execution:\n   - Construct query to retrieve posts:\n      * Filter by specified userId\n      * Filter by forums the current user has permission to access\n      * Apply pagination parameters (startFrom and count)\n      * Order posts by creation date (newest first)\n   - Execute the query to retrieve matching posts\n   - For each retrieved post:\n      * Load post details (content, creation time, etc.)\n      * Format timestamps according to system settings\n      * Check for attachments\n      * Load associated karma information\n   - Count total number of posts by the user (for pagination information)\n\n5. Response Generation:\n   - Prepare success response with:\n      * List of retrieved posts with all details\n      * Pagination metadata:\n         - Total number of posts by the user\n         - Current page information\n         - More pages indicator\n      * IF no posts found, THEN include appropriate message\n   - Return formatted response to the caller",
    "databaseEntities": [
      "jforum_users",
      "jforum_posts",
      "jforum_posts_text",
      "jforum_forums",
      "jforum_topics",
      "jforum_karma"
    ],
    "validationRules": [
      "User ID must be a positive integer",
      "User must exist in the system",
      "Start position must be a non-negative integer",
      "Count must be a positive integer",
      "User must have access to at least one forum",
      "System must have an active database connection"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Post": {
        "id": "number",
        "topicId": "number",
        "forumId": "number",
        "userId": "number",
        "time": "date",
        "userIp": "string",
        "bbCodeEnabled": "boolean",
        "htmlEnabled": "boolean",
        "smiliesEnabled": "boolean",
        "signatureEnabled": "boolean",
        "editCount": "number",
        "editTime": "date",
        "subject": "string",
        "text": "string",
        "postUsername": "string",
        "hasAttachments": "boolean",
        "moderate": "boolean",
        "formatedTime": "string",
        "karma": "number"
      },
      "Pagination": {
        "startFrom": "number",
        "count": "number",
        "totalPosts": "number"
      }
    }
  },
  {
    "featureName": "CountUserPosts",
    "description": "Counts the total number of posts created by a specific user.",
    "inputValues": [
      "userId-number-User"
    ],
    "businessLogic": "1. Input Collection\n   - Collect the userId (number) of the user whose posts need to be counted\n   - The userId is mandatory and must be provided by the caller\n\n2. Data Validation\n   - Validate that userId is provided\n     - IF userId is missing or null THEN\n       - Generate an error message indicating that userId is required\n       - Terminate the operation\n     - END IF\n   - Validate that userId is a positive integer\n     - IF userId is not a positive integer THEN\n       - Generate an error message indicating that userId must be a positive integer\n       - Terminate the operation\n     - END IF\n   - Validate that the user exists in the system\n     - IF user with the provided userId does not exist THEN\n       - Generate an error message indicating that the user does not exist\n       - Terminate the operation\n     - END IF\n\n3. Business Rule Processing\n   - Check if the current user has permission to view the post count\n     - IF current user does not have permission THEN\n       - Generate an error message indicating insufficient permissions\n       - Terminate the operation\n     - END IF\n   - Determine which forums the current user has access to\n     - Retrieve the list of forum IDs the current user is allowed to access\n     - IF no accessible forums exist THEN\n       - Return a post count of zero\n       - Terminate the operation\n     - END IF\n\n4. Core Operation Execution\n   - Initialize a counter for the total number of posts\n   - Query the database to count posts with the following criteria:\n     - Posts created by the specified userId\n     - Posts located in forums the current user has access to\n     - Posts that have not been deleted or marked as hidden\n   - Store the resulting count\n\n5. Response Generation\n   - Format the post count as an integer value\n   - Return the total count of posts created by the specified user\n   - IF an error occurred during processing THEN\n     - Return an appropriate error message\n   - END IF",
    "databaseEntities": [
      "jforum_users",
      "jforum_posts",
      "jforum_forums"
    ],
    "validationRules": [
      "User ID must be a positive integer",
      "User must exist in the system",
      "Current user must have permission to view the requested user's post count",
      "Only count posts in forums the current user has access to"
    ],
    "dbSeedingOperations": [],
    "schema": {}
  },
  {
    "featureName": "CountPreviousPosts",
    "description": "Counts posts that came before a specific post in its topic.",
    "inputValues": [
      "postId-number-Post"
    ],
    "businessLogic": "1. Input Collection\n   - Collect the post ID (postId) as a required input\n   - System will use this ID to identify the target post\n\n2. Data Validation\n   - Validate that postId is provided\n     - IF postId is missing or null THEN\n       - Return error message: \"Post ID is required\"\n     - END IF\n   - Validate that postId is a positive integer\n     - IF postId is not a positive integer THEN\n       - Return error message: \"Post ID must be a positive integer\"\n     - END IF\n   - Validate that the post exists in the system\n     - IF post with postId does not exist THEN\n       - Return error message: \"Post not found\"\n     - END IF\n\n3. Business Rule Processing\n   - Verify user has permission to view the post\n     - IF user does not have permission to view the post THEN\n       - Return error message: \"You do not have permission to view this post\"\n     - END IF\n   - Check if the post belongs to a valid topic\n     - IF post's topic is invalid or deleted THEN\n       - Return error message: \"The post belongs to an invalid topic\"\n     - END IF\n\n4. Core Operation Execution\n   - Retrieve the target post's information\n     - Get the post's topic ID and creation timestamp\n   - Count all posts in the same topic that were created before the target post\n     - Query the posts table for posts with:\n       - Same topic ID as the target post\n       - Creation timestamp earlier than the target post's timestamp\n   - Store the count result\n   - IF any database errors occur during counting THEN\n     - Log the error details\n     - Return error message: \"Unable to count previous posts due to a system error\"\n   - END IF\n\n5. Response Generation\n   - Return the count of previous posts\n   - Include the following information in the response:\n     - Total number of posts that came before the specified post\n     - Post ID that was used for the query\n     - Topic ID that the post belongs to\n   - IF count operation was successful THEN\n     - Return success status with the count value\n   - ELSE\n     - Return error status with appropriate message\n   - END IF",
    "databaseEntities": [
      "jforum_posts",
      "jforum_topics"
    ],
    "validationRules": [
      "Post ID must be provided",
      "Post ID must be a positive integer",
      "Post must exist in the system",
      "User must have permission to view the post",
      "Post must belong to a valid topic"
    ],
    "dbSeedingOperations": [],
    "schema": {}
  },
  {
    "featureName": "SelectLatestByForumForRSS",
    "description": "Retrieves the latest posts from a specific forum for RSS feed generation.",
    "inputValues": [
      "forumId-number-Forum",
      "limit-number-System"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect forumId (mandatory): numeric identifier of the forum\n   - Collect limit (mandatory): maximum number of posts to retrieve\n   - System will generate a list structure to hold the results\n\n2. Data Validation:\n   - Validate forumId:\n      * Check if forumId is a positive integer\n      * Verify forumId exists in the system\n      * IF forumId is invalid or not found, THEN generate appropriate error message\n   - Validate limit:\n      * Ensure limit is a positive integer\n      * IF limit is not positive, THEN use system default value\n\n3. Business Rule Processing:\n   - Check user permissions:\n      * Verify current user has access to the specified forum\n      * IF user lacks permission, THEN return empty result or error message\n   - Check forum status:\n      * Verify forum is active and not archived\n      * IF forum is inactive, THEN return appropriate message\n\n4. Core Operation Execution:\n   - Query preparation:\n      * Prepare to retrieve latest posts from the specified forum\n      * Order posts by timestamp in descending order\n      * Limit results to the specified number\n   - Data retrieval:\n      * Execute the query to fetch posts\n      * FOR each post retrieved:\n         > Extract post details (id, subject, text, topic id, forum id, user id, username, timestamp)\n         > Create post object with extracted information\n         > Add post object to result list\n      * IF no posts found, THEN return empty list\n   - Error handling:\n      * IF any database errors occur during retrieval:\n         > Log the error details\n         > Return appropriate error message\n\n5. Response Generation:\n   - Format the response:\n      * Return the list of post objects\n      * Include metadata about the forum (name, description)\n      * Include timestamp of when the data was retrieved\n   - Success response:\n      * Return the formatted list of posts for RSS generation\n   - Error response:\n      * Return error details if any step failed",
    "databaseEntities": [
      "jforum_forums",
      "jforum_posts",
      "jforum_posts_text",
      "jforum_topics",
      "jforum_users"
    ],
    "validationRules": [
      "Forum ID must be a positive integer",
      "Forum must exist in the system",
      "Limit must be a positive integer",
      "User must have permission to access the forum",
      "Forum must be active"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Post": {
        "id": "number",
        "subject": "string",
        "text": "string",
        "topicId": "number",
        "forumId": "number",
        "userId": "number",
        "postUsername": "string",
        "time": "date"
      },
      "Forum": {
        "id": "number",
        "name": "string",
        "description": "string"
      }
    }
  },
  {
    "featureName": "SelectHotForRSS",
    "description": "Retrieves popular posts across forums for RSS feed generation.",
    "inputValues": [
      "limit-number-Post"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the following inputs:\n     - limit (number, mandatory): Maximum number of posts to retrieve\n\n2. Data Validation:\n   - Validate limit parameter:\n     - IF limit is not provided THEN set a default value\n     - IF limit is not a positive integer THEN return error message \"Limit must be a positive integer\"\n     - IF limit exceeds system maximum THEN cap it to the system maximum value\n\n3. Business Rule Processing:\n   - Verify system state:\n     - Check if the RSS feature is enabled in system settings\n     - Verify user has appropriate permissions to access hot posts\n   - Determine hotness criteria:\n     - Consider post view count, reply count, and recency\n     - Apply weighting algorithm to identify popular posts\n\n4. Core Operation Execution:\n   - Retrieve posts based on hotness criteria:\n     - Query posts ordered by popularity metrics\n     - Limit results to the specified number\n     - Include only posts from public forums\n     - Exclude posts from restricted or private forums\n   - For each retrieved post:\n     - Extract post details (ID, subject, content, topic ID, forum ID)\n     - Extract author information (user ID, username)\n     - Extract timestamp information\n     - Format post data for RSS consumption\n   - Compile retrieved posts into a structured list\n\n5. Response Generation:\n   - IF no posts match the criteria THEN return empty list\n   - IF posts are found THEN:\n     - Return the list of posts with all required fields\n     - Include metadata about the response (total count, generation timestamp)\n   - IF any errors occurred during processing THEN:\n     - Return appropriate error message\n     - Log the error for system administrators",
    "databaseEntities": [
      "jforum_posts",
      "jforum_posts_text",
      "jforum_topics",
      "jforum_forums",
      "jforum_users"
    ],
    "validationRules": [
      "Limit parameter must be a positive integer",
      "RSS feature must be enabled in system settings",
      "User must have appropriate permissions to access posts",
      "Only posts from public forums should be included",
      "Posts from restricted or private forums should be excluded"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Post": {
        "id": "number",
        "subject": "string",
        "text": "string",
        "topicId": "number",
        "forumId": "number",
        "userId": "number",
        "postUsername": "string",
        "time": "date"
      }
    }
  },
  {
    "featureName": "DeletePrivateMessage",
    "description": "Deletes private messages from a user's inbox or sent items with permission validation.",
    "inputValues": [
      "messageIds-object-PrivateMessage",
      "userId-number-User"
    ],
    "businessLogic": "1. Input Collection\n   - Collect the following inputs:\n     - messageIds (array of message IDs to delete, mandatory)\n     - userId (ID of the user requesting deletion, mandatory)\n     - System will determine current user authentication status\n\n2. Data Validation\n   - Validate user authentication:\n     - Check if user is logged in\n     - IF user is not logged in THEN\n       - Redirect to login page\n       - Exit the deletion process\n   - Validate message IDs:\n     - IF messageIds is empty or null THEN\n       - Return error message \"No messages selected for deletion\"\n     - FOR EACH messageId in messageIds:\n       - Verify messageId is a valid positive integer\n       - IF any messageId is invalid THEN\n         - Return error message \"Invalid message ID format\"\n   - Validate user ID:\n     - Verify userId is a valid positive integer\n     - IF userId is invalid THEN\n       - Return error message \"Invalid user ID\"\n     - Verify user exists in the system\n     - IF user does not exist THEN\n       - Return error message \"User not found\"\n\n3. Business Rule Processing\n   - Initialize counters:\n     - Set unreadCount to 0 to track deleted unread messages\n   - Verify user permissions:\n     - FOR EACH messageId in messageIds:\n       - Retrieve the complete message details from storage\n       - IF message does not exist THEN\n         - Skip this message and continue with next\n       - Check if the user is either the sender or recipient of the message\n       - IF user is neither sender nor recipient THEN\n         - Skip this message and continue with next\n       - IF message type is NEW (unread) THEN\n         - Increment unreadCount\n       - Add message to deleteList for processing\n\n4. Core Operation Execution\n   - Process message deletions:\n     - IF deleteList is not empty THEN\n       - Begin transaction\n       - Delete all messages in deleteList for the specified user\n       - Commit transaction\n     - Update user's unread message count:\n       - Retrieve current user's total private message count\n       - Subtract unreadCount from total\n       - IF result is negative THEN\n         - Set total to 0\n       - Update user's private message count to new total\n\n5. Response Generation\n   - Prepare deletion confirmation:\n     - Generate success message \"Messages have been deleted successfully\"\n     - Include link to return to inbox\n   - Display confirmation to user:\n     - Show deletion confirmation message\n     - Provide navigation options for user to continue",
    "databaseEntities": [
      "jforum_privmsgs",
      "jforum_privmsgs_text",
      "jforum_users"
    ],
    "validationRules": [
      "User must be either the sender or recipient of the message to delete it",
      "Message IDs must be valid and exist in the system",
      "User ID must be valid and exist in the system",
      "At least one message must be selected for deletion",
      "User must be logged in to delete messages"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "PrivateMessage": {
        "type": "object",
        "properties": {
          "id": {
            "type": "number",
            "description": "Unique identifier for the private message"
          },
          "type": {
            "type": "number",
            "description": "Type of message (new, read, sent, etc.)"
          },
          "fromUser": {
            "type": "object",
            "description": "User who sent the message"
          },
          "toUser": {
            "type": "object",
            "description": "User who received the message"
          }
        }
      }
    }
  },
  {
    "featureName": "AddSmilie",
    "description": "Creates a new smilie emoticon with code, URL, and disk name.",
    "inputValues": [
      "code-string-Smilie",
      "url-string-Smilie",
      "diskName-string-Smilie"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the following required inputs:\n     1.1. code (string): The text representation of the smilie (mandatory)\n     1.2. url (string): The URL path to the smilie image (mandatory)\n     1.3. diskName (string): The filename of the smilie on disk (mandatory)\n\n2. Data Validation:\n   - Validate each input field:\n     2.1. Validate code:\n         2.1.1. Check if code is not empty\n         2.1.2. Check if code follows proper format (e.g., :), :-(, etc.)\n         2.1.3. If validation fails, generate appropriate error message\n     2.2. Validate URL:\n         2.2.1. Check if URL is not empty\n         2.2.2. Check if URL has valid format\n         2.2.3. If validation fails, generate appropriate error message\n     2.3. Validate diskName:\n         2.3.1. Check if diskName is not empty\n         2.3.2. Check if diskName has valid format (no invalid characters)\n         2.3.3. If validation fails, generate appropriate error message\n     2.4. Check for uniqueness:\n         2.4.1. Verify the smilie code doesn't already exist in the system\n         2.4.2. If code already exists, generate duplicate error message\n\n3. Business Rule Processing:\n   - Perform system checks:\n     3.1. Verify user has permission to add smilies\n     3.2. Check if maximum number of smilies hasn't been reached\n     3.3. Verify the disk location is accessible for storing smilies\n     3.4. IF any system check fails:\n         3.4.1. Generate appropriate error message\n         3.4.2. Abort the operation\n\n4. Core Operation Execution:\n   - Process the smilie creation:\n     4.1. Prepare the smilie data for storage\n     4.2. Store the smilie information in the database\n         4.2.1. Save code, URL, and disk name\n         4.2.2. Generate and store unique identifier for the smilie\n     4.3. IF storage operation fails:\n         4.3.1. Log the error details\n         4.3.2. Roll back any partial changes\n         4.3.3. Generate system error message\n     4.4. IF storage operation succeeds:\n         4.4.1. Update the system's smilie collection\n         4.4.2. Log the successful creation\n\n5. Response Generation:\n   - Generate appropriate response:\n     5.1. IF operation was successful:\n         5.1.1. Include the newly created smilie ID in the response\n         5.1.2. Include success message\n         5.1.3. Include the complete smilie details\n     5.2. IF operation failed:\n         5.2.1. Include detailed error information\n         5.2.2. Provide guidance on how to resolve the issue\n         5.2.3. Include support contact information if needed",
    "databaseEntities": [
      "jforum_smilies"
    ],
    "validationRules": [
      "Smilie code must not be empty",
      "Smilie URL must not be empty",
      "Smilie disk name must not be empty",
      "Smilie code must be unique in the system",
      "User must have permission to add smilies"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Smilie": {
        "id": "number",
        "code": "string",
        "url": "string",
        "diskName": "string"
      }
    }
  },
  {
    "featureName": "FixFirstLastPostId",
    "description": "Updates the first and last post IDs for a topic to maintain proper reference integrity.",
    "inputValues": [
      "topicId-number-Topic"
    ],
    "businessLogic": "1. Input Collection\n   - Collect the topic ID (topicId) from the system\n   - Verify the topic ID is a positive integer\n   - Ensure the topic ID corresponds to an existing topic\n\n2. Data Validation\n   - Validate that the topic ID is not null\n   - Verify that the topic ID is a positive integer\n   - Check if the topic exists in the system\n     - IF topic does not exist THEN\n       - Generate an error message indicating invalid topic ID\n       - Terminate the process\n     - END IF\n\n3. Business Rule Processing\n   - Verify that the topic has associated posts\n     - IF topic has no posts THEN\n       - Log a warning about attempting to fix references for a topic without posts\n       - Terminate the process\n     - END IF\n   - Check system permissions for modifying topic data\n     - IF current user lacks permission THEN\n       - Generate an access denied error\n       - Terminate the process\n     - END IF\n\n4. Core Operation Execution\n   - Retrieve the first post ID for the topic\n     - Query the posts associated with the topic\n     - Identify the post with the earliest creation timestamp\n     - Store this post ID as the first post ID\n   - Retrieve the last post ID for the topic\n     - Query the posts associated with the topic\n     - Identify the post with the latest creation timestamp\n     - Store this post ID as the last post ID\n   - Update the topic record with the correct first and last post IDs\n     - IF update fails THEN\n       - Log the error details\n       - Rollback any changes\n       - Generate an error message about the failure\n     - END IF\n\n5. Response Generation\n   - IF operation completes successfully THEN\n     - Generate a success response indicating the topic references were updated\n     - Include the topic ID in the response\n     - Include the new first and last post IDs in the response\n   - ELSE\n     - Generate an error response with appropriate error details\n     - Include troubleshooting information if available\n   - END IF",
    "databaseEntities": [
      "jforum_topics",
      "jforum_posts"
    ],
    "validationRules": [
      "Topic ID must be a positive integer",
      "Topic must exist in the system",
      "Topic must have at least one associated post",
      "User must have permission to modify topic data"
    ],
    "dbSeedingOperations": [],
    "schema": {}
  },
  {
    "featureName": "DeleteTopics",
    "description": "Batch deletes multiple topics and their associated content.",
    "inputValues": [
      "topicIds-object-TopicList",
      "fromModeration-boolean-ModeratorAction"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect list of topic IDs to be deleted (topicIds)\n   - Determine if deletion is initiated from moderation panel (fromModeration)\n   - Validate user has appropriate permissions to delete topics\n\n2. Data Validation:\n   - Verify all topic IDs exist in the system\n     a. Check each topic ID against the database\n     b. IF any topic ID is invalid, THEN generate appropriate error message\n   - Verify user has permission to delete the specified topics\n     a. Check if user is forum moderator or administrator\n     b. IF user lacks permission, THEN return authorization error\n   - Validate topics are eligible for deletion\n     a. Check if topics are locked or in special state\n     b. IF topics cannot be deleted, THEN return appropriate error\n\n3. Business Rule Processing:\n   - Check system state for deletion constraints\n     a. Verify system is not in maintenance mode\n     b. Ensure no concurrent operations are affecting the topics\n   - Determine impact of deletion\n     a. Calculate number of posts to be removed\n     b. Identify related content (polls, attachments) to be removed\n     c. Determine forum statistics to update\n\n4. Core Operation Execution:\n   - For EACH topic in the list:\n     a. Remove all topic subscriptions/watches\n        i. Identify users watching the topic\n        ii. Remove subscription records\n     b. Delete all associated posts\n        i. Retrieve all post IDs for the topic\n        ii. Delete post content and metadata\n        iii. Remove any attachments linked to posts\n     c. Remove any polls associated with the topic\n        i. Delete poll options\n        ii. Delete poll votes\n        iii. Delete poll main record\n     d. Delete the topic record itself\n     e. IF not from moderation panel:\n        i. Update forum statistics\n        ii. Decrement total topic count for the forum\n   - Update search indexes to remove deleted content\n   - Commit all changes as a single transaction\n     a. IF any operation fails, THEN rollback all changes\n     b. Log deletion details for audit purposes\n\n5. Response Generation:\n   - IF deletion successful:\n     a. Generate success response with summary of deleted items\n     b. Include count of topics and posts removed\n     c. Provide confirmation message\n   - IF deletion fails:\n     a. Generate detailed error response\n     b. Include specific failure points\n     c. Provide recovery suggestions\n   - Return appropriate status code and message",
    "databaseEntities": [
      "jforum_topics",
      "jforum_posts",
      "jforum_posts_text",
      "jforum_forums",
      "jforum_attachments",
      "jforum_users"
    ],
    "validationRules": [
      "User must have permission to delete topics",
      "All topic IDs must exist in the system",
      "Topics must not be locked for deletion",
      "System must not be in maintenance mode during deletion",
      "Forum statistics must be updated after topic deletion"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "TopicList": {
        "type": "array",
        "items": {
          "type": "object",
          "properties": {
            "id": {
              "type": "integer",
              "description": "Unique identifier of the topic"
            },
            "forumId": {
              "type": "integer",
              "description": "ID of the forum containing the topic"
            }
          },
          "required": [
            "id",
            "forumId"
          ]
        }
      },
      "ModeratorAction": {
        "type": "boolean",
        "description": "Flag indicating if the deletion is performed from the moderation panel"
      }
    }
  },
  {
    "featureName": "AddNewTopic",
    "description": "Creates a new forum topic with initial metadata.",
    "inputValues": [
      "title-string-Topic",
      "forumId-number-Forum",
      "content-string-Post",
      "user-object-User",
      "type-number-Topic",
      "isModerated-boolean-Topic",
      "attachments-object-Attachment"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect required inputs:\n     a) title (string, mandatory): The title of the new topic\n     b) forumId (number, mandatory): The forum where the topic will be created\n     c) content (string, mandatory): The content of the first post\n     d) user (object, mandatory): The user creating the topic\n     e) type (number, optional, default=0): The type of topic (normal, sticky, announcement)\n     f) isModerated (boolean, optional, default=false): Whether the topic requires moderation\n     g) attachments (object, optional): Any files attached to the first post\n\n2. Data Validation:\n   - Validate topic title:\n     a) Check if title is not empty\n     b) Verify title length is between 3 and 100 characters\n     c) IF validation fails, THEN return error message \"Topic title must be between 3 and 100 characters\"\n   - Validate forum:\n     a) Check if forumId exists in the system\n     b) Verify user has permission to create topics in this forum\n     c) IF forum doesn't exist, THEN return error message \"Selected forum does not exist\"\n     d) IF user lacks permission, THEN return error message \"You don't have permission to create topics in this forum\"\n   - Validate content:\n     a) Check if content is not empty\n     b) Verify content length is within allowed limits\n     c) IF content is empty, THEN return error message \"Post content cannot be empty\"\n     d) IF content exceeds maximum length, THEN return error message \"Post content exceeds maximum allowed length\"\n   - Validate attachments (if provided):\n     a) Check if file types are allowed\n     b) Verify file sizes are within limits\n     c) IF any attachment validation fails, THEN return appropriate error message\n\n3. Business Rule Processing:\n   - Check forum status:\n     a) Verify forum is not locked or archived\n     b) IF forum is locked, THEN return error message \"Cannot create topic in a locked forum\"\n   - Check user status:\n     a) Verify user is not banned or restricted\n     b) IF user is banned, THEN return error message \"Banned users cannot create topics\"\n   - Check rate limiting:\n     a) Verify user hasn't exceeded topic creation rate limits\n     b) IF rate limit exceeded, THEN return error message \"You are creating topics too quickly. Please wait before creating another topic\"\n   - Check moderation requirements:\n     a) Determine if topic requires moderation based on forum settings and user permissions\n     b) Set isModerated flag accordingly\n\n4. Core Operation Execution:\n   - Create new topic record:\n     a) Generate a new topic ID\n     b) Set topic properties: title, forumId, type, isModerated\n     c) Set creation timestamp to current time\n     d) Associate topic with the creating user\n     e) Initialize topic counters (views=0, replies=0)\n   - Create first post:\n     a) Generate a new post ID\n     b) Set post content and metadata\n     c) Associate post with the topic and user\n     d) Set post timestamp to current time\n     e) Process and store any attachments\n   - Update topic with post references:\n     a) Set topic's firstPostId to the created post ID\n     b) Set topic's lastPostId to the same post ID\n   - Update forum statistics:\n     a) Increment forum's total topics count\n     b) Update forum's last post information\n   - IF topic requires moderation:\n     a) Mark topic as pending approval\n     b) Do not display in public listings until approved\n   - IF any operation fails:\n     a) Roll back all created records\n     b) Return appropriate error message\n\n5. Response Generation:\n   - For successful creation:\n     a) Return success status\n     b) Include created topic ID\n     c) Include navigation information to view the new topic\n     d) Include moderation status if applicable\n   - For failure:\n     a) Return error status\n     b) Include specific error message\n     c) Include any field-specific validation errors\n     d) Provide guidance on how to correct the issue",
    "databaseEntities": [
      "jforum_topics",
      "jforum_posts",
      "jforum_posts_text",
      "jforum_forums",
      "jforum_users",
      "jforum_attachments"
    ],
    "validationRules": [
      "Topic title must not be empty",
      "Topic title must be between 3 and 100 characters",
      "Forum ID must exist in the system",
      "User must have permission to create topics in the selected forum",
      "Post content cannot be empty",
      "Post content must not exceed maximum allowed length",
      "Forum must not be locked or archived",
      "User must not be banned or restricted",
      "User must not exceed topic creation rate limits",
      "Attachment file types must be allowed",
      "Attachment file sizes must be within limits"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "User": {
        "type": "object",
        "properties": {
          "id": {
            "type": "number",
            "description": "Unique identifier for the user"
          },
          "username": {
            "type": "string",
            "description": "User's display name"
          }
        },
        "required": [
          "id"
        ]
      },
      "Attachment": {
        "type": "object",
        "properties": {
          "filename": {
            "type": "string",
            "description": "Name of the attached file"
          },
          "fileContent": {
            "type": "object",
            "description": "Content of the attached file"
          },
          "fileSize": {
            "type": "number",
            "description": "Size of the attached file in bytes"
          },
          "contentType": {
            "type": "string",
            "description": "MIME type of the attached file"
          }
        },
        "required": [
          "filename",
          "fileContent"
        ]
      }
    }
  },
  {
    "featureName": "IncrementTotalViews",
    "description": "Increases the view counter for a topic when a user views it.",
    "inputValues": [
      "topicId-number-Topic"
    ],
    "businessLogic": "1. Input Collection\n   - Collect the topicId (number) of the topic being viewed\n   - This field is mandatory and system-provided\n   - No default value is available\n\n2. Data Validation\n   - Validate topicId\n     - Ensure topicId is a positive integer\n     - Verify topicId exists in the system\n     - IF topicId is invalid or not found THEN\n       - Generate appropriate error message\n       - Terminate the process\n\n3. Business Rule Processing\n   - Check system state\n     - Verify the database connection is available\n     - Ensure the topic is in an active state (not deleted)\n     - IF database connection is unavailable THEN\n       - Generate connection error message\n       - Terminate the process\n     - IF topic is in deleted state THEN\n       - Skip view increment\n       - Terminate the process\n\n4. Core Operation Execution\n   - Update the topic view counter\n     - Locate the topic record using the provided topicId\n     - Increment the total_views field by 1\n     - Commit the change to the database\n     - IF update operation fails THEN\n       - Log the error details\n       - Attempt to rollback the operation\n       - Generate appropriate error message\n\n5. Response Generation\n   - Generate success response\n     - Indicate the view count was successfully incremented\n     - No specific return data is required\n   - IF any errors occurred during processing THEN\n     - Return appropriate error message\n     - Include error details for troubleshooting",
    "databaseEntities": [
      "jforum_topics"
    ],
    "validationRules": [
      "Topic ID must be a positive integer",
      "Topic ID must reference an existing topic",
      "Topic must be in active state (not deleted)"
    ],
    "dbSeedingOperations": [],
    "schema": {}
  },
  {
    "featureName": "IncrementTotalReplies",
    "description": "Increases the reply counter for a topic when a new reply is added.",
    "inputValues": [
      "topicId-number-Topic"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect topicId (mandatory, number) that identifies the topic to update\n   - System will use the current database connection from the context\n\n2. Data Validation:\n   - Validate that topicId is provided\n     * IF topicId is null or zero THEN\n       - Return error: \"Topic ID is required\"\n     * END IF\n   - Validate that topicId represents an existing topic\n     * IF topic does not exist THEN\n       - Return error: \"Topic not found\"\n     * END IF\n\n3. Business Rule Processing:\n   - Check if the topic is in a valid state for incrementing replies\n     * IF topic is locked or deleted THEN\n       - Return error: \"Cannot add replies to this topic\"\n     * END IF\n   - Verify user has permission to add replies to this topic\n     * IF user does not have permission THEN\n       - Return error: \"Insufficient permissions to add replies\"\n     * END IF\n\n4. Core Operation Execution:\n   - Begin database transaction\n     * Increment the total_replies counter for the specified topic\n     * Update the last_post_date to current timestamp\n     * IF any database operation fails THEN\n       - Rollback transaction\n       - Log the error details\n       - Return error: \"Failed to update reply count\"\n     * END IF\n   - Commit transaction\n\n5. Response Generation:\n   - IF operation successful THEN\n     * Return success response with updated topic information\n     * Include new reply count in the response\n   - ELSE\n     * Return appropriate error message based on the failure point\n     * Include suggestion for user action if applicable\n   - END IF",
    "databaseEntities": [
      "jforum_topics"
    ],
    "validationRules": [
      "Topic ID must be a positive integer",
      "Topic must exist in the database",
      "Topic must not be locked or deleted",
      "User must have permission to reply to the topic"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Topic": {
        "type": "object",
        "properties": {
          "id": {
            "type": "number",
            "description": "Unique identifier for the topic"
          },
          "totalReplies": {
            "type": "number",
            "description": "Count of replies to the topic"
          },
          "lastPostDate": {
            "type": "date",
            "description": "Date and time of the last reply"
          }
        },
        "required": [
          "id"
        ]
      }
    }
  },
  {
    "featureName": "DecrementTotalReplies",
    "description": "Decreases the reply counter for a topic when a reply is removed.",
    "inputValues": [
      "topicId-number-Topic"
    ],
    "businessLogic": "1. Input Collection\n   - Collect the following inputs:\n     - topicId (mandatory): Unique identifier of the topic whose reply count needs to be decremented\n\n2. Data Validation\n   - Validate the topic ID:\n     - Check if topicId is provided\n     - Verify topicId is a positive integer\n     - Verify the topic exists in the system\n     - If any validation fails, generate appropriate error message\n\n3. Business Rule Processing\n   - Check if the topic is in a valid state for decrementing replies:\n     - Verify the topic has at least one reply (total replies > 0)\n     - IF total replies count is already 0, THEN\n       - Log warning about attempting to decrement below zero\n       - Exit process without making changes\n     - END IF\n\n4. Core Operation Execution\n   - Decrement the total replies count for the specified topic:\n     - Retrieve the current reply count for the topic\n     - Subtract one from the current reply count\n     - Update the topic record with the new reply count\n     - IF update operation fails, THEN\n       - Log the error details\n       - Revert any partial changes\n       - Generate appropriate error response\n     - END IF\n\n5. Response Generation\n   - IF operation is successful, THEN\n     - Return success status\n     - Include the updated reply count in the response\n   - ELSE\n     - Return error status\n     - Include error details and suggestions for resolution\n   - END IF",
    "databaseEntities": [
      "jforum_topics"
    ],
    "validationRules": [
      "Topic ID must be provided",
      "Topic ID must be a positive integer",
      "Topic must exist in the system",
      "Topic should have at least one reply before decrementing"
    ],
    "dbSeedingOperations": [],
    "schema": {}
  },
  {
    "featureName": "SetLastPostId",
    "description": "Updates the reference to the most recent post in a topic.",
    "inputValues": [
      "topicId-number-Topic",
      "postId-number-Post"
    ],
    "businessLogic": "1. Input Collection\n   - Collect the following inputs:\n     - topicId (mandatory): Unique identifier for the topic to be updated\n     - postId (mandatory): Identifier of the post to be set as the last post\n\n2. Data Validation\n   - Validate topicId:\n     - Check if topicId is provided\n     - Verify topicId is a positive integer\n     - IF topicId is invalid or missing, THEN generate an error message indicating invalid topic identifier\n   - Validate postId:\n     - Check if postId is provided\n     - Verify postId is a positive integer\n     - IF postId is invalid or missing, THEN generate an error message indicating invalid post identifier\n\n3. Business Rule Processing\n   - Verify topic existence:\n     - Check if the topic with the provided topicId exists in the system\n     - IF topic does not exist, THEN generate an error message indicating topic not found\n   - Verify post existence:\n     - Check if the post with the provided postId exists in the system\n     - IF post does not exist, THEN generate an error message indicating post not found\n   - Verify post belongs to topic:\n     - Check if the post with postId belongs to the topic with topicId\n     - IF post does not belong to the topic, THEN generate an error message indicating post-topic mismatch\n\n4. Core Operation Execution\n   - Update topic record:\n     - Locate the topic record using the topicId\n     - Update the last_post_id field with the provided postId\n     - Save the changes to the topic record\n   - Update related information:\n     - Update the topic's last update timestamp to current time\n     - IF update operation fails, THEN rollback any changes and generate an error message\n\n5. Response Generation\n   - Success response:\n     - Generate confirmation message indicating the topic's last post reference was successfully updated\n     - Include the updated topic identifier in the response\n   - Error response:\n     - For validation errors, return appropriate error messages\n     - For database errors, return a system error message\n     - Include error details to help troubleshoot the issue",
    "databaseEntities": [
      "jforum_topics",
      "jforum_posts"
    ],
    "validationRules": [
      "Topic ID must be a positive integer",
      "Post ID must be a positive integer",
      "Topic must exist in the system",
      "Post must exist in the system",
      "Post must belong to the specified topic"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Topic": {
        "id": "number",
        "forumId": "number",
        "title": "string",
        "firstPostId": "number",
        "lastPostId": "number",
        "type": "number",
        "moderated": "boolean",
        "totalViews": "number",
        "totalReplies": "number"
      },
      "Post": {
        "id": "number",
        "topicId": "number",
        "userId": "number",
        "content": "string",
        "time": "date"
      }
    }
  },
  {
    "featureName": "SelectAllTopicsByForum",
    "description": "Retrieves all topics belonging to a specific forum.",
    "inputValues": [
      "forumId-number-Forum"
    ],
    "businessLogic": "1. Input Collection\n   - Collect forumId (mandatory) - numeric identifier of the forum\n\n2. Data Validation\n   - Validate forumId\n     - Check if forumId is provided\n     - Verify forumId is a positive integer\n     - Verify the forum exists in the system\n   - IF validation fails THEN\n     - Generate appropriate error message\n     - Terminate process\n\n3. Business Rule Processing\n   - Check user permissions\n     - Verify current user has access rights to view the specified forum\n     - IF user lacks permission THEN\n       - Generate access denied message\n       - Terminate process\n   - Check forum status\n     - Verify forum is active and not archived\n     - IF forum is inactive THEN\n       - Generate appropriate notification\n       - Terminate process\n\n4. Core Operation Execution\n   - Retrieve all topics associated with the forum\n     - Query topics database using forumId as filter\n     - Sort topics according to system default sorting (typically by last activity date)\n     - Include relevant topic metadata:\n       - Topic title\n       - Creation date\n       - Author information\n       - Reply count\n       - View count\n       - Last post information\n   - Process topic status indicators\n     - Mark topics as read/unread based on user's last visit\n     - Identify sticky/announcement topics\n     - Identify locked topics\n     - Identify topics with polls\n\n5. Response Generation\n   - Format topic list for display\n     - Group topics by type (announcements, sticky, normal)\n     - Include pagination information if applicable\n   - IF no topics found THEN\n     - Generate appropriate empty state message\n   - IF operation successful THEN\n     - Return formatted topic list\n   - ELSE\n     - Generate error message with support information\n     - Log the error details",
    "databaseEntities": [
      "Forum",
      "Topic",
      "User"
    ],
    "validationRules": [
      "Forum ID must be a positive integer",
      "Forum must exist in the system",
      "User must have permission to view the forum",
      "Forum must be active"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Topic": {
        "id": "number",
        "title": "string",
        "forumId": "number",
        "postedBy": "object",
        "creationDate": "date",
        "lastPostId": "number",
        "lastPostDate": "date",
        "totalReplies": "number",
        "totalViews": "number",
        "isSticky": "boolean",
        "isLocked": "boolean",
        "hasPoll": "boolean"
      },
      "Forum": {
        "id": "number",
        "name": "string",
        "description": "string",
        "categoryId": "number",
        "totalTopics": "number",
        "totalPosts": "number",
        "lastPostId": "number",
        "isActive": "boolean"
      }
    }
  },
  {
    "featureName": "SelectTopicsByUserWithPagination",
    "description": "Retrieves topics created by a specific user with pagination support.",
    "inputValues": [
      "userId-number-User",
      "startFrom-number-PaginationParams",
      "count-number-PaginationParams"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect userId (mandatory): Unique identifier of the user whose topics will be retrieved\n   - Collect startFrom (mandatory): Starting index for pagination\n   - Collect count (mandatory): Number of topics to retrieve\n   - System will use these parameters to fetch a specific range of topics\n\n2. Data Validation:\n   - Validate userId:\n      * Ensure userId is a positive integer\n      * Verify userId exists in the system\n      * IF userId is invalid or not found THEN return appropriate error message\n   - Validate pagination parameters:\n      * Ensure startFrom is a non-negative integer\n      * Ensure count is a positive integer\n      * IF startFrom or count is invalid THEN use default values (startFrom=0, count=10)\n\n3. Business Rule Processing:\n   - Check user access permissions:\n      * Verify the requesting user has permission to view topics\n      * Determine which forums the user has access to view\n      * Build a list of allowed forum IDs for the query\n      * IF user has no forum access THEN return empty result with appropriate message\n   - Check database connection:\n      * Ensure database connection is available\n      * IF connection is unavailable THEN return system error message\n   - Prepare pagination boundaries:\n      * Calculate the end boundary by adding count to startFrom\n      * This accommodates the pagination approach which requires both start and end indices\n\n4. Core Operation Execution:\n   - Query topic records:\n      * Retrieve topics where the poster ID matches the provided userId\n      * Filter topics to only include those from forums the user has access to\n      * Apply pagination using startFrom and count parameters\n      * Sort topics by creation date (newest first)\n   - For each topic retrieved:\n      * Collect basic topic information (id, title, creation date)\n      * Include forum information where the topic was posted\n      * Include topic statistics (views, replies)\n      * Include last post information\n      * Check for attachments and mark topics with attachments accordingly\n      * Format dates according to system's configured date format\n   - Process user information:\n      * Collect IDs of users who created topics and made last posts\n      * Retrieve usernames for all collected user IDs in a single operation\n      * Associate usernames with corresponding topics\n   - Count total number of topics by this user (for pagination information)\n   - IF any database errors occur during retrieval THEN:\n      * Log the error with appropriate details\n      * Handle gracefully with appropriate error message\n      * Close all database resources properly\n\n5. Response Generation:\n   - Prepare paginated result:\n      * Include list of topic objects with their details\n      * Include pagination metadata:\n         > Total number of topics by this user\n         > Current page information\n         > More pages indicator\n   - IF no topics found THEN return empty list with appropriate message\n   - IF operation successful THEN return formatted topic list with pagination details\n   - IF any errors occurred during processing THEN return error details with support information",
    "databaseEntities": [
      "jforum_users",
      "jforum_topics",
      "jforum_forums",
      "jforum_posts"
    ],
    "validationRules": [
      "User ID must be a positive integer",
      "User must exist in the system",
      "Start index must be a non-negative integer",
      "Count must be a positive integer",
      "User must have permission to view the requested topics",
      "Topics must belong to the specified user",
      "Database connection must be available",
      "Pagination parameters must be adjusted for database-specific implementation",
      "All database resources must be properly closed after use",
      "Access to topics must be restricted to forums the user has permission to view"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Topic": {
        "id": "number",
        "title": "string",
        "forumId": "number",
        "postedBy": "object",
        "creationDate": "date",
        "lastPostId": "number",
        "totalViews": "number",
        "totalReplies": "number",
        "type": "number",
        "isModerated": "boolean",
        "hasAttach": "boolean",
        "firstPostTime": "string",
        "lastPostTime": "string",
        "lastPostDate": "date"
      },
      "User": {
        "id": "number",
        "username": "string"
      },
      "PaginationParams": {
        "startFrom": "number",
        "count": "number"
      },
      "PaginationResult": {
        "topics": "array",
        "totalTopics": "number",
        "currentPage": "number",
        "hasMorePages": "boolean"
      }
    }
  },
  {
    "featureName": "GetTotalPosts",
    "description": "Counts the total number of posts within a specific topic.",
    "inputValues": [
      "topicId-number-Topic"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect topicId (mandatory, number) to identify the target topic\n\n2. Data Validation:\n   - Validate topicId:\n     a. Ensure topicId is provided\n     b. Verify topicId is a positive integer\n     c. Return error message if validation fails\n\n3. Business Rule Processing:\n   - Verify topic existence:\n     a. Check if topic with given topicId exists in the system\n     b. IF topic does not exist THEN\n        i. Generate appropriate error message\n        ii. Return error response\n     c. IF topic exists THEN\n        i. Proceed to next step\n\n4. Core Operation Execution:\n   - Count posts for the specified topic:\n     a. Initialize counter for total posts\n     b. Retrieve all posts associated with the given topicId\n     c. Count the number of posts found\n     d. Store the count as total posts\n\n5. Response Generation:\n   - Prepare response with post count:\n     a. IF operation successful THEN\n        i. Include total post count in response\n        ii. Include topic information (title, creation date) for reference\n     b. IF operation failed THEN\n        i. Include error details\n        ii. Include suggestions for troubleshooting",
    "databaseEntities": [
      "jforum_topics",
      "jforum_posts"
    ],
    "validationRules": [
      "Topic ID must be a positive integer",
      "Topic must exist in the system",
      "User must have permission to view the topic"
    ],
    "dbSeedingOperations": [],
    "schema": {}
  },
  {
    "featureName": "SubscribeUsers",
    "description": "Subscribes multiple users to a topic for notifications.",
    "inputValues": [
      "topicId-number-Topic",
      "users-object-UserList"
    ],
    "businessLogic": "1. Input Collection\n   - Collect the topic ID (required, numeric identifier)\n   - Collect the list of users to subscribe (required, list of user objects)\n   - Each user object must contain at minimum a user ID\n\n2. Data Validation\n   - Validate topic ID\n     - Verify topic ID is a positive integer\n     - Verify topic ID exists in the system\n     - IF topic ID is invalid or not found, THEN generate an error message\n   - Validate user list\n     - Verify user list is not empty\n     - Verify each user in the list has a valid user ID\n     - IF user list is empty, THEN generate an error message\n     - IF any user ID is invalid, THEN generate an error message\n\n3. Business Rule Processing\n   - Check topic status\n     - Verify the topic is active and not locked\n     - IF topic is locked or inactive, THEN generate an error message\n   - Check user permissions\n     - Verify each user has permission to subscribe to topics\n     - IF any user lacks permission, THEN exclude that user and log a warning\n   - Check for existing subscriptions\n     - For each user, check if they are already subscribed to the topic\n     - IF user is already subscribed, THEN skip that user and continue with others\n\n4. Core Operation Execution\n   - Create subscription records\n     - FOR each valid user in the list:\n       - IF user is not already subscribed to the topic, THEN:\n         - Create a new subscription record linking the user to the topic\n         - Set the initial read status for the subscription\n         - Record the subscription timestamp\n   - Update notification preferences\n     - FOR each successfully subscribed user:\n       - Update the user's notification settings for this topic if specified\n       - Set default notification method based on user preferences\n\n5. Response Generation\n   - Generate success response\n     - Include the number of users successfully subscribed\n     - Include the topic information (ID, title)\n     - Include list of users that were already subscribed (if any)\n   - Generate error response (if needed)\n     - Include specific error messages for validation failures\n     - Include list of users that could not be subscribed with reasons\n     - Provide guidance on how to resolve the issues",
    "databaseEntities": [
      "jforum_topics",
      "jforum_users"
    ],
    "validationRules": [
      "Topic ID must be a positive integer",
      "Topic ID must reference an existing topic",
      "User list must not be empty",
      "Each user ID must be a positive integer",
      "Each user ID must reference an existing user",
      "Topic must be active and not locked",
      "Users must have permission to subscribe to topics"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "UserList": {
        "type": "array",
        "items": {
          "type": "object",
          "properties": {
            "id": {
              "type": "integer",
              "description": "User identifier"
            }
          },
          "required": [
            "id"
          ]
        }
      }
    }
  },
  {
    "featureName": "RemoveTopicSubscriptions",
    "description": "Removes all user subscriptions for a specific topic.",
    "inputValues": [
      "topicId-number-Topic"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the topicId (mandatory)\n   - System will identify the topic to remove subscriptions from\n\n2. Data Validation:\n   - Validate that topicId is provided\n     - IF topicId is missing or invalid THEN\n       - Generate an error message indicating that a valid topic ID is required\n       - Halt the operation\n     - END IF\n   - Verify that the topic exists in the system\n     - IF topic does not exist THEN\n       - Generate an error message indicating that the specified topic cannot be found\n       - Halt the operation\n     - END IF\n\n3. Business Rule Processing:\n   - Check if the topic has any subscriptions\n     - IF no subscriptions exist for this topic THEN\n       - Skip deletion process\n       - Generate a notification that no subscriptions were found\n     - END IF\n   - Verify user permissions\n     - IF current user is not authorized to manage topic subscriptions THEN\n       - Generate an access denied error message\n       - Halt the operation\n     - END IF\n\n4. Core Operation Execution:\n   - Begin subscription removal process\n     - Locate all subscription records associated with the specified topic\n     - Remove all subscription entries for the topic\n     - Update any related notification settings\n     - IF any errors occur during deletion THEN\n       - Rollback any partial changes\n       - Generate an error message describing the failure\n       - Halt the operation\n     - END IF\n\n5. Response Generation:\n   - IF operation completes successfully THEN\n     - Generate a success message indicating all subscriptions were removed\n     - Include the number of subscriptions that were removed\n     - Provide confirmation that users will no longer receive notifications for this topic\n   - ELSE\n     - Generate an appropriate error message\n     - Include troubleshooting information if available\n   - END IF",
    "databaseEntities": [
      "jforum_topics",
      "jforum_users"
    ],
    "validationRules": [
      "Topic ID must be a positive integer",
      "Topic must exist in the system",
      "User must have permission to manage topic subscriptions"
    ],
    "dbSeedingOperations": [],
    "schema": {}
  },
  {
    "featureName": "UpdateReadStatus",
    "description": "Updates the read/unread status of a topic for a specific user.",
    "inputValues": [
      "topicId-number-Topic",
      "userId-number-User",
      "readStatus-boolean-Topic"
    ],
    "businessLogic": "1. Input Collection\n   - Collect the following required inputs:\n     a. topicId (mandatory): Unique identifier for the topic\n     b. userId (mandatory): Unique identifier for the user\n     c. readStatus (mandatory): Boolean flag indicating whether the topic is read (true) or unread (false)\n\n2. Data Validation\n   - Validate topicId:\n     a. Check if topicId is provided\n     b. Verify topicId is a positive integer\n     c. IF validation fails, THEN generate appropriate error message\n   - Validate userId:\n     a. Check if userId is provided\n     b. Verify userId is a positive integer\n     c. IF validation fails, THEN generate appropriate error message\n   - Validate readStatus:\n     a. Check if readStatus is provided\n     b. Verify readStatus is a boolean value\n     c. IF validation fails, THEN generate appropriate error message\n\n3. Business Rule Processing\n   - Check if topic exists:\n     a. Verify the topic with the provided topicId exists in the system\n     b. IF topic does not exist, THEN return error message indicating invalid topic\n   - Check if user exists:\n     a. Verify the user with the provided userId exists in the system\n     b. IF user does not exist, THEN return error message indicating invalid user\n   - Check if user is subscribed to the topic:\n     a. Verify if the user is subscribed to the topic\n     b. IF user is not subscribed, THEN return error message indicating user is not subscribed to the topic\n\n4. Core Operation Execution\n   - Update read status:\n     a. Convert boolean readStatus to numeric value (1 for read, 0 for unread)\n     b. Update the subscription record for the specified user and topic with the new read status\n     c. IF update operation fails, THEN:\n        i. Log the error details\n        ii. Generate appropriate error message\n        iii. Roll back any partial changes\n\n5. Response Generation\n   - For successful update:\n     a. Generate success response indicating the read status was updated successfully\n     b. Include the topicId and new read status in the response\n   - For failed update:\n     a. Generate error response with appropriate error message\n     b. Include error details for troubleshooting",
    "databaseEntities": [
      "jforum_topics",
      "jforum_users"
    ],
    "validationRules": [
      "Topic ID must be a positive integer",
      "User ID must be a positive integer",
      "Read status must be a boolean value",
      "Topic must exist in the system",
      "User must exist in the system",
      "User must be subscribed to the topic"
    ],
    "dbSeedingOperations": [],
    "schema": {}
  },
  {
    "featureName": "GetNewMessages",
    "description": "Retrieves topics with new messages based on a list of topic IDs.",
    "inputValues": [
      "topicIds-object-TopicIdList"
    ],
    "businessLogic": "1. Input Collection\n   - Collect the list of topic IDs from the user\n     1.1. Verify that the input is properly formatted as a collection\n     1.2. Check if the collection is accessible and readable\n\n2. Data Validation\n   - Validate the input topic IDs\n     2.1. Check if the list of topic IDs is not empty\n     2.2. Verify that each topic ID is a valid identifier\n     2.3. IF the list is empty THEN\n          2.3.1. Return an empty result set\n          2.3.2. End processing\n     2.4. IF any ID is invalid THEN\n          2.4.1. Filter out invalid IDs\n          2.4.2. Log warning about invalid IDs\n\n3. Business Rule Processing\n   - Check access permissions for topics\n     3.1. Verify the current user has permission to view the requested topics\n     3.2. Filter out any topics the user doesn't have access to\n     3.3. IF user has no access to any topics THEN\n          3.3.1. Return empty result set\n          3.3.2. End processing\n\n4. Core Operation Execution\n   - Retrieve topics with new messages\n     4.1. Format the list of topic IDs for processing\n     4.2. Query the system for topics matching the provided IDs\n     4.3. For each topic found:\n          4.3.1. Retrieve basic topic information (title, ID, status)\n          4.3.2. Retrieve posting information (time, views, replies)\n          4.3.3. Retrieve user information for the topic creator\n          4.3.4. Retrieve information about the last post in the topic\n     4.4. IF any errors occur during retrieval THEN\n          4.4.1. Log the error details\n          4.4.2. Return appropriate error message\n\n5. Response Generation\n   - Format and return the topic information\n     5.1. Organize topics in a structured format\n     5.2. Include all relevant topic details:\n          5.2.1. Topic title and identifier\n          5.2.2. Creation timestamp\n          5.2.3. Topic status and type\n          5.2.4. View and reply counts\n          5.2.5. Information about the topic creator\n          5.2.6. Information about the last post\n     5.3. Return the formatted list of topics with new messages",
    "databaseEntities": [
      "jforum_topics",
      "jforum_users",
      "jforum_posts"
    ],
    "validationRules": [
      "Topic IDs list must not be empty",
      "Each topic ID must be a valid identifier",
      "User must have permission to view the requested topics"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "TopicIdList": {
        "type": "array",
        "items": {
          "type": "integer",
          "description": "Unique identifier for a topic"
        }
      },
      "Topic": {
        "type": "object",
        "properties": {
          "id": {
            "type": "integer",
            "description": "Unique identifier for the topic"
          },
          "title": {
            "type": "string",
            "description": "Title of the topic"
          },
          "time": {
            "type": "string",
            "format": "date-time",
            "description": "Creation time of the topic"
          },
          "status": {
            "type": "integer",
            "description": "Status code of the topic"
          },
          "views": {
            "type": "integer",
            "description": "Number of views for the topic"
          },
          "replies": {
            "type": "integer",
            "description": "Number of replies to the topic"
          },
          "postedBy": {
            "type": "object",
            "description": "User who created the topic"
          },
          "lastPostBy": {
            "type": "object",
            "description": "User who made the last post in the topic"
          }
        }
      }
    }
  },
  {
    "featureName": "FillTopicsData",
    "description": "Populates topic objects with complete data including user information.",
    "inputValues": [
      "preparedStatement-object-PreparedStatement",
      "dateTimeFormat-string-SystemConfig"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect prepared statement containing topic query\n   - Retrieve system date time format configuration\n   - Prepare data structures for collecting user IDs\n\n2. Data Validation:\n   - Verify prepared statement is not null\n     IF prepared statement is null THEN\n       Return empty result list\n     END IF\n   - Ensure database connection is active\n     IF connection is not active THEN\n       Throw appropriate exception\n       Exit process\n     END IF\n\n3. Business Rule Processing:\n   - Initialize result collection for topics\n   - Initialize string buffers for collecting user IDs\n     Create first poster ID collection buffer\n     Create last poster ID collection buffer\n   - Prepare date formatter using system configuration\n     IF date format is invalid THEN\n       Use default date format\n     END IF\n\n4. Core Operation Execution:\n   - Execute query and process result set\n     Execute the prepared statement query\n     WHILE results available DO\n       Extract base topic data (ID, title, etc.)\n       Create topic poster user object with ID\n       Create last post user object with ID\n       Set attachment flag based on attach count\n       Format and set first post timestamp\n       Format and set last post timestamp\n       Add topic to result collection\n       Append user IDs to respective buffers\n     END WHILE\n   - Process user information\n     IF any topics were found THEN\n       Prepare user ID list from collected IDs\n       Query database for user information using ID list\n       Create mapping of user IDs to usernames\n       FOR each topic in result collection\n         Set poster username from user mapping\n         Set last poster username from user mapping\n       END FOR\n     END IF\n   - Handle resources properly\n     Close result set\n     Close prepared statement\n     Handle any exceptions during processing\n\n5. Response Generation:\n   - Return populated topic collection\n     IF operation successful THEN\n       Return complete list of topic objects with all data populated\n     ELSE\n       Throw appropriate exception with error details\n     END IF",
    "databaseEntities": [
      "jforum_topics",
      "jforum_users",
      "jforum_posts"
    ],
    "validationRules": [
      "Prepared statement must not be null",
      "Database connection must be active",
      "Date format must be valid for timestamp formatting",
      "Topic creator information must be populated",
      "Last post author information must be populated"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "PreparedStatement": {
        "type": "object",
        "description": "Database prepared statement containing the topic query to execute"
      },
      "Topic": {
        "type": "object",
        "properties": {
          "id": {
            "type": "number",
            "description": "Unique identifier for the topic"
          },
          "title": {
            "type": "string",
            "description": "Title of the topic"
          },
          "postedBy": {
            "type": "object",
            "description": "User who created the topic",
            "properties": {
              "id": {
                "type": "number",
                "description": "User ID of the topic creator"
              },
              "username": {
                "type": "string",
                "description": "Username of the topic creator"
              }
            }
          },
          "lastPostBy": {
            "type": "object",
            "description": "User who made the last post in the topic",
            "properties": {
              "id": {
                "type": "number",
                "description": "User ID of the last poster"
              },
              "username": {
                "type": "string",
                "description": "Username of the last poster"
              }
            }
          },
          "hasAttach": {
            "type": "boolean",
            "description": "Indicates if the topic has attachments"
          },
          "firstPostTime": {
            "type": "string",
            "description": "Formatted date/time when the topic was created"
          },
          "lastPostTime": {
            "type": "string",
            "description": "Formatted date/time of the last post"
          },
          "lastPostDate": {
            "type": "object",
            "description": "Date object representing the last post time"
          }
        }
      }
    }
  },
  {
    "featureName": "SetFirstPostId",
    "description": "Updates a topic with the ID of its first post.",
    "inputValues": [
      "topicId-number-Topic",
      "postId-number-Post"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the following inputs:\n     a. topicId (mandatory): Unique identifier for the topic to be updated\n     b. postId (mandatory): Identifier of the first post to be associated with the topic\n\n2. Data Validation:\n   - Validate topicId:\n     a. Check if topicId is provided\n     b. Verify topicId is a positive integer\n     c. IF validation fails, THEN generate appropriate error message\n   - Validate postId:\n     a. Check if postId is provided\n     b. Verify postId is a positive integer\n     c. IF validation fails, THEN generate appropriate error message\n\n3. Business Rule Processing:\n   - Verify topic existence:\n     a. Check if a topic with the provided topicId exists in the system\n     b. IF topic does not exist, THEN generate error message \"Topic not found\"\n   - Verify post existence:\n     a. Check if a post with the provided postId exists in the system\n     b. IF post does not exist, THEN generate error message \"Post not found\"\n   - Verify post-topic relationship:\n     a. Check if the post belongs to the specified topic\n     b. IF post does not belong to the topic, THEN generate error message \"Post does not belong to the specified topic\"\n\n4. Core Operation Execution:\n   - Update topic record:\n     a. Locate the topic record using topicId\n     b. Set the first_post_id field to the provided postId\n     c. Save the updated topic record\n     d. IF update operation fails, THEN:\n        i. Log the failure details\n        ii. Prepare error response with appropriate message\n        iii. Abort the operation\n\n5. Response Generation:\n   - For successful update:\n     a. Prepare success response indicating the topic was updated successfully\n     b. Include the updated topic identifier in the response\n   - For failed update:\n     a. Include detailed error information in the response\n     b. Provide guidance on how to resolve the issue",
    "databaseEntities": [
      "jforum_topics",
      "jforum_posts"
    ],
    "validationRules": [
      "Topic ID must be a positive integer",
      "Post ID must be a positive integer",
      "Topic must exist in the system",
      "Post must exist in the system",
      "Post must belong to the specified topic"
    ],
    "dbSeedingOperations": [],
    "schema": {}
  },
  {
    "featureName": "GetMinPostId",
    "description": "Retrieves the minimum (earliest) post ID for a specific topic.",
    "inputValues": [
      "topicId-number-Topic"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect topicId (number, mandatory)\n   - No optional fields or default values required\n   - System will use the topicId to query the database\n\n2. Data Validation:\n   - Validate topicId:\n     a. Check if topicId is provided\n     b. Verify topicId is a positive integer\n     c. Return error if topicId is missing or invalid\n\n3. Business Rule Processing:\n   - Verify topic existence:\n     a. Check if the provided topicId exists in the system\n     b. If topic does not exist, return appropriate error message\n     c. If topic exists, proceed to next step\n\n4. Core Operation Execution:\n   - Retrieve minimum post ID:\n     a. Query the posts associated with the specified topic\n     b. Find the minimum post ID value among all posts in the topic\n     c. If no posts are found for the topic, set minimum post ID to -1\n     d. Store the minimum post ID for return\n\n5. Response Generation:\n   - Success response:\n     a. Return the minimum post ID value\n     b. If no posts were found, return -1 indicating no posts exist\n   - Error response:\n     a. Return appropriate error message if topic does not exist\n     b. Return system error message if database operation fails",
    "databaseEntities": [
      "jforum_topics",
      "jforum_posts"
    ],
    "validationRules": [
      "Topic ID must be provided",
      "Topic ID must be a positive integer",
      "Topic must exist in the system"
    ],
    "dbSeedingOperations": [],
    "schema": {}
  },
  {
    "featureName": "SetModerationStatus",
    "description": "Updates moderation status for all topics in a forum.",
    "inputValues": [
      "forumId-number-Forum",
      "status-boolean-ModerationStatus"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect forumId (mandatory, number): Identifier of the forum to update\n   - Collect status (mandatory, boolean): New moderation status to set\n   - System will use current user session for authorization\n\n2. Data Validation:\n   - Validate forumId:\n     2.1. Check if forumId is provided and is a positive integer\n     2.2. IF forumId is missing or invalid THEN\n          2.2.1. Return error message \"Invalid forum identifier\"\n   - Validate status:\n     2.3. Check if status is provided as a boolean value\n     2.4. IF status is not a boolean THEN\n          2.4.1. Return error message \"Moderation status must be true or false\"\n   - Validate user permissions:\n     2.5. Check if current user has moderation privileges for the specified forum\n     2.6. IF user lacks required permissions THEN\n          2.6.1. Return error message \"Insufficient permissions to modify moderation status\"\n\n3. Business Rule Processing:\n   - Verify forum existence:\n     3.1. Check if forum with provided forumId exists in the system\n     3.2. IF forum does not exist THEN\n          3.2.1. Return error message \"Forum not found\"\n   - Check system state:\n     3.3. Verify the system is not in maintenance mode\n     3.4. IF system is in maintenance mode THEN\n          3.4.1. Return error message \"System is currently in maintenance mode\"\n   - Check forum state:\n     3.5. Verify the forum is active and not locked\n     3.6. IF forum is locked or inactive THEN\n          3.6.1. Return error message \"Cannot modify moderation status of inactive or locked forum\"\n\n4. Core Operation Execution:\n   - Update moderation status:\n     4.1. Begin transaction\n     4.2. Update all topics in the specified forum with the new moderation status\n     4.3. IF update operation fails THEN\n          4.3.1. Rollback transaction\n          4.3.2. Log error details\n          4.3.3. Return error message \"Failed to update moderation status\"\n     4.4. Commit transaction\n   - Update forum metadata:\n     4.5. Update forum's last modified timestamp\n     4.6. Record the user who made the change\n     4.7. IF metadata update fails THEN\n          4.7.1. Log warning (non-critical failure)\n\n5. Response Generation:\n   - Success response:\n     5.1. Generate confirmation message including:\n          5.1.1. Number of topics affected\n          5.1.2. New moderation status\n          5.1.3. Forum name\n     5.2. Include timestamp of the operation\n   - Error response:\n     5.3. Include specific error message from previous steps\n     5.4. Provide guidance on how to resolve the issue\n     5.5. Include support reference information if needed",
    "databaseEntities": [
      "jforum_forums",
      "jforum_topics",
      "jforum_users",
      "jforum_groups",
      "jforum_moderator_groups"
    ],
    "validationRules": [
      "Forum ID must be a positive integer",
      "Moderation status must be a boolean value",
      "User must have moderation privileges for the specified forum",
      "Forum must exist in the system",
      "Forum must be active and not locked",
      "System must not be in maintenance mode"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Forum": {
        "id": "number",
        "name": "string",
        "description": "string",
        "isActive": "boolean",
        "isLocked": "boolean",
        "lastModified": "date",
        "moderationEnabled": "boolean"
      },
      "ModerationStatus": {
        "enabled": "boolean"
      }
    }
  },
  {
    "featureName": "SetModerationStatusByTopic",
    "description": "Updates moderation status for a specific topic.",
    "inputValues": [
      "topicId-number-Topic",
      "status-boolean-Topic"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect topicId (number, mandatory) - Unique identifier of the topic to update\n   - Collect status (boolean, mandatory) - New moderation status to set (true for moderated, false for unmoderated)\n   - System will use current user context for authorization\n\n2. Data Validation:\n   - Validate topicId:\n     a. Verify topicId is not null or empty\n     b. Verify topicId is a positive integer\n     c. Verify topicId exists in the system\n     d. IF validation fails, THEN return appropriate error message\n   - Validate status:\n     a. Verify status is a valid boolean value\n     b. IF validation fails, THEN return appropriate error message\n\n3. Business Rule Processing:\n   - Verify user permissions:\n     a. Check if current user has moderation privileges for this topic\n     b. IF user lacks required permissions, THEN return access denied error\n   - Check topic state:\n     a. Verify topic is in a state that allows moderation status changes\n     b. IF topic is locked or deleted, THEN return appropriate error message\n\n4. Core Operation Execution:\n   - Update topic moderation status:\n     a. Locate topic record using topicId\n     b. Set moderation status field to provided status value (convert boolean to appropriate database value)\n     c. Save updated topic record\n     d. IF update fails, THEN log error details and return system error message\n     e. Record moderation action in system logs with user information, timestamp, and action details\n\n5. Response Generation:\n   - On success:\n     a. Generate success response with confirmation message\n     b. Include updated topic information in response\n     c. Include timestamp of the operation\n   - On failure:\n     a. Generate error response with specific error details\n     b. Include guidance for resolving the issue if applicable\n     c. Provide support reference if needed",
    "databaseEntities": [
      "jforum_topics"
    ],
    "validationRules": [
      "Topic ID must be a positive integer",
      "Topic ID must reference an existing topic",
      "Status must be a valid boolean value",
      "User must have moderation privileges for the topic",
      "Topic must not be in a locked or deleted state"
    ],
    "dbSeedingOperations": [],
    "schema": {}
  },
  {
    "featureName": "GetPendingActivations",
    "description": "Retrieves a list of users with pending account activations.",
    "inputValues": [],
    "businessLogic": "1. Input Collection:\n   - No user inputs required for this feature\n   - System will use current database connection for retrieval\n\n2. Data Validation:\n   - Verify database connection is available\n   - IF database connection is not available THEN\n     - Generate appropriate error message\n     - Terminate process\n   - END IF\n\n3. Business Rule Processing:\n   - Verify user has appropriate permissions to view pending activations\n   - IF user does not have required permissions THEN\n     - Generate access denied error\n     - Terminate process\n   - END IF\n   - Prepare query parameters for retrieving pending activations\n\n4. Core Operation Execution:\n   - Execute database query to retrieve pending user activations\n   - FOR each pending user record found:\n     - Extract user identifier\n     - Extract username\n     - Extract registration date\n     - Create user object with extracted information\n     - Add user object to result list\n   - END FOR\n   - IF database error occurs during retrieval THEN\n     - Log error details\n     - Generate database error message\n     - Terminate process\n   - END IF\n\n5. Response Generation:\n   - Return list of pending activation users\n   - IF no pending activations found THEN\n     - Return empty list\n   - END IF\n   - Include count of pending activations in response\n   - Format response according to system requirements",
    "databaseEntities": [
      "jforum_users",
      "jforum_user_groups"
    ],
    "validationRules": [
      "User must have administrative privileges to access pending activations",
      "Database connection must be available",
      "User records must contain valid registration dates",
      "User records must contain valid usernames"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "User": {
        "id": "number",
        "username": "string",
        "registrationDate": "date",
        "active": "number"
      }
    }
  },
  {
    "featureName": "GetUserByUsername",
    "description": "Retrieves a user by their username with all associated profile information.",
    "inputValues": [
      "username-string-User"
    ],
    "businessLogic": "1. Input Collection\n   - Collect the following required input:\n     a. username (string): The unique identifier for the user to retrieve\n   - No optional fields are required for this operation\n   - No system-generated fields are needed at this stage\n\n2. Data Validation\n   - Validate the username input:\n     a. Check if username is provided\n        IF username is empty or null THEN\n          Return error message \"Username cannot be empty\"\n     b. Check if username format is valid\n        IF username contains invalid characters THEN\n          Return error message \"Username contains invalid characters\"\n     c. Check if username length is within acceptable range\n        IF username length is outside valid range THEN\n          Return error message \"Username must be between X and Y characters\"\n\n3. Business Rule Processing\n   - Verify system state for user retrieval:\n     a. Check if the user database is accessible\n        IF database connection fails THEN\n          Return error message \"Unable to access user database\"\n     b. Check if the requesting entity has permission to view user data\n        IF permission check fails THEN\n          Return error message \"Insufficient permissions to view user data\"\n\n4. Core Operation Execution\n   - Retrieve user data by username:\n     a. Search for user record matching the provided username\n        IF no user found THEN\n          Return error message \"User not found\"\n     b. Retrieve user's basic profile information\n        - Personal details (email, registration date, etc.)\n        - Preferences and settings\n        - Activity statistics\n     c. Retrieve user's extended profile information\n        - Biography\n        - Contact information\n        - Social media handles\n     d. Retrieve user's group memberships\n        FOR each group the user belongs to:\n          - Get group name and ID\n          - Add to user's group list\n     e. Calculate user's status information\n        - Active/inactive status\n        - Last visit timestamp\n        - Total posts count\n\n5. Response Generation\n   - Prepare success response with user data:\n     a. Format user profile information\n     b. Include all retrieved user attributes\n     c. Include group membership information\n     d. Include activity statistics\n   - Return complete user profile object\n   - If any errors occurred during retrieval:\n     a. Generate appropriate error message\n     b. Include error details and suggestions for resolution",
    "databaseEntities": [
      "jforum_users",
      "jforum_user_groups",
      "jforum_groups"
    ],
    "validationRules": [
      "Username must not be empty",
      "Username must contain valid characters",
      "Username must be within the allowed length range",
      "User must exist in the system",
      "Requesting entity must have permission to view user data"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "User": {
        "id": "number",
        "username": "string",
        "email": "string",
        "registrationDate": "date",
        "lastVisit": "date",
        "totalPosts": "number",
        "signature": "string",
        "biography": "string",
        "avatar": "string",
        "website": "string",
        "from": "string",
        "occupation": "string",
        "interests": "string",
        "gender": "string",
        "rankId": "number",
        "karma": "number",
        "active": "number",
        "groups": "array",
        "privateMessagesCount": "number",
        "settings": {
          "allowHtml": "boolean",
          "allowBbCode": "boolean",
          "allowSmilies": "boolean",
          "notifyOnMessages": "boolean",
          "viewEmailEnabled": "boolean",
          "viewOnlineEnabled": "boolean",
          "attachSignatureEnabled": "boolean"
        },
        "contactInfo": {
          "aim": "string",
          "icq": "string",
          "msnm": "string",
          "yim": "string"
        }
      },
      "Group": {
        "id": "number",
        "name": "string"
      }
    }
  },
  {
    "featureName": "UpdateUserProfile",
    "description": "Updates a user's profile information and preferences.",
    "inputValues": [
      "userId-number-User",
      "username-string-User",
      "email-string-User",
      "password-string-User",
      "signature-string-User",
      "biography-string-User",
      "website-string-User",
      "location-string-User",
      "occupation-string-User",
      "interests-string-User",
      "avatar-string-User",
      "language-string-User",
      "preferences-object-UserPreferences"
    ],
    "businessLogic": "1. Input Collection\n   - Collect user profile data:\n     1.1. Obtain userId (mandatory) to identify the user\n     1.2. Collect personal information fields (all optional):\n          - username\n          - email\n          - password\n          - signature\n          - biography\n          - website\n          - location (from field)\n          - occupation\n          - interests\n          - avatar URL\n          - language preference\n     1.3. Collect user preferences (all optional):\n          - privateMessagesEnabled\n          - viewEmailEnabled\n          - viewOnlineEnabled\n          - notifyOnMessagesEnabled\n          - attachSignatureEnabled\n          - avatarEnabled\n          - bbCodeEnabled\n          - htmlEnabled\n          - smiliesEnabled\n          - notifyPrivateMessagesEnabled\n          - notifyAlways\n          - notifyText\n          - themeId\n\n2. Data Validation\n   - Validate all provided input fields:\n     2.1. Validate userId:\n          - IF userId is not provided or invalid THEN\n            - Return error message \"Valid user ID is required\"\n     2.2. Validate username (if provided):\n          - IF username is empty THEN\n            - Return error message \"Username cannot be empty\"\n          - IF username length is less than 3 characters THEN\n            - Return error message \"Username must be at least 3 characters long\"\n          - IF username contains invalid characters THEN\n            - Return error message \"Username contains invalid characters\"\n     2.3. Validate email (if provided):\n          - IF email is not in valid format THEN\n            - Return error message \"Email address is not valid\"\n     2.4. Validate password (if provided):\n          - IF password length is less than minimum required THEN\n            - Return error message \"Password must be at least [minimum] characters long\"\n     2.5. Validate signature (if provided):\n          - IF signature exceeds maximum length THEN\n            - Return error message \"Signature exceeds maximum allowed length\"\n     2.6. Validate biography (if provided):\n          - IF biography exceeds maximum length THEN\n            - Return error message \"Biography exceeds maximum allowed length\"\n     2.7. Validate website (if provided):\n          - IF website is not a valid URL THEN\n            - Return error message \"Website URL is not valid\"\n     2.8. Validate avatar (if provided):\n          - IF avatar URL is not valid THEN\n            - Return error message \"Avatar URL is not valid\"\n\n3. Business Rule Processing\n   - Verify system constraints and business rules:\n     3.1. Check if user exists:\n          - Retrieve user record using userId\n          - IF user not found THEN\n            - Return error message \"User not found\"\n     3.2. Check if user is active:\n          - IF user is marked as deleted THEN\n            - Return error message \"Cannot update profile for inactive user\"\n     3.3. Check username uniqueness (if username is being changed):\n          - IF new username is different from current username THEN\n            - Check if username already exists for another user\n            - IF username exists THEN\n              - Return error message \"Username already taken\"\n     3.4. Check email uniqueness (if email is being changed):\n          - IF new email is different from current email THEN\n            - Check if email already exists for another user\n            - IF email exists THEN\n              - Return error message \"Email address already in use\"\n\n4. Core Operation Execution\n   - Update the user profile information:\n     4.1. Prepare user data update:\n          - Create user object with current values\n          - Update object with new values for all provided fields\n     4.2. Update personal information:\n          - Update username (if provided)\n          - Update email (if provided)\n          - Update password (if provided)\n          - Update signature (if provided)\n          - Update biography (if provided)\n          - Update website (if provided)\n          - Update location (if provided)\n          - Update occupation (if provided)\n          - Update interests (if provided)\n          - Update avatar (if provided)\n          - Update language (if provided)\n     4.3. Update user preferences:\n          - Update privateMessagesEnabled (if provided)\n          - Update viewEmailEnabled (if provided)\n          - Update viewOnlineEnabled (if provided)\n          - Update notifyOnMessagesEnabled (if provided)\n          - Update attachSignatureEnabled (if provided)\n          - Update avatarEnabled (if provided)\n          - Update bbCodeEnabled (if provided)\n          - Update htmlEnabled (if provided)\n          - Update smiliesEnabled (if provided)\n          - Update notifyPrivateMessagesEnabled (if provided)\n          - Update notifyAlways (if provided)\n          - Update notifyText (if provided)\n          - Update themeId (if provided)\n     4.4. Save updated user profile:\n          - Persist all changes to user record\n          - IF update fails THEN\n            - Revert any partial changes\n            - Return error message \"Failed to update user profile\"\n\n5. Response Generation\n   - Generate appropriate response based on operation outcome:\n     5.1. For successful update:\n          - Generate success message \"User profile updated successfully\"\n          - Include summary of updated fields\n     5.2. For failed update:\n          - Include specific error message explaining the failure\n          - Provide guidance on how to correct the issue\n     5.3. Include next steps information:\n          - Suggest reviewing updated profile\n          - Provide link to view profile page",
    "databaseEntities": [
      "jforum_users",
      "jforum_user_groups"
    ],
    "validationRules": [
      "User ID must be valid and exist in the system",
      "Username must be at least 3 characters long if provided",
      "Username must be unique if changed",
      "Email must be in valid format if provided",
      "Email must be unique if changed",
      "Password must meet minimum length requirements if provided",
      "Signature must not exceed maximum allowed length",
      "Biography must not exceed maximum allowed length",
      "Website URL must be valid if provided",
      "Avatar URL must be valid if provided",
      "User must be active (not deleted) to update profile"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "UserPreferences": {
        "type": "object",
        "properties": {
          "privateMessagesEnabled": {
            "type": "boolean",
            "description": "Whether user can receive private messages"
          },
          "viewEmailEnabled": {
            "type": "boolean",
            "description": "Whether user's email is visible to others"
          },
          "viewOnlineEnabled": {
            "type": "boolean",
            "description": "Whether user's online status is visible"
          },
          "notifyOnMessagesEnabled": {
            "type": "boolean",
            "description": "Whether user receives notifications on messages"
          },
          "attachSignatureEnabled": {
            "type": "boolean",
            "description": "Whether signature is attached to posts"
          },
          "avatarEnabled": {
            "type": "boolean",
            "description": "Whether avatar is displayed"
          },
          "bbCodeEnabled": {
            "type": "boolean",
            "description": "Whether BBCode is enabled in posts"
          },
          "htmlEnabled": {
            "type": "boolean",
            "description": "Whether HTML is enabled in posts"
          },
          "smiliesEnabled": {
            "type": "boolean",
            "description": "Whether smilies are enabled in posts"
          },
          "notifyPrivateMessagesEnabled": {
            "type": "boolean",
            "description": "Whether user receives notifications on private messages"
          },
          "notifyAlways": {
            "type": "boolean",
            "description": "Whether user always receives notifications"
          },
          "notifyText": {
            "type": "boolean",
            "description": "Whether user receives text notifications"
          },
          "themeId": {
            "type": "number",
            "description": "User's preferred theme ID"
          }
        }
      }
    }
  },
  {
    "featureName": "CreateUserWithSpecifiedId",
    "description": "Creates a new user with a predefined ID and assigns them to the default user group.",
    "inputValues": [
      "userId-number-User",
      "username-string-User",
      "password-string-User",
      "email-string-User",
      "activationKey-string-User"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the following required inputs:\n     a. userId (number): The predefined user ID to be assigned\n     b. username (string): The username for the new account\n     c. password (string): The password for authentication\n     d. email (string): The user's email address\n     e. activationKey (string, optional): Key for account activation\n\n2. Data Validation:\n   - Validate userId:\n     a. IF userId is not provided or is not a positive integer THEN\n        i. Return error: \"User ID must be a valid positive integer\"\n   - Validate username:\n     a. IF username is empty or null THEN\n        i. Return error: \"Username is required\"\n     b. IF username length is less than 3 characters THEN\n        i. Return error: \"Username must be at least 3 characters long\"\n     c. IF username already exists in the system THEN\n        i. Return error: \"Username already exists\"\n   - Validate password:\n     a. IF password is empty or null THEN\n        i. Return error: \"Password is required\"\n     b. IF password does not meet security requirements THEN\n        i. Return error: \"Password does not meet security requirements\"\n   - Validate email:\n     a. IF email is empty or null THEN\n        i. Return error: \"Email is required\"\n     b. IF email format is invalid THEN\n        i. Return error: \"Invalid email format\"\n     c. IF email already exists in the system THEN\n        i. Return error: \"Email already exists\"\n\n3. Business Rule Processing:\n   - Check if user ID is available:\n     a. IF a user with the specified ID already exists THEN\n        i. Return error: \"User ID is already in use\"\n   - Verify system configuration:\n     a. IF login authenticator is not configured THEN\n        i. Return error: \"System configuration error: login authenticator not configured\"\n   - Determine default user group:\n     a. Retrieve the default user group ID from system configuration\n     b. IF default user group does not exist THEN\n        i. Return error: \"Default user group not configured\"\n\n4. Core Operation Execution:\n   - Create new user record:\n     a. Prepare user data with the following fields:\n        i. User ID (as specified in input)\n        ii. Username\n        iii. Password (properly secured)\n        iv. Email\n        v. Registration timestamp (current system time)\n        vi. Activation key (if provided)\n     b. Insert the new user record with the specified ID\n     c. IF insertion fails THEN\n        i. Rollback any changes\n        ii. Return error: \"Failed to create user record\"\n   - Assign user to default group:\n     a. Create association between new user and default user group\n     b. IF group assignment fails THEN\n        i. Rollback user creation\n        ii. Return error: \"Failed to assign user to default group\"\n   - Initialize user properties:\n     a. Set default values for user preferences and settings\n     b. Set initial post count to 0\n     c. Set user status to inactive if activation is required\n\n5. Response Generation:\n   - For successful creation:\n     a. Return success status\n     b. Include created user information:\n        i. User ID\n        ii. Username\n        iii. Email\n        iv. Registration date\n        v. Group membership information\n     c. Include activation instructions if applicable\n   - For failed creation:\n     a. Return failure status\n     b. Include specific error message\n     c. Include any validation errors encountered",
    "databaseEntities": [
      "jforum_users",
      "jforum_user_groups"
    ],
    "validationRules": [
      "User ID must be a valid positive integer",
      "Username is required and must be at least 3 characters long",
      "Username must be unique in the system",
      "Password is required and must meet security requirements",
      "Email is required and must have a valid format",
      "Email must be unique in the system",
      "User ID must not already be in use"
    ],
    "dbSeedingOperations": [
      "Ensure default user group exists in jforum_groups"
    ],
    "schema": {
      "User": {
        "userId": "number",
        "username": "string",
        "password": "string",
        "email": "string",
        "activationKey": "string",
        "registrationDate": "date"
      }
    }
  },
  {
    "featureName": "DecrementUserPostCount",
    "description": "Decreases the post count for a specific user.",
    "inputValues": [
      "userId-number-User"
    ],
    "businessLogic": "1. Input Collection\n   - Collect userId (mandatory, number): The unique identifier of the user whose post count needs to be decremented\n   - System will use the current database connection from the execution context\n\n2. Data Validation\n   - Validate userId:\n     a. Check if userId is provided\n     b. Verify userId is a positive integer\n     c. If validation fails, generate appropriate error message\n\n3. Business Rule Processing\n   - Check if user exists in the system\n     a. IF user does not exist, THEN abort operation and return error\n     b. IF user exists, THEN continue\n   - Check if user's post count is greater than zero\n     a. IF post count is already zero, THEN consider whether to abort or leave unchanged\n     b. IF post count is greater than zero, THEN continue\n\n4. Core Operation Execution\n   - Prepare database operation to decrement post count\n   - Execute update operation to reduce user's post count by one\n   - IF operation fails:\n     a. Roll back any changes\n     b. Log the error details\n     c. Return appropriate error message\n   - IF operation succeeds:\n     a. Commit the changes\n     b. Proceed to response generation\n\n5. Response Generation\n   - IF operation was successful:\n     a. Return success status\n     b. Include updated user information if needed\n   - IF operation failed:\n     a. Return failure status\n     b. Include error details and reason for failure\n     c. Provide guidance for resolution if applicable",
    "databaseEntities": [
      "jforum_users"
    ],
    "validationRules": [
      "User ID must be a valid positive integer",
      "User must exist in the system",
      "User's post count should preferably be greater than zero before decrementing"
    ],
    "dbSeedingOperations": [],
    "schema": {}
  },
  {
    "featureName": "IncrementUserPostCount",
    "description": "Increases the post count for a specific user.",
    "inputValues": [
      "userId-number-User"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect userId (mandatory, number) to identify the user whose post count will be incremented\n   - System will use the current database connection from the execution context\n\n2. Data Validation:\n   - Validate userId:\n     a. Check if userId is provided\n     b. Verify userId is a positive integer\n     c. If validation fails, generate appropriate error message\n\n3. Business Rule Processing:\n   - Check if user exists in the system:\n     a. Verify the user with the provided userId exists in the database\n     b. Confirm the user is not marked as deleted\n     c. If user does not exist or is deleted, abort the operation and return error\n\n4. Core Operation Execution:\n   - Update user record:\n     a. Retrieve the current post count for the user\n     b. Increment the post count by 1\n     c. Update the user record with the new post count\n     d. If update fails, handle database exception and provide rollback mechanism\n\n5. Response Generation:\n   - For successful operation:\n     a. Return confirmation that post count was incremented\n     b. Include the updated post count in the response\n   - For failed operation:\n     a. Return appropriate error message\n     b. Include error details for troubleshooting",
    "databaseEntities": [
      "jforum_users"
    ],
    "validationRules": [
      "User ID must be a positive integer",
      "User must exist in the system",
      "User must not be marked as deleted"
    ],
    "dbSeedingOperations": [],
    "schema": {}
  },
  {
    "featureName": "GetAllUsers",
    "description": "Retrieves a list of all users in the system.",
    "inputValues": [
      "startFrom-number-User",
      "count-number-User"
    ],
    "businessLogic": "1. Input Collection\n   - Collect the following inputs:\n     a. startFrom (number, optional): The starting index for pagination\n     b. count (number, optional): The maximum number of users to retrieve\n\n2. Data Validation\n   - Validate input parameters:\n     a. IF startFrom is provided:\n        i. Ensure startFrom is a non-negative integer\n        ii. IF startFrom is negative, set to 0\n     b. IF count is provided:\n        i. Ensure count is a non-negative integer\n        ii. IF count is negative, set to 0\n\n3. Business Rule Processing\n   - Check system state:\n     a. Verify the user database is accessible\n     b. Verify the requesting user has permission to view user list\n     c. IF system is in maintenance mode:\n        i. Check if requesting user has administrative privileges\n        ii. IF not, return appropriate error message\n\n4. Core Operation Execution\n   - Retrieve user records:\n     a. IF both startFrom and count are specified:\n        i. Retrieve limited set of users starting from the specified index\n        ii. Limit results to the specified count\n     b. ELSE:\n        i. Retrieve all users in the system\n     c. For each user record:\n        i. Extract basic user information (ID, username, email, registration date, etc.)\n        ii. Exclude sensitive information based on user permissions\n        iii. Format data for response\n     d. IF no users are found:\n        i. Return empty list\n\n5. Response Generation\n   - Prepare the response:\n     a. Format the list of users with the following information for each user:\n        i. User ID\n        ii. Username\n        iii. Email address (if viewable based on permissions)\n        iv. Registration date\n        v. Total posts count\n        vi. Karma points\n        vii. User status (active/deleted)\n     b. Include metadata in response:\n        i. Total number of users in the system\n        ii. Pagination information if applicable\n     c. Return the formatted user list",
    "databaseEntities": [
      "jforum_users",
      "jforum_user_groups"
    ],
    "validationRules": [
      "Start index must be a non-negative integer",
      "Count must be a non-negative integer",
      "User must have permission to view user list"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "User": {
        "type": "object",
        "properties": {
          "id": {
            "type": "number"
          },
          "username": {
            "type": "string"
          },
          "email": {
            "type": "string"
          },
          "registrationDate": {
            "type": "date"
          },
          "totalPosts": {
            "type": "number"
          },
          "karma": {
            "type": "object",
            "properties": {
              "karmaPoints": {
                "type": "number"
              }
            }
          },
          "deleted": {
            "type": "number"
          },
          "from": {
            "type": "string"
          },
          "website": {
            "type": "string"
          },
          "viewEmailEnabled": {
            "type": "boolean"
          }
        }
      }
    }
  },
  {
    "featureName": "GetPaginatedUsers",
    "description": "Retrieves a paginated list of users with specified start and count parameters.",
    "inputValues": [
      "startFrom-number-User",
      "count-number-User"
    ],
    "businessLogic": "1. Input Collection\n   - Collect the following inputs:\n     - startFrom (number): The starting index for pagination (mandatory)\n     - count (number): The maximum number of users to retrieve (mandatory)\n\n2. Data Validation\n   - Validate startFrom parameter:\n     - IF startFrom is negative THEN\n       - Return error message indicating that startFrom must be non-negative\n     - END IF\n   - Validate count parameter:\n     - IF count is negative THEN\n       - Return error message indicating that count must be non-negative\n     - END IF\n\n3. Business Rule Processing\n   - Check system state:\n     - IF database connection is not available THEN\n       - Return appropriate error message about system unavailability\n     - END IF\n   - Determine query approach:\n     - IF count is greater than 0 THEN\n       - Prepare to execute paginated query with limits\n     - ELSE\n       - Prepare to execute query to retrieve all users\n     - END IF\n\n4. Core Operation Execution\n   - Execute the user retrieval operation:\n     - Query the user database with pagination parameters\n     - For each user record retrieved:\n       - Extract user information (ID, username, email, registration date, post count, etc.)\n       - Create user object with extracted information\n       - Add user object to result collection\n     - IF any errors occur during retrieval THEN\n       - Log the error details\n       - Prepare appropriate error response\n     - END IF\n\n5. Response Generation\n   - Prepare the success response:\n     - Include the list of retrieved user objects\n     - Include pagination metadata:\n       - Total number of users in the system\n       - Current page information (startFrom and count)\n       - More results indicator (if applicable)\n   - Return the formatted response to the caller",
    "databaseEntities": [
      "jforum_users",
      "jforum_user_groups"
    ],
    "validationRules": [
      "Start index must be a non-negative number",
      "Count must be a non-negative number",
      "Database connection must be available"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "User": {
        "type": "object",
        "properties": {
          "id": {
            "type": "number",
            "description": "Unique identifier for the user"
          },
          "username": {
            "type": "string",
            "description": "User's display name"
          },
          "email": {
            "type": "string",
            "description": "User's email address"
          },
          "registrationDate": {
            "type": "date",
            "description": "Date when user registered"
          },
          "totalPosts": {
            "type": "number",
            "description": "Total number of posts by the user"
          },
          "karma": {
            "type": "object",
            "description": "User's karma information"
          },
          "deleted": {
            "type": "number",
            "description": "Indicates if the user is deleted"
          }
        }
      }
    }
  },
  {
    "featureName": "GetAllUsersWithKarma",
    "description": "Retrieves all users with their karma information from the system.",
    "inputValues": [
      "startFrom-number-User",
      "count-number-User"
    ],
    "businessLogic": "1. Input Collection\n   - Collect the following inputs:\n     - startFrom (number): Starting index for pagination (optional, defaults to 0)\n     - count (number): Maximum number of users to retrieve (optional, defaults to 0 which means all users)\n\n2. Data Validation\n   - Validate input parameters:\n     - IF startFrom is provided, THEN ensure it is a non-negative integer\n     - IF count is provided, THEN ensure it is a non-negative integer\n     - IF invalid parameters are detected, THEN prepare appropriate error message\n\n3. Business Rule Processing\n   - Check system state:\n     - Verify that the user database is accessible\n     - Verify that the karma system is enabled\n     - IF system is in maintenance mode, THEN abort operation and return appropriate message\n\n4. Core Operation Execution\n   - Retrieve users from the system:\n     - IF both startFrom and count parameters are provided and valid:\n       - Retrieve limited set of users starting from the specified index\n     - ELSE:\n       - Retrieve all users from the system\n   - For each retrieved user:\n     - Load basic user information (id, username, email, registration date, post count, etc.)\n     - Load associated karma information\n     - Combine user and karma data into a unified user object\n   - Organize retrieved users into a structured list\n   - IF no users are found, THEN prepare empty result list\n\n5. Response Generation\n   - Prepare response with the following information:\n     - List of user objects with their karma information\n     - Total count of users retrieved\n     - Pagination information if applicable\n     - IF an error occurred during processing, THEN include appropriate error details\n     - Return the complete response to the caller",
    "databaseEntities": [
      "jforum_users",
      "jforum_karma"
    ],
    "validationRules": [
      "Start index must be a non-negative integer",
      "Count must be a non-negative integer",
      "User database must be accessible",
      "Karma system must be enabled"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "User": {
        "id": "number",
        "username": "string",
        "email": "string",
        "registrationDate": "date",
        "totalPosts": "number",
        "deleted": "number",
        "from": "string",
        "webSite": "string",
        "viewEmailEnabled": "boolean",
        "karma": {
          "karmaPoints": "number"
        }
      }
    }
  },
  {
    "featureName": "GetPaginatedUsersWithKarma",
    "description": "Retrieves a paginated list of users with their karma information.",
    "inputValues": [
      "startFrom-number-User",
      "count-number-User"
    ],
    "businessLogic": "1. Input Collection\n   - Collect the following inputs:\n     - startFrom (number): The starting index for pagination (mandatory)\n     - count (number): The maximum number of users to retrieve (mandatory)\n     - System will use default values (0) if inputs are not provided\n\n2. Data Validation\n   - Validate pagination parameters:\n     - IF startFrom is provided, THEN ensure it is a non-negative integer\n       - IF startFrom is negative, THEN set error message \"Starting index cannot be negative\"\n     - IF count is provided, THEN ensure it is a non-negative integer\n       - IF count is negative, THEN set error message \"Count cannot be negative\"\n\n3. Business Rule Processing\n   - Check system state:\n     - Verify the user database is accessible\n       - IF database is not accessible, THEN generate appropriate error message\n     - Determine if the requesting user has permission to view user information\n       - IF user lacks permission, THEN return permission denied error\n\n4. Core Operation Execution\n   - Retrieve paginated user list:\n     - IF count is greater than 0, THEN:\n       - Retrieve users starting from the 'startFrom' index up to 'count' users\n     - ELSE:\n       - Retrieve all users without pagination\n     - For each retrieved user, collect basic information:\n       - User ID\n       - Username\n       - Email address\n       - Registration date\n       - Post count\n       - Location information\n       - Website URL\n       - Email visibility preference\n       - Account status (active/deleted)\n   - Enhance user data with karma information:\n     - For each user in the list:\n       - Retrieve and attach karma points information\n       - Calculate karma status based on points\n   - Sort the user list according to system default or specified criteria\n\n5. Response Generation\n   - Prepare success response:\n     - Create a structured list of users with their information\n     - Include pagination metadata:\n       - Total number of users in the system\n       - Current page information\n       - More pages indicator\n     - Format the response according to the system standards\n   - Handle error responses:\n     - IF any errors occurred during processing, THEN:\n       - Generate appropriate error message\n       - Include error code and description\n       - Provide guidance for resolving the issue",
    "databaseEntities": [
      "jforum_users",
      "jforum_karma"
    ],
    "validationRules": [
      "Starting index (startFrom) must be a non-negative integer",
      "Count must be a non-negative integer",
      "User must have permission to view user information"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "User": {
        "type": "object",
        "properties": {
          "id": {
            "type": "integer"
          },
          "username": {
            "type": "string"
          },
          "email": {
            "type": "string"
          },
          "registrationDate": {
            "type": "date"
          },
          "totalPosts": {
            "type": "integer"
          },
          "from": {
            "type": "string"
          },
          "website": {
            "type": "string"
          },
          "viewEmailEnabled": {
            "type": "boolean"
          },
          "deleted": {
            "type": "integer"
          },
          "karma": {
            "type": "object",
            "properties": {
              "karmaPoints": {
                "type": "integer"
              }
            }
          }
        }
      }
    }
  },
  {
    "featureName": "GetUsersByGroup",
    "description": "Retrieves users belonging to a specific group with pagination support.",
    "inputValues": [
      "groupId-number-Group",
      "startPosition-number-Pagination",
      "count-number-Pagination"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the following inputs:\n     a. groupId (mandatory): Numeric identifier of the group to retrieve users from\n     b. startPosition (mandatory): Numeric value indicating the starting position for pagination\n     c. count (mandatory): Numeric value indicating the maximum number of users to retrieve\n\n2. Data Validation:\n   - Validate groupId:\n     a. Ensure groupId is provided\n     b. Verify groupId is a positive integer\n     c. IF groupId is invalid or missing, THEN return error message \"Invalid group identifier\"\n   - Validate pagination parameters:\n     a. Ensure startPosition is a non-negative integer\n     b. Ensure count is a positive integer\n     c. IF pagination parameters are invalid, THEN return error message \"Invalid pagination parameters\"\n\n3. Business Rule Processing:\n   - Verify group existence:\n     a. Check if the specified group exists in the system\n     b. IF group does not exist, THEN return error message \"Group not found\"\n   - Verify user access permissions:\n     a. Check if the current user has permission to view users in this group\n     b. IF user lacks permission, THEN return error message \"Insufficient permissions to view group members\"\n\n4. Core Operation Execution:\n   - Retrieve total count of users in the group:\n     a. Count all users belonging to the specified group\n     b. Store this count for pagination metadata\n   - Retrieve paginated user list:\n     a. Query user records that belong to the specified group\n     b. Apply pagination using startPosition and count parameters\n     c. For each user record, extract relevant user information\n     d. IF no users are found, THEN return empty list with pagination metadata\n   - Process user data:\n     a. For each user, collect standard profile information\n     b. Format user data according to response requirements\n     c. Exclude sensitive information based on system privacy settings\n\n5. Response Generation:\n   - Prepare success response:\n     a. Include list of retrieved users with their information\n     b. Include pagination metadata:\n        i. Total number of users in the group\n        ii. Current page information\n        iii. Indication if more users are available\n     c. Include group information summary\n   - Handle potential errors:\n     a. Database connectivity issues: Return appropriate error message\n     b. Permission errors: Return access denied message\n     c. System errors: Return generic error with support information",
    "databaseEntities": [
      "jforum_users",
      "jforum_groups",
      "jforum_user_groups"
    ],
    "validationRules": [
      "Group ID must be a positive integer",
      "Start position must be a non-negative integer",
      "Count must be a positive integer",
      "Group must exist in the system",
      "User must have permission to view group members"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "User": {
        "type": "object",
        "properties": {
          "id": {
            "type": "number",
            "description": "Unique identifier for the user"
          },
          "username": {
            "type": "string",
            "description": "User's display name"
          },
          "email": {
            "type": "string",
            "description": "User's email address"
          },
          "registrationDate": {
            "type": "date",
            "description": "Date when user registered"
          },
          "totalPosts": {
            "type": "number",
            "description": "Total number of posts by the user"
          },
          "karma": {
            "type": "object",
            "description": "User's karma information"
          },
          "from": {
            "type": "string",
            "description": "User's location"
          },
          "website": {
            "type": "string",
            "description": "User's website URL"
          },
          "viewEmailEnabled": {
            "type": "boolean",
            "description": "Whether user's email is visible to others"
          },
          "deleted": {
            "type": "number",
            "description": "Indicates if user account is deleted"
          }
        }
      },
      "Group": {
        "type": "object",
        "properties": {
          "id": {
            "type": "number",
            "description": "Unique identifier for the group"
          },
          "name": {
            "type": "string",
            "description": "Name of the group"
          }
        }
      },
      "Pagination": {
        "type": "object",
        "properties": {
          "totalUsers": {
            "type": "number",
            "description": "Total number of users in the group"
          },
          "startPosition": {
            "type": "number",
            "description": "Starting position of current page"
          },
          "count": {
            "type": "number",
            "description": "Number of users per page"
          },
          "hasMore": {
            "type": "boolean",
            "description": "Indicates if more users are available"
          }
        }
      }
    }
  },
  {
    "featureName": "GetTotalUsersByGroup",
    "description": "Counts the total number of users in a specific group.",
    "inputValues": [
      "groupId-number-Group"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the required input parameter:\n     - groupId (number): The unique identifier of the group to count users for\n     - This field is mandatory and must be provided by the caller\n\n2. Data Validation:\n   - Validate the groupId input:\n     - Ensure groupId is not null\n     - Verify groupId is a positive integer\n     - IF groupId is invalid or missing THEN\n       - Generate appropriate error message\n       - Terminate processing and return error\n\n3. Business Rule Processing:\n   - Verify the group exists in the system:\n     - Check if the provided groupId corresponds to a valid group\n     - IF group does not exist THEN\n       - Generate a \"Group not found\" error message\n       - Terminate processing and return error\n   - Verify the user has permission to view group information:\n     - Check if the current user has sufficient privileges\n     - IF user lacks permission THEN\n       - Generate an \"Insufficient permissions\" error message\n       - Terminate processing and return error\n\n4. Core Operation Execution:\n   - Query the database to count users in the specified group:\n     - Prepare the query to count users associated with the groupId\n     - Execute the query to retrieve the total count\n     - Handle any potential errors during the counting process\n     - IF query execution fails THEN\n       - Log the error details\n       - Generate a system error message\n       - Terminate processing and return error\n\n5. Response Generation:\n   - Format the successful response:\n     - Include the total count of users in the group\n     - Include the groupId for reference\n     - Return the formatted response to the caller\n   - IF any errors occurred during processing:\n     - Include detailed error information\n     - Include suggestions for resolving the error if applicable",
    "databaseEntities": [
      "jforum_users",
      "jforum_groups",
      "jforum_user_groups"
    ],
    "validationRules": [
      "Group ID must be a positive integer",
      "Group must exist in the system",
      "User must have permission to view group information"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Group": {
        "type": "object",
        "properties": {
          "id": {
            "type": "number",
            "description": "Unique identifier for the group"
          },
          "name": {
            "type": "string",
            "description": "Name of the group"
          }
        },
        "required": [
          "id"
        ]
      }
    }
  },
  {
    "featureName": "CheckUsernameAvailability",
    "description": "Verifies if a username is already registered in the system.",
    "inputValues": [
      "username-string-User"
    ],
    "businessLogic": "1. Input Collection\n   - Collect the following input:\n     a. username (string, mandatory): The username to check for availability\n\n2. Data Validation\n   - Validate the username input:\n     a. Check if username is provided\n        IF username is empty or null THEN\n          Return error message indicating username is required\n     b. Check username format\n        IF username does not meet format requirements THEN\n          Return error message indicating invalid username format\n     c. Check username length\n        IF username length is less than minimum required length THEN\n          Return error message indicating username is too short\n        IF username length exceeds maximum allowed length THEN\n          Return error message indicating username is too long\n\n3. Business Rule Processing\n   - Verify system state for username check:\n     a. Check if the system is in maintenance mode\n        IF system is in maintenance mode THEN\n          Return appropriate error message\n     b. Check if username restrictions are in place\n        IF username contains restricted words or patterns THEN\n          Return error message indicating username contains prohibited content\n\n4. Core Operation Execution\n   - Perform username availability check:\n     a. Search for the username in the user database\n        IF username exists in the database THEN\n          Set availability status to false (username is taken)\n        ELSE\n          Set availability status to true (username is available)\n     b. Record the username check attempt in system logs\n        Store username, timestamp, and result of availability check\n\n5. Response Generation\n   - Generate appropriate response based on availability:\n     a. IF username is available THEN\n          Return success response with availability status as true\n     b. IF username is not available THEN\n          Return success response with availability status as false\n     c. Include any relevant suggestions or alternative usernames if configured\n     d. Include timestamp of when the check was performed",
    "databaseEntities": [
      "jforum_users"
    ],
    "validationRules": [
      "Username must not be empty",
      "Username must meet the system's format requirements",
      "Username must be within the allowed length limits",
      "Username must not contain restricted words or patterns"
    ],
    "dbSeedingOperations": [],
    "schema": {}
  },
  {
    "featureName": "SaveNewUserPassword",
    "description": "Updates a user's password using their email address.",
    "inputValues": [
      "password-string-User",
      "email-string-User"
    ],
    "businessLogic": "1. Input Collection\n   - Collect the following required inputs:\n     a. password (string): The new password for the user\n     b. email (string): The email address to identify the user\n   - Both fields are mandatory\n   - No default values are provided\n\n2. Data Validation\n   - Validate email input:\n     a. Check if email is not empty\n     b. Verify email follows a valid email format\n     c. IF email format is invalid THEN generate appropriate error message\n   - Validate password input:\n     a. Check if password is not empty\n     b. Verify password meets minimum length requirements\n     c. Verify password meets complexity requirements (if applicable)\n     d. IF password does not meet requirements THEN generate appropriate error message\n\n3. Business Rule Processing\n   - Verify user existence:\n     a. Check if a user with the provided email exists in the system\n     b. IF user does not exist THEN generate \"User not found\" error\n   - Verify account status:\n     a. Check if the user account is active\n     b. Check if the user account is not deleted\n     c. IF account is inactive or deleted THEN generate appropriate error message\n\n4. Core Operation Execution\n   - Process password update:\n     a. Generate secure password hash from the provided password\n     b. Update the user record with the new password hash\n     c. IF update operation fails THEN:\n        i. Log the failure details\n        ii. Rollback any changes\n        iii. Generate system error message\n     d. IF update operation succeeds THEN:\n        i. Record the password change timestamp\n        ii. Clear any existing password reset tokens or flags\n\n5. Response Generation\n   - For successful password update:\n     a. Generate success message indicating password was updated\n     b. Include information about when the change takes effect\n   - For failed password update:\n     a. Return specific error message based on the failure reason\n     b. Provide guidance on how to resolve the issue\n     c. Include support contact information if needed",
    "databaseEntities": [
      "jforum_users"
    ],
    "validationRules": [
      "Email must not be empty",
      "Email must be in a valid format",
      "Password must not be empty",
      "Password must meet minimum length requirements",
      "Password must meet complexity requirements",
      "User with the provided email must exist in the system",
      "User account must be active and not deleted"
    ],
    "dbSeedingOperations": [],
    "schema": {}
  },
  {
    "featureName": "WriteLostPasswordHash",
    "description": "Stores or updates a lost password hash for a user's email address.",
    "inputValues": [
      "email-string-User",
      "hash-string-User"
    ],
    "businessLogic": "1. Input Collection\n   1.1. Collect user email address (mandatory)\n      1.1.1. Email must be provided as a string\n      1.1.2. Email is used to identify the user account\n   1.2. Collect password hash (mandatory)\n      1.2.1. Hash must be provided as a string\n      1.2.2. Hash can be empty to clear the stored hash\n      1.2.3. Hash represents a temporary token for password reset\n\n2. Data Validation\n   2.1. Validate email format\n      2.1.1. Check if email follows standard email format\n      2.1.2. IF email format is invalid, THEN return error message\n   2.2. Validate email existence\n      2.2.1. Check if the provided email exists in the system\n      2.2.2. IF email does not exist, THEN return appropriate error message\n   2.3. Validate hash format (when not empty)\n      2.3.1. Check if hash meets required format and length\n      2.3.2. IF hash format is invalid, THEN return error message\n\n3. Business Rule Processing\n   3.1. Check system state\n      3.1.1. Verify the system allows password reset operations\n      3.1.2. IF system is in maintenance mode, THEN return appropriate message\n   3.2. Check user account status\n      3.2.1. Verify the user account is active\n      3.2.2. IF account is locked, disabled, or deleted, THEN return appropriate message\n   3.3. Check for rate limiting\n      3.3.1. Verify the user hasn't exceeded password reset attempts\n      3.3.2. IF rate limit exceeded, THEN return appropriate message\n\n4. Core Operation Execution\n   4.1. Update user record\n      4.1.1. Locate user record using the email address\n      4.1.2. Update the lost password hash field with the provided hash value\n      4.1.3. IF hash is empty, THEN clear the existing hash value\n      4.1.4. Record the timestamp of this operation\n   4.2. Handle operation result\n      4.2.1. IF update operation fails, THEN prepare error response\n      4.2.2. IF update operation succeeds, THEN prepare success response\n\n5. Response Generation\n   5.1. Generate success response\n      5.1.1. Indicate the hash was successfully stored or cleared\n      5.1.2. Include timestamp of the operation\n   5.2. Generate error response\n      5.2.1. Include specific error code and message\n      5.2.2. Provide guidance on next steps\n      5.2.3. Include support contact information if needed",
    "databaseEntities": [
      "jforum_users"
    ],
    "validationRules": [
      "Email must be in valid format",
      "Email must exist in the system",
      "Hash must meet security requirements when provided",
      "User account must be active"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "User": {
        "properties": {
          "email": {
            "type": "string",
            "format": "email",
            "description": "User's email address"
          },
          "hash": {
            "type": "string",
            "description": "Lost password hash for verification"
          }
        },
        "required": [
          "email"
        ]
      }
    }
  },
  {
    "featureName": "FindUsersByName",
    "description": "Searches for users by name with option for exact or partial matching.",
    "inputValues": [
      "searchName-string-User",
      "exactMatch-boolean-User"
    ],
    "businessLogic": "1. Input Collection\n   1.1. Collect the search name input from the user\n      1.1.1. The search name must be provided as a text string\n      1.1.2. The search name is mandatory\n   1.2. Collect the exact match preference\n      1.2.1. The exact match is a boolean flag (true/false)\n      1.2.2. If not specified, default to false (partial matching)\n\n2. Data Validation\n   2.1. Validate search name input\n      2.1.1. Check if search name is not empty\n      2.1.2. IF search name is empty THEN\n         2.1.2.1. Generate validation error message\n         2.1.2.2. Return error to user\n      2.1.3. Check if search name contains only valid characters\n      2.1.4. IF search name contains invalid characters THEN\n         2.1.4.1. Generate validation error message\n         2.1.4.2. Return error to user\n   2.2. Validate exact match parameter\n      2.2.1. Ensure exact match is a valid boolean value\n      2.2.2. IF exact match is invalid THEN\n         2.2.2.1. Use default value (false)\n\n3. Business Rule Processing\n   3.1. Prepare search criteria\n      3.1.1. IF exact match is true THEN\n         3.1.1.1. Set up criteria to match username exactly\n      3.1.2. ELSE\n         3.1.2.1. Set up criteria to match username partially (containing the search term)\n   3.2. Verify user has permission to search users\n      3.2.1. Check if current user has required permissions\n      3.2.2. IF user lacks permission THEN\n         3.2.2.1. Generate permission error message\n         3.2.2.2. Return error to user\n\n4. Core Operation Execution\n   4.1. Execute user search\n      4.1.1. Search for users matching the name criteria\n      4.1.2. Apply any system filters for deleted or inactive users\n      4.1.3. IF search fails due to system error THEN\n         4.1.3.1. Log the error details\n         4.1.3.2. Generate system error message\n         4.1.3.3. Return error to user\n   4.2. Process search results\n      4.2.1. Create a list to store matching users\n      4.2.2. FOR each matching user record\n         4.2.2.1. Extract user information (ID, username, email)\n         4.2.2.2. Check if user is deleted\n         4.2.2.3. Add user to results list\n      4.2.3. Sort results alphabetically by username\n\n5. Response Generation\n   5.1. Prepare success response\n      5.1.1. Include total count of matching users\n      5.1.2. Include list of matching users with their details\n      5.1.3. IF no users found THEN\n         5.1.3.1. Include appropriate message indicating no matches\n   5.2. Return response to user\n      5.2.1. Format response according to system standards\n      5.2.2. Include any pagination information if applicable",
    "databaseEntities": [
      "jforum_users"
    ],
    "validationRules": [
      "Search name must not be empty",
      "Search name must contain only valid characters",
      "Exact match parameter must be a valid boolean value",
      "User must have permission to search for users"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "User": {
        "id": "number",
        "username": "string",
        "email": "string",
        "deleted": "number"
      }
    }
  },
  {
    "featureName": "ValidateActivationKeyHash",
    "description": "Validates an activation key hash for a specific user ID.",
    "inputValues": [
      "userId-number-User",
      "hash-string-User"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the following required inputs:\n     a. userId (number): The unique identifier of the user\n     b. hash (string): The activation key hash to validate\n   - Both fields are mandatory for this operation\n\n2. Data Validation:\n   a. Validate User ID:\n      - Verify that userId is a positive integer\n      - Verify that userId is not null or empty\n      - IF userId is invalid THEN\n        - Generate appropriate error message\n        - Return validation failure\n   b. Validate Hash:\n      - Verify that hash is not null or empty\n      - Verify that hash meets the required format and length\n      - IF hash is invalid THEN\n        - Generate appropriate error message\n        - Return validation failure\n\n3. Business Rule Processing:\n   a. Verify User Existence:\n      - Check if the user with the provided userId exists in the system\n      - IF user does not exist THEN\n        - Generate user not found error\n        - Return validation failure\n   b. Verify Hash Association:\n      - Check if the provided hash is associated with the specified user\n      - IF hash is not associated with the user THEN\n        - Generate invalid association error\n        - Return validation failure\n\n4. Core Operation Execution:\n   a. Validate Activation Key Hash:\n      - Compare the provided hash with the stored hash for the user\n      - Check if the hash is valid and not expired\n      - IF hash matches and is valid THEN\n        - Mark validation as successful\n      - ELSE\n        - Mark validation as failed\n   b. Handle Results:\n      - Record the validation attempt in the system\n      - IF validation was successful THEN\n        - Prepare success response\n      - ELSE\n        - Prepare failure response\n\n5. Response Generation:\n   a. For Successful Validation:\n      - Generate success response indicating the hash is valid\n      - Include any additional information about next steps\n   b. For Failed Validation:\n      - Generate failure response with appropriate error message\n      - Include information about why validation failed\n      - Provide guidance on how to proceed",
    "databaseEntities": [
      "jforum_users"
    ],
    "validationRules": [
      "User ID must be a positive integer",
      "User ID must exist in the system",
      "Hash must not be empty",
      "Hash must be associated with the specified user",
      "Hash must be in valid format"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "User": {
        "type": "object",
        "properties": {
          "userId": {
            "type": "number",
            "description": "Unique identifier for the user"
          },
          "hash": {
            "type": "string",
            "description": "Activation key hash for user verification"
          }
        },
        "required": [
          "userId",
          "hash"
        ]
      }
    }
  },
  {
    "featureName": "WriteUserActive",
    "description": "Activates a user account by user ID.",
    "inputValues": [
      "userId-number-User"
    ],
    "businessLogic": "1. Input Collection\n   - Collect the following required input:\n     a. userId (number): The unique identifier of the user account to activate\n     b. System will not require any additional inputs for this operation\n\n2. Data Validation\n   - Validate the userId input:\n     a. Check if userId is provided\n        IF userId is missing or null THEN\n          Return error message: \"User ID is required\"\n     b. Verify userId is a positive integer\n        IF userId is not a positive integer THEN\n          Return error message: \"Invalid User ID format\"\n     c. Check if userId exists in the system\n        IF userId does not exist in the system THEN\n          Return error message: \"User not found\"\n\n3. Business Rule Processing\n   - Check user account status:\n     a. Verify if the user account is currently inactive\n        IF user account is already active THEN\n          Return message: \"User account is already active\"\n     b. Check if the user account is deleted\n        IF user account is marked as deleted THEN\n          Return error message: \"Cannot activate a deleted user account\"\n     c. Verify if the user has completed all required registration steps\n        IF required registration steps are incomplete THEN\n          Return error message: \"User must complete all registration requirements before activation\"\n\n4. Core Operation Execution\n   - Activate the user account:\n     a. Update the user's status to active in the system\n     b. Record the activation timestamp\n     c. Clear any pending activation requests or tokens\n     d. IF activation fails due to system error THEN\n          Log the error details\n          Return error message: \"System error occurred during activation\"\n\n5. Response Generation\n   - Generate success response:\n     a. Confirm the user account has been successfully activated\n     b. Include the user ID in the response\n     c. Include activation timestamp\n     d. Provide information about next steps for the user\n   - IF any errors occurred:\n     a. Return appropriate error message from previous steps\n     b. Include support contact information if applicable",
    "databaseEntities": [
      "jforum_users"
    ],
    "validationRules": [
      "User ID must be provided",
      "User ID must be a positive integer",
      "User ID must exist in the system",
      "User account must not be already active",
      "User account must not be deleted",
      "User must have completed all required registration steps"
    ],
    "dbSeedingOperations": [],
    "schema": {}
  },
  {
    "featureName": "HasUsernameChanged",
    "description": "Checks if a username has been changed for a specific user ID.",
    "inputValues": [
      "userId-number-User",
      "usernameToCheck-string-User"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect userId (number, mandatory) - The unique identifier of the user\n   - Collect usernameToCheck (string, mandatory) - The username to compare with the stored username\n\n2. Data Validation:\n   - Validate userId:\n      * Ensure userId is a positive integer\n      * Ensure userId is not null or empty\n      * IF validation fails, THEN return appropriate error message\n   - Validate usernameToCheck:\n      * Ensure usernameToCheck is not null or empty\n      * Ensure usernameToCheck follows username format rules\n      * IF validation fails, THEN return appropriate error message\n\n3. Business Rule Processing:\n   - Check if the user exists in the system:\n      * Verify the userId corresponds to an existing user record\n      * IF user does not exist, THEN return error indicating invalid user\n   - Prepare for username comparison:\n      * Determine if case sensitivity should be applied based on system settings\n      * Set up comparison parameters accordingly\n\n4. Core Operation Execution:\n   - Retrieve the current username from the database:\n      * Query the user record using the provided userId\n      * Extract the stored username value\n      * IF retrieval fails, THEN handle the error and return appropriate message\n   - Compare the stored username with the provided usernameToCheck:\n      * Apply case sensitivity rules as determined in step 3\n      * IF usernameToCheck is different from the stored username, THEN set status to true (changed)\n      * ELSE set status to false (not changed)\n\n5. Response Generation:\n   - Prepare the response with the comparison result:\n      * Include the boolean status indicating whether the username has changed\n      * IF status is true, THEN include additional information about the username change\n      * IF any errors occurred during processing, THEN include error details\n   - Return the final response to the caller",
    "databaseEntities": [
      "jforum_users"
    ],
    "validationRules": [
      "User ID must be a positive integer",
      "Username to check must not be empty",
      "User ID must correspond to an existing user in the system"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "User": {
        "type": "object",
        "properties": {
          "userId": {
            "type": "number",
            "description": "Unique identifier for the user"
          },
          "username": {
            "type": "string",
            "description": "User's login name"
          }
        },
        "required": [
          "userId",
          "username"
        ]
      }
    }
  },
  {
    "featureName": "LoadKarma",
    "description": "Loads karma status for a list of users.",
    "inputValues": [
      "users-object-UserList"
    ],
    "businessLogic": "1. Input Collection\n   - Collect list of User objects (users)\n     - Each User object must contain at minimum a user ID\n     - The list may contain one or more User objects\n     - The list must not be null\n\n2. Data Validation\n   - Validate the user list input\n     - IF the user list is null or empty THEN\n       - Return an empty result list\n       - Log appropriate warning message\n     - FOR EACH user in the list\n       - Verify user object has valid ID\n       - IF any user has invalid ID THEN\n         - Skip that user\n         - Log warning about skipped user\n\n3. Business Rule Processing\n   - Verify system access permissions\n     - Check if current operation is allowed to access karma data\n     - IF access is not permitted THEN\n       - Log access violation attempt\n       - Return empty result list\n   - Verify karma feature is enabled in system settings\n     - IF karma feature is disabled THEN\n       - Return original user list without karma data\n       - Log information message about disabled feature\n\n4. Core Operation Execution\n   - Initialize result list to store users with karma data\n   - FOR EACH valid user in the input list\n     - Retrieve user's total karma value from karma data store\n     - Update the user object with karma information\n     - Add the updated user to the result list\n     - IF karma retrieval fails for a user THEN\n       - Set default karma value (0)\n       - Log error about karma retrieval failure\n       - Continue processing remaining users\n\n5. Response Generation\n   - Return the list of users with karma data\n   - Include the following in each user object:\n     - Original user information\n     - Total karma points\n     - Karma rating status (positive/negative/neutral)\n   - IF any errors occurred during processing\n     - Include error information in response\n     - Provide partial results where available",
    "databaseEntities": [
      "jforum_users",
      "jforum_karma"
    ],
    "validationRules": [
      "User list must not be null",
      "Each user must have a valid ID",
      "Karma feature must be enabled in system settings",
      "Current operation must have permission to access karma data"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "UserList": {
        "type": "array",
        "items": {
          "type": "object",
          "properties": {
            "id": {
              "type": "integer",
              "description": "Unique identifier for the user"
            },
            "username": {
              "type": "string",
              "description": "User's display name"
            },
            "email": {
              "type": "string",
              "description": "User's email address"
            },
            "deleted": {
              "type": "integer",
              "description": "Flag indicating if user is deleted"
            },
            "karma": {
              "type": "object",
              "description": "User's karma information",
              "properties": {
                "totalPoints": {
                  "type": "integer",
                  "description": "Total karma points for the user"
                },
                "karmaStatus": {
                  "type": "string",
                  "description": "Status based on karma points (positive/negative/neutral)"
                }
              }
            }
          },
          "required": [
            "id"
          ]
        }
      }
    }
  },
  {
    "featureName": "SelectUserSessionById",
    "description": "Retrieves user session information by user ID.",
    "inputValues": [
      "userId-number-User",
      "sessionId-string-UserSession"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect userId (mandatory): A unique numeric identifier for the user\n   - Collect sessionId (mandatory): A unique string identifier for the session\n   - System will use current connection for database operations\n\n2. Data Validation:\n   - Validate userId:\n     a. Ensure userId is provided\n     b. Verify userId is a positive integer\n     c. Return error if validation fails\n   - Validate sessionId:\n     a. Ensure sessionId is provided\n     b. Verify sessionId is not empty\n     c. Return error if validation fails\n\n3. Business Rule Processing:\n   - Check system access permissions:\n     a. Verify the requesting entity has permission to access session data\n     b. If permission check fails, return appropriate error message\n   - Verify system state:\n     a. Ensure the system is in a valid state to process session queries\n     b. If system is in maintenance mode, return appropriate notification\n\n4. Core Operation Execution:\n   - Prepare session query:\n     a. Create query parameters using the provided userId\n     b. Set up data retrieval mechanism\n   - Execute session lookup:\n     a. Search for session record matching the userId\n     b. If no record is found, return null indicating no active session\n     c. If record is found, retrieve session details\n   - Process session data:\n     a. Extract session time information\n     b. Extract session start timestamp\n     c. Populate session object with retrieved data\n\n5. Response Generation:\n   - For successful retrieval:\n     a. Return populated session object with all session details\n     b. Include session time and start time in the response\n   - For unsuccessful retrieval:\n     a. Return null if no session exists for the user\n     b. Include appropriate status information\n   - Handle any unexpected conditions:\n     a. Generate appropriate error messages for system failures\n     b. Provide guidance for resolving any issues encountered",
    "databaseEntities": [
      "jforum_sessions",
      "jforum_users"
    ],
    "validationRules": [
      "User ID must be a positive integer",
      "Session ID must be a non-empty string",
      "User must exist in the system",
      "Session record must contain valid timestamp data"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "UserSession": {
        "type": "object",
        "properties": {
          "sessionId": {
            "type": "string",
            "description": "Unique identifier for the user session"
          },
          "userId": {
            "type": "integer",
            "description": "User identifier associated with this session"
          },
          "startTime": {
            "type": "object",
            "description": "Timestamp when the session started"
          },
          "sessionTime": {
            "type": "integer",
            "description": "Duration of the session in milliseconds"
          }
        },
        "required": [
          "sessionId",
          "userId",
          "startTime"
        ]
      }
    }
  },
  {
    "featureName": "ExecuteAddRole",
    "description": "Executes role addition for users or groups with associated role values.",
    "inputValues": [
      "id-number-Entity",
      "role-object-Role",
      "roleValues-object-RoleValueCollection",
      "supportAutoGeneratedKeys-boolean-System",
      "sql-string-System",
      "autoKeysQuery-string-System"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the following inputs:\n     a. id (number, mandatory): The identifier for the user or group to assign the role to\n     b. role (object, mandatory): The role to be assigned\n     c. roleValues (object, optional): Collection of values associated with the role\n     d. supportAutoGeneratedKeys (boolean, mandatory): Flag indicating if auto-generated keys are supported\n     e. sql (string, mandatory): SQL statement for role insertion\n     f. autoKeysQuery (string, mandatory): Query to retrieve generated keys if not supported automatically\n\n2. Data Validation:\n   - Validate the id:\n     a. IF id is null or less than 1 THEN\n        i. Generate error message: \"Invalid entity ID provided\"\n     b. ENDIF\n   - Validate the role object:\n     a. IF role is null THEN\n        i. Generate error message: \"Role object cannot be null\"\n     b. ENDIF\n     c. IF role.name is null or empty THEN\n        i. Generate error message: \"Role name cannot be empty\"\n     d. ENDIF\n   - Validate SQL statements:\n     a. IF sql is null or empty THEN\n        i. Generate error message: \"SQL statement for role insertion cannot be empty\"\n     b. ENDIF\n     c. IF supportAutoGeneratedKeys is false AND autoKeysQuery is null or empty THEN\n        i. Generate error message: \"Auto keys query must be provided when auto-generated keys are not supported\"\n     d. ENDIF\n\n3. Business Rule Processing:\n   - Verify database connection:\n     a. IF database connection is not available THEN\n        i. Generate error message: \"Database connection is not available\"\n        ii. Abort operation\n     b. ENDIF\n   - Check for role name uniqueness for the entity:\n     a. IF role with same name already exists for this entity THEN\n        i. Determine if this is an update or duplicate based on business rules\n        ii. IF duplicate is not allowed THEN\n           1. Generate error message: \"Role already exists for this entity\"\n           2. Abort operation\n        iii. ENDIF\n     b. ENDIF\n\n4. Core Operation Execution:\n   - Prepare database statement:\n     a. IF supportAutoGeneratedKeys is true THEN\n        i. Create statement with RETURN_GENERATED_KEYS flag\n     b. ELSE\n        i. Create regular statement\n     c. ENDIF\n   - Execute role insertion:\n     a. Set parameters in prepared statement:\n        i. Set entity ID parameter\n        ii. Set role name parameter\n     b. Execute the statement\n     c. IF execution fails THEN\n        i. Generate error message: \"Failed to insert role record\"\n        ii. Abort operation and rollback if needed\n     d. ENDIF\n   - Process role values if provided:\n     a. IF roleValues is not null THEN\n        i. Retrieve the generated role ID:\n           1. IF supportAutoGeneratedKeys is true THEN\n              a. Get ID from generated keys\n           2. ELSE\n              a. Execute autoKeysQuery to retrieve the ID\n           3. ENDIF\n        ii. IF role ID could not be obtained THEN\n           1. Generate error message: \"Could not obtain the latest role ID\"\n           2. Abort operation and rollback if needed\n        iii. ENDIF\n        iv. FOR EACH value in roleValues:\n           1. Insert role value record linking it to the role ID\n           2. IF any insertion fails THEN\n              a. Generate error message: \"Failed to insert role value\"\n              b. Abort operation and rollback if needed\n           3. ENDIF\n        v. ENDFOR\n     b. ENDIF\n   - Ensure all resources are properly closed\n\n5. Response Generation:\n   - On successful completion:\n     a. Generate success response with:\n        i. Status indicator showing success\n        ii. Role ID that was created or updated\n        iii. Summary of role values added (if any)\n   - On failure:\n     a. Generate error response with:\n        i. Status indicator showing failure\n        ii. Detailed error message\n        iii. Error code if applicable\n        iv. Suggestions for resolution if possible",
    "databaseEntities": [
      "jforum_users",
      "jforum_groups",
      "jforum_user_groups"
    ],
    "validationRules": [
      "Entity ID must be a positive integer",
      "Role name must not be empty",
      "SQL statement must be provided",
      "Auto keys query must be provided when auto-generated keys are not supported",
      "Database connection must be available",
      "Role values must be valid if provided"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Role": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "description": "The name of the role"
          },
          "values": {
            "type": "array",
            "items": {
              "$ref": "#/RoleValue"
            },
            "description": "Collection of values associated with this role"
          }
        },
        "required": [
          "name"
        ]
      },
      "RoleValue": {
        "type": "object",
        "properties": {
          "value": {
            "type": "string",
            "description": "The value associated with a role"
          }
        },
        "required": [
          "value"
        ]
      },
      "RoleValueCollection": {
        "type": "array",
        "items": {
          "$ref": "#/RoleValue"
        },
        "description": "Collection of role values"
      }
    }
  },
  {
    "featureName": "GroupIdAsString",
    "description": "Converts an array of group IDs into a comma-separated string representation.",
    "inputValues": [
      "ids-object-IntArray"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the array of group IDs (ids) of type integer array\n   - This array contains the IDs of groups that need to be converted to a string\n   - All IDs are required; empty array is allowed\n\n2. Data Validation:\n   - Validate that the input is a valid array\n   - IF input array is null THEN\n     - Return an empty string or handle the null case appropriately\n   - Validate that all elements in the array are valid integer IDs\n   - IF any element is invalid THEN\n     - Skip the invalid element or handle the error appropriately\n\n3. Business Rule Processing:\n   - Check if the array is empty\n   - IF array is empty THEN\n     - Return an empty string\n   - Determine the format for the output string (comma-separated values without spaces)\n\n4. Core Operation Execution:\n   - Initialize an empty string buffer to store the result\n   - Process all elements except the last one:\n     - FOR each ID from index 0 to length-2:\n       - Append the current ID to the string buffer\n       - Append a comma separator\n   - Handle the last element separately to avoid trailing comma:\n     - IF array has at least one element THEN\n       - Append the last element (at index length-1) to the string buffer\n\n5. Response Generation:\n   - Return the final string containing comma-separated IDs\n   - The format will be \"id1,id2,id3,...,idN\" without any trailing comma\n   - IF the input array was empty THEN\n     - Return an empty string",
    "databaseEntities": [
      "jforum_groups",
      "jforum_user_groups"
    ],
    "validationRules": [
      "Input must be a valid array of integers",
      "Empty array is allowed and will result in an empty string",
      "Null input should be handled appropriately"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "IntArray": {
        "type": "array",
        "items": {
          "type": "integer"
        },
        "description": "An array of integer group IDs"
      }
    }
  },
  {
    "featureName": "SelectAllByTopicByLimit",
    "description": "Retrieves paginated posts from a specific topic with limit and offset parameters.",
    "inputValues": [
      "topicId-number-Topic",
      "start-number-Pagination",
      "count-number-Pagination"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the following required inputs:\n     1.1. topicId (number): Unique identifier of the topic from which to retrieve posts\n     1.2. start (number): Starting position for pagination (offset)\n     1.3. count (number): Maximum number of posts to retrieve (limit)\n\n2. Data Validation:\n   2.1. Validate topicId:\n      - Ensure topicId is provided\n      - Verify topicId is a positive integer\n      - Check if topicId exists in the system\n      - IF topicId is invalid or not found, THEN return appropriate error message\n   \n   2.2. Validate pagination parameters:\n      - Ensure start is a non-negative integer\n      - Ensure count is a positive integer\n      - IF start is negative, THEN set start to 0\n      - IF count is less than 1, THEN set count to a default value (e.g., 10)\n\n3. Business Rule Processing:\n   3.1. Check cache availability:\n      - Check if posts for the requested topic are available in cache\n      - IF posts are in cache, THEN retrieve from cache\n      - IF posts are not in cache, THEN prepare for database retrieval\n   \n   3.2. Check cache size constraints:\n      - Verify if adding a new topic to cache would exceed maximum cache size\n      - IF cache is full, THEN prepare to remove oldest entries\n\n4. Core Operation Execution:\n   4.1. Retrieve posts (when not in cache):\n      - Fetch all posts belonging to the specified topic from the database\n      - Process each post to prepare it for display\n      - Store the processed posts in the cache for future requests\n      - Manage cache size by removing oldest entries if necessary\n   \n   4.2. Apply pagination:\n      - Calculate the end index based on start and count parameters\n      - IF end index exceeds collection size, THEN adjust to collection size\n      - Extract the subset of posts based on start and end indices\n   \n   4.3. Handle special cases:\n      - IF no posts are found for the topic, THEN return empty collection\n      - Ensure thread safety when updating the cache\n\n5. Response Generation:\n   5.1. Prepare success response:\n      - Return the paginated list of posts\n      - Ensure posts are properly ordered (typically chronologically)\n      - Include all necessary post details (content, author, timestamp, etc.)\n   \n   5.2. Handle error scenarios:\n      - IF any errors occurred during processing, THEN include error details in response\n      - Provide appropriate error messages for different failure scenarios",
    "databaseEntities": [
      "jforum_topics",
      "jforum_posts",
      "jforum_posts_text",
      "jforum_users"
    ],
    "validationRules": [
      "Topic ID must be a positive integer",
      "Topic must exist in the system",
      "Start position (offset) must be a non-negative integer",
      "Count (limit) must be a positive integer",
      "User must have permission to view the requested topic",
      "Topic must be active and not deleted"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Post": {
        "type": "object",
        "properties": {
          "id": {
            "type": "number",
            "description": "Unique identifier for the post"
          },
          "content": {
            "type": "string",
            "description": "Text content of the post"
          },
          "authorId": {
            "type": "number",
            "description": "User ID of the post author"
          },
          "authorName": {
            "type": "string",
            "description": "Username of the post author"
          },
          "postDate": {
            "type": "date",
            "description": "Date and time when the post was created"
          },
          "editDate": {
            "type": "date",
            "description": "Date and time when the post was last edited"
          },
          "topicId": {
            "type": "number",
            "description": "ID of the topic this post belongs to"
          }
        }
      }
    }
  },
  {
    "featureName": "SelectByUserByLimit",
    "description": "Retrieves paginated posts made by a specific user with limit and offset parameters.",
    "inputValues": [
      "userId-number-User",
      "startFrom-number-Pagination",
      "count-number-Pagination"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect userId (mandatory): Unique identifier of the user whose posts are being retrieved\n   - Collect startFrom (mandatory): Starting position for pagination (zero-based index)\n   - Collect count (mandatory): Maximum number of posts to retrieve\n\n2. Data Validation:\n   - Validate userId:\n     a. Verify userId is not null\n     b. Verify userId is a positive integer\n     c. IF userId is invalid THEN return error message \"Invalid user identifier provided\"\n   - Validate pagination parameters:\n     a. Verify startFrom is not null\n     b. Verify startFrom is a non-negative integer\n     c. Verify count is not null\n     d. Verify count is a positive integer\n     e. IF startFrom is negative THEN return error message \"Starting position cannot be negative\"\n     f. IF count is less than or equal to zero THEN return error message \"Count must be greater than zero\"\n\n3. Business Rule Processing:\n   - Verify user existence:\n     a. Check if user with provided userId exists in the system\n     b. IF user does not exist THEN return error message \"User not found\"\n   - Verify user access permissions:\n     a. Check if the requesting user has permission to view posts by the specified user\n     b. IF permission check fails THEN return error message \"Insufficient permissions to view these posts\"\n\n4. Core Operation Execution:\n   - Prepare query parameters:\n     a. Set userId parameter to filter posts by specific user\n     b. Set startFrom parameter to determine starting position\n     c. Set count parameter to limit number of results\n   - Execute post retrieval operation:\n     a. Retrieve posts made by the specified user\n     b. Apply pagination using startFrom and count parameters\n     c. Order posts by creation date (newest first)\n     d. Include necessary post metadata (title, creation date, forum information)\n   - Process retrieved posts:\n     a. Format post data for presentation\n     b. Calculate total post count for pagination information\n     c. IF no posts found THEN set empty result list but continue execution\n\n5. Response Generation:\n   - Prepare success response:\n     a. Include list of retrieved posts with their details\n     b. Include pagination metadata (current page, total pages, total posts)\n     c. Include user information summary\n   - Handle potential errors:\n     a. IF database error occurs during retrieval THEN return error message \"Unable to retrieve posts at this time\"\n     b. Include appropriate status code with response",
    "databaseEntities": [
      "jforum_users",
      "jforum_posts",
      "jforum_posts_text",
      "jforum_topics",
      "jforum_forums"
    ],
    "validationRules": [
      "User ID must be a positive integer",
      "Starting position must be a non-negative integer",
      "Count must be a positive integer",
      "User must exist in the system",
      "Requesting user must have permission to view the specified user's posts"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Post": {
        "type": "object",
        "properties": {
          "id": {
            "type": "number"
          },
          "subject": {
            "type": "string"
          },
          "text": {
            "type": "string"
          },
          "creationDate": {
            "type": "date"
          },
          "userId": {
            "type": "number"
          },
          "topicId": {
            "type": "number"
          },
          "forumId": {
            "type": "number"
          }
        }
      },
      "Pagination": {
        "type": "object",
        "properties": {
          "currentPage": {
            "type": "number"
          },
          "totalPages": {
            "type": "number"
          },
          "totalPosts": {
            "type": "number"
          }
        }
      }
    }
  },
  {
    "featureName": "CreatePostDAO",
    "description": "Creates and returns a HSQLDB-specific implementation of the Post Data Access Object.",
    "inputValues": [],
    "businessLogic": "1. Input Collection:\n   - No external inputs required\n   - System will use internal configuration and class definitions\n\n2. Data Validation:\n   - Verify that the HsqldbPostDAO implementation exists in the system\n   - Ensure the HsqldbPostDAO implements all required PostDAO interface methods\n   - Validate that the static postDao instance has been properly initialized\n\n3. Business Rule Processing:\n   - Check if a custom PostDAO implementation should be used based on system configuration\n   - Verify that the database connection for HSQLDB is properly configured\n   - Ensure the PostDAO implementation is compatible with the current database schema\n\n4. Core Operation Execution:\n   - Return the existing static instance of HsqldbPostDAO\n   - IF the static instance is null or invalid:\n     a. Create a new instance of HsqldbPostDAO\n     b. Assign it to the static postDao variable\n     c. Return the newly created instance\n   - ELSE:\n     a. Return the existing static instance\n\n5. Response Generation:\n   - Return the PostDAO implementation object\n   - IF any errors occurred during retrieval or creation:\n     a. Generate appropriate error information\n     b. Log the error details\n     c. Return null or throw an exception based on system error handling policy",
    "databaseEntities": [
      "jforum_posts",
      "jforum_posts_text"
    ],
    "validationRules": [
      "HsqldbPostDAO must implement all methods defined in the PostDAO interface",
      "Database connection must be properly configured for HSQLDB",
      "PostDAO implementation must be compatible with the current database schema"
    ],
    "dbSeedingOperations": [],
    "schema": {}
  },
  {
    "featureName": "CreateTopicDAO",
    "description": "Creates and returns a database-specific implementation of the Topic Data Access Object.",
    "inputValues": [
      "databaseType-string-Database"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect databaseType (string, mandatory) - The type of database for which to create the DAO\n   - No optional fields\n   - No default values\n\n2. Data Validation:\n   - Validate databaseType:\n     a. Check if databaseType is not empty\n        IF databaseType is empty THEN\n          Return error message \"Database type must be specified\"\n     b. Check if databaseType is supported\n        IF databaseType is not in supported database types THEN\n          Return error message \"Unsupported database type\"\n\n3. Business Rule Processing:\n   - Check if DAO implementation exists for the specified database type\n     a. Verify that a TopicDAO implementation exists for the specified database type\n        IF implementation does not exist THEN\n          Return error message \"No TopicDAO implementation available for the specified database type\"\n     b. Verify that the implementation is properly configured\n        IF implementation is not properly configured THEN\n          Return error message \"TopicDAO implementation is not properly configured\"\n\n4. Core Operation Execution:\n   - Create the appropriate TopicDAO instance\n     a. Determine the correct implementation class based on databaseType\n     b. Instantiate the TopicDAO implementation\n        IF instantiation fails THEN\n          Return error message \"Failed to create TopicDAO instance\"\n     c. Initialize the TopicDAO with necessary dependencies\n        IF initialization fails THEN\n          Return error message \"Failed to initialize TopicDAO instance\"\n\n5. Response Generation:\n   - Return the created TopicDAO instance\n     a. Ensure the instance is properly initialized and ready for use\n     b. Include any configuration information that might be relevant\n     c. In case of errors, provide detailed error information including:\n        - Error type\n        - Error message\n        - Possible resolution steps",
    "databaseEntities": [
      "jforum_topics",
      "jforum_forums",
      "jforum_posts",
      "jforum_users"
    ],
    "validationRules": [
      "Database type must be supported by the system",
      "TopicDAO implementation must exist for the specified database type",
      "TopicDAO implementation must be properly configured"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Database": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "description": "The type of database (e.g., HSQLDB, MySQL, PostgreSQL)"
          },
          "configuration": {
            "type": "object",
            "description": "Database-specific configuration parameters"
          }
        },
        "required": [
          "type"
        ]
      }
    }
  },
  {
    "featureName": "CreateUserDAO",
    "description": "Creates and returns a database-specific implementation of the User Data Access Object for data operations.",
    "inputValues": [
      "databaseType-string-Database"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect database type information (mandatory)\n   - System will use existing configuration settings (system-generated)\n\n2. Data Validation:\n   - Validate database type parameter:\n      * Check if database type is not empty\n      * Verify database type is supported by the system\n      * IF database type is not supported THEN prepare error message\n   - Validate system configuration:\n      * Verify database connection parameters are available\n      * Check if required database drivers are registered\n      * IF configuration is invalid THEN prepare system configuration error\n\n3. Business Rule Processing:\n   - Determine appropriate User DAO implementation:\n      * IF database type matches current system database type THEN use cached instance\n      * IF database type is different THEN prepare to create new instance\n   - Verify DAO implementation availability:\n      * Check if implementation class for specified database exists\n      * IF implementation not found THEN fall back to generic implementation\n      * Verify implementation supports all required operations\n\n4. Core Operation Execution:\n   - Create User DAO instance:\n      * IF cached instance exists and is valid THEN retrieve cached instance\n      * IF new instance needed THEN instantiate appropriate database-specific implementation\n      * Initialize DAO with necessary dependencies\n      * Register instance in system registry if caching is enabled\n   - Configure created DAO:\n      * Apply any database-specific settings\n      * Set up connection parameters\n      * Initialize prepared statement templates if needed\n\n5. Response Generation:\n   - Return User DAO instance:\n      * Include reference to created DAO object\n      * Include information about database type used\n   - Error response (if applicable):\n      * Include specific error details if creation failed\n      * Provide guidance on resolving configuration issues\n      * Log detailed error information for system administrators",
    "databaseEntities": [
      "jforum_users",
      "jforum_user_groups"
    ],
    "validationRules": [
      "Database type must be supported by the system",
      "Database connection parameters must be valid",
      "User DAO implementation must support all required user operations",
      "System must have appropriate access rights to user data tables"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "UserDAO": {
        "type": "object",
        "properties": {
          "databaseType": {
            "type": "string",
            "description": "The type of database for which the DAO is created"
          },
          "implementation": {
            "type": "string",
            "description": "The specific implementation class used for the DAO"
          }
        }
      }
    }
  },
  {
    "featureName": "SelectAllUsersByGroup",
    "description": "Retrieves a paginated list of users belonging to a specific group.",
    "inputValues": [
      "groupId-number-Group",
      "startPosition-number-Pagination",
      "count-number-Pagination"
    ],
    "businessLogic": "1. Input Collection:\n   1.1. Collect the following required inputs:\n       - groupId (number): The unique identifier of the group to filter users by\n       - startPosition (number): The starting position for pagination\n       - count (number): The maximum number of records to return\n\n2. Data Validation:\n   2.1. Validate groupId:\n       - IF groupId is null or not a positive integer THEN\n           - Return error: \"Group ID must be a valid positive integer\"\n   2.2. Validate pagination parameters:\n       - IF startPosition is negative THEN\n           - Return error: \"Start position must be a non-negative integer\"\n       - IF count is not a positive integer THEN\n           - Return error: \"Count must be a positive integer\"\n\n3. Business Rule Processing:\n   3.1. Check if the specified group exists:\n       - Verify that a group with the provided groupId exists in the system\n       - IF group does not exist THEN\n           - Return error: \"The specified group does not exist\"\n   3.2. Check user access permissions:\n       - Verify if the current user has permission to view users in this group\n       - IF user lacks permission THEN\n           - Return error: \"Insufficient permissions to view users in this group\"\n\n4. Core Operation Execution:\n   4.1. Retrieve user records:\n       - Find all users associated with the specified group\n       - Apply pagination using startPosition and count parameters\n       - Sort users according to the system's default sorting criteria (typically by username or registration date)\n   4.2. Process user data:\n       - For each user record retrieved:\n           - Extract only the necessary user information for display\n           - Filter out any sensitive information based on viewing permissions\n       - Count the total number of users in the group (for pagination information)\n\n5. Response Generation:\n   5.1. Prepare success response:\n       - Create a collection of user records with relevant information\n       - Include pagination metadata:\n           - Total number of users in the group\n           - Current page information\n           - Whether more records exist\n   5.2. Handle empty results:\n       - IF no users found in the specified group THEN\n           - Return an empty collection with appropriate metadata\n       - ELSE\n           - Return the collection of user records with pagination metadata",
    "databaseEntities": [
      "jforum_users",
      "jforum_groups",
      "jforum_user_groups"
    ],
    "validationRules": [
      "Group ID must be a valid positive integer",
      "Start position must be a non-negative integer",
      "Count must be a positive integer",
      "The specified group must exist in the system",
      "User must have permission to view users in the specified group"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "User": {
        "type": "object",
        "properties": {
          "id": {
            "type": "number",
            "description": "Unique identifier for the user"
          },
          "username": {
            "type": "string",
            "description": "User's login name"
          },
          "registrationDate": {
            "type": "date",
            "description": "Date when user registered"
          },
          "email": {
            "type": "string",
            "description": "User's email address"
          },
          "active": {
            "type": "boolean",
            "description": "Whether the user account is active"
          }
        }
      },
      "Group": {
        "type": "object",
        "properties": {
          "id": {
            "type": "number",
            "description": "Unique identifier for the group"
          },
          "name": {
            "type": "string",
            "description": "Name of the group"
          },
          "description": {
            "type": "string",
            "description": "Description of the group"
          }
        }
      },
      "PaginationResult": {
        "type": "object",
        "properties": {
          "users": {
            "type": "array",
            "items": {
              "$ref": "#/User"
            },
            "description": "List of users belonging to the group"
          },
          "totalUsers": {
            "type": "number",
            "description": "Total number of users in the group"
          },
          "startPosition": {
            "type": "number",
            "description": "Starting position of the current page"
          },
          "count": {
            "type": "number",
            "description": "Number of users in the current page"
          },
          "hasMore": {
            "type": "boolean",
            "description": "Whether more users exist beyond the current page"
          }
        }
      }
    }
  },
  {
    "featureName": "GetGroupSecurityDAO",
    "description": "Provides access to MySQL 3.23 specific implementation of group security data access operations.",
    "inputValues": [
      "databaseType-string-Database"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect database type information (string)\n   - System will determine if the database is MySQL 3.23\n   - No user input is required as this is a system-level operation\n\n2. Data Validation:\n   - Validate database type information\n     a. Check if database type is properly specified\n     b. Verify that database type is supported by the system\n     c. IF database type is not specified or not supported, THEN return appropriate error message\n\n3. Business Rule Processing:\n   - Verify system configuration for database access\n     a. Check if database connection parameters are properly configured\n     b. Verify that the system has necessary permissions to access the database\n     c. IF any configuration is missing or invalid, THEN log error and return appropriate message\n   - Determine appropriate Group Security DAO implementation\n     a. IF database type is MySQL 3.23, THEN select MySQL323GroupSecurityDAO implementation\n     b. ELSE use standard implementation based on database type\n\n4. Core Operation Execution:\n   - Initialize the appropriate Group Security DAO implementation\n     a. Create an instance of the DAO if it doesn't exist\n     b. Ensure the DAO is properly configured for database access\n   - Prepare the DAO for use\n     a. Set any required configuration parameters\n     b. Initialize any required resources\n   - Return the initialized DAO instance\n     a. Ensure the instance is ready for use\n     b. Verify that all required methods are available\n\n5. Response Generation:\n   - Return the Group Security DAO instance\n     a. Include reference to the appropriate implementation\n     b. Ensure the instance is properly initialized\n   - IF any errors occurred during the process:\n     a. Generate appropriate error message\n     b. Include details about the nature of the error\n     c. Provide guidance for resolving the issue",
    "databaseEntities": [
      "jforum_groups",
      "jforum_user_groups"
    ],
    "validationRules": [
      "Database type must be supported by the system",
      "Database connection parameters must be properly configured",
      "System must have necessary permissions to access the database"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "GroupSecurityDAO": {
        "type": "object",
        "properties": {
          "implementation": {
            "type": "string",
            "description": "The specific implementation of the GroupSecurityDAO"
          },
          "databaseType": {
            "type": "string",
            "description": "The type of database being used"
          }
        }
      }
    }
  },
  {
    "featureName": "ReadPostTextFromResultSet",
    "description": "Retrieves post text content from database result set using specialized blob handling techniques.",
    "inputValues": [
      "resultSet-object-ResultSet"
    ],
    "businessLogic": "1. Input Collection:\n   1.1. Receive database result set object containing post data\n       1.1.1. Result set must contain a column named 'post_text'\n       1.1.2. The column must contain text content stored in binary format\n\n2. Data Validation:\n   2.1. Validate result set parameter\n       2.1.1. Check if result set is not null\n       2.1.2. Verify result set is open and valid\n       2.1.3. IF result set is invalid or closed THEN\n             - Generate appropriate error message\n             - Return empty string or throw exception based on system configuration\n   2.2. Validate column existence\n       2.2.1. Check if 'post_text' column exists in the result set\n       2.2.2. IF column does not exist THEN\n             - Generate appropriate error message\n             - Return empty string or throw exception based on system configuration\n\n3. Business Rule Processing:\n   3.1. Determine text encoding format\n       3.1.1. Identify the binary storage format (UTF-16 in this case)\n       3.1.2. Select appropriate reading method based on storage format\n   3.2. Check for content size limitations\n       3.2.1. IF content exceeds system-defined size limits THEN\n             - Log warning about oversized content\n             - Proceed with retrieval but may need truncation based on system settings\n\n4. Core Operation Execution:\n   4.1. Access binary data stream\n       4.1.1. Locate the binary data for the 'post_text' column in the result set\n       4.1.2. Open binary stream to the data\n   4.2. Process binary data\n       4.2.1. Read binary data using appropriate character encoding\n       4.2.2. Convert binary data to string format\n       4.2.3. Handle any special characters or formatting requirements\n   4.3. Clean up resources\n       4.3.1. Close any opened streams\n       4.3.2. Release any temporary resources used during conversion\n\n5. Response Generation:\n   5.1. Return processed text content\n       5.1.1. Return the extracted and converted text as a string\n       5.1.2. IF extraction failed THEN\n             - Return empty string or null based on system configuration\n             - Ensure error is logged for troubleshooting",
    "databaseEntities": [
      "jforum_posts",
      "jforum_posts_text"
    ],
    "validationRules": [
      "Result set must not be null",
      "Result set must be open and valid",
      "Result set must contain a 'post_text' column",
      "Binary data must be properly formatted for conversion"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "ResultSet": {
        "type": "object",
        "description": "Database result set containing query results",
        "properties": {
          "post_text": {
            "type": "binary",
            "description": "Binary data containing post text content"
          }
        },
        "required": [
          "post_text"
        ]
      }
    }
  },
  {
    "featureName": "GetPostTextFromResultSet",
    "description": "Retrieves post text content from database result set using specialized text extraction.",
    "inputValues": [
      "resultSet-object-ResultSet"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the database result set object containing post data\n   - Identify the column name containing the post text (\"post_text\")\n   - Determine the appropriate text extraction method based on data storage format\n\n2. Data Validation:\n   - Verify the result set is not null\n   - Ensure the result set is positioned at a valid row\n   - Confirm the required column \"post_text\" exists in the result set\n   - Check if the post_text field contains null value\n     IF post_text is null THEN\n       Return empty string\n     END IF\n\n3. Business Rule Processing:\n   - Determine the character encoding format of the stored text\n   - Select appropriate text extraction method based on storage format\n   - Prepare memory buffers for text extraction if needed\n   - Set up any required conversion parameters for character encoding\n\n4. Core Operation Execution:\n   - Access the binary data stream from the post_text column\n   - Read the binary content from the stream\n   - Convert the binary data to text using the appropriate character encoding\n   - Handle any potential data truncation or corruption\n   - Close any resources used during text extraction\n   - Perform any necessary post-processing on the extracted text\n\n5. Response Generation:\n   - Return the extracted post text as a string\n   - IF extraction fails THEN\n     Generate appropriate error information\n     Return empty string or error placeholder\n   - Include metadata about the extraction process if needed\n   - Ensure proper memory cleanup after text extraction",
    "databaseEntities": [
      "jforum_posts",
      "jforum_posts_text"
    ],
    "validationRules": [
      "Result set must not be null",
      "Result set must be positioned at a valid row",
      "Post text column must exist in the result set",
      "Binary data must be properly converted to text using correct character encoding"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "ResultSet": {
        "type": "object",
        "description": "Database result set containing query results",
        "properties": {
          "post_text": {
            "type": "binary",
            "description": "Binary data containing the post text content"
          }
        }
      }
    }
  },
  {
    "featureName": "ReadModerationLogDescription",
    "description": "Reads moderation log description content from storage fields.",
    "inputValues": [
      "logId-number-ModerationLog",
      "resultSet-object-ResultSet"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect moderation log ID (required, system-generated number)\n   - Obtain result set containing moderation log data (required, system-generated object)\n\n2. Data Validation:\n   - Validate moderation log ID:\n     a. Check if log ID is a positive integer\n     b. Verify log ID exists in the system\n     c. Return appropriate error if validation fails\n   - Validate result set:\n     a. Verify result set is not null\n     b. Confirm result set contains required fields (log_description, log_original_message)\n     c. Return appropriate error if validation fails\n\n3. Business Rule Processing:\n   - Check user permissions:\n     a. Verify current user has permission to view moderation logs\n     b. IF user lacks permission, THEN return access denied error\n   - Check system state:\n     a. Verify system is in operational state for data retrieval\n     b. IF system is in maintenance mode, THEN return appropriate error\n\n4. Core Operation Execution:\n   - Retrieve description content:\n     a. Access the binary content field for description\n     b. Convert binary content to readable text format\n     c. Handle any encoding-specific requirements\n     d. IF content retrieval fails, THEN log error and return empty string\n   - Retrieve original message content (if requested):\n     a. Access the binary content field for original message\n     b. Convert binary content to readable text format\n     c. Handle any encoding-specific requirements\n     d. IF content retrieval fails, THEN log error and return empty string\n\n5. Response Generation:\n   - Prepare response with retrieved content:\n     a. Format description text for display\n     b. Include metadata (timestamp, log type, associated users)\n     c. Return complete moderation log entry with readable description\n   - Handle error scenarios:\n     a. Return appropriate error messages for any failures\n     b. Include support information for troubleshooting",
    "databaseEntities": [
      "jforum_users",
      "jforum_posts",
      "jforum_topics"
    ],
    "validationRules": [
      "Moderation log ID must be a positive integer",
      "Result set must not be null",
      "Result set must contain required fields",
      "User must have permission to view moderation logs"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "ResultSet": {
        "type": "object",
        "properties": {
          "log_id": {
            "type": "number",
            "description": "Unique identifier for the moderation log entry"
          },
          "log_description": {
            "type": "binary",
            "description": "Binary content field containing the description text"
          },
          "log_original_message": {
            "type": "binary",
            "description": "Binary content field containing the original message text"
          },
          "user_id": {
            "type": "number",
            "description": "ID of the user who performed the moderation action"
          },
          "log_type": {
            "type": "number",
            "description": "Type code indicating the kind of moderation action"
          },
          "post_id": {
            "type": "number",
            "description": "ID of the post being moderated"
          },
          "topic_id": {
            "type": "number",
            "description": "ID of the topic being moderated"
          },
          "poster_id": {
            "type": "number",
            "description": "ID of the user who created the moderated content"
          },
          "log_date": {
            "type": "date",
            "description": "Timestamp when the moderation action occurred"
          }
        }
      },
      "ModerationLog": {
        "type": "object",
        "properties": {
          "id": {
            "type": "number",
            "description": "Unique identifier for the moderation log entry"
          },
          "description": {
            "type": "string",
            "description": "Description of the moderation action"
          },
          "originalMessage": {
            "type": "string",
            "description": "Original content before moderation"
          },
          "type": {
            "type": "number",
            "description": "Type code indicating the kind of moderation action"
          },
          "user": {
            "type": "object",
            "description": "User who performed the moderation action"
          },
          "posterUser": {
            "type": "object",
            "description": "User who created the moderated content"
          },
          "postId": {
            "type": "number",
            "description": "ID of the post being moderated"
          },
          "topicId": {
            "type": "number",
            "description": "ID of the topic being moderated"
          }
        }
      }
    }
  },
  {
    "featureName": "ReadModerationLogOriginalMessage",
    "description": "Retrieves the original message content from moderation logs stored in the system.",
    "inputValues": [
      "logId-number-ModerationLog"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the moderation log ID (logId) from the user request\n   - Verify the logId is provided and is a valid number\n   - System will use the current user's session information for access control\n\n2. Data Validation:\n   - Validate that logId is a positive integer\n     * IF logId is not a positive integer THEN\n       - Return an error message indicating invalid log ID format\n     * END IF\n   - Verify the log entry exists in the system\n     * IF log entry does not exist THEN\n       - Return an error message indicating the log was not found\n     * END IF\n   - Verify the current user has permission to view moderation logs\n     * IF user does not have sufficient permissions THEN\n       - Return an access denied error message\n     * END IF\n\n3. Business Rule Processing:\n   - Check if the user has appropriate role to view moderation logs\n     * IF user is not an administrator or moderator THEN\n       - Return an access denied error message\n     * END IF\n   - Verify the log entry contains an original message\n     * IF original message field is null or empty THEN\n       - Return a notification that no original message exists for this log\n     * END IF\n\n4. Core Operation Execution:\n   - Retrieve the moderation log record using the provided logId\n   - Extract the original message content from the log record\n   - Format the original message for proper display\n     * Process any special characters or formatting\n     * Prepare the content for presentation\n   - Record the access to the log in the system audit trail\n     * Store user ID, timestamp, and action type\n\n5. Response Generation:\n   - Prepare the response containing:\n     * Log ID\n     * Original message content\n     * Timestamp of when the log was created\n     * User who performed the moderation action\n     * Type of moderation action performed\n   - Return the formatted response to the user\n   - IF any errors occurred during retrieval THEN\n     * Return appropriate error message with error code\n     * Include support contact information if needed\n   - END IF",
    "databaseEntities": [
      "ModerationLog",
      "User"
    ],
    "validationRules": [
      "Log ID must be a positive integer",
      "User must have administrator or moderator permissions to view moderation logs",
      "The requested log entry must exist in the system",
      "The log entry must contain an original message"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "ModerationLog": {
        "id": "number",
        "userId": "number",
        "timestamp": "date",
        "type": "number",
        "postId": "number",
        "topicId": "number",
        "posterUserId": "number",
        "description": "string",
        "originalMessage": "string"
      },
      "User": {
        "id": "number",
        "username": "string",
        "permissions": "object"
      }
    }
  },
  {
    "featureName": "AddNewPostText",
    "description": "Adds text content for a new forum post with subject and body.",
    "inputValues": [
      "postId-number-Post",
      "subject-string-Post",
      "text-string-Post"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the following inputs:\n     1.1. postId (mandatory): Unique identifier for the post\n     1.2. subject (mandatory): Subject line of the post\n     1.3. text (mandatory): Main content body of the post\n\n2. Data Validation:\n   - Validate all input fields:\n     2.1. Validate postId:\n         2.1.1. Check if postId is provided\n         2.1.2. Verify postId is a positive integer\n         2.1.3. IF postId is invalid THEN generate error message \"Invalid post identifier\"\n     2.2. Validate subject:\n         2.2.1. Check if subject is provided\n         2.2.2. Verify subject is not empty after trimming whitespace\n         2.2.3. Check if subject length is within acceptable limits\n         2.2.4. IF subject is invalid THEN generate error message \"Subject cannot be empty or exceed maximum length\"\n     2.3. Validate text:\n         2.3.1. Check if text is provided\n         2.3.2. Verify text is not empty after trimming whitespace\n         2.3.3. Check if text length is within acceptable limits\n         2.3.4. IF text is invalid THEN generate error message \"Post content cannot be empty or exceed maximum length\"\n\n3. Business Rule Processing:\n   - Verify system state and dependencies:\n     3.1. Check if the post exists in the system:\n         3.1.1. Verify post record exists with the given postId\n         3.1.2. IF post does not exist THEN generate error message \"Post does not exist\"\n     3.2. Check user permissions:\n         3.2.1. Verify current user has permission to create post content\n         3.2.2. IF user lacks permission THEN generate error message \"Insufficient permissions to create post content\"\n     3.3. Check forum status:\n         3.3.1. Verify the forum is active and allows posting\n         3.3.2. IF forum is locked or inactive THEN generate error message \"Forum is currently not accepting new posts\"\n\n4. Core Operation Execution:\n   - Process the post text creation:\n     4.1. Prepare post text data:\n         4.1.1. Format subject and text according to system requirements\n         4.1.2. Sanitize inputs to prevent security issues\n     4.2. Store post text information:\n         4.2.1. Create a new record in the posts_text table with postId and subject\n         4.2.2. Store the post text content in the appropriate field\n         4.2.3. IF storage operation fails THEN:\n             4.2.3.1. Roll back any partial changes\n             4.2.3.2. Generate error message \"Failed to save post content\"\n     4.3. Update related records:\n         4.3.1. Update the main post record to reflect text content addition\n         4.3.2. Update any relevant timestamps or metadata\n\n5. Response Generation:\n   - Generate appropriate response:\n     5.1. For successful operation:\n         5.1.1. Create success response indicating post text was added successfully\n         5.1.2. Include confirmation details such as post identifier\n     5.2. For failed operation:\n         5.2.1. Include specific error message explaining the failure reason\n         5.2.2. Provide guidance on how to resolve the issue\n         5.2.3. Include support information if applicable",
    "databaseEntities": [
      "jforum_posts",
      "jforum_posts_text"
    ],
    "validationRules": [
      "Post ID must be a valid positive integer",
      "Post must exist in the system",
      "Subject must not be empty",
      "Text content must not be empty",
      "User must have permission to create post content"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Post": {
        "id": "number",
        "subject": "string",
        "text": "string"
      }
    }
  },
  {
    "featureName": "UpdatePostText",
    "description": "Updates the subject and text content of an existing forum post.",
    "inputValues": [
      "postId-number-Post",
      "subject-string-Post",
      "text-string-Post"
    ],
    "businessLogic": "1. Input Collection\n   - Collect the following inputs:\n     1.1. postId (mandatory): Unique identifier of the post to update\n     1.2. subject (mandatory): New subject line for the post\n     1.3. text (mandatory): New content text for the post\n     1.4. userId (system-generated): Identifier of the user performing the update\n\n2. Data Validation\n   - Validate all input fields:\n     2.1. Validate postId:\n         2.1.1. Check if postId is provided\n         2.1.2. Verify postId is a positive integer\n         2.1.3. Return error message if validation fails: \"Invalid post identifier\"\n     2.2. Validate subject:\n         2.2.1. Check if subject is provided\n         2.2.2. Verify subject is not empty after trimming\n         2.2.3. Verify subject length is within allowed limits (1-255 characters)\n         2.2.4. Return error message if validation fails: \"Subject cannot be empty and must be between 1-255 characters\"\n     2.3. Validate text:\n         2.3.1. Check if text is provided\n         2.3.2. Verify text is not empty after trimming\n         2.3.3. Verify text length is within allowed limits (minimum 1 character)\n         2.3.4. Return error message if validation fails: \"Post content cannot be empty\"\n\n3. Business Rule Processing\n   - Verify system state and permissions:\n     3.1. Check if the post exists in the system\n         3.1.1. IF post does not exist THEN\n             3.1.2. Return error message: \"Post not found\"\n     3.2. Verify user has permission to edit the post\n         3.2.1. Check if user is the original post author OR has moderator privileges\n         3.2.2. IF user lacks permission THEN\n             3.2.3. Return error message: \"You do not have permission to edit this post\"\n     3.3. Check if the post is locked or in a locked topic\n         3.3.1. IF post is locked THEN\n             3.3.2. Return error message: \"This post cannot be edited because it is locked\"\n     3.4. Check if editing time limit has expired (if applicable)\n         3.4.1. IF time limit for editing has passed AND user is not a moderator THEN\n             3.4.2. Return error message: \"The time limit for editing this post has expired\"\n\n4. Core Operation Execution\n   - Update the post content in the system:\n     4.1. Retrieve the existing post record\n         4.1.1. Load current post data including metadata\n     4.2. Update post subject\n         4.2.1. Replace current subject with new subject\n     4.3. Update post text content\n         4.3.1. Replace current text with new text\n     4.4. Update modification metadata\n         4.4.1. Set last edit timestamp to current time\n         4.4.2. Set last edit user ID to current user ID\n         4.4.3. Increment edit count\n     4.5. Save changes to the database\n         4.5.1. Update post record with new information\n         4.5.2. IF update fails THEN\n             4.5.3. Revert any partial changes\n             4.5.4. Return error message: \"Failed to update post content\"\n\n5. Response Generation\n   - Generate appropriate response:\n     5.1. IF update is successful THEN\n         5.1.1. Return success response with updated post details\n         5.1.2. Include post ID, subject, and confirmation message\n     5.2. IF update fails at any point THEN\n         5.2.1. Return error response with specific error message\n         5.2.2. Include guidance on how to resolve the issue if applicable",
    "databaseEntities": [
      "jforum_posts",
      "jforum_posts_text",
      "jforum_topics",
      "jforum_users"
    ],
    "validationRules": [
      "Post ID must exist in the system",
      "Subject must not be empty",
      "Subject must be between 1-255 characters",
      "Post text content must not be empty",
      "User must have permission to edit the post",
      "Post must not be in a locked state",
      "Time limit for editing must not have expired (if applicable)"
    ],
    "dbSeedingOperations": [],
    "schema": {}
  },
  {
    "featureName": "GetPostText",
    "description": "Retrieves the text content of a forum post from the database.",
    "inputValues": [
      "postId-number-Post"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect post ID (mandatory, numeric)\n   - System will determine database connection from current context\n\n2. Data Validation:\n   - Validate post ID:\n     a. Check if post ID is provided\n     b. Verify post ID is a positive integer\n     c. IF validation fails, THEN prepare error message indicating invalid post ID\n\n3. Business Rule Processing:\n   - Check system access permissions:\n     a. Verify current user has permission to view the requested post\n     b. IF user lacks permission, THEN prepare access denied error\n   - Verify post existence:\n     a. Check if post with provided ID exists in the system\n     b. IF post does not exist, THEN prepare not found error\n\n4. Core Operation Execution:\n   - Retrieve post data:\n     a. Locate post record using the provided post ID\n     b. Access the post text content from the posts_text table\n     c. Read the binary text data and convert to appropriate character encoding\n     d. IF data retrieval fails, THEN prepare database error message\n\n5. Response Generation:\n   - Success response:\n     a. Format the retrieved post text content\n     b. Include post subject if available\n     c. Return the formatted post content to the caller\n   - Error response:\n     a. Include specific error message based on failure condition\n     b. Provide appropriate error code\n     c. Include guidance for resolving the issue if applicable",
    "databaseEntities": [
      "Post",
      "PostText"
    ],
    "validationRules": [
      "Post ID must be a positive integer",
      "Post must exist in the database",
      "User must have permission to view the post",
      "Post text content must be properly decoded from binary format"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Post": {
        "id": "number",
        "subject": "string",
        "text": "string"
      }
    }
  },
  {
    "featureName": "SelectPostsByTopicWithPagination",
    "description": "Retrieves paginated posts for a specific forum topic.",
    "inputValues": [
      "topicId-number-Topic",
      "startFrom-number-Pagination",
      "count-number-Pagination"
    ],
    "businessLogic": "1. Input Collection\n   1.1. Collect the following required inputs:\n       - topicId (number): Unique identifier of the topic\n       - startFrom (number): Starting position for pagination\n       - count (number): Maximum number of posts to retrieve\n   1.2. All fields are mandatory for this operation\n   1.3. System will use these values to determine which posts to retrieve\n\n2. Data Validation\n   2.1. Validate topicId\n       2.1.1. Ensure topicId is a positive integer\n       2.1.2. IF topicId is invalid or missing, THEN generate error message: \"Valid topic identifier required\"\n   2.2. Validate pagination parameters\n       2.2.1. Ensure startFrom is a non-negative integer\n       2.2.2. Ensure count is a positive integer\n       2.2.3. IF startFrom is invalid, THEN generate error message: \"Valid starting position required\"\n       2.2.4. IF count is invalid, THEN generate error message: \"Valid count value required\"\n\n3. Business Rule Processing\n   3.1. Verify topic existence\n       3.1.1. Check if the specified topic exists in the system\n       3.1.2. IF topic does not exist, THEN generate error message: \"Topic not found\"\n   3.2. Verify user access permissions\n       3.2.1. Check if the current user has permission to view the topic\n       3.2.2. IF user lacks permission, THEN generate error message: \"Insufficient permissions to view this topic\"\n   3.3. Determine actual pagination range\n       3.3.1. Calculate the ending position as startFrom + count\n       3.3.2. Adjust pagination parameters if they exceed available data boundaries\n\n4. Core Operation Execution\n   4.1. Retrieve posts for the specified topic\n       4.1.1. Query the posts associated with the topic ID\n       4.1.2. Apply pagination parameters to limit results\n       4.1.3. Include all relevant post information (content, author, timestamp, etc.)\n       4.1.4. Sort posts by their creation date in ascending order\n   4.2. Process retrieved posts\n       4.2.1. For each post, retrieve the associated text content\n       4.2.2. For each post, retrieve author information\n       4.2.3. For each post, check for attachments\n       4.2.4. Format post content according to system settings\n   4.3. Handle empty result sets\n       4.3.1. IF no posts are found within the pagination range, THEN return an empty collection\n       4.3.2. Do not generate an error for empty results\n\n5. Response Generation\n   5.1. Prepare success response\n       5.1.1. Include the collection of retrieved posts\n       5.1.2. Include pagination metadata (current page, total posts, etc.)\n       5.1.3. Include topic information for context\n   5.2. Handle potential errors\n       5.2.1. For validation errors, return appropriate error messages\n       5.2.2. For permission errors, return access denied message\n       5.2.3. For system errors, return generic error message with support information",
    "databaseEntities": [
      "jforum_topics",
      "jforum_posts",
      "jforum_posts_text",
      "jforum_users",
      "jforum_attachments",
      "jforum_forums"
    ],
    "validationRules": [
      "Topic ID must be a positive integer",
      "Starting position must be a non-negative integer",
      "Count must be a positive integer",
      "Topic must exist in the system",
      "User must have permission to view the topic",
      "Forum must be in the list of allowed forums for the user"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Post": {
        "id": "number",
        "topicId": "number",
        "userId": "number",
        "subject": "string",
        "text": "string",
        "creationDate": "date",
        "hasAttachments": "boolean",
        "postUsername": "string",
        "forumId": "number"
      },
      "Topic": {
        "id": "number",
        "forumId": "number",
        "title": "string",
        "postCount": "number",
        "status": "string"
      },
      "Pagination": {
        "startFrom": "number",
        "count": "number",
        "totalItems": "number",
        "currentPage": "number"
      }
    }
  },
  {
    "featureName": "SelectPostsByUserWithPagination",
    "description": "Retrieves paginated posts created by a specific user.",
    "inputValues": [
      "userId-number-User",
      "startFrom-number-Pagination",
      "count-number-Pagination"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect userId (mandatory): Unique identifier of the user whose posts are being retrieved\n   - Collect startFrom (mandatory): Starting position for pagination\n   - Collect count (mandatory): Number of posts to retrieve\n   - System will use these parameters to build a paginated result set\n\n2. Data Validation:\n   - Validate userId:\n      * Verify userId is a positive integer\n      * Verify userId exists in the system\n      * IF userId is invalid or not found, THEN return appropriate error message\n   - Validate pagination parameters:\n      * Verify startFrom is a non-negative integer\n      * Verify count is a positive integer\n      * IF either parameter is invalid, THEN use system default values or return error\n\n3. Business Rule Processing:\n   - Check user access permissions:\n      * Verify the requesting user has permission to view the target user's posts\n      * IF permission check fails, THEN return access denied error\n   - Check forum access permissions:\n      * Retrieve list of forums the current user is allowed to access\n      * Only posts from these allowed forums will be included in results\n   - Check system resource availability:\n      * Verify the system can handle the requested pagination size\n      * IF count exceeds maximum allowed limit, THEN adjust to maximum allowed value\n\n4. Core Operation Execution:\n   - Calculate pagination boundaries:\n      * Determine the starting record position based on startFrom\n      * Determine the ending record position based on startFrom + count\n   - Retrieve posts:\n      * Fetch posts created by the specified user within the calculated boundaries\n      * Filter posts to only include those from forums the user has access to\n      * Include relevant post metadata (creation date, topic association, etc.)\n      * Sort posts according to system default sorting (typically by date, newest first)\n   - Process retrieved posts:\n      * Format post content for display\n      * Resolve any user-specific display preferences\n      * Create a structured list of post objects with all required information\n\n5. Response Generation:\n   - Prepare success response:\n      * Include the list of retrieved posts\n      * Include pagination metadata (current page, total posts, total pages)\n      * Include any relevant user information\n   - Handle empty results:\n      * IF no posts are found, THEN return empty list with appropriate message\n      * Include pagination metadata even for empty results\n   - Return the complete response to the caller",
    "databaseEntities": [
      "jforum_users",
      "jforum_posts",
      "jforum_posts_text",
      "jforum_topics",
      "jforum_forums"
    ],
    "validationRules": [
      "User ID must be a positive integer",
      "User ID must exist in the system",
      "Start position must be a non-negative integer",
      "Count must be a positive integer",
      "Requesting user must have permission to view the target user's posts",
      "Posts must be filtered to only include those from forums the user has access to"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Post": {
        "id": "number",
        "userId": "number",
        "topicId": "number",
        "forumId": "number",
        "subject": "string",
        "text": "string",
        "creationDate": "date",
        "editCount": "number",
        "lastEditDate": "date",
        "username": "string",
        "postTime": "date"
      },
      "Pagination": {
        "startFrom": "number",
        "count": "number",
        "totalRecords": "number",
        "totalPages": "number"
      }
    }
  },
  {
    "featureName": "AddPrivateMessageText",
    "description": "Adds text content to a private message by writing to a database storage field.",
    "inputValues": [
      "messageId-number-PrivateMessage",
      "messageText-string-PrivateMessage"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the following inputs:\n     a. messageId (number, mandatory): The unique identifier of the private message\n     b. messageText (string, mandatory): The text content to be added to the private message\n\n2. Data Validation:\n   - Validate messageId:\n     a. Check if messageId is provided\n     b. Verify messageId is a positive integer\n     c. IF validation fails, THEN generate error message \"Invalid message identifier provided\"\n   - Validate messageText:\n     a. Check if messageText is provided\n     b. Verify messageText is not empty\n     c. IF validation fails, THEN generate error message \"Message text cannot be empty\"\n\n3. Business Rule Processing:\n   - Verify message existence:\n     a. Check if a private message with the provided messageId exists in the system\n     b. IF message does not exist, THEN generate error \"Private message not found\"\n   - Verify user permissions:\n     a. Check if the current user has permission to modify this private message\n     b. IF user lacks permission, THEN generate error \"Insufficient permissions to modify this message\"\n   - Check message state:\n     a. Verify if the message is in an editable state\n     b. IF message is not editable, THEN generate error \"Message cannot be modified in its current state\"\n\n4. Core Operation Execution:\n   - Prepare message text storage:\n     a. Format the message text according to system requirements\n     b. Prepare the storage mechanism for the text content\n   - Store message text:\n     a. Associate the text content with the private message using messageId\n     b. Write the text content to the storage field\n     c. IF storage operation fails, THEN:\n        i. Revert any partial changes\n        ii. Generate error \"Failed to store message text\"\n   - Update message metadata:\n     a. Update the last modified timestamp\n     b. Update any relevant flags or indicators\n\n5. Response Generation:\n   - For successful operation:\n     a. Generate success confirmation\n     b. Include the messageId in the response\n     c. Provide timestamp of the operation\n   - For failed operation:\n     a. Include specific error message explaining the failure\n     b. Provide guidance on how to resolve the issue\n     c. Include any relevant error codes for troubleshooting",
    "databaseEntities": [
      "PrivateMessage",
      "jforum_privmsgs",
      "jforum_privmsgs_text"
    ],
    "validationRules": [
      "Message ID must be a positive integer",
      "Message text cannot be empty",
      "Private message must exist in the system",
      "User must have permission to modify the message",
      "Message must be in an editable state"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "PrivateMessage": {
        "id": "number",
        "post": {
          "text": "string"
        }
      }
    }
  },
  {
    "featureName": "GetPrivateMessageText",
    "description": "Retrieves text content of a private message from a database BLOB field.",
    "inputValues": [
      "messageId-number-PrivateMessage"
    ],
    "businessLogic": "1. Input Collection\n   - Collect the private message ID (messageId) from the user request\n   - Verify that messageId is provided and is a valid numeric identifier\n   - Determine if any additional context information is required (e.g., user permissions)\n\n2. Data Validation\n   - Validate that the messageId is a positive integer\n   - Verify that the messageId is within valid range for the system\n   - IF messageId is invalid or missing THEN\n     - Generate appropriate error message\n     - Terminate process and return error response\n   - END IF\n\n3. Business Rule Processing\n   - Check if the requesting user has permission to access this private message\n     - Verify if the user is either the sender or recipient of the message\n     - IF user does not have permission THEN\n       - Log unauthorized access attempt\n       - Return access denied error\n     - END IF\n   - Check if the message exists in the system\n     - Query the private message record using messageId\n     - IF message not found THEN\n       - Generate appropriate error message\n       - Return not found error\n     - END IF\n   - Check if the message has been deleted or archived\n     - IF message is marked as deleted THEN\n       - Determine if recovery is possible based on system rules\n       - IF recovery not possible THEN\n         - Return appropriate error message\n       - END IF\n     - END IF\n\n4. Core Operation Execution\n   - Locate the private message record using the messageId\n   - Access the associated text content from the storage system\n     - Retrieve the BLOB field containing the message text\n     - Convert the BLOB data to appropriate text format\n     - Handle any character encoding requirements\n   - IF text retrieval fails THEN\n     - Log the error with appropriate details\n     - Prepare fallback response or error message\n   - END IF\n   - Update message read status if applicable\n     - IF message was unread AND recipient is requesting THEN\n       - Mark message as read\n       - Update read timestamp\n     - END IF\n\n5. Response Generation\n   - Prepare the response with the retrieved message text\n   - Include relevant metadata about the message:\n     - Message subject\n     - Sender information\n     - Timestamp information\n     - Read status\n   - Format the response according to system standards\n   - Return the complete message information to the requester\n   - IF any errors occurred during processing THEN\n     - Include appropriate error codes and messages\n     - Provide guidance on resolving the issue if applicable\n   - END IF",
    "databaseEntities": [
      "PrivateMessage",
      "User"
    ],
    "validationRules": [
      "Message ID must be a positive integer",
      "User must be authorized to access the requested message",
      "Message must exist in the system",
      "Message text must be successfully decoded from storage format"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "PrivateMessage": {
        "id": "number",
        "senderId": "number",
        "recipientId": "number",
        "subject": "string",
        "text": "string",
        "sentDate": "date",
        "readDate": "date",
        "isRead": "boolean",
        "isDeleted": "boolean"
      },
      "User": {
        "id": "number",
        "username": "string"
      }
    }
  },
  {
    "featureName": "SelectAllUsers",
    "description": "Retrieves a paginated list of users with custom pagination logic for Oracle database.",
    "inputValues": [
      "startFrom-number-Pagination",
      "count-number-Pagination",
      "groupId-number-Group"
    ],
    "businessLogic": "1. Input Collection:\n   1.1. Collect pagination parameters:\n       1.1.1. startFrom (mandatory): The starting index for pagination.\n       1.1.2. count (mandatory): The number of records to retrieve.\n       1.1.3. groupId (optional): The group identifier to filter users by group.\n\n2. Data Validation:\n   2.1. Validate startFrom parameter:\n       2.1.1. IF startFrom is negative THEN\n             Return error message: \"Starting index cannot be negative.\"\n       2.1.2. IF startFrom is not a whole number THEN\n             Return error message: \"Starting index must be a whole number.\"\n   2.2. Validate count parameter:\n       2.2.1. IF count is negative THEN\n             Return error message: \"Count cannot be negative.\"\n       2.2.2. IF count is not a whole number THEN\n             Return error message: \"Count must be a whole number.\"\n   2.3. Validate groupId parameter (if provided):\n       2.3.1. IF groupId is provided THEN\n             IF groupId is not a positive integer THEN\n                 Return error message: \"Group ID must be a positive integer.\"\n             IF group with groupId does not exist THEN\n                 Return error message: \"Specified group does not exist.\"\n\n3. Business Rule Processing:\n   3.1. Determine the query type based on inputs:\n       3.1.1. IF groupId is provided THEN\n             Set operation mode to \"filter by group\"\n       3.1.2. ELSE\n             Set operation mode to \"all users\"\n   3.2. Determine the ending index for pagination:\n       3.2.1. IF count is greater than zero THEN\n             Set endIndex to startFrom + count\n       3.2.2. ELSE\n             Set endIndex to 0 (indicating no upper limit)\n   3.3. Check system state:\n       3.3.1. Verify user database is accessible\n       3.3.2. Verify current user has permission to view user list\n       3.3.3. IF operation mode is \"filter by group\" THEN\n             Verify current user has permission to view the specified group\n\n4. Core Operation Execution:\n   4.1. Prepare user retrieval operation:\n       4.1.1. IF operation mode is \"all users\" THEN\n             4.1.1.1. IF count is greater than 0 THEN\n                   Set up query with startFrom and endIndex limits\n                   Configure result set for scrollable navigation\n                   Execute query to retrieve limited user records\n                   Position cursor at the startFrom position in the result set\n             4.1.1.2. ELSE\n                   Set up query to retrieve all users without limits\n                   Execute query to retrieve all user records\n       4.1.2. ELSE IF operation mode is \"filter by group\" THEN\n             Set up query with groupId, startFrom, and count parameters\n   4.2. Execute the query to retrieve users:\n       4.2.1. Fetch user records from the database\n       4.2.2. IF query fails THEN\n             Log the error details\n             Return error message: \"Unable to retrieve user list.\"\n   4.3. Process the retrieved user records:\n       4.3.1. Format each user record for display\n       4.3.2. Remove sensitive information from user records\n       4.3.3. Sort users according to default or specified criteria\n       4.3.4. IF operation mode is \"all users\" AND count is greater than 0 THEN\n             Load additional karma information for each user\n\n5. Response Generation:\n   5.1. Prepare success response:\n       5.1.1. Include the list of retrieved users\n       5.1.2. Include pagination metadata:\n             - Total number of users in the system or group\n             - Current page information\n             - More pages indicator\n       5.1.3. IF operation mode is \"filter by group\" THEN\n             Include group information in the response\n   5.2. Return the formatted user list with pagination details",
    "databaseEntities": [
      "jforum_users",
      "jforum_user_groups",
      "jforum_groups",
      "jforum_karma"
    ],
    "validationRules": [
      "Starting index must be a non-negative whole number",
      "Count must be a non-negative whole number",
      "Group ID, if provided, must be a positive integer",
      "User must have permission to view the user list",
      "User must have permission to view the specified group if filtering by group"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Pagination": {
        "type": "object",
        "properties": {
          "startFrom": {
            "type": "number",
            "description": "The starting index for pagination"
          },
          "count": {
            "type": "number",
            "description": "The number of records to retrieve"
          }
        },
        "required": [
          "startFrom",
          "count"
        ]
      },
      "Group": {
        "type": "object",
        "properties": {
          "groupId": {
            "type": "number",
            "description": "The identifier of the group to filter users by"
          }
        },
        "required": [
          "groupId"
        ]
      }
    }
  },
  {
    "featureName": "ReadBlobUTF16BinaryStream",
    "description": "Reads binary data from a database BLOB field and converts it to a UTF-16 encoded string.",
    "inputValues": [
      "resultSet-object-DatabaseResultSet",
      "fieldName-string-DatabaseField"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the database result set containing the BLOB data\n   - Collect the field name that identifies the BLOB column\n   - Both inputs are mandatory for processing\n\n2. Data Validation:\n   - Validate that the result set is not null\n     * IF result set is null THEN\n       - Generate an error indicating invalid result set\n       - Terminate processing\n     * END IF\n   - Validate that the field name is not empty\n     * IF field name is empty or null THEN\n       - Generate an error indicating invalid field name\n       - Terminate processing\n     * END IF\n   - Verify the field exists in the result set\n     * IF field does not exist in result set THEN\n       - Generate an error indicating field not found\n       - Terminate processing\n     * END IF\n\n3. Business Rule Processing:\n   - Check if the BLOB field contains null value\n     * IF BLOB field is null THEN\n       - Return empty string as result\n       - Terminate processing\n     * END IF\n   - Verify system has sufficient memory for processing\n     * IF system memory is insufficient THEN\n       - Generate resource limitation error\n       - Terminate processing\n     * END IF\n\n4. Core Operation Execution:\n   - Retrieve the BLOB object from the result set using the field name\n   - Obtain a binary input stream from the BLOB object\n   - Initialize a buffer to hold the string data\n   - Set up a reading buffer with appropriate size (4096 bytes)\n   - WHILE there is data to read from the stream DO\n     * Read bytes from the stream into the buffer\n     * IF bytes were read THEN\n       - Convert the bytes to a string using UTF-16 encoding\n       - Append the converted string to the result buffer\n     * END IF\n   - END WHILE\n   - Close the input stream to release resources\n   - Return the complete string from the buffer\n   - IF any errors occur during processing THEN\n     * Release all resources\n     * Generate appropriate error message\n     * Terminate processing\n   * END IF\n\n5. Response Generation:\n   - On success:\n     * Return the complete UTF-16 decoded string\n     * Include information about the size of data processed\n   - On failure:\n     * Return detailed error information\n     * Include the nature of the failure (connection, encoding, or memory issue)\n     * Provide guidance for resolving common issues",
    "databaseEntities": [
      "jforum_posts_text"
    ],
    "validationRules": [
      "Result set must not be null",
      "Field name must not be empty",
      "Field must exist in the result set",
      "BLOB data must be properly formatted for UTF-16 conversion"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "DatabaseResultSet": {
        "type": "object",
        "description": "Represents a database query result set containing rows of data",
        "properties": {
          "metadata": {
            "type": "object",
            "description": "Information about the columns in the result set"
          },
          "rows": {
            "type": "array",
            "description": "The data rows returned by the query"
          }
        }
      },
      "DatabaseField": {
        "type": "string",
        "description": "The name of a column in the database result set"
      }
    }
  },
  {
    "featureName": "WriteBlobUTF16BinaryStream",
    "description": "Writes UTF-16 encoded string data to a database BLOB field using binary streams.",
    "inputValues": [
      "query-string-Database",
      "idForQuery-number-Database",
      "value-string-Content"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the following required inputs:\n     a. query (string): SQL query statement for locating the BLOB field\n     b. idForQuery (number): Identifier to locate the specific record\n     c. value (string): The text content to be stored in UTF-16 encoding\n   - System will use the current database connection from the execution context\n\n2. Data Validation:\n   - Validate query parameter:\n     a. Verify query is not empty\n     b. Verify query contains proper SQL syntax for updating a BLOB field\n     c. Verify query includes a parameter placeholder for the record identifier\n     d. IF validation fails, THEN generate appropriate error message\n   - Validate idForQuery parameter:\n     a. Verify idForQuery is a positive integer\n     b. IF validation fails, THEN generate appropriate error message\n   - Validate value parameter:\n     a. Verify value is not null\n     b. IF validation fails, THEN generate appropriate error message\n\n3. Business Rule Processing:\n   - Verify database connection availability:\n     a. Check if a valid database connection exists in the execution context\n     b. IF no valid connection exists, THEN generate connection error\n   - Verify record existence and locking:\n     a. Ensure the query includes FOR UPDATE clause to lock the record during update\n     b. Verify the target table has been properly initialized with EMPTY_BLOB() for the field\n\n4. Core Operation Execution:\n   - Prepare database statement:\n     a. Create a prepared statement using the provided query\n     b. Set the idForQuery as a parameter in the prepared statement\n   - Execute query and retrieve result:\n     a. Execute the query to locate the target BLOB field\n     b. Move to the first result record\n     c. Retrieve the BLOB object from the result set\n   - Write data to BLOB:\n     a. Obtain binary output stream from the BLOB object\n     b. Convert the input string value to UTF-16 byte format\n     c. Write the converted bytes to the BLOB via the output stream\n     d. Close the binary output stream to complete the write operation\n   - Handle potential failures:\n     a. IF any I/O errors occur during writing, THEN capture error details\n     b. IF database errors occur, THEN ensure proper cleanup of resources\n     c. Ensure all resources are properly closed even if exceptions occur\n\n5. Response Generation:\n   - Success response:\n     a. Return confirmation that the data was successfully written\n     b. Include information about the updated record\n   - Error response:\n     a. Provide detailed error information if the operation fails\n     b. Include specific error codes and messages for troubleshooting\n     c. Suggest possible remediation steps based on the error type",
    "databaseEntities": [
      "jforum_posts_text"
    ],
    "validationRules": [
      "SQL query must not be empty",
      "SQL query must contain FOR UPDATE clause",
      "Record identifier must be a positive integer",
      "Input string value must not be null",
      "Database connection must be available",
      "Target BLOB field must be initialized with EMPTY_BLOB()"
    ],
    "dbSeedingOperations": [
      "Ensure target tables have BLOB fields initialized with EMPTY_BLOB() function"
    ],
    "schema": {}
  },
  {
    "featureName": "CreatePostDataAccess",
    "description": "Provides data access functionality for forum posts in SQL Server environment.",
    "inputValues": [
      "postContent-string-Post",
      "postTitle-string-Post",
      "authorId-number-User",
      "forumId-number-Forum",
      "topicId-number-Topic",
      "attachments-object-Attachment",
      "postDate-date-Post",
      "postOptions-object-PostOptions"
    ],
    "businessLogic": "1. Input Collection:\n   1.1. Collect required post information:\n       - postContent (mandatory): The content of the post\n       - postTitle (mandatory): The title of the post\n       - authorId (mandatory): Identifier of the post author\n       - forumId (mandatory): Identifier of the forum where the post belongs\n       - topicId (mandatory): Identifier of the topic where the post belongs\n       - attachments (optional): Any files attached to the post\n       - postDate (system-generated): Current timestamp if not provided\n       - postOptions (optional): Additional post settings like notification preferences\n\n2. Data Validation:\n   2.1. Validate post content:\n       - Check if postContent is not empty\n       - Verify content length is within allowed limits\n       - IF validation fails, THEN return appropriate error message\n   2.2. Validate post title:\n       - Check if postTitle is not empty\n       - Verify title length is within allowed limits\n       - IF validation fails, THEN return appropriate error message\n   2.3. Validate author information:\n       - Verify authorId exists in the user database\n       - Check if user has permission to create posts\n       - IF validation fails, THEN return appropriate error message\n   2.4. Validate forum and topic:\n       - Verify forumId exists in the forum database\n       - Verify topicId exists in the topic database\n       - Check if topic belongs to the specified forum\n       - Verify forum and topic are not locked or archived\n       - IF validation fails, THEN return appropriate error message\n   2.5. Validate attachments if present:\n       - Check file types against allowed extensions\n       - Verify file sizes are within allowed limits\n       - Count total attachments to ensure they don't exceed maximum\n       - IF validation fails, THEN return appropriate error message\n\n3. Business Rule Processing:\n   3.1. Check system state:\n       - Verify database connection is available\n       - Check system is not in maintenance mode\n       - IF system unavailable, THEN return appropriate error message\n   3.2. Apply posting rules:\n       - Check if user is banned or restricted\n       - Verify user hasn't exceeded posting limits\n       - Check for duplicate post content if enabled\n       - IF rules violated, THEN return appropriate error message\n   3.3. Process content filters:\n       - Apply word censoring if enabled\n       - Check content against spam filters\n       - Process any BBCode or formatting\n       - IF content violates policies, THEN return appropriate error message\n   3.4. Apply SQL Server specific rules:\n       - Handle text field size limitations\n       - Manage SQL Server specific data type constraints\n       - Process any special character escaping needed for SQL Server\n       - IF any SQL Server specific constraints are violated, THEN return appropriate error message\n\n4. Core Operation Execution:\n   4.1. Prepare post data:\n       - Generate unique post identifier\n       - Format post content for storage\n       - Prepare metadata (creation date, IP address)\n   4.2. Store post information:\n       - Create post record in jforum_posts table\n       - Store post content in jforum_posts_text table\n       - Update topic information with new post count and last post data\n       - Update forum statistics with new post count and last post data\n   4.3. Process attachments if present:\n       - Store attachment metadata in jforum_attachments table\n       - Link attachments to the post\n   4.4. Update user statistics:\n       - Increment user post count\n       - Update user's last posting date\n   4.5. Handle failure scenarios:\n       - IF any storage operation fails, THEN rollback all changes\n       - Log detailed error information\n       - Return appropriate error message\n   4.6. Handle SQL Server transaction management:\n       - Ensure proper transaction isolation level\n       - Manage transaction locks appropriately\n       - Handle deadlock prevention strategies\n\n5. Response Generation:\n   5.1. For successful post creation:\n       - Return success status\n       - Include created post identifier\n       - Include timestamp of creation\n       - Provide navigation information to view the post\n   5.2. For failed operations:\n       - Return failure status\n       - Include specific error code\n       - Provide user-friendly error message\n       - Include troubleshooting information when appropriate\n   5.3. For SQL Server specific issues:\n       - Return database-specific error information\n       - Provide SQL Server error codes when applicable\n       - Include guidance for SQL Server specific resolution steps",
    "databaseEntities": [
      "jforum_posts",
      "jforum_posts_text",
      "jforum_topics",
      "jforum_forums",
      "jforum_users",
      "jforum_attachments",
      "jforum_words",
      "jforum_karma",
      "jforum_moderator_groups"
    ],
    "validationRules": [
      "Post content must not be empty",
      "Post title must not be empty",
      "Author ID must reference an existing user",
      "Forum ID must reference an existing forum",
      "Topic ID must reference an existing topic",
      "Topic must belong to the specified forum",
      "Forum and topic must not be locked or archived",
      "Attachment file types must be allowed by the system",
      "Attachment file sizes must not exceed configured limits",
      "Total number of attachments must not exceed maximum allowed",
      "User must have permission to create posts",
      "User must not be banned or restricted",
      "User must not have exceeded posting limits",
      "System must not be in maintenance mode",
      "Content must comply with SQL Server text field size limitations",
      "Post data must conform to SQL Server data type constraints"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Attachment": {
        "type": "object",
        "properties": {
          "fileName": {
            "type": "string",
            "description": "Name of the attached file"
          },
          "fileSize": {
            "type": "number",
            "description": "Size of the file in bytes"
          },
          "fileType": {
            "type": "string",
            "description": "MIME type of the file"
          },
          "fileContent": {
            "type": "string",
            "description": "Base64 encoded file content"
          }
        },
        "required": [
          "fileName",
          "fileSize",
          "fileType",
          "fileContent"
        ]
      },
      "PostOptions": {
        "type": "object",
        "properties": {
          "notifyReplies": {
            "type": "boolean",
            "description": "Whether to notify the author of replies"
          },
          "bbCodeEnabled": {
            "type": "boolean",
            "description": "Whether BBCode formatting is enabled for this post"
          },
          "smiliesEnabled": {
            "type": "boolean",
            "description": "Whether smilies are enabled for this post"
          },
          "signatureEnabled": {
            "type": "boolean",
            "description": "Whether to include user signature with the post"
          }
        }
      }
    }
  },
  {
    "featureName": "CreateTopicDataAccess",
    "description": "Provides data access functionality for forum topics in SQL Server environment.",
    "inputValues": [
      "topicData-object-Topic",
      "forumId-number-Forum",
      "userId-number-User",
      "subject-string-Topic",
      "message-string-Post",
      "priority-number-Topic",
      "attachments-object-Attachment"
    ],
    "businessLogic": "1. Input Collection:\n   1.1. Collect required topic information:\n       - topicData (mandatory): Contains core topic properties\n       - forumId (mandatory): Identifier of the forum where topic will be created\n       - userId (mandatory): Identifier of the user creating the topic\n       - subject (mandatory): Title of the topic\n       - message (mandatory): Initial post content\n       - priority (optional): Topic priority level, default is normal (0)\n       - attachments (optional): Any files attached to the initial post\n   1.2. System will generate:\n       - topicId: Unique identifier for the new topic\n       - creationDate: Current timestamp\n       - lastPostDate: Same as creation date initially\n       - status: Default to unlocked (0)\n\n2. Data Validation:\n   2.1. Validate forumId:\n       - IF forumId is null or invalid THEN\n         - Generate error: \"Forum identifier is required\"\n   2.2. Validate userId:\n       - IF userId is null or invalid THEN\n         - Generate error: \"User identifier is required\"\n   2.3. Validate subject:\n       - IF subject is empty or null THEN\n         - Generate error: \"Topic subject is required\"\n       - IF subject length exceeds maximum allowed characters THEN\n         - Generate error: \"Subject exceeds maximum length\"\n   2.4. Validate message:\n       - IF message is empty or null THEN\n         - Generate error: \"Message content is required\"\n       - IF message length exceeds maximum allowed characters THEN\n         - Generate error: \"Message exceeds maximum length\"\n   2.5. Validate attachments (if provided):\n       - FOR EACH attachment:\n         - Check if file type is allowed\n         - Verify file size is within limits\n         - IF any validation fails THEN\n           - Generate error: \"Invalid attachment: [specific reason]\"\n\n3. Business Rule Processing:\n   3.1. Check user permissions:\n       - Verify user has permission to create topics in the specified forum\n       - IF user lacks permission THEN\n         - Generate error: \"User does not have permission to create topics in this forum\"\n   3.2. Check forum status:\n       - Verify forum is not locked or archived\n       - IF forum is locked or archived THEN\n         - Generate error: \"Cannot create topic in locked or archived forum\"\n   3.3. Check user status:\n       - Verify user account is active and not banned\n       - IF user is banned or inactive THEN\n         - Generate error: \"User account is not active or is banned\"\n   3.4. Check for duplicate topics:\n       - IF identical topic was created by same user in last X minutes THEN\n         - Generate warning: \"Similar topic recently created\"\n\n4. Core Operation Execution:\n   4.1. Create new topic record:\n       - Generate unique topic identifier\n       - Set topic creation timestamp\n       - Associate topic with specified forum\n       - Set topic status to normal/unlocked\n       - Set topic type based on priority\n       - Record topic creator (userId)\n   4.2. Create initial post:\n       - Generate unique post identifier\n       - Associate post with new topic\n       - Store message content\n       - Set post timestamp\n       - Associate post with user\n   4.3. Process attachments (if any):\n       - FOR EACH attachment:\n         - Store attachment metadata\n         - Associate attachment with post\n   4.4. Update forum statistics:\n       - Increment topic count for forum\n       - Update last post information for forum\n   4.5. Update user statistics:\n       - Increment post count for user\n   4.6. IF any operation fails THEN:\n       - Rollback all changes\n       - Generate error: \"Failed to create topic: [specific reason]\"\n\n5. Response Generation:\n   5.1. On success:\n       - Return created topic identifier\n       - Include summary of topic details\n       - Include initial post identifier\n   5.2. On failure:\n       - Return appropriate error code\n       - Include detailed error message\n       - Provide guidance on resolving the issue",
    "databaseEntities": [
      "jforum_topics",
      "jforum_posts",
      "jforum_posts_text",
      "jforum_forums",
      "jforum_users",
      "jforum_attachments"
    ],
    "validationRules": [
      "Forum identifier must be valid",
      "User identifier must be valid",
      "Topic subject must not be empty",
      "Topic subject must not exceed maximum length",
      "Message content must not be empty",
      "Message content must not exceed maximum length",
      "User must have permission to create topics in the specified forum",
      "Forum must not be locked or archived",
      "User account must be active and not banned",
      "Attachments must be of allowed file types",
      "Attachments must not exceed size limits"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Topic": {
        "type": "object",
        "properties": {
          "id": {
            "type": "number"
          },
          "forumId": {
            "type": "number"
          },
          "subject": {
            "type": "string"
          },
          "userId": {
            "type": "number"
          },
          "creationDate": {
            "type": "date"
          },
          "lastPostDate": {
            "type": "date"
          },
          "type": {
            "type": "number"
          },
          "status": {
            "type": "number"
          },
          "priority": {
            "type": "number"
          }
        },
        "required": [
          "forumId",
          "subject",
          "userId"
        ]
      },
      "Attachment": {
        "type": "object",
        "properties": {
          "id": {
            "type": "number"
          },
          "fileName": {
            "type": "string"
          },
          "fileSize": {
            "type": "number"
          },
          "contentType": {
            "type": "string"
          },
          "fileContent": {
            "type": "object"
          }
        },
        "required": [
          "fileName",
          "fileContent"
        ]
      }
    }
  },
  {
    "featureName": "CreateUserDataAccess",
    "description": "Provides data access functionality for forum users in SQL Server environment.",
    "inputValues": [
      "userData-object-User",
      "databaseConnection-object-DatabaseConnection",
      "databaseType-string-DatabaseType"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect user data object containing:\n     - username (mandatory): User's login name\n     - email (mandatory): User's email address\n     - password (mandatory): User's encrypted password\n     - registrationDate (system-generated): Current timestamp\n     - lastVisit (system-generated): Current timestamp\n     - activationStatus (optional): Default to 'inactive' if not provided\n     - signature (optional): User's forum signature\n     - avatar (optional): User's profile image reference\n     - userRank (optional): Default to 'member' if not provided\n   - Obtain database connection object for data operations\n   - Determine database type from input (SQL Server in this case)\n\n2. Data Validation:\n   - Validate username:\n     - Check if username is not empty\n     - Verify username length is between 3 and 25 characters\n     - Ensure username contains only alphanumeric characters and underscores\n     - Verify username is unique in the system\n     - Return error message if validation fails: \"Invalid username format or username already exists\"\n   - Validate email:\n     - Check if email is not empty\n     - Verify email follows standard email format\n     - Ensure email is unique in the system\n     - Return error message if validation fails: \"Invalid email format or email already in use\"\n   - Validate password:\n     - Check if password is not empty\n     - Verify password meets minimum complexity requirements\n     - Return error message if validation fails: \"Password does not meet security requirements\"\n   - Validate database type:\n     - Check if database type is supported\n     - Verify database connection is compatible with specified type\n     - Return error message if validation fails: \"Unsupported database type or incompatible connection\"\n\n3. Business Rule Processing:\n   - Check system state:\n     - Verify user registration is currently allowed in system settings\n     - Check if maximum user limit has not been reached\n     - Return error message if checks fail: \"User registration is currently disabled\"\n   - Prepare user group associations:\n     - Determine default groups for new user based on system configuration\n     - Verify groups exist and are valid for new user assignment\n     - Return error message if validation fails: \"Unable to assign default user groups\"\n   - Initialize database access driver:\n     - Select appropriate data access implementation based on database type\n     - For SQL Server, use SQL Server specific implementation\n     - Verify driver availability for the database type\n     - Return error message if initialization fails: \"Unable to initialize data access driver for the specified database\"\n\n4. Core Operation Execution:\n   - Initialize the user data access object:\n     - Create instance of appropriate user DAO implementation\n     - Configure DAO with database connection parameters\n     - IF initialization fails, abort process and return error\n   - Create new user record:\n     - Generate unique user ID\n     - Set registration date and last visit to current time\n     - Set default values for optional fields if not provided\n     - Store user record in database using database-specific operations\n     - IF storage operation fails, abort process and return error\n   - Create user group associations:\n     - Link user to default groups in the system\n     - IF group association fails:\n       - Roll back user creation\n       - Return error message: \"Failed to create user group associations\"\n   - Initialize user preferences:\n     - Create default notification settings\n     - Set default forum view preferences\n     - IF preference initialization fails, log warning but continue\n\n5. Response Generation:\n   - On success:\n     - Return created user object with assigned ID\n     - Include success status indicator\n     - Include timestamp of user creation\n     - Return reference to the created user data access object\n   - On failure:\n     - Return error status\n     - Include specific error message explaining the failure reason\n     - Include error code for programmatic handling\n     - Provide guidance for resolving common errors",
    "databaseEntities": [
      "jforum_users",
      "jforum_groups",
      "jforum_user_groups",
      "jforum_posts",
      "jforum_topics"
    ],
    "validationRules": [
      "Username must not be empty",
      "Username must be between 3 and 25 characters",
      "Username must contain only alphanumeric characters and underscores",
      "Username must be unique in the system",
      "Email must not be empty",
      "Email must follow standard email format",
      "Email must be unique in the system",
      "Password must not be empty",
      "Password must meet minimum complexity requirements",
      "User registration must be currently allowed in system settings",
      "Maximum user limit must not be reached",
      "Database type must be supported by the system",
      "Database connection must be compatible with specified database type"
    ],
    "dbSeedingOperations": [
      "Ensure default user groups exist in jforum_groups",
      "Ensure system settings for user registration are configured",
      "Ensure database driver configurations are properly set for SQL Server"
    ],
    "schema": {
      "User": {
        "type": "object",
        "properties": {
          "id": {
            "type": "number",
            "description": "Unique identifier for the user"
          },
          "username": {
            "type": "string",
            "description": "User's login name"
          },
          "email": {
            "type": "string",
            "description": "User's email address"
          },
          "password": {
            "type": "string",
            "description": "User's encrypted password"
          },
          "registrationDate": {
            "type": "date",
            "description": "Date when user registered"
          },
          "lastVisit": {
            "type": "date",
            "description": "Date of user's last system access"
          },
          "activationStatus": {
            "type": "string",
            "description": "Account activation status"
          },
          "signature": {
            "type": "string",
            "description": "User's forum signature"
          },
          "avatar": {
            "type": "string",
            "description": "User's profile image reference"
          },
          "userRank": {
            "type": "string",
            "description": "User's rank in the forum"
          }
        },
        "required": [
          "username",
          "email",
          "password"
        ]
      },
      "DatabaseConnection": {
        "type": "object",
        "properties": {
          "connectionId": {
            "type": "string",
            "description": "Unique identifier for the database connection"
          },
          "status": {
            "type": "string",
            "description": "Current status of the connection"
          },
          "databaseType": {
            "type": "string",
            "description": "Type of database being connected to"
          }
        },
        "required": [
          "connectionId",
          "status"
        ]
      },
      "DatabaseType": {
        "type": "string",
        "enum": [
          "SQLServer",
          "MySQL",
          "PostgreSQL",
          "Oracle",
          "Generic"
        ],
        "description": "Supported database types for the forum system"
      }
    }
  },
  {
    "featureName": "CreatePrivateMessageDataAccess",
    "description": "Provides data access functionality for private messages in the system.",
    "inputValues": [
      "messageContent-string-PrivateMessage",
      "sender-object-User",
      "recipient-object-User",
      "subject-string-PrivateMessage",
      "sendDate-date-PrivateMessage",
      "messageType-number-PrivateMessage",
      "attachments-object-Attachment"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect required input fields:\n     1.1. messageContent (string, mandatory): The content of the private message\n     1.2. sender (object, mandatory): The user sending the message\n     1.3. recipient (object, mandatory): The user receiving the message\n     1.4. subject (string, mandatory): The subject line of the message\n     1.5. sendDate (date, mandatory): The date and time when the message is sent\n     1.6. messageType (number, mandatory): The type of private message\n     1.7. attachments (object, optional): Any files attached to the message\n\n2. Data Validation:\n   - Validate each input field:\n     2.1. messageContent validation:\n         a. Check if messageContent is not empty\n         b. Verify messageContent length is within allowed limits\n         c. IF validation fails, THEN return appropriate error message\n     2.2. sender validation:\n         a. Verify sender exists in the system\n         b. Check if sender has permission to send messages\n         c. IF validation fails, THEN return appropriate error message\n     2.3. recipient validation:\n         a. Verify recipient exists in the system\n         b. Check if recipient can receive messages\n         c. Verify recipient is not blocking messages from sender\n         d. IF validation fails, THEN return appropriate error message\n     2.4. subject validation:\n         a. Check if subject is not empty\n         b. Verify subject length is within allowed limits\n         c. IF validation fails, THEN return appropriate error message\n     2.5. sendDate validation:\n         a. Verify sendDate is a valid date format\n         b. Check if sendDate is not in the future\n         c. IF validation fails, THEN return appropriate error message\n     2.6. messageType validation:\n         a. Verify messageType is a valid type code\n         b. IF validation fails, THEN return appropriate error message\n     2.7. attachments validation (if provided):\n         a. Check if attachment size is within allowed limits\n         b. Verify attachment format is supported\n         c. IF validation fails, THEN return appropriate error message\n\n3. Business Rule Processing:\n   - Verify system state and constraints:\n     3.1. Check if the private messaging system is enabled\n     3.2. Verify sender has not exceeded their message quota\n     3.3. Check if recipient's inbox has available space\n     3.4. Verify any content filtering rules:\n         a. Check message content against prohibited content list\n         b. Scan attachments for potential security issues\n     3.5. IF any business rule fails, THEN return appropriate error message\n\n4. Core Operation Execution:\n   - Process the private message data:\n     4.1. Create new private message record:\n         a. Generate unique identifier for the message\n         b. Store message metadata (sender, recipient, subject, date, type)\n         c. Store message content in appropriate storage\n     4.2. Process attachments if present:\n         a. Store attachment data\n         b. Link attachments to the message\n     4.3. Update related records:\n         a. Update sender's sent messages count\n         b. Update recipient's unread messages count\n     4.4. IF any operation fails:\n         a. Rollback any partial data changes\n         b. Log the failure details\n         c. Return appropriate error message\n\n5. Response Generation:\n   - Prepare the operation result:\n     5.1. For successful operation:\n         a. Return success status\n         b. Include the created message identifier\n         c. Provide confirmation details\n     5.2. For failed operation:\n         a. Return failure status\n         b. Include specific error code\n         c. Provide detailed error message\n         d. Include suggestions for resolution if applicable",
    "databaseEntities": [
      "jforum_privmsgs",
      "jforum_privmsgs_text",
      "jforum_users",
      "jforum_attachments"
    ],
    "validationRules": [
      "Message content must not be empty",
      "Subject must not be empty",
      "Sender must be a valid user in the system",
      "Recipient must be a valid user in the system",
      "Message type must be a valid type code",
      "Send date must be a valid date not in the future",
      "Attachment size must be within allowed limits",
      "Attachment format must be supported by the system",
      "Sender must not have exceeded their message quota",
      "Recipient's inbox must have available space"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "User": {
        "type": "object",
        "properties": {
          "id": {
            "type": "number",
            "description": "Unique identifier for the user"
          },
          "username": {
            "type": "string",
            "description": "User's login name"
          },
          "email": {
            "type": "string",
            "description": "User's email address"
          },
          "messageQuota": {
            "type": "number",
            "description": "Maximum number of messages allowed"
          }
        },
        "required": [
          "id",
          "username"
        ]
      },
      "Attachment": {
        "type": "object",
        "properties": {
          "id": {
            "type": "number",
            "description": "Unique identifier for the attachment"
          },
          "filename": {
            "type": "string",
            "description": "Name of the attached file"
          },
          "filesize": {
            "type": "number",
            "description": "Size of the file in bytes"
          },
          "contentType": {
            "type": "string",
            "description": "MIME type of the attachment"
          },
          "data": {
            "type": "string",
            "description": "Binary content of the attachment"
          }
        },
        "required": [
          "filename",
          "data"
        ]
      }
    }
  },
  {
    "featureName": "CreateKarmaDataAccess",
    "description": "Provides data access functionality for karma system in SQL Server environment.",
    "inputValues": [
      "karmaId-number-Karma",
      "userId-number-User",
      "postId-number-Post",
      "points-number-Karma",
      "topicId-number-Topic",
      "rateDate-date-Karma",
      "karmaStatus-object-KarmaStatus"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect karma data inputs:\n     1.1. userId (mandatory): Identifier of the user giving karma\n     1.2. postId (mandatory): Identifier of the post receiving karma\n     1.3. points (mandatory): Numeric value representing karma points\n     1.4. topicId (optional): Identifier of the topic containing the post\n     1.5. rateDate (system-generated): Current timestamp when karma is given\n     1.6. karmaId (system-generated): Unique identifier for the karma entry\n\n2. Data Validation:\n   2.1. Validate userId:\n      - Check if userId is not null\n      - Verify userId exists in the jforum_users table\n      - IF userId is invalid THEN return error message \"Invalid user identifier\"\n   2.2. Validate postId:\n      - Check if postId is not null\n      - Verify postId exists in the jforum_posts table\n      - IF postId is invalid THEN return error message \"Invalid post identifier\"\n   2.3. Validate points:\n      - Check if points value is within allowed range\n      - IF points value is outside allowed range THEN return error message \"Karma points must be within valid range\"\n   2.4. Validate user karma permissions:\n      - Check if user has permission to give karma\n      - IF user lacks permission THEN return error message \"User does not have permission to give karma\"\n   2.5. Validate karma uniqueness:\n      - Check if user has already given karma to this post\n      - IF duplicate karma entry exists THEN return error message \"User has already rated this post\"\n\n3. Business Rule Processing:\n   3.1. Check system karma settings:\n      - Verify karma system is enabled\n      - Check minimum time between karma ratings\n      - IF karma system is disabled THEN return error message \"Karma system is currently disabled\"\n      - IF minimum time between ratings not met THEN return error message \"Please wait before giving more karma\"\n   3.2. Check post eligibility:\n      - Verify post is not locked or in a restricted forum\n      - Verify post is not the user's own post\n      - IF post is locked THEN return error message \"Cannot rate locked posts\"\n      - IF post belongs to the user THEN return error message \"Cannot rate your own posts\"\n   3.3. Calculate karma impact:\n      - Determine how the new karma affects the post's total karma\n      - Determine how the new karma affects the post author's total karma\n\n4. Core Operation Execution:\n   4.1. Create karma record:\n      - Generate new karma entry with collected data\n      - Associate karma with user, post, and topic\n      - Set timestamp for the karma action\n      - Store karma points value\n   4.2. Update related records:\n      - Update post's total karma score\n      - Update post author's total karma score\n      - Update karma count statistics\n   4.3. Handle transaction integrity:\n      - Ensure all updates are completed successfully\n      - IF any operation fails THEN rollback all changes and return error message \"Failed to process karma operation\"\n\n5. Response Generation:\n   5.1. For successful karma operation:\n      - Return success status\n      - Include updated karma totals for the post\n      - Include updated karma totals for the post author\n   5.2. For failed karma operation:\n      - Return failure status\n      - Include specific error message explaining the failure reason\n      - Include guidance for resolving the issue if applicable",
    "databaseEntities": [
      "jforum_karma",
      "jforum_users",
      "jforum_posts",
      "jforum_topics"
    ],
    "validationRules": [
      "User must exist in the system",
      "Post must exist in the system",
      "User must have permission to give karma",
      "User cannot rate their own posts",
      "User cannot rate the same post multiple times",
      "Karma points must be within the allowed range",
      "Karma system must be enabled",
      "Minimum time between karma ratings must be respected",
      "Post must not be in a locked state"
    ],
    "dbSeedingOperations": [
      "Ensure karma configuration settings are initialized",
      "Set up default karma permissions for user groups"
    ],
    "schema": {
      "KarmaStatus": {
        "type": "object",
        "properties": {
          "totalPoints": {
            "type": "number",
            "description": "Total karma points for the post"
          },
          "voterCount": {
            "type": "number",
            "description": "Number of users who have rated the post"
          },
          "userKarmaPoints": {
            "type": "number",
            "description": "Total karma points for the post author"
          },
          "lastVoteDate": {
            "type": "string",
            "format": "date-time",
            "description": "Timestamp of the last karma vote"
          }
        }
      }
    }
  },
  {
    "featureName": "SelectPrivateMessageById",
    "description": "Retrieves a private message by its unique identifier.",
    "inputValues": [
      "messageId-number-PrivateMessage"
    ],
    "businessLogic": "1. Input Collection\n   - Collect the private message ID (messageId) from the user request\n   - The messageId is mandatory and must be a positive integer\n   - No default value is provided; the user must specify a valid ID\n\n2. Data Validation\n   - Validate the messageId:\n     a. Verify that messageId is not null or empty\n     b. Confirm messageId is a valid positive integer\n     c. Check that messageId is within the acceptable range for database IDs\n   - IF any validation fails, THEN:\n     a. Generate appropriate error message indicating invalid message ID\n     b. Return error response to the user\n\n3. Business Rule Processing\n   - Verify system state and user permissions:\n     a. Check if the current user has permission to view the requested message\n     b. Verify if the message exists in the system\n     c. Determine if the user is either the sender or recipient of the message\n   - IF user lacks permission or message doesn't exist, THEN:\n     a. Generate appropriate error message about access restriction or non-existent message\n     b. Return error response to the user\n\n4. Core Operation Execution\n   - Retrieve the private message:\n     a. Search for the message with the specified ID in the message repository\n     b. Retrieve all associated message data including sender, recipient, subject, text content, and metadata\n     c. IF message is found, THEN format the message data for presentation\n     d. IF message is not found, THEN prepare a not-found response\n   - Update message status if needed:\n     a. IF message is unread AND current user is the recipient, THEN mark as read\n     b. Update the last access timestamp for the message\n\n5. Response Generation\n   - For successful retrieval:\n     a. Format the complete message details including sender information, timestamp, subject, and content\n     b. Include metadata such as read status, priority, and any attachments\n     c. Return the formatted message to the user\n   - For failed retrieval:\n     a. Generate appropriate error message explaining why retrieval failed\n     b. Include suggestions for troubleshooting if applicable\n     c. Return the error response to the user",
    "databaseEntities": [
      "jforum_privmsgs",
      "jforum_privmsgs_text",
      "jforum_users"
    ],
    "validationRules": [
      "Message ID must be a positive integer",
      "Message must exist in the database",
      "User must have permission to view the requested message",
      "User must be either the sender or recipient of the message"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "PrivateMessage": {
        "id": "number",
        "fromUser": "object",
        "toUser": "object",
        "subject": "string",
        "text": "string",
        "sendDate": "date",
        "readDate": "date",
        "isRead": "boolean",
        "type": "number"
      },
      "User": {
        "id": "number",
        "username": "string",
        "email": "string"
      }
    }
  },
  {
    "featureName": "SelectAllTopicsByForumWithPagination",
    "description": "Retrieves paginated forum topics with specified limit and offset.",
    "inputValues": [
      "forumId-number-Forum",
      "startFrom-number-Pagination",
      "count-number-Pagination"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect forumId (mandatory): numeric identifier of the forum\n   - Collect startFrom (mandatory): numeric value indicating the starting position for pagination\n   - Collect count (mandatory): numeric value indicating the number of topics to retrieve\n   - System will use these inputs to construct a paginated query\n\n2. Data Validation:\n   - Validate forumId:\n     a. Check if forumId is provided and is a positive integer\n     b. Check if forumId exists in the system\n     c. IF forumId is invalid or not found, THEN return appropriate error message\n   - Validate pagination parameters:\n     a. Check if startFrom is a non-negative integer\n     b. Check if count is a positive integer\n     c. IF either parameter is invalid, THEN return appropriate error message\n   - Validate user permissions:\n     a. Check if current user has permission to view the specified forum\n     b. IF user lacks permission, THEN return access denied error\n\n3. Business Rule Processing:\n   - Check forum status:\n     a. Verify if the forum is active and not archived\n     b. IF forum is inactive or archived, THEN return appropriate status message\n   - Apply forum visibility rules:\n     a. Check if forum is visible to the current user based on user groups and permissions\n     b. IF forum is not visible, THEN return access denied error\n   - Determine sorting criteria:\n     a. Apply default sorting (typically by last post date, descending)\n     b. Consider any user preferences or system settings for topic sorting\n\n4. Core Operation Execution:\n   - Calculate pagination boundaries:\n     a. Determine the start index based on startFrom parameter\n     b. Calculate the end index by adding count to startFrom\n   - Retrieve topics:\n     a. Query the topics for the specified forum with pagination limits\n     b. Include relevant topic metadata (title, creation date, last post date, etc.)\n     c. Include topic statistics (reply count, view count)\n     d. Include information about the topic creator and last poster\n   - Apply topic filtering:\n     a. Filter out topics based on user permissions and forum rules\n     b. Handle sticky/announcement topics according to forum display rules\n\n5. Response Generation:\n   - Prepare success response:\n     a. Format the list of topics with all required attributes\n     b. Include pagination metadata (current page, total pages, total topics)\n     c. Include forum information for context\n   - Handle empty results:\n     a. IF no topics match the criteria, THEN return empty list with appropriate metadata\n     b. Include pagination information even for empty results\n   - Error handling:\n     a. IF any database or system errors occur during retrieval, THEN return appropriate error message\n     b. Include error details for troubleshooting",
    "databaseEntities": [
      "jforum_topics",
      "jforum_forums",
      "jforum_posts",
      "jforum_users"
    ],
    "validationRules": [
      "Forum ID must be a positive integer",
      "Forum ID must reference an existing forum",
      "Start index must be a non-negative integer",
      "Count must be a positive integer",
      "User must have permission to view the specified forum",
      "Forum must be active and not archived"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Topic": {
        "id": "number",
        "title": "string",
        "forumId": "number",
        "creationDate": "date",
        "lastPostDate": "date",
        "userId": "number",
        "views": "number",
        "replies": "number",
        "status": "number",
        "isSticky": "boolean",
        "hasAttachments": "boolean",
        "lastPosterId": "number"
      },
      "Forum": {
        "id": "number",
        "name": "string",
        "description": "string",
        "categoryId": "number",
        "lastPostDate": "date",
        "totalTopics": "number",
        "totalPosts": "number"
      },
      "Pagination": {
        "startFrom": "number",
        "count": "number",
        "totalRecords": "number",
        "totalPages": "number"
      }
    }
  },
  {
    "featureName": "SelectUsersByGroup",
    "description": "Retrieves users belonging to a specific group with pagination support.",
    "inputValues": [
      "groupId-number-Group",
      "startFrom-number-Pagination",
      "count-number-Pagination"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the following inputs:\n     a. groupId (mandatory): Numeric identifier of the group to filter users by\n     b. startFrom (mandatory): Numeric value indicating the starting position for pagination\n     c. count (mandatory): Numeric value indicating the maximum number of users to return\n\n2. Data Validation:\n   - Validate groupId:\n     a. Verify groupId is a positive integer\n     b. IF groupId is missing or invalid THEN\n        i. Generate appropriate error message\n        ii. Terminate operation\n   - Validate pagination parameters:\n     a. Verify startFrom is a non-negative integer\n     b. Verify count is a positive integer\n     c. IF any pagination parameter is invalid THEN\n        i. Generate appropriate error message\n        ii. Terminate operation\n\n3. Business Rule Processing:\n   - Verify group existence:\n     a. Check if the specified group exists in the system\n     b. IF group does not exist THEN\n        i. Generate \"Group not found\" error message\n        ii. Terminate operation\n   - Verify user access permissions:\n     a. Check if the current user has permission to view users in the specified group\n     b. IF user lacks permission THEN\n        i. Generate \"Insufficient permissions\" error message\n        ii. Terminate operation\n\n4. Core Operation Execution:\n   - Prepare user retrieval operation:\n     a. Formulate query to select users belonging to the specified group\n     b. Apply pagination parameters (startFrom and count) to limit results\n     c. Execute the query to retrieve matching user records\n     d. IF query execution fails THEN\n        i. Log the error details\n        ii. Generate system error message\n        iii. Terminate operation\n   - Process retrieved user records:\n     a. For each user record retrieved:\n        i. Extract user information (ID, username, registration date, etc.)\n        ii. Format user data according to system requirements\n        iii. Add formatted user data to result collection\n     b. IF no users found in the specified group THEN\n        i. Return empty result collection\n\n5. Response Generation:\n   - Prepare success response:\n     a. Include the collection of user records\n     b. Include pagination metadata:\n        i. Total number of users in the group\n        ii. Current page information\n        iii. Indication if more users are available\n     c. Return formatted response to caller\n   - Handle error scenarios:\n     a. For validation errors, return specific error messages\n     b. For system errors, return appropriate error codes and messages\n     c. Include support information for troubleshooting",
    "databaseEntities": [
      "jforum_users",
      "jforum_groups",
      "jforum_user_groups"
    ],
    "validationRules": [
      "Group ID must be a positive integer",
      "Start position must be a non-negative integer",
      "Count must be a positive integer",
      "Group must exist in the system",
      "User must have permission to view group members"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "User": {
        "type": "object",
        "properties": {
          "id": {
            "type": "number",
            "description": "Unique identifier for the user"
          },
          "username": {
            "type": "string",
            "description": "User's login name"
          },
          "registrationDate": {
            "type": "date",
            "description": "Date when user registered"
          },
          "email": {
            "type": "string",
            "description": "User's email address"
          }
        }
      },
      "Group": {
        "type": "object",
        "properties": {
          "id": {
            "type": "number",
            "description": "Unique identifier for the group"
          },
          "name": {
            "type": "string",
            "description": "Name of the group"
          },
          "description": {
            "type": "string",
            "description": "Description of the group"
          }
        }
      },
      "Pagination": {
        "type": "object",
        "properties": {
          "startFrom": {
            "type": "number",
            "description": "Starting position for pagination"
          },
          "count": {
            "type": "number",
            "description": "Maximum number of records to return"
          },
          "total": {
            "type": "number",
            "description": "Total number of records available"
          }
        }
      }
    }
  },
  {
    "featureName": "SelectAllUsersWithKarma",
    "description": "Retrieves users with their karma information and pagination support.",
    "inputValues": [
      "startFrom-number-User",
      "count-number-User"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the following inputs:\n     - startFrom (number): The starting index for pagination (mandatory)\n     - count (number): The maximum number of users to retrieve (mandatory)\n\n2. Data Validation:\n   - Validate startFrom parameter:\n     - IF startFrom is negative THEN\n       - Generate error message: \"Starting index must be a non-negative number\"\n     - END IF\n   - Validate count parameter:\n     - IF count is negative THEN\n       - Generate error message: \"Count must be a non-negative number\"\n     - END IF\n\n3. Business Rule Processing:\n   - Check system state:\n     - Verify database connection is available\n     - IF database connection is unavailable THEN\n       - Generate error: \"Database connection error\"\n       - Exit process\n     - END IF\n   - Determine pagination approach:\n     - IF count is greater than 0 THEN\n       - Use limited query approach with pagination parameters\n     - ELSE\n       - Use standard query to retrieve all users\n     - END IF\n\n4. Core Operation Execution:\n   - Retrieve basic user information:\n     - IF using limited query approach THEN\n       - Retrieve users from database using startFrom and count parameters\n       - Position result cursor at the startFrom position\n     - ELSE\n       - Retrieve all users from database\n     - END IF\n   - Process retrieved user records:\n     - For each user record:\n       - Extract user attributes (id, username, email, etc.)\n       - Create user object with extracted attributes\n     - Add user object to results collection\n   - Enhance user data with karma information:\n     - For each user in the results collection:\n       - Retrieve karma data associated with the user\n       - Calculate total karma value\n       - Attach karma information to user object\n\n5. Response Generation:\n   - Prepare response with user collection:\n     - Format each user with their attributes and karma information\n     - Include pagination metadata:\n       - Total number of users available\n       - Current page information\n       - More results indicator\n   - Return the collection of users with karma information\n   - IF any errors occurred during processing THEN\n     - Generate appropriate error response\n     - Include error details and suggestions for resolution\n   - END IF",
    "databaseEntities": [
      "jforum_users",
      "jforum_karma"
    ],
    "validationRules": [
      "Starting index (startFrom) must be a non-negative number",
      "Count must be a non-negative number",
      "Database connection must be available"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "User": {
        "type": "object",
        "properties": {
          "id": {
            "type": "number"
          },
          "username": {
            "type": "string"
          },
          "email": {
            "type": "string"
          },
          "registrationDate": {
            "type": "date"
          },
          "karma": {
            "type": "object",
            "properties": {
              "karmaPoints": {
                "type": "number"
              },
              "karmaVotes": {
                "type": "number"
              }
            }
          }
        }
      }
    }
  },
  {
    "featureName": "CreateModerationLogDataAccess",
    "description": "Provides data access implementation for moderation logs in SQL Server 2000 environment.",
    "inputValues": [
      "moderationAction-string-ModerationLog",
      "moderationDate-date-ModerationLog",
      "moderatorId-number-User",
      "postId-number-Post",
      "topicId-number-Topic",
      "description-string-ModerationLog"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect moderation log data:\n     1.1. Collect moderationAction (mandatory): The type of moderation action performed\n     1.2. Collect moderationDate (mandatory): The date when the moderation action occurred\n     1.3. Collect moderatorId (mandatory): The identifier of the user who performed the moderation\n     1.4. Collect postId (optional): The identifier of the post being moderated, if applicable\n     1.5. Collect topicId (optional): The identifier of the topic being moderated, if applicable\n     1.6. Collect description (optional): Additional details about the moderation action\n\n2. Data Validation:\n   2.1. Validate moderationAction:\n      - Check if moderationAction is not empty\n      - Verify moderationAction is one of the allowed moderation types\n      - IF validation fails, THEN return appropriate error message\n   2.2. Validate moderationDate:\n      - Check if moderationDate is not empty\n      - Verify moderationDate is not in the future\n      - IF validation fails, THEN return appropriate error message\n   2.3. Validate moderatorId:\n      - Check if moderatorId is not empty\n      - Verify moderatorId exists in the user database\n      - Verify user has moderation privileges\n      - IF validation fails, THEN return appropriate error message\n   2.4. Validate postId (if provided):\n      - Verify postId exists in the post database\n      - IF validation fails, THEN return appropriate error message\n   2.5. Validate topicId (if provided):\n      - Verify topicId exists in the topic database\n      - IF validation fails, THEN return appropriate error message\n\n3. Business Rule Processing:\n   3.1. Check system state:\n      - Verify database connection is available\n      - Verify user session is valid\n      - IF any check fails, THEN return system unavailable error\n   3.2. Check moderation permissions:\n      - Verify the moderator has permission for the specified action\n      - Verify the moderator has permission for the specified forum section\n      - IF permission check fails, THEN return permission denied error\n\n4. Core Operation Execution:\n   4.1. Prepare moderation log entry:\n      - Format all collected data according to storage requirements\n      - Generate unique identifier for the log entry\n   4.2. Store moderation log entry:\n      - Create new record in the moderation log storage\n      - Link to related entities (posts, topics, users)\n      - IF storage operation fails, THEN:\n        - Revert any partial changes\n        - Return storage failure error\n   4.3. Update related records:\n      - Update moderation status on affected posts or topics\n      - Update moderation count for the moderator\n      - IF update operations fail, THEN:\n        - Attempt to roll back changes\n        - Return update failure error\n\n5. Response Generation:\n   5.1. For successful operation:\n      - Return success status\n      - Include the identifier of the created moderation log entry\n      - Include timestamp of the operation\n   5.2. For failed operation:\n      - Return failure status\n      - Include specific error code and message\n      - Include guidance for resolving the issue\n      - Log detailed error information for system administrators",
    "databaseEntities": [
      "jforum_users",
      "jforum_topics",
      "jforum_posts",
      "jforum_moderation_log"
    ],
    "validationRules": [
      "Moderation action must not be empty",
      "Moderation date must not be empty or in the future",
      "Moderator ID must exist in the user database",
      "Moderator must have moderation privileges",
      "Post ID must exist in the post database if provided",
      "Topic ID must exist in the topic database if provided",
      "At least one of Post ID or Topic ID must be provided"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "ModerationLog": {
        "type": "object",
        "properties": {
          "id": {
            "type": "number",
            "description": "Unique identifier for the moderation log entry"
          },
          "moderationAction": {
            "type": "string",
            "description": "Type of moderation action performed"
          },
          "moderationDate": {
            "type": "date",
            "description": "Date when the moderation action occurred"
          },
          "moderatorId": {
            "type": "number",
            "description": "Identifier of the user who performed the moderation"
          },
          "postId": {
            "type": "number",
            "description": "Identifier of the post being moderated, if applicable"
          },
          "topicId": {
            "type": "number",
            "description": "Identifier of the topic being moderated, if applicable"
          },
          "description": {
            "type": "string",
            "description": "Additional details about the moderation action"
          }
        },
        "required": [
          "moderationAction",
          "moderationDate",
          "moderatorId"
        ]
      }
    }
  },
  {
    "featureName": "SelectLatestForumPostsForRSS",
    "description": "Retrieves latest posts from a specific forum formatted for RSS feeds.",
    "inputValues": [
      "forumId-number-Forum",
      "limit-number-System"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect forumId (mandatory): numeric identifier of the forum to retrieve posts from\n   - Collect limit (mandatory): maximum number of posts to retrieve\n   - System will use current user's access permissions (system-generated)\n\n2. Data Validation:\n   - Validate forumId:\n      * Must be a positive integer\n      * Must correspond to an existing forum in the system\n      * Error message if forum doesn't exist: \"The specified forum does not exist\"\n   - Validate limit:\n      * Must be a positive integer\n      * Must not exceed system-defined maximum (e.g., 50)\n      * Error message if limit exceeds maximum: \"Requested number of posts exceeds the allowed maximum\"\n   - Validate user permissions:\n      * Verify current user has read access to the specified forum\n      * Error message if access denied: \"You do not have permission to view this forum\"\n\n3. Business Rule Processing:\n   - Check forum status:\n      * IF forum is active THEN continue\n      * ELSE return error: \"The requested forum is not active\"\n   - Check content availability:\n      * IF forum contains posts THEN continue\n      * ELSE return empty result set with notification: \"No posts available in this forum\"\n\n4. Core Operation Execution:\n   - Retrieve posts from the specified forum:\n      * Select posts ordered by post time (newest first)\n      * Limit results to the specified number\n      * Include only posts from topics that are not private or deleted\n   - For each post retrieved:\n      * Extract post ID, subject, text content, topic ID, forum ID\n      * Extract author information (user ID, username)\n      * Format post date/time appropriately for RSS\n      * Build complete post object with all required RSS fields\n   - If any database error occurs during retrieval:\n      * Log the error details\n      * Return system error: \"Unable to retrieve forum posts at this time\"\n\n5. Response Generation:\n   - Compile list of post objects:\n      * Each post contains: ID, subject, content, topic ID, forum ID, author details, and timestamp\n   - Format response for RSS consumption:\n      * Include all required RSS metadata\n      * Format post content according to RSS specifications\n   - Return the formatted list of posts:\n      * If posts were found, return the complete list with success status\n      * If no posts match criteria, return empty list with appropriate notification",
    "databaseEntities": [
      "jforum_forums",
      "jforum_posts",
      "jforum_posts_text",
      "jforum_topics",
      "jforum_users"
    ],
    "validationRules": [
      "Forum ID must be a positive integer",
      "Forum ID must reference an existing forum",
      "Limit must be a positive integer",
      "Limit must not exceed system maximum",
      "User must have read access to the specified forum",
      "Forum must be active to retrieve posts"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Post": {
        "id": "number",
        "subject": "string",
        "text": "string",
        "topicId": "number",
        "forumId": "number",
        "userId": "number",
        "username": "string",
        "postTime": "date"
      }
    }
  },
  {
    "featureName": "SelectHotPostsForRSS",
    "description": "Retrieves popular posts across forums formatted for RSS feeds.",
    "inputValues": [
      "limit-number-Post"
    ],
    "businessLogic": "1. Input Collection\n   - Collect the following inputs:\n     - limit (number, mandatory): Maximum number of posts to retrieve\n\n2. Data Validation\n   - Validate limit parameter:\n     - IF limit is null or undefined THEN\n       - Set default limit to system-defined value\n     - IF limit is not a positive integer THEN\n       - Return error message indicating limit must be a positive integer\n     - IF limit exceeds maximum allowed value THEN\n       - Cap limit to maximum allowed value\n\n3. Business Rule Processing\n   - Check system state:\n     - IF system is in maintenance mode THEN\n       - Return appropriate error message\n     - IF RSS feed functionality is disabled THEN\n       - Return appropriate error message\n   - Verify user permissions:\n     - IF current user does not have permission to view RSS feeds THEN\n       - Return access denied message\n   - Determine accessible forums:\n     - Get list of forums the current user has permission to view\n     - IF no accessible forums exist THEN\n       - Return empty result set\n\n4. Core Operation Execution\n   - Query database for hot posts:\n     - Select posts based on popularity criteria (such as view count, reply count)\n     - Filter posts to only include those from accessible forums\n     - Order posts by popularity metrics in descending order\n     - Limit results to specified limit parameter\n   - For each post retrieved:\n     - Extract post details (ID, subject, content, topic ID, forum ID)\n     - Extract author information (user ID, username)\n     - Extract timestamp information\n     - Format post content for RSS compatibility\n     - Create post object with all required information\n     - Add post object to result collection\n   - IF no posts match criteria THEN\n     - Return empty result collection\n\n5. Response Generation\n   - Prepare RSS-compatible response:\n     - Format collection of post objects for RSS feed\n     - Include metadata such as feed title, description, and generation timestamp\n     - Return formatted collection of posts\n   - IF any errors occurred during processing THEN\n     - Log error details\n     - Return appropriate error message",
    "databaseEntities": [
      "jforum_posts",
      "jforum_posts_text",
      "jforum_topics",
      "jforum_forums",
      "jforum_users"
    ],
    "validationRules": [
      "Limit parameter must be a positive integer",
      "User must have permission to access the forums containing the posts",
      "Only posts from publicly accessible forums should be included",
      "Posts must be ordered by popularity metrics",
      "Result set must not exceed the specified limit"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Post": {
        "id": "number",
        "subject": "string",
        "text": "string",
        "topicId": "number",
        "forumId": "number",
        "userId": "number",
        "postUsername": "string",
        "time": "date"
      }
    }
  },
  {
    "featureName": "CheckAttachmentThumbnail",
    "description": "Determines if a thumbnail exists for the attachment based on system configuration.",
    "inputValues": [
      "attachment-object-Attachment",
      "systemConfiguration-object-SystemConfiguration"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the attachment object with its information\n   - Retrieve system configuration settings\n     - Thumbnail creation setting (enabled/disabled)\n     - Attachment storage directory path\n\n2. Data Validation:\n   - Validate attachment object exists\n     - IF attachment is NULL THEN\n       - Return error indicating invalid attachment\n     - END IF\n   - Validate attachment info exists\n     - IF attachment info is NULL THEN\n       - Return error indicating incomplete attachment data\n     - END IF\n   - Validate physical filename exists in attachment info\n     - IF physical filename is empty or NULL THEN\n       - Return error indicating missing filename\n     - END IF\n   - Validate system configuration\n     - IF system configuration is NULL THEN\n       - Return error indicating missing configuration\n     - END IF\n\n3. Business Rule Processing:\n   - Check if thumbnail creation is enabled in system configuration\n     - IF thumbnail creation setting is disabled THEN\n       - Return FALSE as thumbnails are not supported\n     - END IF\n   - Determine the expected thumbnail file path\n     - Construct path using storage directory and attachment's physical filename\n     - Append \"_thumb\" suffix to the physical filename\n\n4. Core Operation Execution:\n   - Check for thumbnail file existence\n     - Verify if the file exists at the constructed path\n     - IF file exists at the path THEN\n       - Set thumbnail existence flag to TRUE\n     - ELSE\n       - Set thumbnail existence flag to FALSE\n     - END IF\n   - IF thumbnail exists THEN\n     - Generate the accessible thumbnail path\n     - Construct using upload directory path and physical filename with \"_thumb\" suffix\n   - END IF\n\n5. Response Generation:\n   - Return the thumbnail existence status (TRUE/FALSE)\n   - IF thumbnail exists THEN\n     - Include the accessible thumbnail path in the response\n   - END IF",
    "databaseEntities": [
      "jforum_attachments"
    ],
    "validationRules": [
      "Attachment object must not be null",
      "Attachment info must not be null",
      "Physical filename must not be empty",
      "System configuration must be properly initialized",
      "Thumbnail creation setting must be accessible in system configuration",
      "Storage directory path must be defined in system configuration"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Attachment": {
        "id": "number",
        "postId": "number",
        "privmsgsId": "number",
        "userId": "number",
        "info": {
          "type": "object",
          "properties": {
            "physicalFilename": "string"
          }
        }
      },
      "SystemConfiguration": {
        "thumbnailCreationEnabled": "boolean",
        "attachmentStorageDirectory": "string",
        "attachmentUploadDirectory": "string"
      }
    }
  },
  {
    "featureName": "GetAttachmentThumbnailPath",
    "description": "Retrieves the file path for an attachment's thumbnail image.",
    "inputValues": [
      "attachment-object-Attachment"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the attachment object with its associated information\n     1.1. Verify the attachment object is not null\n     1.2. Ensure the attachment contains info property with physical filename\n     1.3. System will use configuration settings for path construction\n\n2. Data Validation:\n   - Validate the attachment data is complete and accessible\n     2.1. Verify the attachment info object exists\n        2.1.1. IF attachment info is null THEN return error indicating missing attachment information\n     2.2. Verify the physical filename exists in the attachment info\n        2.2.1. IF physical filename is empty or null THEN return error indicating invalid attachment\n     2.3. Validate system configuration is available\n        2.3.1. Ensure upload directory configuration exists\n        2.3.2. IF configuration is missing THEN return error indicating system configuration issue\n\n3. Business Rule Processing:\n   - Determine the thumbnail path based on system configuration and attachment data\n     3.1. Retrieve the base upload directory from system configuration\n        3.1.1. Get the value for attachments upload directory from system settings\n     3.2. Combine the base directory with attachment's physical filename\n        3.2.1. Append the physical filename from the attachment info\n        3.2.2. Append the \"_thumb\" suffix to indicate this is a thumbnail path\n     3.3. Format the path according to system requirements\n        3.3.1. Ensure proper directory separators are used\n        3.3.2. Normalize the path if required by the system\n\n4. Core Operation Execution:\n   - Construct the complete thumbnail path\n     4.1. Start with the base upload directory path\n     4.2. Add directory separator character\n     4.3. Append the physical filename of the attachment\n     4.4. Append the \"_thumb\" suffix to the filename\n     4.5. Combine all elements into a complete file path string\n\n5. Response Generation:\n   - Return the constructed thumbnail path\n     5.1. IF path construction is successful THEN return the complete thumbnail path string\n     5.2. IF any errors occurred during path construction THEN return appropriate error message\n     5.3. Include the path format in the response for reference",
    "databaseEntities": [
      "jforum_attachments"
    ],
    "validationRules": [
      "Attachment object must not be null",
      "Attachment info object must not be null",
      "Physical filename must exist in the attachment info",
      "System configuration for upload directory must be available"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Attachment": {
        "id": "number",
        "postId": "number",
        "privmsgsId": "number",
        "userId": "number",
        "info": {
          "type": "object",
          "properties": {
            "physicalFilename": "string"
          }
        }
      }
    }
  },
  {
    "featureName": "MatchBanlistEntry",
    "description": "Determines if a banlist entry matches another based on user ID, email, or IP address patterns.",
    "inputValues": [
      "banlistEntry-object-Banlist",
      "banlistToCompare-object-Banlist"
    ],
    "businessLogic": "1. Input Collection\n   - Collect the following inputs:\n     a. banlistEntry (Banlist object, mandatory) - The reference banlist entry to check against\n     b. banlistToCompare (Banlist object, mandatory) - The banlist entry to be compared\n\n2. Data Validation\n   - Validate banlistEntry:\n     a. Verify banlistEntry is not null\n     b. Check if at least one of the following fields is populated: userId, email, or ip\n   - Validate banlistToCompare:\n     a. Verify banlistToCompare is not null\n     b. Check if at least one of the following fields is populated: userId, email, or ip\n   - IF any validation fails, THEN\n     a. Generate appropriate error message\n     b. Return error response\n\n3. Business Rule Processing\n   - Check for userId match:\n     a. IF both banlistEntry.userId and banlistToCompare.userId are greater than 0, THEN\n        i. Compare if banlistEntry.userId equals banlistToCompare.userId\n        ii. IF equal, set match status to true\n   - Check for email match:\n     a. IF both banlistEntry.email and banlistToCompare.email are not empty, THEN\n        i. Compare if banlistEntry.email equals banlistToCompare.email\n        ii. IF equal, set match status to true\n   - Check for IP address match:\n     a. IF both banlistEntry.ip and banlistToCompare.ip are not empty, THEN\n        i. IF banlistEntry.ip exactly equals banlistToCompare.ip, THEN\n           * Set match status to true\n        ii. ELSE perform pattern matching:\n           * Split both IP addresses into segments using dot (.) as separator\n           * IF both IPs have the same number of segments, THEN\n             - Compare each segment:\n               + IF reference segment is not wildcard (*), THEN\n                 > Compare segment values for equality\n                 > IF any non-wildcard segment doesn't match, set match status to false\n               + Track if all segments are wildcards\n             - IF at least one segment is not a wildcard AND all compared segments match, THEN\n               + Set match status to true\n\n4. Core Operation Execution\n   - Determine final match result:\n     a. IF any of the following conditions are true:\n        i. User IDs match (both greater than 0 and equal)\n        ii. Emails match (both non-empty and equal)\n        iii. IP addresses match (either exact match or pattern match)\n        THEN set final result to true (match found)\n     b. ELSE set final result to false (no match)\n\n5. Response Generation\n   - Return the match result:\n     a. IF match found, THEN return true\n     b. ELSE return false",
    "databaseEntities": [
      "jforum_users"
    ],
    "validationRules": [
      "At least one banlist entry field (userId, email, or ip) must be populated",
      "User ID must be greater than 0 to be considered for matching",
      "Email addresses must be non-empty to be considered for matching",
      "IP addresses must be non-empty to be considered for matching",
      "IP pattern matching requires the same number of segments in both addresses",
      "IP pattern matching requires at least one non-wildcard segment"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Banlist": {
        "type": "object",
        "properties": {
          "id": {
            "type": "number",
            "description": "Unique identifier for the banlist entry"
          },
          "userId": {
            "type": "number",
            "description": "User ID associated with the ban"
          },
          "ip": {
            "type": "string",
            "description": "IP address or pattern associated with the ban"
          },
          "email": {
            "type": "string",
            "description": "Email address associated with the ban"
          }
        }
      }
    }
  },
  {
    "featureName": "CompareIpAddresses",
    "description": "Compares IP addresses with support for wildcard matching patterns.",
    "inputValues": [
      "ipAddress1-string-IpAddress",
      "ipAddress2-string-IpAddress"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect ipAddress1 (string, mandatory): The first IP address for comparison\n   - Collect ipAddress2 (string, mandatory): The second IP address for comparison\n   - System will determine if wildcards (*) are present in either address\n\n2. Data Validation:\n   - Validate ipAddress1 format:\n     a. Check if ipAddress1 is not empty\n     b. Verify ipAddress1 follows IP address format (xxx.xxx.xxx.xxx) where xxx can be a number or wildcard (*)\n     c. Ensure ipAddress1 has exactly 4 segments separated by periods\n     d. Return error if validation fails\n   - Validate ipAddress2 format:\n     a. Check if ipAddress2 is not empty\n     b. Verify ipAddress2 follows IP address format (xxx.xxx.xxx.xxx) where xxx can be a number or wildcard (*)\n     c. Ensure ipAddress2 has exactly 4 segments separated by periods\n     d. Return error if validation fails\n\n3. Business Rule Processing:\n   - Check for exact match:\n     a. IF ipAddress1 equals ipAddress2 (case-insensitive comparison)\n        THEN return match result as true\n   - Check for special cases:\n     a. IF either address consists of only wildcards (*.*.*.* format)\n        THEN return match result as false (prevent overly broad matching)\n\n4. Core Operation Execution:\n   - Split both IP addresses into segments:\n     a. Split ipAddress1 by period (.) delimiter into segments\n     b. Split ipAddress2 by period (.) delimiter into segments\n   - Compare segments one by one:\n     a. Initialize match status as true\n     b. Initialize wildcard-only flag as true\n     c. FOR each segment position (0 to 3):\n        i. IF current segment in either address is not a wildcard (*)\n           THEN set wildcard-only flag to false\n        ii. IF current segment in ipAddress1 is not a wildcard AND current segments don't match\n            THEN set match status to false and exit loop\n     d. IF wildcard-only flag is true\n        THEN set match status to false (prevent matching on all wildcards)\n\n5. Response Generation:\n   - Return the match result:\n     a. IF match status is true\n        THEN return successful match indication\n     b. ELSE return no match indication\n   - Include comparison details:\n     a. The original IP addresses compared\n     b. Which segments matched and which didn't\n     c. Whether wildcards were involved in the comparison",
    "databaseEntities": [
      "jforum_users"
    ],
    "validationRules": [
      "IP addresses must not be empty",
      "IP addresses must have exactly 4 segments separated by periods",
      "Each segment must be either a number or a wildcard (*)",
      "An IP address consisting only of wildcards (*.*.*.*) is considered invalid for matching",
      "Comparison must be case-insensitive"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "IpAddress": {
        "type": "object",
        "properties": {
          "address": {
            "type": "string",
            "description": "The IP address in xxx.xxx.xxx.xxx format where xxx can be a number or wildcard (*)"
          },
          "segments": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "The IP address split into its four segments"
          }
        }
      }
    }
  },
  {
    "featureName": "CalculateTotalVotes",
    "description": "Calculates the total number of votes across all options in a poll.",
    "inputValues": [
      "poll-object-Poll"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the Poll object which contains:\n     - id (number): Unique identifier for the poll\n     - topicId (number): Associated topic identifier\n     - label (string): The poll question or title\n     - options (list): Collection of PollOption objects\n     - Each PollOption contains:\n       - voteCount (number): Number of votes for this option\n\n2. Data Validation:\n   - Verify Poll object is not null\n     - IF Poll is null THEN\n       - Return error: \"Invalid poll data provided\"\n     - END IF\n   - Verify Poll options list is accessible\n     - IF options list cannot be accessed THEN\n       - Return error: \"Cannot access poll options\"\n     - END IF\n\n3. Business Rule Processing:\n   - Check if poll is active\n     - IF poll has a length value greater than 0 THEN\n       - Calculate end time by adding length (in days) to start time\n       - IF current time is after end time THEN\n         - Mark poll as closed\n       - END IF\n     - END IF\n\n4. Core Operation Execution:\n   - Initialize vote counter to zero\n   - FOR EACH option in the poll options list:\n     - Retrieve the vote count from the option\n     - Add the option's vote count to the total vote counter\n   - END FOR\n\n5. Response Generation:\n   - Return the calculated total votes count\n   - Include poll status (open or closed) in the response\n   - IF total votes is zero THEN\n     - Include notification that no votes have been cast yet\n   - END IF",
    "databaseEntities": [
      "jforum_topics"
    ],
    "validationRules": [
      "Poll object must not be null",
      "Poll options list must be accessible",
      "Each poll option must have a valid vote count"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Poll": {
        "type": "object",
        "properties": {
          "id": {
            "type": "number",
            "description": "Unique identifier for the poll"
          },
          "topicId": {
            "type": "number",
            "description": "Associated topic identifier"
          },
          "length": {
            "type": "number",
            "description": "Duration of the poll in days (0 means no limit)"
          },
          "label": {
            "type": "string",
            "description": "The poll question or title"
          },
          "startTime": {
            "type": "date",
            "description": "When the poll was started"
          },
          "options": {
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "voteCount": {
                  "type": "number",
                  "description": "Number of votes for this option"
                },
                "text": {
                  "type": "string",
                  "description": "The text of this poll option"
                }
              }
            },
            "description": "List of available options in this poll"
          }
        }
      }
    }
  },
  {
    "featureName": "CheckPollStatus",
    "description": "Determines if a poll is open based on its start time and duration.",
    "inputValues": [
      "startTime-date-Poll",
      "length-number-Poll"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect poll start time (startTime) as a date value\n   - Collect poll duration (length) in days as a number value\n   - Note: Both values are mandatory for status determination\n\n2. Data Validation:\n   - Validate startTime:\n     * Ensure startTime is a valid date\n     * Verify startTime is not null\n     * Check that startTime is properly formatted\n     * IF startTime is invalid THEN return validation error\n   - Validate length:\n     * Ensure length is a non-negative number\n     * Verify length is properly formatted as an integer\n     * IF length is negative THEN return validation error\n\n3. Business Rule Processing:\n   - Check for special case handling:\n     * IF length equals 0 THEN\n       > Poll is considered permanently open\n       > Skip duration calculation\n       > Set poll status to \"open\"\n       > Proceed to Response Generation\n     * ELSE continue to duration calculation\n   - Calculate poll end date:\n     * Create end date by adding length (in days) to startTime\n     * Store calculated end date for comparison\n\n4. Core Operation Execution:\n   - Determine current system time\n   - Compare current time with calculated end date:\n     * IF current time is before the end date THEN\n       > Set poll status to \"open\"\n     * ELSE\n       > Set poll status to \"closed\"\n   - Record determination result\n\n5. Response Generation:\n   - Return poll status result (open or closed)\n   - Include additional context information:\n     * Poll identifier\n     * Current status\n     * End date (if applicable)\n     * Remaining time (if poll is open and has a duration)",
    "databaseEntities": [
      "jforum_topics"
    ],
    "validationRules": [
      "Poll start time must be a valid date",
      "Poll length must be a non-negative integer",
      "Poll is considered open if length is 0",
      "Poll is open if current time is before end time",
      "Poll is closed if current time is after end time"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Poll": {
        "id": "number",
        "topicId": "number",
        "length": "number",
        "label": "string",
        "startTime": "date",
        "options": "array"
      },
      "PollOption": {
        "id": "number",
        "pollId": "number",
        "text": "string",
        "voteCount": "number"
      }
    }
  },
  {
    "featureName": "ManagePollOptions",
    "description": "Adds and removes options from a poll with proper relationship management.",
    "inputValues": [
      "pollId-number-Poll",
      "pollOption-object-PollOption",
      "action-string-Poll"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the following inputs:\n     * pollId (mandatory): Unique identifier for the poll to be modified\n     * pollOption (mandatory): The poll option to be added or removed\n     * action (mandatory): The operation to perform ('add' or 'remove')\n\n2. Data Validation:\n   - Validate Poll ID:\n     * Verify pollId is a positive integer\n     * Verify poll exists in the system\n     * IF poll does not exist, THEN return error message \"Poll not found\"\n   - Validate Poll Option:\n     * Verify pollOption has a non-empty text value\n     * IF adding option, verify option text is not empty\n     * IF adding option, verify option text length is within allowed limits\n     * IF removing option, verify option ID exists\n   - Validate Action:\n     * Verify action is either 'add' or 'remove'\n     * IF action is invalid, THEN return error message \"Invalid action specified\"\n\n3. Business Rule Processing:\n   - Check Poll Status:\n     * Verify if poll is still open for modifications\n     * IF poll has already ended, THEN return error message \"Cannot modify options for a closed poll\"\n   - Check Option Constraints:\n     * IF adding option AND poll already has maximum allowed options, THEN return error message \"Maximum number of options reached\"\n     * IF removing option AND poll has only one option remaining, THEN return error message \"Poll must have at least one option\"\n   - Check Voting Status:\n     * IF removing option AND option has votes, THEN confirm with user about vote deletion\n     * IF user does not confirm deletion of votes, THEN cancel operation\n\n4. Core Operation Execution:\n   - Process Add Option:\n     * IF action is 'add', THEN:\n       - Create new poll option record\n       - Associate option with the poll\n       - Initialize vote count to zero\n       - Record change in poll modification history\n   - Process Remove Option:\n     * IF action is 'remove', THEN:\n       - Remove association between option and poll\n       - Delete option votes if any\n       - Record change in poll modification history\n   - Update Poll:\n     * Update last modified timestamp for the poll\n     * Recalculate total votes for the poll\n\n5. Response Generation:\n   - Success Response:\n     * Return success message based on action performed\n     * For add: \"Poll option successfully added\"\n     * For remove: \"Poll option successfully removed\"\n     * Include updated list of poll options\n   - Error Response:\n     * Return appropriate error message from validation or business rule processing\n     * Include guidance on how to correct the issue",
    "databaseEntities": [
      "Poll",
      "PollOption",
      "PollChanges"
    ],
    "validationRules": [
      "Poll ID must be a positive integer",
      "Poll must exist in the system",
      "Poll option text must not be empty",
      "Action must be either 'add' or 'remove'",
      "Poll must have at least one option",
      "Poll must not exceed maximum allowed options",
      "User must confirm deletion of options with votes"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "PollOption": {
        "id": "number",
        "text": "string",
        "voteCount": "number",
        "poll": "object"
      },
      "Poll": {
        "id": "number",
        "topicId": "number",
        "length": "number",
        "label": "string",
        "startTime": "date",
        "options": "array",
        "pollChanges": "object"
      }
    }
  },
  {
    "featureName": "SearchForPollChanges",
    "description": "Identifies changes between two poll versions including modified, deleted, and new options.",
    "inputValues": [
      "firstPoll-object-Poll",
      "secondPoll-object-Poll"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the following inputs:\n     a. firstPoll (mandatory): The complete, most recent poll version, typically from the database\n     b. secondPoll (mandatory): The poll to compare with, typically containing updated information\n\n2. Data Validation:\n   - Validate poll inputs:\n     a. Check if firstPoll is not null\n        IF firstPoll is null THEN\n          Return empty change set with hasChanges flag set to false\n     b. Check if secondPoll is not null\n        IF secondPoll is null THEN\n          Return empty change set with hasChanges flag set to false\n     c. Verify both polls have valid structures with accessible properties\n        IF either poll lacks required properties THEN\n          Return empty change set with hasChanges flag set to false\n\n3. Business Rule Processing:\n   - Initialize change tracking containers:\n     a. Create empty list for deleted options\n     b. Create empty list for new options\n     c. Create empty list for changed options\n     d. Set hasChanges flag to false initially\n   - Compare poll metadata:\n     a. Compare poll labels\n        IF firstPoll.label != secondPoll.label THEN\n          Set hasChanges flag to true\n     b. Compare poll lengths (duration)\n        IF firstPoll.length != secondPoll.length THEN\n          Set hasChanges flag to true\n\n4. Core Operation Execution:\n   - Process existing options from firstPoll:\n     a. FOR EACH option in firstPoll.options:\n        i. Search for matching option by ID in secondPoll.options\n        ii. IF matching option found AND option text differs THEN\n            Add to changedOptions list\n            Set hasChanges flag to true\n        iii. IF no matching option found THEN\n            Add to deletedOptions list\n            Set hasChanges flag to true\n   - Process potential new options from secondPoll:\n     a. FOR EACH option in secondPoll.options:\n        i. Search for matching option by ID in firstPoll.options\n        ii. IF no matching option found THEN\n            Add to newOptions list\n            Set hasChanges flag to true\n\n5. Response Generation:\n   - Prepare change summary response:\n     a. Include lists of:\n        i. Changed options with their new text\n        ii. Deleted options that were removed\n        iii. New options that were added\n     b. Include hasChanges flag indicating if any differences were found\n     c. Return the complete change summary",
    "databaseEntities": [
      "jforum_topics",
      "jforum_posts"
    ],
    "validationRules": [
      "Both poll objects must not be null for comparison",
      "Poll options must have valid IDs for proper comparison",
      "Poll options must have text content for meaningful comparison"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Poll": {
        "type": "object",
        "properties": {
          "id": {
            "type": "number",
            "description": "Unique identifier for the poll"
          },
          "label": {
            "type": "string",
            "description": "The poll question or title"
          },
          "length": {
            "type": "number",
            "description": "Duration or time period for the poll"
          },
          "options": {
            "type": "array",
            "items": {
              "$ref": "#/PollOption"
            },
            "description": "List of available options in the poll"
          }
        }
      },
      "PollOption": {
        "type": "object",
        "properties": {
          "id": {
            "type": "number",
            "description": "Unique identifier for the poll option"
          },
          "text": {
            "type": "string",
            "description": "The text content of the poll option"
          }
        }
      }
    }
  },
  {
    "featureName": "TrackPollOptionChanges",
    "description": "Tracks modifications to existing poll options by comparing text values.",
    "inputValues": [
      "firstPoll-object-Poll",
      "secondPoll-object-Poll"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the following inputs:\n     a. firstPoll (mandatory): The original poll object with current options\n     b. secondPoll (mandatory): The modified poll object with updated options\n\n2. Data Validation:\n   - Validate poll objects:\n     a. Check if firstPoll is not null\n        IF firstPoll is null THEN\n           Return error message \"Original poll cannot be null\"\n     b. Check if secondPoll is not null\n        IF secondPoll is null THEN\n           Return error message \"Modified poll cannot be null\"\n     c. Verify both polls have options collections\n        IF either poll's options collection is null THEN\n           Initialize as empty collection\n\n3. Business Rule Processing:\n   - Compare poll metadata:\n     a. Check if poll labels are different\n        IF firstPoll.label != secondPoll.label THEN\n           Mark changes detected\n     b. Check if poll lengths are different\n        IF firstPoll.length != secondPoll.length THEN\n           Mark changes detected\n   - Process option changes:\n     a. Initialize collections for tracking:\n        - deletedOptions: Options present in first poll but missing in second\n        - newOptions: Options present in second poll but not in first\n        - changedOptions: Options present in both but with different text\n     b. FOR EACH option in firstPoll.options:\n        i. Find matching option by ID in secondPoll.options\n        ii. IF matching option found THEN\n            - Compare text values\n            - IF texts are different THEN\n              Add to changedOptions\n        iii. IF no matching option found THEN\n            Add to deletedOptions\n     c. FOR EACH option in secondPoll.options:\n        i. Find matching option by ID in firstPoll.options\n        ii. IF no matching option found THEN\n            Add to newOptions\n\n4. Core Operation Execution:\n   - Compile change summary:\n     a. Set hasChanges flag to true if any of the following conditions are met:\n        - Poll metadata (label or length) has changed\n        - deletedOptions collection is not empty\n        - newOptions collection is not empty\n        - changedOptions collection is not empty\n     b. Organize all changes into appropriate collections:\n        - Store all deleted options in deletedOptions collection\n        - Store all new options in newOptions collection\n        - Store all modified options in changedOptions collection\n\n5. Response Generation:\n   - Return change tracking object with:\n     a. hasChanges: Boolean indicating if any changes were detected\n     b. deletedOptions: Collection of options removed from the poll\n     c. newOptions: Collection of options added to the poll\n     d. changedOptions: Collection of options with modified text\n     e. Original reference polls for context",
    "databaseEntities": [
      "jforum_topics"
    ],
    "validationRules": [
      "First poll object must not be null",
      "Second poll object must not be null",
      "Poll options must have unique IDs",
      "Option text changes must be tracked when text values differ",
      "Options present in first poll but not in second are considered deleted",
      "Options present in second poll but not in first are considered new"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Poll": {
        "id": "number",
        "label": "string",
        "length": "number",
        "options": "array:PollOption"
      },
      "PollOption": {
        "id": "number",
        "text": "string"
      }
    }
  },
  {
    "featureName": "DetectDeletedPollOptions",
    "description": "Identifies poll options that have been removed between poll versions.",
    "inputValues": [
      "firstPoll-object-Poll",
      "secondPoll-object-Poll"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the following inputs:\n     - firstPoll (mandatory): The complete, most recent poll version, typically from the database\n     - secondPoll (mandatory): The poll to compare with, typically containing updated data\n\n2. Data Validation:\n   - Validate firstPoll input:\n     - IF firstPoll is null THEN\n       - Return empty result with no changes detected\n     - Verify firstPoll contains a valid label property\n     - Verify firstPoll contains a valid length property\n     - Verify firstPoll contains a list of options\n   - Validate secondPoll input:\n     - IF secondPoll is null THEN\n       - Return empty result with no changes detected\n     - Verify secondPoll contains a valid label property\n     - Verify secondPoll contains a valid length property\n     - Verify secondPoll contains a list of options\n\n3. Business Rule Processing:\n   - Initialize tracking variables:\n     - Create empty lists for deleted options, new options, and changed options\n     - Set hasChanges flag to false initially\n   - Compare poll metadata:\n     - IF firstPoll label does not match secondPoll label THEN\n       - Set hasChanges flag to true\n     - IF firstPoll length does not match secondPoll length THEN\n       - Set hasChanges flag to true\n\n4. Core Operation Execution:\n   - Process existing options:\n     - FOR EACH option in firstPoll options:\n       - Search for matching option by ID in secondPoll options\n       - IF matching option found THEN\n         - IF option text does not match matching option text THEN\n           - Add matching option to changed options list\n           - Set hasChanges flag to true\n       - ELSE (no matching option found)\n         - Add option to deleted options list\n         - Set hasChanges flag to true\n   - Process new options:\n     - FOR EACH option in secondPoll options:\n       - Search for matching option by ID in firstPoll options\n       - IF no matching option found THEN\n         - Add option to new options list\n         - Set hasChanges flag to true\n\n5. Response Generation:\n   - Prepare result object containing:\n     - List of deleted options\n     - List of new options\n     - List of changed options\n     - Boolean flag indicating if any changes were detected\n   - Return the complete result object",
    "databaseEntities": [
      "jforum_topics"
    ],
    "validationRules": [
      "Both poll versions must be provided for comparison",
      "Poll options must have unique identifiers",
      "Poll options must contain text content"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Poll": {
        "type": "object",
        "properties": {
          "label": {
            "type": "string",
            "description": "The title or question of the poll"
          },
          "length": {
            "type": "number",
            "description": "The duration or time limit of the poll"
          },
          "options": {
            "type": "array",
            "items": {
              "$ref": "#/definitions/PollOption"
            },
            "description": "List of available options in the poll"
          }
        },
        "required": [
          "label",
          "length",
          "options"
        ]
      },
      "PollOption": {
        "type": "object",
        "properties": {
          "id": {
            "type": "number",
            "description": "Unique identifier for the poll option"
          },
          "text": {
            "type": "string",
            "description": "The content or description of the poll option"
          }
        },
        "required": [
          "id",
          "text"
        ]
      }
    }
  },
  {
    "featureName": "IdentifyNewPollOptions",
    "description": "Detects newly added poll options in the updated poll version.",
    "inputValues": [
      "firstPoll-object-Poll",
      "secondPoll-object-Poll"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the following inputs:\n     a. firstPoll (mandatory): The complete, most recent poll version, typically from the database\n     b. secondPoll (mandatory): The poll to compare with, typically containing updated data\n\n2. Data Validation:\n   - Validate poll objects:\n     a. Check if firstPoll is not null\n        IF firstPoll is null THEN\n           Return error message indicating original poll is required\n     b. Check if secondPoll is not null\n        IF secondPoll is null THEN\n           Return error message indicating updated poll is required\n     c. Verify both polls have valid structures with options lists\n        IF either poll has invalid structure THEN\n           Return error message indicating invalid poll format\n\n3. Business Rule Processing:\n   - Initialize tracking lists:\n     a. Create empty list for new options\n     b. Create empty list for deleted options\n     c. Create empty list for changed options\n   - Compare poll metadata:\n     a. Compare poll labels\n        IF first poll label does not match second poll label THEN\n           Mark that changes exist\n     b. Compare poll length (duration)\n        IF first poll length does not match second poll length THEN\n           Mark that changes exist\n\n4. Core Operation Execution:\n   - Process existing options:\n     a. FOR EACH option in the first poll's options list:\n        i. Search for matching option by ID in second poll's options list\n        ii. IF matching option found THEN\n            - Compare option text\n            - IF text is different THEN\n              * Add to changed options list\n        iii. IF no matching option found THEN\n            - Add to deleted options list\n   - Identify new options:\n     a. FOR EACH option in the second poll's options list:\n        i. Search for matching option by ID in first poll's options list\n        ii. IF no matching option found THEN\n            - Add to new options list\n   - Determine if any changes exist:\n     a. IF any of these conditions are true, mark that changes exist:\n        - Poll metadata (label, length) differs\n        - New options list is not empty\n        - Changed options list is not empty\n        - Deleted options list is not empty\n\n5. Response Generation:\n   - Prepare response with the following information:\n     a. List of new poll options identified\n     b. List of changed poll options\n     c. List of deleted poll options\n     d. Boolean flag indicating whether any changes were detected\n   - Return the complete change summary",
    "databaseEntities": [
      "jforum_topics"
    ],
    "validationRules": [
      "Both poll objects must not be null",
      "Poll options must have valid IDs for comparison",
      "Poll options must have text content for comparison"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Poll": {
        "type": "object",
        "properties": {
          "id": {
            "type": "number",
            "description": "Unique identifier for the poll"
          },
          "label": {
            "type": "string",
            "description": "The title or question of the poll"
          },
          "length": {
            "type": "number",
            "description": "Duration of the poll in days"
          },
          "options": {
            "type": "array",
            "items": {
              "$ref": "#/PollOption"
            },
            "description": "List of options available in the poll"
          }
        }
      },
      "PollOption": {
        "type": "object",
        "properties": {
          "id": {
            "type": "number",
            "description": "Unique identifier for the poll option"
          },
          "text": {
            "type": "string",
            "description": "The text content of the poll option"
          }
        }
      }
    }
  },
  {
    "featureName": "CheckQuotaExceeded",
    "description": "Checks if a given file size exceeds the configured quota limit.",
    "inputValues": [
      "fileSize-number-File",
      "quotaLimit-object-QuotaLimit"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect fileSize (number): Size of the file to be checked\n   - Collect quotaLimit (object): The quota limit configuration object containing:\n     * size (number): The numeric value of the size limit\n     * type (number): The unit type of the size limit (KB or MB)\n   - System will use constants KB=1 and MB=2 for type identification\n\n2. Data Validation:\n   - Validate fileSize:\n     * Ensure fileSize is a positive number\n     * IF fileSize is negative or zero THEN\n       > Return error message \"File size must be a positive number\"\n   - Validate quotaLimit object:\n     * Ensure quotaLimit object is not null\n     * IF quotaLimit is null THEN\n       > Return error message \"Quota limit configuration is missing\"\n     * Ensure quotaLimit.size is a positive number\n     * IF quotaLimit.size is negative or zero THEN\n       > Return error message \"Quota size must be a positive number\"\n     * Ensure quotaLimit.type is either KB (1) or MB (2)\n     * IF quotaLimit.type is not KB or MB THEN\n       > Return error message \"Invalid quota type specified\"\n\n3. Business Rule Processing:\n   - Determine the quota limit in bytes:\n     * IF quotaLimit.type equals KB THEN\n       > Set quotaLimitInBytes = quotaLimit.size * 1024\n     * ELSE IF quotaLimit.type equals MB THEN\n       > Set quotaLimitInBytes = quotaLimit.size * 1024 * 1024\n   - Check system constraints:\n     * Verify the system can handle the comparison operation\n     * IF system memory is insufficient THEN\n       > Return error message \"System cannot process this request at this time\"\n\n4. Core Operation Execution:\n   - Compare file size with quota limit:\n     * IF fileSize > quotaLimitInBytes THEN\n       > Set quotaExceeded = true\n     * ELSE\n       > Set quotaExceeded = false\n   - Calculate remaining quota:\n     * Set remainingQuota = quotaLimitInBytes - fileSize\n     * IF remainingQuota < 0 THEN\n       > Set remainingQuota = 0\n\n5. Response Generation:\n   - Prepare the quota check result:\n     * Include the quotaExceeded status (boolean)\n     * Include the original file size (number)\n     * Include the quota limit in bytes (number)\n     * Include the remaining quota in bytes (number)\n   - IF quotaExceeded is true THEN\n     * Include a message indicating the quota has been exceeded\n     * Include the amount by which the quota was exceeded\n   - ELSE\n     * Include a message indicating the file is within quota limits\n     * Include the percentage of quota used\n   - Return the complete quota check result",
    "databaseEntities": [
      "jforum_quota_limit",
      "jforum_attachments"
    ],
    "validationRules": [
      "File size must be a positive number",
      "Quota limit configuration must not be null",
      "Quota size must be a positive number",
      "Quota type must be either KB (1) or MB (2)"
    ],
    "dbSeedingOperations": [
      "Ensure at least one default quota limit record exists in jforum_quota_limit table"
    ],
    "schema": {
      "QuotaLimit": {
        "type": "object",
        "properties": {
          "id": {
            "type": "number",
            "description": "Unique identifier for the quota limit"
          },
          "description": {
            "type": "string",
            "description": "Description of the quota limit"
          },
          "size": {
            "type": "number",
            "description": "Size value of the quota limit"
          },
          "type": {
            "type": "number",
            "description": "Unit type of the size (1 for KB, 2 for MB)"
          }
        },
        "required": [
          "size",
          "type"
        ]
      }
    }
  },
  {
    "featureName": "GetSizeInBytes",
    "description": "Calculates the quota limit size in bytes based on KB or MB configuration.",
    "inputValues": [
      "size-number-QuotaLimit",
      "type-number-QuotaLimit"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect quota limit information:\n     - size: The numerical size value (mandatory)\n     - type: The unit type identifier (mandatory)\n       - Type can be KB (1) or MB (2)\n\n2. Data Validation:\n   - Validate size input:\n     - Ensure size is a positive number\n     - Verify size is within acceptable range for the system\n     - If invalid, generate appropriate error message\n   - Validate type input:\n     - Verify type is either KB (1) or MB (2)\n     - If invalid type provided, generate error message\n\n3. Business Rule Processing:\n   - Determine conversion factor based on type:\n     - IF type equals KB (1) THEN\n       - Set conversion factor to 1024 (bytes per KB)\n     - ELSE IF type equals MB (2) THEN\n       - Set conversion factor to 1,048,576 (bytes per MB)\n     - ELSE\n       - Handle invalid type error\n\n4. Core Operation Execution:\n   - Calculate bytes value:\n     - Multiply size by the determined conversion factor\n     - Store result as bytes value\n   - Handle potential numeric overflow:\n     - IF calculated value exceeds system limits THEN\n       - Handle overflow condition\n       - Generate appropriate warning\n\n5. Response Generation:\n   - Return calculated size in bytes\n   - Include original size and unit type in response for reference\n   - If any errors occurred during calculation:\n     - Return error details\n     - Provide guidance on valid input ranges",
    "databaseEntities": [
      "jforum_quota_limit"
    ],
    "validationRules": [
      "Size must be a positive number",
      "Type must be either KB (1) or MB (2)",
      "Calculated byte size must not exceed system numeric limits"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "QuotaLimit": {
        "id": "number",
        "description": "string",
        "size": "number",
        "type": "number"
      }
    }
  },
  {
    "featureName": "CompareTopicsByType",
    "description": "Compares topics by type and last post date for sorting purposes.",
    "inputValues": [
      "topic1-object-Topic",
      "topic2-object-Topic"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect two Topic objects for comparison:\n     - topic1 (mandatory): The first Topic object to compare\n     - topic2 (mandatory): The second Topic object to compare\n   - Both objects must contain:\n     - type: A numeric value representing the topic type\n     - lastPostDate: A date value representing when the last post was made\n\n2. Data Validation:\n   - Validate topic1 is not null\n     - IF topic1 is null THEN return error indicating first comparison object is missing\n   - Validate topic2 is not null\n     - IF topic2 is null THEN return error indicating second comparison object is missing\n   - Validate topic1 has a valid type value\n     - IF topic1.type is undefined THEN return error indicating missing type information\n   - Validate topic2 has a valid type value\n     - IF topic2.type is undefined THEN return error indicating missing type information\n   - Validate topic1 has a valid lastPostDate\n     - IF topic1.lastPostDate is undefined THEN return error indicating missing date information\n   - Validate topic2 has a valid lastPostDate\n     - IF topic2.lastPostDate is undefined THEN return error indicating missing date information\n\n3. Business Rule Processing:\n   - Determine the comparison priority rules:\n     - Topic type has higher priority than post date\n     - Higher topic types should appear before lower topic types\n     - For same topic types, more recent posts should appear first\n\n4. Core Operation Execution:\n   - Compare the topic types between topic1 and topic2\n     - IF topic1.type < topic2.type THEN\n       - Return 1 (indicating topic1 should be placed after topic2)\n     - ELSE IF topic1.type == topic2.type THEN\n       - Compare the lastPostDate of both topics\n       - Return the result of comparing topic2.lastPostDate with topic1.lastPostDate\n         (This ensures more recent posts appear first when types are equal)\n     - ELSE\n       - Return -1 (indicating topic1 should be placed before topic2)\n\n5. Response Generation:\n   - Return the comparison result as an integer value:\n     - Return 1: Indicates topic1 should be sorted after topic2\n     - Return 0: Indicates topic1 and topic2 are equivalent for sorting purposes\n     - Return -1: Indicates topic1 should be sorted before topic2",
    "databaseEntities": [
      "jforum_topics"
    ],
    "validationRules": [
      "Both topics must not be null",
      "Both topics must have a defined type value",
      "Both topics must have a valid lastPostDate",
      "Higher topic types should be sorted before lower topic types",
      "For equal topic types, more recent posts should be sorted first"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Topic": {
        "type": "object",
        "properties": {
          "type": {
            "type": "number",
            "description": "Numeric value representing the topic type"
          },
          "lastPostDate": {
            "type": "date",
            "description": "Date when the last post was made in the topic"
          }
        },
        "required": [
          "type",
          "lastPostDate"
        ]
      }
    }
  },
  {
    "featureName": "UpdateSessionTime",
    "description": "Updates the user session time based on the current system time.",
    "inputValues": [
      "startTime-date-UserSession"
    ],
    "businessLogic": "1. Input Collection:\n   - Retrieve the current user session object\n   - Verify the session has a valid startTime field (mandatory)\n   - System will use the current system time (automatically generated)\n\n2. Data Validation:\n   - Validate that startTime is not null\n     * IF startTime is null THEN\n       - Generate error message: \"Session start time is not initialized\"\n       - Abort operation\n     * END IF\n   - Validate that startTime is not in the future\n     * IF startTime is in the future THEN\n       - Generate error message: \"Invalid session start time\"\n       - Abort operation\n     * END IF\n\n3. Business Rule Processing:\n   - Verify the user session is active\n     * IF session is expired THEN\n       - Generate error message: \"Cannot update expired session\"\n       - Abort operation\n     * END IF\n   - Check if user has permission to update session time\n     * IF user does not have permission THEN\n       - Generate error message: \"Insufficient permissions to update session\"\n       - Abort operation\n     * END IF\n\n4. Core Operation Execution:\n   - Calculate the new session time:\n     * Compute the difference between current system time and session start time\n     * Formula: sessionTime = currentSystemTime - startTime\n   - Update the session time value in the user session object\n   - IF update fails THEN\n     * Log the error\n     * Revert to previous session time value\n     * Generate error message: \"Failed to update session time\"\n   * END IF\n\n5. Response Generation:\n   - IF operation is successful THEN\n     * Return success status\n     * Include updated session time value\n     * Include session last update timestamp\n   - ELSE\n     * Return error status\n     * Include error message\n     * Include support information\n   - END IF",
    "databaseEntities": [
      "jforum_sessions"
    ],
    "validationRules": [
      "Session start time must not be null",
      "Session start time must not be in the future",
      "User session must be active",
      "User must have permission to update session time"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "UserSession": {
        "type": "object",
        "properties": {
          "sessionTime": {
            "type": "number",
            "description": "Duration of the session in milliseconds"
          },
          "startTime": {
            "type": "date",
            "description": "Time when the session started"
          },
          "userId": {
            "type": "number",
            "description": "ID of the user associated with this session"
          },
          "sessionId": {
            "type": "string",
            "description": "Unique identifier for the session"
          }
        },
        "required": [
          "startTime"
        ]
      }
    }
  },
  {
    "featureName": "ValidateCaptchaResponse",
    "description": "Validates user's captcha response against the stored challenge.",
    "inputValues": [
      "userResponse-string-UserSession"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect user response (userResponse-string): The text entered by the user as their captcha solution\n   - System retrieves current captcha challenge from user session\n\n2. Data Validation:\n   - Validate userResponse:\n     a. Check if userResponse is not null or empty\n     b. Check if userResponse contains only valid characters\n     c. If validation fails, return appropriate error message\n\n3. Business Rule Processing:\n   - Check if captcha validation is enabled in system configuration:\n     a. IF captcha is required for registration OR captcha is required for posts THEN\n        i. Verify that a captcha challenge exists in the current user session\n        ii. IF no captcha challenge exists THEN\n            - Return error indicating captcha challenge is missing\n     b. ELSE\n        i. Skip validation and return success\n   - Check if case-insensitive validation is enabled:\n     a. IF case should be ignored THEN\n        i. Convert userResponse to lowercase for comparison\n\n4. Core Operation Execution:\n   - Compare user's response against the stored captcha challenge:\n     a. Pass userResponse to the captcha validation engine\n     b. Get validation result (boolean)\n   - Clean up resources:\n     a. Destroy the current captcha challenge from session\n     b. Release any associated resources\n\n5. Response Generation:\n   - Return validation result:\n     a. IF validation successful THEN\n        i. Return success status (true)\n     b. ELSE\n        i. Return failure status (false)\n   - Include appropriate message based on result",
    "databaseEntities": [
      "jforum_sessions"
    ],
    "validationRules": [
      "User response must not be empty",
      "Captcha challenge must exist in the user session if captcha validation is enabled",
      "User response must match the expected solution for the captcha challenge"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "UserSession": {
        "type": "object",
        "properties": {
          "imageCaptcha": {
            "type": "object",
            "description": "The captcha challenge object stored in the user session"
          },
          "userResponse": {
            "type": "string",
            "description": "The text entered by the user as their captcha solution"
          }
        }
      }
    }
  },
  {
    "featureName": "CreateNewCaptcha",
    "description": "Generates a new image captcha challenge for the user.",
    "inputValues": [],
    "businessLogic": "1. Input Collection:\n   - No user inputs required for this feature\n   - System will generate the captcha internally\n\n2. Data Validation:\n   - Check if captcha functionality is enabled in system settings\n     - IF captcha is disabled for both registration and posts, THEN skip captcha generation\n   - Verify user session exists and is valid\n     - IF session is invalid or expired, THEN return error\n\n3. Business Rule Processing:\n   - Check system configuration for captcha settings\n     - Determine if captcha is required based on current context (registration or posting)\n     - Retrieve captcha complexity settings from system configuration\n   - Prepare system resources for captcha generation\n     - Ensure image generation capabilities are available\n     - Verify memory allocation for image creation\n\n4. Core Operation Execution:\n   - Destroy any existing captcha in the user session\n     - Release resources associated with previous captcha\n     - Clear previous captcha validation state\n   - Request a new captcha instance from the captcha service\n     - Generate random challenge text according to complexity rules\n     - Create image representation of the challenge text\n     - Apply visual distortion techniques to prevent automated recognition\n   - Store the new captcha in the user session\n     - Associate captcha with current user session\n     - Set captcha creation timestamp\n\n5. Response Generation:\n   - Prepare success response\n     - Include status indicating captcha was successfully created\n     - Do not include actual captcha solution in response\n   - Provide information on how to display the captcha\n     - Include reference to how the client can retrieve the captcha image\n     - Include any necessary display instructions\n   - Return success status",
    "databaseEntities": [
      "jforum_sessions"
    ],
    "validationRules": [
      "User session must be valid and active",
      "Previous captcha must be properly destroyed before creating a new one",
      "System must have captcha functionality enabled"
    ],
    "dbSeedingOperations": [],
    "schema": {}
  },
  {
    "featureName": "MakeAnonymous",
    "description": "Converts the current user session to an anonymous session.",
    "inputValues": [
      "userSession-object-UserSession"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the current UserSession object\n   - No additional user inputs required as this is a system-initiated operation\n   - The operation will use system-defined anonymous user ID\n\n2. Data Validation:\n   - Verify the UserSession object is valid and not null\n   - Verify the system has a properly configured anonymous user ID\n   - IF the session is already anonymous THEN\n     - Skip further processing\n     - Return with no changes\n   - END IF\n\n3. Business Rule Processing:\n   - Check if there are any pending operations that require authentication\n   - IF user has unsaved data or operations in progress THEN\n     - Determine if these operations should be preserved or discarded\n     - Prepare warning messages if applicable\n   - END IF\n   - Verify the anonymous user ID exists in the system\n   - Check if the current session has special permissions that will be lost\n\n4. Core Operation Execution:\n   - Update session start time to current system time\n   - Update last visit time to current system time\n   - Set user ID to the system's anonymous user ID\n   - Remove auto-login cookies if present\n     - Clear the auto-login cookie\n     - Set the user data cookie to anonymous user ID\n   - Mark session as not logged in\n   - Reset any user-specific session attributes\n   - Preserve session ID to maintain the same browser session\n\n5. Response Generation:\n   - Return updated UserSession with anonymous status\n   - Include information about the session change\n   - Provide any relevant messages about lost permissions or data\n   - Return navigation options for anonymous users",
    "databaseEntities": [
      "jforum_users",
      "jforum_sessions"
    ],
    "validationRules": [
      "UserSession object must not be null",
      "System must have a valid anonymous user ID configured",
      "Session cookies must be properly updated to reflect anonymous status"
    ],
    "dbSeedingOperations": [
      "Ensure anonymous user exists in jforum_users table",
      "Ensure anonymous user has appropriate permissions configured"
    ],
    "schema": {
      "UserSession": {
        "type": "object",
        "properties": {
          "sessionId": {
            "type": "string",
            "description": "Unique identifier for the user session"
          },
          "userId": {
            "type": "integer",
            "description": "User identifier associated with the session"
          },
          "username": {
            "type": "string",
            "description": "Username associated with the session"
          },
          "startTime": {
            "type": "date",
            "description": "Session start timestamp"
          },
          "lastVisit": {
            "type": "date",
            "description": "Last visit timestamp"
          },
          "sessionTime": {
            "type": "number",
            "description": "Duration of the session in milliseconds"
          },
          "autoLogin": {
            "type": "boolean",
            "description": "Flag indicating if auto-login is enabled"
          }
        }
      }
    }
  },
  {
    "featureName": "RegisterBasicInfo",
    "description": "Sets up basic session information for first-time forum visitors.",
    "inputValues": [
      "sessionId-string-UserSession",
      "ip-string-UserSession"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect session identifier (sessionId) from the system\n   - Collect IP address (ip) from the visitor's connection\n   - System will generate the following values:\n     * startTime: Current system timestamp\n     * lastVisit: Current system timestamp\n     * userId: Anonymous user identifier from system configuration\n\n2. Data Validation:\n   - Validate session identifier:\n     * VERIFY sessionId is not null\n     * VERIFY sessionId is a valid string format\n     * IF sessionId is invalid THEN generate error message \"Invalid session identifier\"\n   - Validate IP address:\n     * VERIFY IP address is in valid format\n     * IF IP address is invalid THEN generate error message \"Invalid IP address format\"\n\n3. Business Rule Processing:\n   - VERIFY system configuration is properly loaded\n     * CHECK that anonymous user ID is available from system configuration\n     * IF configuration is not available THEN generate error \"System configuration not available\"\n   - VERIFY session tracking is enabled\n     * IF session tracking is disabled THEN log warning but continue process\n\n4. Core Operation Execution:\n   - Create or update user session with basic information:\n     * SET session start time to current timestamp\n     * SET last visit time to current timestamp\n     * SET user ID to anonymous user ID from system configuration\n     * SET session ID to provided session identifier\n     * SET IP address to provided IP address\n     * SET default language based on system configuration\n   - Register session in the system:\n     * ADD session to active sessions collection\n     * UPDATE session timestamp\n\n5. Response Generation:\n   - Success response:\n     * RETURN initialized user session object with basic information\n     * INCLUDE session identifier for future reference\n     * INCLUDE timestamp of session creation\n   - Error response:\n     * INCLUDE specific validation or processing error message\n     * INCLUDE guidance for resolving the issue",
    "databaseEntities": [
      "jforum_sessions",
      "jforum_users"
    ],
    "validationRules": [
      "Session identifier must be valid",
      "IP address must be in valid format",
      "System configuration must be available",
      "Anonymous user ID must be defined in system configuration"
    ],
    "dbSeedingOperations": [
      "Ensure anonymous user exists in jforum_users table"
    ],
    "schema": {
      "UserSession": {
        "sessionId": "string",
        "userId": "number",
        "username": "string",
        "startTime": "date",
        "lastVisit": "date",
        "sessionTime": "number",
        "ip": "string",
        "lang": "string",
        "autoLogin": "boolean",
        "privateMessages": "number"
      }
    }
  },
  {
    "featureName": "DataToUser",
    "description": "Updates user session with information from a user profile including user ID, username, private message count, session start time, and language preferences.",
    "inputValues": [
      "user-object-User"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the User object containing user profile information\n     - User ID (mandatory)\n     - Username (mandatory)\n     - Private message count (mandatory)\n     - Language preference (mandatory)\n     - System will generate current timestamp for session start time\n\n2. Data Validation:\n   - Validate User object\n     - Verify User object is not null\n     - Verify User ID is a positive integer\n     - Verify Username is not empty\n     - Verify Private message count is a non-negative integer\n     - Verify Language preference is a valid language code\n   - IF any validation fails THEN\n     - Generate appropriate error message\n     - Abort the operation\n\n3. Business Rule Processing:\n   - Verify user session exists\n     - IF session does not exist THEN\n       - Create new session\n     - ELSE\n       - Use existing session\n   - Check user permissions and roles\n     - Determine if user has administrator privileges\n     - Determine if user has moderator privileges\n\n4. Core Operation Execution:\n   - Update user session with user information\n     - Set user ID in the session\n     - Set username in the session\n     - Set private message count in the session\n     - Set session start time to current timestamp\n     - Set language preference in the session\n   - Update session status\n     - Mark session as authenticated\n     - Update last activity timestamp\n\n5. Response Generation:\n   - Return success status\n     - Indicate session was successfully updated\n   - IF any errors occurred during the process THEN\n     - Return error details\n     - Include guidance for resolving the issue",
    "databaseEntities": [
      "jforum_users",
      "jforum_sessions",
      "jforum_privmsgs"
    ],
    "validationRules": [
      "User object must not be null",
      "User ID must be a positive integer",
      "Username must not be empty",
      "Private message count must be a non-negative integer",
      "Language preference must be a valid language code"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "User": {
        "id": "number",
        "username": "string",
        "privateMessagesCount": "number",
        "lang": "string"
      }
    }
  },
  {
    "featureName": "CheckModeratorStatus",
    "description": "Verifies if the user has moderation rights for a specific forum.",
    "inputValues": [
      "userId-number-User",
      "forumId-number-Forum"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect userId (mandatory, number): The identifier of the user to check\n   - Collect forumId (mandatory, number): The identifier of the forum to check moderation rights for\n   - System will use existing security repository for permission verification\n\n2. Data Validation:\n   - Validate userId:\n      - Ensure userId is a positive integer\n      - Verify userId exists in the system\n      - IF userId is invalid or not found, THEN return error message\n   - Validate forumId:\n      - Ensure forumId is a positive integer\n      - Verify forumId exists in the system\n      - IF forumId is invalid or not found, THEN return error message\n\n3. Business Rule Processing:\n   - Check if user has general moderation permission:\n      - Retrieve user's permission control from security repository\n      - Verify if user has system-wide moderation rights\n      - IF user has system-wide moderation rights, THEN set hasModerationRights to true\n   - Check if user has forum-specific moderation permission:\n      - Retrieve forum-specific permissions for the user\n      - Verify if user has moderation rights specifically for the requested forum\n      - IF user has forum-specific moderation rights, THEN set hasModerationRights to true\n   - IF neither general nor forum-specific moderation rights exist, THEN set hasModerationRights to false\n\n4. Core Operation Execution:\n   - Combine the results of general and forum-specific permission checks:\n      - User must have general moderation permission AND forum-specific moderation permission\n      - Set final moderationStatus based on these combined checks\n   - Record the permission check in system logs (optional):\n      - Log userId, forumId, and result of moderation check\n      - Include timestamp of when check was performed\n\n5. Response Generation:\n   - Return moderationStatus result:\n      - IF moderationStatus is true, THEN return success response with moderator status confirmed\n      - IF moderationStatus is false, THEN return success response with moderator status denied\n      - Include userId and forumId in the response for reference\n   - IF any errors occurred during processing, THEN:\n      - Return appropriate error message\n      - Include error details for troubleshooting",
    "databaseEntities": [
      "jforum_users",
      "jforum_forums",
      "jforum_moderator_groups",
      "jforum_user_groups"
    ],
    "validationRules": [
      "User ID must be a positive integer",
      "Forum ID must be a positive integer",
      "User must exist in the system",
      "Forum must exist in the system",
      "User must have general moderation permission to be a moderator",
      "User must have forum-specific moderation permission to moderate the specific forum"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "User": {
        "id": "number",
        "username": "string",
        "permissions": "object"
      },
      "Forum": {
        "id": "number",
        "name": "string",
        "moderators": "array"
      },
      "Permission": {
        "userId": "number",
        "permissionType": "string",
        "forumId": "number"
      }
    }
  },
  {
    "featureName": "HandleExceptionData",
    "description": "Processes exceptions by logging details, formatting error messages, and rendering exception template.",
    "inputValues": [
      "exception-object-Throwable",
      "writer-object-Writer",
      "request-object-RequestContext"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the thrown exception (Throwable object)\n   - Collect the output writer for response rendering\n   - Collect the request context containing URL information\n   - System will use logging configuration from system settings\n   - System will access user session data for permission checks\n\n2. Data Validation:\n   - Validate that the exception object is not null\n     * IF exception is null THEN abort processing\n   - Validate that the writer object is available for output\n     * IF writer is null THEN log error and abort processing\n   - Validate request context for URL extraction\n     * IF request is null THEN use empty string as URL information\n\n3. Business Rule Processing:\n   - Check user permission for viewing stack trace details\n     * Retrieve stack trace visibility setting from system configuration\n     * IF stack trace is restricted to moderators THEN\n       * Check if current user is logged in\n       * Check if current user has moderator privileges\n     * ELSE allow stack trace viewing for all users\n   - Determine the most appropriate error message to display\n     * Check for cause chain to find root cause message\n     * IF no cause message is available THEN use exception's direct message\n     * IF no direct message is available THEN use exception's string representation\n\n4. Core Operation Execution:\n   - Capture exception details\n     * Create string writer to hold stack trace information\n     * Create print writer to format exception details\n     * Print full exception stack trace to the writer\n     * Extract current URL from request context\n     * Append URL information to the stack trace\n   - Log the complete exception information\n     * Write the full stack trace to system error log\n   - Format error message for display\n     * Extract the most descriptive message from exception chain\n     * Remove potentially harmful HTML characters from message\n     * Prepare stack trace content based on user permissions\n     * Remove potentially harmful HTML characters from stack trace\n   - Prepare template data\n     * Add formatted stack trace to template context\n     * Add formatted error message to template context\n\n5. Response Generation:\n   - Render exception template\n     * Load the exception template from template configuration\n     * Process template with prepared context data\n     * Write rendered template to output writer\n   - Handle rendering failures\n     * Catch any exceptions that occur during rendering\n     * Log secondary exceptions to error log\n     * Ensure all writers are properly closed",
    "databaseEntities": [],
    "validationRules": [
      "Exception object must not be null",
      "Writer object must be available for output",
      "HTML characters must be filtered from error messages",
      "Stack trace visibility must be restricted based on user permissions",
      "All exceptions must be properly logged"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Throwable": {
        "type": "object",
        "properties": {
          "message": {
            "type": "string",
            "description": "The error message associated with the exception"
          },
          "cause": {
            "type": "object",
            "description": "The underlying cause of this exception"
          },
          "stackTrace": {
            "type": "array",
            "description": "The stack trace elements of the exception"
          }
        }
      },
      "Writer": {
        "type": "object",
        "description": "Output writer for rendering response"
      },
      "RequestContext": {
        "type": "object",
        "properties": {
          "requestURI": {
            "type": "string",
            "description": "The URI of the request"
          },
          "queryString": {
            "type": "string",
            "description": "The query string of the request"
          }
        }
      }
    }
  },
  {
    "featureName": "ExtractCurrentUrl",
    "description": "Retrieves and formats the current request URL for inclusion in error reports.",
    "inputValues": [
      "request-object-RequestContext"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the RequestContext object\n   - Check if the RequestContext is available or null\n\n2. Data Validation:\n   - Validate that the RequestContext object is accessible\n     - IF RequestContext is null THEN\n       - Return an empty string as the URL information\n     - ELSE\n       - Proceed to URL extraction\n\n3. Business Rule Processing:\n   - Determine how to handle null RequestContext scenarios\n     - System should gracefully handle null RequestContext by returning empty string\n     - No additional business constraints apply\n\n4. Core Operation Execution:\n   - Extract URL components from the RequestContext\n     - Retrieve the request URI from the RequestContext\n     - Retrieve the query string from the RequestContext\n     - Format the extracted information into a readable string\n       - Start with a newline character and \"URL is: \" prefix\n       - Append the request URI\n       - Append a question mark character\n       - Append the query string\n\n5. Response Generation:\n   - Return the formatted URL string\n   - The returned string should follow the format: \"\\nURL is: {requestURI}?{queryString}\"\n   - If RequestContext was null, return an empty string",
    "databaseEntities": [],
    "validationRules": [
      "RequestContext may be null and must be handled gracefully",
      "The returned URL string must include both the URI and query string when available",
      "The URL string must be properly formatted with a newline and prefix"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "RequestContext": {
        "type": "object",
        "properties": {
          "requestURI": {
            "type": "string",
            "description": "The URI portion of the request URL"
          },
          "queryString": {
            "type": "string",
            "description": "The query string portion of the request URL"
          }
        }
      }
    }
  },
  {
    "featureName": "GetBBCollection",
    "description": "Retrieves the BBCode collection from cache for forum text formatting.",
    "inputValues": [],
    "businessLogic": "1. Input Collection:\n   - No user inputs required for this feature\n   - System will use internal cache identifiers:\n     * Fully Qualified Name (FQN) for cache location\n     * BBCollection key name for specific data retrieval\n\n2. Data Validation:\n   - Verify Cache System Availability\n     * IF cache engine is not initialized THEN\n       - Generate system error indicating cache system unavailable\n       - Abort operation\n     * END IF\n   - Verify Cache Path Existence\n     * IF the specified FQN path does not exist in cache THEN\n       - Return empty or null result\n     * END IF\n\n3. Business Rule Processing:\n   - Check BBCode Collection Existence\n     * IF BBCollection does not exist at the specified cache location THEN\n       - Return null or empty collection\n       - Log warning about missing BBCode collection\n     * END IF\n   - Verify BBCollection Type\n     * IF retrieved object is not of expected BBCodeHandler type THEN\n       - Generate type mismatch error\n       - Return null or empty result\n     * END IF\n\n4. Core Operation Execution:\n   - Retrieve BBCode Collection\n     * Access cache system using predefined FQN path\n     * Request object stored under BBCOLLECTION key\n     * Cast retrieved object to appropriate BBCodeHandler type\n   - Prepare Collection for Return\n     * Ensure collection is ready for immediate use\n     * No modifications to the collection are performed\n\n5. Response Generation:\n   - Return BBCode Collection\n     * IF retrieval was successful THEN\n       - Return the BBCodeHandler collection object\n     * ELSE\n       - Return null or appropriate error indicator\n       - Include diagnostic information about failure reason\n     * END IF",
    "databaseEntities": [],
    "validationRules": [
      "Cache system must be initialized before retrieval",
      "BBCode collection must exist in the cache",
      "Retrieved object must be of BBCodeHandler type"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "BBCodeHandler": {
        "type": "object",
        "properties": {
          "bbCodes": {
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "tagName": {
                  "type": "string",
                  "description": "Name of the BBCode tag"
                },
                "replacement": {
                  "type": "string",
                  "description": "HTML replacement for the BBCode"
                },
                "regex": {
                  "type": "boolean",
                  "description": "Whether the tag uses regex for matching"
                }
              }
            }
          }
        }
      }
    }
  },
  {
    "featureName": "SetBBCollection",
    "description": "Stores the BBCode handler collection in cache for forum text formatting.",
    "inputValues": [
      "bbCollection-object-BBCodeHandler"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect BBCodeHandler object (bbCollection) containing forum text formatting rules\n   - Verify the bbCollection is not null\n   - Ensure the bbCollection contains valid BBCode formatting rules\n\n2. Data Validation:\n   - Validate that the BBCodeHandler object is properly initialized\n     - Check that the object is not null\n     - Verify that the BBCodeHandler contains at least one BBCode definition\n     - Ensure each BBCode definition has a valid name and pattern\n   - IF validation fails THEN prepare appropriate error message\n\n3. Business Rule Processing:\n   - Check if cache system is properly initialized\n     - Verify that the cache engine has been set\n     - Ensure the cache engine is operational\n   - Determine if an existing BBCode collection exists in cache\n     - IF existing collection exists THEN prepare to replace it\n     - IF no existing collection exists THEN prepare to create new cache entry\n   - Verify system has sufficient cache resources\n\n4. Core Operation Execution:\n   - Store the BBCodeHandler collection in the cache system\n     - Use the predefined fully qualified name (FQN) as the cache namespace\n     - Use the predefined collection identifier as the cache key\n     - Add the BBCodeHandler object to the cache\n   - Verify the cache operation completed successfully\n     - Check that the object was properly stored\n     - Ensure the object is retrievable from cache\n\n5. Response Generation:\n   - IF cache operation successful THEN\n     - Return success status\n     - Provide confirmation that BBCode collection is now available for forum text formatting\n   - ELSE\n     - Return failure status\n     - Include error details explaining why the cache operation failed\n     - Provide guidance for resolving the issue",
    "databaseEntities": [],
    "validationRules": [
      "BBCodeHandler object must not be null",
      "BBCodeHandler must contain at least one BBCode definition",
      "Cache engine must be properly initialized before storing BBCode collection",
      "Each BBCode definition must have a valid name and pattern"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "BBCodeHandler": {
        "type": "object",
        "properties": {
          "bbCodes": {
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "name": {
                  "type": "string",
                  "description": "The name of the BBCode tag"
                },
                "pattern": {
                  "type": "string",
                  "description": "The regex pattern for matching the BBCode"
                },
                "replacement": {
                  "type": "string",
                  "description": "The replacement pattern for the BBCode"
                }
              }
            }
          },
          "findByName": {
            "type": "function",
            "description": "Method to find a BBCode by its tag name"
          }
        }
      }
    }
  },
  {
    "featureName": "FindBBCodeByName",
    "description": "Locates a specific BBCode tag by its name from the cached collection.",
    "inputValues": [
      "tagName-string-BBCode"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the required input parameter:\n     a. tagName (string, mandatory): The name of the BBCode tag to find\n     b. No default values are provided\n     c. No system-generated fields are used\n\n2. Data Validation:\n   - Validate the tagName input:\n     a. Check if tagName is not null\n        i. IF tagName is null THEN\n           - Generate an error indicating that tag name is required\n           - Terminate the operation\n        ii. ELSE continue to next validation\n     b. Check if tagName is not empty\n        i. IF tagName is empty THEN\n           - Generate an error indicating that tag name cannot be empty\n           - Terminate the operation\n        ii. ELSE continue to next validation\n\n3. Business Rule Processing:\n   - Verify the BBCode collection availability:\n     a. Check if the BBCode collection cache exists\n        i. IF BBCode collection cache does not exist THEN\n           - Generate an error indicating that BBCode collection is not initialized\n           - Terminate the operation\n        ii. ELSE continue to next step\n     b. Determine which collection to search:\n        i. The system maintains two collections of BBCode tags:\n           - Regular BBCode tags (bbMap)\n           - Always-process BBCode tags (alwaysProcessMap)\n        ii. For this operation, only search in the regular BBCode tags collection\n\n4. Core Operation Execution:\n   - Retrieve the BBCode from the collection:\n     a. Access the regular BBCode collection (bbMap)\n     b. Perform direct lookup using the tagName as the key:\n        i. The collection is structured as a map with tag names as keys\n        ii. Retrieve the BBCode object associated with the provided tagName\n        iii. IF the key exists in the map THEN\n             - The corresponding BBCode object is retrieved\n        iv. IF the key does not exist in the map THEN\n            - The result will be null\n\n5. Response Generation:\n   - Generate the appropriate response:\n     a. IF a matching BBCode was found THEN\n        i. Return the BBCode object with its complete properties:\n           - Tag name\n           - Regular expression pattern\n           - Replacement text\n           - Processing flags (removeQuotes, alwaysProcess)\n     b. ELSE\n        i. Return null to indicate that no matching BBCode was found\n     c. No additional metadata is included in the response",
    "databaseEntities": [],
    "validationRules": [
      "Tag name must not be null",
      "Tag name must not be empty",
      "BBCode collection must be initialized before searching"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "BBCode": {
        "type": "object",
        "properties": {
          "tagName": {
            "type": "string",
            "description": "The name of the BBCode tag"
          },
          "regex": {
            "type": "string",
            "description": "Regular expression pattern for the BBCode"
          },
          "replace": {
            "type": "string",
            "description": "Replacement pattern for the BBCode"
          },
          "removeQuotes": {
            "type": "boolean",
            "description": "Whether to remove quotes during processing"
          },
          "alwaysProcess": {
            "type": "boolean",
            "description": "Whether the BBCode should always be processed"
          }
        }
      }
    }
  },
  {
    "featureName": "CheckBanStatus",
    "description": "Determines if a user should be banned based on matching criteria against the banlist.",
    "inputValues": [
      "userInfo-object-BanCandidate"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect user information (userInfo) to check against the ban criteria\n     1.1. Extract user identification details from the input object\n     1.2. Prepare the user information for ban criteria matching\n     1.3. Ensure all required identification fields are present\n\n2. Data Validation:\n   - Validate the user information provided for ban checking\n     2.1. Verify that the user information contains at least one identifiable attribute\n     2.2. Check that the format of each identification attribute is valid\n     2.3. IF any required identification attribute is missing or invalid THEN\n          2.3.1. Generate an error message indicating invalid user information\n          2.3.2. Abort the ban checking process\n     2.4. ELSE continue to the next step\n\n3. Business Rule Processing:\n   - Prepare the system for ban status checking\n     3.1. Verify that the banlist repository is accessible\n     3.2. IF the banlist is not loaded or accessible THEN\n          3.2.1. Attempt to load the banlist from the data source\n          3.2.2. IF loading fails THEN\n                 3.2.2.1. Generate an error indicating banlist unavailability\n                 3.2.2.2. Abort the ban checking process\n     3.3. ELSE continue with the loaded banlist\n\n4. Core Operation Execution:\n   - Check if the user matches any ban criteria in the banlist\n     4.1. Initialize ban status as 'not banned'\n     4.2. FOR each entry in the banlist DO\n          4.2.1. Compare the user information against the current ban entry criteria\n          4.2.2. IF the user information matches the ban criteria THEN\n                 4.2.2.1. Set ban status to 'banned'\n                 4.2.2.2. Record the matching ban reason\n                 4.2.2.3. Exit the loop\n          4.2.3. ELSE continue checking the next ban entry\n     4.3. IF no matches were found THEN\n          4.3.1. Keep ban status as 'not banned'\n\n5. Response Generation:\n   - Generate the appropriate response based on the ban check results\n     5.1. Create a result object containing:\n          5.1.1. Ban status (banned or not banned)\n          5.1.2. IF banned THEN include reason for ban\n          5.1.3. IF banned THEN include ban duration information if available\n     5.2. Return the ban check result to the caller\n     5.3. IF banned THEN\n          5.3.1. Log the ban match for audit purposes\n     5.4. ELSE\n          5.4.1. Allow normal system access",
    "databaseEntities": [
      "jforum_users"
    ],
    "validationRules": [
      "User information must contain at least one identifiable attribute",
      "Banlist must be accessible and loaded before checking",
      "Each ban criteria must be properly formatted and valid",
      "Ban matching must check all relevant user attributes against ban criteria"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "BanCandidate": {
        "type": "object",
        "properties": {
          "username": {
            "type": "string",
            "description": "User's login name"
          },
          "email": {
            "type": "string",
            "description": "User's email address"
          },
          "ipAddress": {
            "type": "string",
            "description": "User's IP address"
          },
          "userId": {
            "type": "number",
            "description": "User's unique identifier"
          }
        },
        "required": [
          "username",
          "email",
          "ipAddress"
        ]
      }
    }
  },
  {
    "featureName": "AddBanEntry",
    "description": "Adds a new ban entry to the banlist cache.",
    "inputValues": [
      "banEntry-object-Banlist"
    ],
    "businessLogic": "1. Input Collection\n   - Collect the ban entry object with the following properties:\n     - id: A unique identifier for the ban entry\n     - Type information (could be IP, username, or email)\n     - Value of the ban entry (the actual IP, username, or email to ban)\n     - Additional metadata (creation date, expiration date if applicable)\n   - System will automatically assign an ID if not provided\n\n2. Data Validation\n   - Validate ban entry object structure\n     - Ensure the ban entry has a valid type specified\n     - Ensure the ban value is not empty\n     - Verify the format of the ban value based on its type:\n       * IF type is IP, THEN validate IP address format\n       * IF type is email, THEN validate email format\n       * IF type is username, THEN validate username format\n     - Check that expiration date, if provided, is in the future\n   - IF any validation fails, THEN\n     - Generate appropriate error message\n     - Halt the process and return validation error\n\n3. Business Rule Processing\n   - Check for duplicate ban entries\n     - Retrieve current banlist from cache\n     - Check if an identical ban entry already exists\n     - IF duplicate found, THEN\n       * Generate duplicate entry error\n       * Halt the process\n   - Verify user has appropriate permissions to add ban entries\n   - Check system limits on number of ban entries if applicable\n\n4. Core Operation Execution\n   - Retrieve the current banlist map from cache\n     - IF banlist does not exist in cache, THEN create a new empty map\n   - Add the new ban entry to the banlist map\n     - Use the ban entry ID as the key\n     - Store the complete ban entry object as the value\n   - Update the banlist in the cache with the modified map\n   - Persist the ban entry to the database for permanent storage\n     - Create database record with all ban entry details\n     - Ensure database operation completes successfully\n   - IF database operation fails, THEN\n     - Remove the entry from cache\n     - Generate appropriate error message\n     - Halt the process\n\n5. Response Generation\n   - Generate success response\n     - Include confirmation message\n     - Include the ID of the newly added ban entry\n     - Include summary of the ban entry details\n   - Return success status with ban entry information\n   - Log the addition of the new ban entry for audit purposes",
    "databaseEntities": [
      "jforum_banlist"
    ],
    "validationRules": [
      "Ban entry must have a valid type (IP, username, or email)",
      "Ban value must not be empty",
      "Ban value must match the format requirements for its type",
      "Expiration date, if provided, must be in the future",
      "Duplicate ban entries are not allowed"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Banlist": {
        "type": "object",
        "properties": {
          "id": {
            "type": "number",
            "description": "Unique identifier for the ban entry"
          },
          "type": {
            "type": "string",
            "description": "Type of ban (IP, username, email)",
            "enum": [
              "IP",
              "USERNAME",
              "EMAIL"
            ]
          },
          "value": {
            "type": "string",
            "description": "The actual value to ban (IP address, username, or email)"
          },
          "creationDate": {
            "type": "date",
            "description": "Date when the ban entry was created"
          },
          "expirationDate": {
            "type": "date",
            "description": "Optional date when the ban expires"
          }
        },
        "required": [
          "type",
          "value"
        ]
      }
    }
  },
  {
    "featureName": "RemoveBanEntry",
    "description": "Removes a ban entry from the banlist cache by its ID.",
    "inputValues": [
      "banlistId-number-Banlist"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the following required input:\n     1.1. banlistId (number, mandatory): The unique identifier of the ban entry to be removed\n\n2. Data Validation:\n   - Validate the banlist ID input:\n     2.1. Check if banlistId is provided\n        IF banlistId is null or undefined THEN\n           Return error message: \"Ban ID is required\"\n     2.2. Verify banlistId is a valid number\n        IF banlistId is not a number THEN\n           Return error message: \"Ban ID must be a number\"\n     2.3. Verify banlistId is a positive integer\n        IF banlistId is not a positive integer THEN\n           Return error message: \"Ban ID must be a positive integer\"\n\n3. Business Rule Processing:\n   - Verify the ban entry exists:\n     3.1. Check if the ban entry with the specified ID exists in the banlist cache\n        IF ban entry does not exist THEN\n           Return error message: \"Ban entry not found with the specified ID\"\n\n4. Core Operation Execution:\n   - Remove the ban entry from the cache:\n     4.1. Retrieve the current banlist collection from the cache\n     4.2. Remove the ban entry with the specified ID from the collection\n     4.3. Update the banlist collection in the cache with the modified collection\n     4.4. IF any error occurs during removal THEN\n           Log the error details\n           Return error message: \"Failed to remove ban entry\"\n\n5. Response Generation:\n   - Generate appropriate response:\n     5.1. IF removal is successful THEN\n           Return success message: \"Ban entry successfully removed\"\n           Include the ID of the removed ban entry in the response\n     5.2. IF removal fails THEN\n           Return error message with details about the failure\n           Include support information if needed",
    "databaseEntities": [
      "jforum_users"
    ],
    "validationRules": [
      "Ban ID must be provided",
      "Ban ID must be a valid positive integer",
      "Ban entry must exist in the system"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Banlist": {
        "id": "number",
        "type": "string",
        "value": "string"
      }
    }
  },
  {
    "featureName": "LoadBanlist",
    "description": "Loads all ban entries from the database into the cache for efficient access and validation.",
    "inputValues": [],
    "businessLogic": "1. Input Collection:\n   - No direct user inputs required for this operation\n   - System-generated trigger initiates the process\n\n2. Data Validation:\n   - No input validation required as this is a system-initiated process\n\n3. Business Rule Processing:\n   - Verify cache system is initialized and available\n   - Check if cache engine is properly configured\n   - Ensure database connection is available\n\n4. Core Operation Execution:\n   4.1. Initialize data structures\n      - Create empty collection to store ban entries\n   4.2. Retrieve ban entries\n      - Connect to the data source\n      - Query all ban entries from the database\n      - Retrieve complete list of ban records\n   4.3. Process ban entries\n      - FOR each ban entry in the retrieved list:\n         - Extract ban entry details (ID, type, value)\n         - Format the ban entry for cache storage\n         - Add the formatted ban entry to the collection\n   4.4. Update cache\n      - Clear any existing ban entries in the cache\n      - Store the complete collection of ban entries in the cache\n      - Set appropriate cache expiration policies\n   4.5. Verify cache population\n      - Confirm all entries were successfully cached\n      - Log the number of ban entries loaded\n\n5. Response Generation:\n   - Return success status indicating cache was populated\n   - Include count of loaded ban entries\n   - IF any errors occurred during loading:\n      - Generate appropriate error message\n      - Include details about which part of the process failed",
    "databaseEntities": [
      "jforum_banlist"
    ],
    "validationRules": [
      "Cache system must be properly initialized before loading ban entries",
      "Database connection must be available",
      "Ban entries must be successfully retrieved from the database",
      "All retrieved ban entries must be properly formatted before caching",
      "Cache must be successfully updated with all ban entries"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Banlist": {
        "id": "number",
        "type": "string",
        "value": "string"
      }
    }
  },
  {
    "featureName": "GetCategory",
    "description": "Retrieves a category by its ID with user access control validation.",
    "inputValues": [
      "categoryId-number-Category",
      "userId-number-User"
    ],
    "businessLogic": "1. Input Collection\n   - Collect the following inputs:\n     a. categoryId (number, mandatory): The unique identifier of the category to retrieve\n     b. userId (number, mandatory): The identifier of the user requesting the category\n     c. System will use current session user ID if userId is not explicitly provided\n\n2. Data Validation\n   - Validate inputs:\n     a. Validate categoryId:\n        i. Ensure categoryId is a positive integer\n        ii. Ensure categoryId exists in the system\n        iii. Return error if categoryId is invalid or not found\n     b. Validate userId:\n        i. Ensure userId is a positive integer\n        ii. Ensure userId exists in the system\n        iii. Use current session user if userId is not provided\n\n3. Business Rule Processing\n   - Check access permissions:\n     a. Retrieve permission control for the user\n     b. IF user has no permission control:\n        i. Create new permission control for the user\n     c. Check if user has access to the requested category:\n        i. IF user does not have access permission to the category:\n           - Return null (indicating category not accessible)\n        ii. ELSE continue with retrieval\n\n4. Core Operation Execution\n   - Retrieve category data:\n     a. Check if category exists in the system cache\n        i. IF category exists in cache:\n           - Retrieve category data from cache\n        ii. ELSE:\n           - Log warning about cache miss\n           - Attempt to reload categories from data source\n           - Check cache again after reload\n           - IF category still not in cache:\n              * Throw exception indicating category cannot be found\n     b. Apply access control filter:\n        i. IF user has access to the category:\n           - Return the complete category data\n        ii. ELSE:\n           - Return null (indicating category not accessible)\n\n5. Response Generation\n   - Format the response:\n     a. IF category was successfully retrieved AND user has access:\n        i. Return complete category object with all associated data\n     b. IF category was not found OR user lacks access permission:\n        i. Return null to indicate category is not available\n     c. IF system error occurred during retrieval:\n        i. Throw appropriate exception with details about the failure",
    "databaseEntities": [
      "jforum_categories",
      "jforum_forums",
      "jforum_user_groups",
      "jforum_groups",
      "jforum_users"
    ],
    "validationRules": [
      "Category ID must be a positive integer",
      "Category must exist in the system",
      "User must have permission to access the requested category",
      "User ID must be valid if explicitly provided"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Category": {
        "id": "number",
        "name": "string",
        "order": "number",
        "forums": "array"
      },
      "User": {
        "id": "number",
        "username": "string"
      },
      "PermissionControl": {
        "userId": "number",
        "permissions": "object"
      }
    }
  },
  {
    "featureName": "GetAllCategories",
    "description": "Retrieves all categories accessible to the current user.",
    "inputValues": [
      "userId-number-User"
    ],
    "businessLogic": "1. Input Collection\n   - Collect userId (number) from the current user session\n   - If userId is not provided, use the current authenticated user's ID from the session facade\n   - System will use this userId to filter categories based on access permissions\n\n2. Data Validation\n   - Validate that userId is a valid positive integer\n     - IF userId is invalid or negative THEN\n       - Generate an error message indicating invalid user identification\n       - Terminate the process\n     - END IF\n   - Verify that the user session is active\n     - IF user session has expired THEN\n       - Generate an authentication required error\n       - Terminate the process\n     - END IF\n   - Verify the system cache is initialized\n     - IF the categories cache is not initialized THEN\n       - Initialize the categories cache\n     - END IF\n\n3. Business Rule Processing\n   - Retrieve user's permission control settings\n     - Load security repository data for the specified userId\n     - Prepare permission control object with user's access rights\n   - Initialize an empty categories list to store results\n   - Retrieve the complete set of categories from the system cache\n     - IF categories set is not found or is null THEN\n       - Attempt to reload categories data from the data source\n       - IF reload fails THEN\n         - Generate a system error indicating categories could not be loaded\n         - Terminate the process\n       - END IF\n     - END IF\n\n4. Core Operation Execution\n   - For each category in the complete categories set:\n     - Check if the current user has access permission to the category\n       - Verify category access permission using permission control object\n       - IF user has access permission to the category THEN\n         - Add the category to the results list\n         - For each forum in the category:\n           - Check if the user has access permission to the forum\n           - IF user has access permission to the forum THEN\n             - Include the forum in the category's forum list\n           - ELSE\n             - Exclude the forum from the category's forum list\n           - END IF\n       - END IF\n   - Sort the categories list by display order\n     - Categories with lower order values appear first in the list\n   - For each category in the filtered list:\n     - Sort the forums within the category by their display order\n\n5. Response Generation\n   - Prepare the response with the filtered categories list\n     - For each accessible category, include:\n       - Category ID\n       - Category name\n       - Category description\n       - Category display order\n       - List of forums within the category (only those accessible to the user)\n         - For each forum include:\n           - Forum ID\n           - Forum name\n           - Forum description\n           - Forum order\n           - Last post information (if available)\n           - Total topics count\n           - Total posts count\n   - Return the complete list of accessible categories\n   - IF no categories are accessible to the user THEN\n     - Return an empty list (not an error)\n   - END IF",
    "databaseEntities": [
      "jforum_categories",
      "jforum_forums",
      "jforum_users",
      "jforum_user_groups",
      "jforum_groups",
      "jforum_topics",
      "jforum_posts"
    ],
    "validationRules": [
      "User ID must be a valid positive integer",
      "User must have an active session",
      "User must have appropriate permissions to view categories",
      "Categories must be properly loaded in the system",
      "Category order must be respected in the display sequence",
      "Forums within categories must be ordered by their display sequence"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Category": {
        "id": "number",
        "name": "string",
        "description": "string",
        "order": "number",
        "forums": "array"
      },
      "Forum": {
        "id": "number",
        "name": "string",
        "description": "string",
        "order": "number",
        "categoryId": "number",
        "totalTopics": "number",
        "totalPosts": "number",
        "lastPostInfo": "object-LastPostInfo"
      },
      "LastPostInfo": {
        "postId": "number",
        "postDate": "string",
        "postTimeMillis": "number",
        "topicId": "number",
        "topicReplies": "number",
        "userId": "number",
        "username": "string"
      }
    }
  },
  {
    "featureName": "CheckCategoryAccessibility",
    "description": "Validates if a user has permission to access a specific category.",
    "inputValues": [
      "userId-number-User",
      "categoryId-number-Category",
      "permissionControl-object-PermissionControl"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect userId (number, mandatory) - The identifier of the user requesting access\n   - Collect categoryId (number, mandatory) - The identifier of the category to check access for\n   - Collect permissionControl (object, optional) - Permission control object containing user security settings\n\n2. Data Validation:\n   - Validate userId:\n     a. Verify userId is a positive integer\n     b. Verify userId exists in the system\n     c. IF userId is invalid or not found THEN\n        - Return error message indicating invalid user\n   - Validate categoryId:\n     a. Verify categoryId is a positive integer\n     b. Verify categoryId exists in the system\n     c. IF categoryId is invalid or not found THEN\n        - Return error message indicating invalid category\n\n3. Business Rule Processing:\n   - Determine the appropriate permission control:\n     a. IF permissionControl object is provided THEN\n        - Use the provided permissionControl object\n     b. ELSE\n        - Retrieve permission control from security repository using userId\n   - Check system state:\n     a. Verify the category repository is properly loaded\n     b. IF category repository is not loaded THEN\n        - Initialize the category repository\n        - IF initialization fails THEN\n          - Return error indicating system configuration issue\n\n4. Core Operation Execution:\n   - Perform permission check:\n     a. Using the permission control, check if user can access the specified category\n     b. Permission check evaluates against security constants for category access\n     c. IF user has required permissions THEN\n        - Set access result to true\n     d. ELSE\n        - Set access result to false\n   - Handle special cases:\n     a. IF user has administrator privileges THEN\n        - Override access result to true regardless of category permissions\n     b. IF category is marked as publicly accessible THEN\n        - Override access result to true regardless of user permissions\n\n5. Response Generation:\n   - Prepare the response:\n     a. Return boolean result indicating whether access is allowed (true) or denied (false)\n   - IF access is denied THEN\n     - Include reason for denial in response context\n   - IF access is allowed THEN\n     - Include category information in response context for further operations",
    "databaseEntities": [
      "jforum_categories",
      "jforum_users",
      "jforum_groups",
      "jforum_user_groups"
    ],
    "validationRules": [
      "User ID must be a valid positive integer",
      "Category ID must be a valid positive integer",
      "Category must exist in the system",
      "User must have permission to access the category",
      "Permission control must contain valid security settings"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "PermissionControl": {
        "type": "object",
        "properties": {
          "userId": {
            "type": "number",
            "description": "ID of the user whose permissions are being checked"
          },
          "permissions": {
            "type": "object",
            "description": "Collection of permission settings for the user"
          }
        },
        "required": [
          "userId",
          "permissions"
        ]
      }
    }
  },
  {
    "featureName": "ReloadCategory",
    "description": "Updates a category's name and order in the cache.",
    "inputValues": [
      "category-object-Category"
    ],
    "businessLogic": "1. Input Collection\n   - Collect the Category object with updated name and order\n   - Required fields:\n     * Category ID (system-generated identifier)\n     * Category name (mandatory string)\n     * Category order (mandatory number)\n\n2. Data Validation\n   - Validate Category object\n     * Verify Category ID exists and is a positive integer\n     * Verify Category name is not empty\n     * Verify Category order is a non-negative integer\n   - IF any validation fails THEN\n     * Generate appropriate error message\n     * Terminate the operation\n\n3. Business Rule Processing\n   - Check if the category exists in the system\n     * IF category does not exist THEN\n       * Generate error message indicating category not found\n       * Terminate the operation\n   - Check if another category already has the requested order\n     * Find category with the same order as the updated category\n     * Store reference to this category if found\n\n4. Core Operation Execution\n   - Create a temporary sorted collection of categories\n     * Add all existing categories to the collection\n   - IF another category exists with the same order THEN\n     * Remove that category from the temporary collection\n     * Remove that category from the cache by ID\n   - Add the updated category to the temporary collection\n   - Add the updated category to the cache by ID\n   - IF another category was found with the same order AND it's not the same category being updated THEN\n     * Remove the original version of the updated category from the collection\n     * Set the order of the displaced category to the original order of the updated category\n     * Add the displaced category back to the collection\n     * Update the displaced category in the cache by ID\n   - Update the categories collection in the cache\n\n5. Response Generation\n   - IF operation completes successfully THEN\n     * Return success status\n     * Indicate category was successfully updated in the cache\n   - IF any errors occur during processing THEN\n     * Return error status\n     * Include specific error details and suggestions for resolution",
    "databaseEntities": [
      "jforum_categories",
      "jforum_forums"
    ],
    "validationRules": [
      "Category ID must exist in the system",
      "Category name must not be empty",
      "Category order must be a non-negative integer"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Category": {
        "id": "number",
        "name": "string",
        "order": "number",
        "forums": "array"
      }
    }
  },
  {
    "featureName": "RefreshCategory",
    "description": "Refreshes a category entry in the cache to ensure data consistency.",
    "inputValues": [
      "category-object-Category"
    ],
    "businessLogic": "1. Input Collection\n   - Collect the Category object to be refreshed\n     - Category must contain at minimum the category ID\n     - Category should contain updated information\n\n2. Data Validation\n   - Validate Category object\n     - Ensure Category object is not null\n     - Verify Category ID is valid (greater than 0)\n     - Check that Category contains all required attributes\n     - Validate that Category follows proper structure\n   - IF any validation fails THEN\n     - Generate appropriate error message\n     - Terminate the operation\n\n3. Business Rule Processing\n   - Check system state\n     - Verify cache system is operational\n     - Ensure Category exists in the cache\n   - IF Category does not exist in cache THEN\n     - Generate error indicating Category not found\n     - Terminate the operation\n\n4. Core Operation Execution\n   - Update Category in cache\n     - Add or update Category in cache using category ID as key\n     - Retrieve current category set from cache\n     - Remove the existing Category from the set\n     - Add the updated Category to the set\n     - Update the category set in cache\n   - Handle synchronization\n     - Ensure thread safety during cache update\n     - Prevent concurrent modifications\n   - IF any operation fails THEN\n     - Revert any partial changes\n     - Log the failure\n     - Generate appropriate error message\n\n5. Response Generation\n   - Generate success response\n     - Indicate Category was successfully refreshed\n     - Include Category ID in response\n   - IF operation failed THEN\n     - Generate error response\n     - Include error details and reason for failure\n     - Provide guidance for resolution",
    "databaseEntities": [
      "jforum_categories",
      "jforum_forums"
    ],
    "validationRules": [
      "Category object must not be null",
      "Category ID must be greater than 0",
      "Category must exist in the cache",
      "Cache system must be operational"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Category": {
        "id": "number",
        "name": "string",
        "order": "number",
        "forums": "array"
      }
    }
  },
  {
    "featureName": "RefreshForum",
    "description": "Updates a forum within its parent category in the cache.",
    "inputValues": [
      "forum-object-Forum"
    ],
    "businessLogic": "1. Input Collection\n   - Collect the Forum object to be refreshed\n     - Forum object must contain all necessary attributes including ID and categoryId\n     - System will use this object to update the cached version\n\n2. Data Validation\n   - Validate Forum object integrity\n     - Ensure forum object is not null\n     - Verify forum ID is valid (greater than 0)\n     - Verify categoryId is valid (greater than 0)\n     - Check that all required forum attributes are present\n   - IF any validation fails THEN\n     - Generate appropriate error message\n     - Terminate the operation\n\n3. Business Rule Processing\n   - Verify category existence\n     - Retrieve the parent category using the forum's categoryId\n     - IF category does not exist THEN\n       - Log error about missing parent category\n       - Terminate the operation\n     - ELSE continue with refresh operation\n   - Check user permissions (if applicable)\n     - Verify current user has permission to modify forum data\n     - IF user lacks permission THEN\n       - Generate access denied message\n       - Terminate the operation\n\n4. Core Operation Execution\n   - Retrieve the parent category from cache\n     - Use forum's categoryId to identify the correct parent category\n   - Update forum in category\n     - Add or update the forum within the parent category's forum collection\n     - Ensure forum ordering is maintained within the category\n   - Refresh category in cache\n     - Update the category object in the cache with the modified forum\n     - Ensure all category relationships remain intact\n   - Update related cache entries\n     - Update any secondary cache entries that reference the forum\n     - Maintain consistency across all cached data\n\n5. Response Generation\n   - Generate success response\n     - Indicate the forum was successfully refreshed in the cache\n     - Include forum identifier in the response\n   - IF any errors occurred during the process THEN\n     - Generate appropriate error response\n     - Include details about what went wrong\n     - Provide guidance on how to resolve the issue",
    "databaseEntities": [
      "jforum_categories",
      "jforum_forums"
    ],
    "validationRules": [
      "Forum object must not be null",
      "Forum ID must be greater than 0",
      "Forum categoryId must be greater than 0",
      "Parent category must exist in the system",
      "User must have permission to update forum data"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Forum": {
        "type": "object",
        "properties": {
          "id": {
            "type": "integer",
            "description": "Unique identifier for the forum"
          },
          "categoryId": {
            "type": "integer",
            "description": "ID of the parent category"
          },
          "name": {
            "type": "string",
            "description": "Name of the forum"
          },
          "description": {
            "type": "string",
            "description": "Description of the forum"
          },
          "order": {
            "type": "integer",
            "description": "Display order within the category"
          },
          "totalTopics": {
            "type": "integer",
            "description": "Count of topics in the forum"
          },
          "totalPosts": {
            "type": "integer",
            "description": "Count of posts in the forum"
          },
          "lastPostInfo": {
            "type": "object",
            "description": "Information about the last post in the forum"
          }
        },
        "required": [
          "id",
          "categoryId",
          "name"
        ]
      }
    }
  },
  {
    "featureName": "RemoveCategory",
    "description": "Removes a category from the cache system.",
    "inputValues": [
      "category-object-Category"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the Category object to be removed\n     - Category must contain at minimum the category ID\n     - Other category properties may be present but are not required for removal\n\n2. Data Validation:\n   - Validate Category object\n     - Verify the Category object is not null\n     - Verify the Category ID is valid (greater than 0)\n     - IF validation fails, THEN generate appropriate error message\n\n3. Business Rule Processing:\n   - Check if the category exists in the cache\n     - Verify the category with the provided ID exists in the cache system\n     - IF category does not exist, THEN generate a \"Category not found\" error\n   - Check for dependencies\n     - Determine if any forums are associated with this category\n     - Note any relationships that will be affected by removal\n\n4. Core Operation Execution:\n   - Remove category from primary storage\n     - Remove the category entry using the category ID as key\n   - Update category collection\n     - Retrieve the current set of categories\n     - Remove the target category from the set\n     - Save the updated set back to the cache\n   - Update relationship mappings\n     - Retrieve the current relationship map\n     - Remove all entries where the category ID matches the target category\n     - Save the updated relationship map back to the cache\n   - Handle any cleanup operations\n     - Ensure all references to the category are removed\n     - Update any dependent counters or statistics\n\n5. Response Generation:\n   - Generate success response\n     - Indicate the category was successfully removed\n     - Include the ID of the removed category\n   - Generate error response if any operation failed\n     - Include specific error details and reason for failure\n     - Provide guidance on how to resolve the issue",
    "databaseEntities": [
      "jforum_categories",
      "jforum_forums"
    ],
    "validationRules": [
      "Category object must not be null",
      "Category ID must be greater than zero",
      "Category must exist in the cache before removal"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Category": {
        "type": "object",
        "properties": {
          "id": {
            "type": "integer",
            "description": "Unique identifier for the category"
          },
          "name": {
            "type": "string",
            "description": "Name of the category"
          },
          "order": {
            "type": "integer",
            "description": "Display order of the category"
          },
          "forums": {
            "type": "array",
            "description": "List of forums associated with this category"
          }
        },
        "required": [
          "id"
        ]
      }
    }
  },
  {
    "featureName": "AddCategory",
    "description": "Adds a new category to the cache system.",
    "inputValues": [
      "category-object-Category"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the Category object with the following properties:\n     - id: Unique identifier for the category\n     - name: Name of the category\n     - order: Display order of the category\n     - forums: Collection of forums associated with this category\n\n2. Data Validation:\n   - Validate Category object:\n     - Ensure category id is a positive integer\n     - Verify category name is not empty\n     - Confirm order value is a non-negative integer\n     - Check that forums collection is properly initialized (can be empty)\n   - IF any validation fails, THEN:\n     - Generate appropriate error message\n     - Abort the operation\n\n3. Business Rule Processing:\n   - Check if category with same id already exists in cache:\n     - IF category with same id exists, THEN:\n       - Generate duplicate category error\n       - Abort the operation\n   - Check if category with same order already exists:\n     - IF category with same order exists, THEN:\n       - Note potential conflict for handling in next step\n\n4. Core Operation Execution:\n   - Acquire synchronization lock to prevent concurrent modifications\n   - Convert category id to string format for cache storage\n   - Add category to cache using category id as key\n   - Retrieve existing category set from cache:\n     - IF category set doesn't exist, THEN:\n       - Create new ordered category set\n   - Add new category to the set\n   - Update the category set in cache\n   - Process forum relationships:\n     - Retrieve existing relation map from cache\n     - IF relation map doesn't exist, THEN:\n       - Create new relation map\n     - FOR EACH forum in the category's forums collection:\n       - Add mapping between forum id and category id to relation map\n   - Store updated relation map in cache\n   - Release synchronization lock\n\n5. Response Generation:\n   - IF operation completes successfully, THEN:\n     - Return success indicator\n     - Include category id of newly added category\n   - IF operation fails, THEN:\n     - Return failure indicator\n     - Include specific error message and reason for failure",
    "databaseEntities": [
      "jforum_categories",
      "jforum_forums"
    ],
    "validationRules": [
      "Category ID must be a positive integer",
      "Category name must not be empty",
      "Category order must be a non-negative integer",
      "Category ID must be unique in the system",
      "Forums collection must be properly initialized"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Category": {
        "id": "integer",
        "name": "string",
        "order": "integer",
        "forums": "array"
      }
    }
  },
  {
    "featureName": "GetForum",
    "description": "Retrieves a specific forum if it exists and is accessible to the user.",
    "inputValues": [
      "forumId-number-Forum",
      "userId-number-User"
    ],
    "businessLogic": "1. Input Collection\n   - Collect forumId (mandatory): Numeric identifier of the forum to retrieve\n   - Collect userId (system-generated): Current user's identifier\n\n2. Data Validation\n   - Validate forumId:\n     a. Check if forumId is provided\n     b. Verify forumId is a positive integer\n     c. Return error message if validation fails\n\n3. Business Rule Processing\n   - Check forum existence:\n     a. Retrieve category relationship for the requested forum\n     b. IF category relationship is not found THEN\n        i. Return null indicating forum does not exist\n     c. Retrieve category using the relationship\n\n   - Check user access permissions:\n     a. Verify if the category containing the forum is accessible to the user\n     b. IF category is not accessible THEN\n        i. Return null indicating forum is not accessible\n\n4. Core Operation Execution\n   - Retrieve forum data:\n     a. Get forum object from the category using forumId\n     b. IF forum is not found in the category THEN\n        i. Return null indicating forum does not exist\n\n   - Prepare forum data for display:\n     a. Ensure forum metadata is properly loaded\n     b. Load forum statistics if needed\n     c. Load last post information if needed\n     d. Load moderator list if needed\n\n5. Response Generation\n   - Success response:\n     a. Return complete forum object with all relevant information\n     b. Include forum properties (name, description, etc.)\n     c. Include forum statistics (total posts, total topics)\n     d. Include last post information\n\n   - Error response:\n     a. Return null if forum does not exist\n     b. Return null if forum exists but user does not have access",
    "databaseEntities": [
      "jforum_forums",
      "jforum_categories",
      "jforum_users",
      "jforum_posts",
      "jforum_topics",
      "jforum_moderator_groups"
    ],
    "validationRules": [
      "Forum ID must be a positive integer",
      "User must have access permission to view the forum",
      "Forum must exist in the system",
      "Category containing the forum must be accessible to the user"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Forum": {
        "id": "number",
        "name": "string",
        "description": "string",
        "categoryId": "number",
        "totalTopics": "number",
        "totalPosts": "number",
        "lastPostInfo": "object"
      },
      "Category": {
        "id": "number",
        "name": "string",
        "order": "number",
        "forums": "array"
      },
      "LastPostInfo": {
        "postId": "number",
        "postDate": "string",
        "postTimeMillis": "number",
        "topicId": "number",
        "topicReplies": "number",
        "userId": "number",
        "username": "string"
      }
    }
  },
  {
    "featureName": "IsForumAccessible",
    "description": "Checks if a forum is accessible to a specific user.",
    "inputValues": [
      "userId-number-User",
      "forumId-number-Forum"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect userId (number, required): The identifier of the user requesting access\n   - Collect forumId (number, required): The identifier of the forum to check access for\n   - System will determine categoryId (number, system-generated): The category to which the forum belongs\n\n2. Data Validation:\n   - Validate userId:\n      * Ensure userId is a positive integer\n      * Verify userId exists in the system\n      * If validation fails, return appropriate error message\n   - Validate forumId:\n      * Ensure forumId is a positive integer\n      * Verify forumId exists in the system\n      * If validation fails, return appropriate error message\n\n3. Business Rule Processing:\n   - Retrieve category relationship:\n      * Determine the categoryId associated with the forumId\n      * IF category relationship cannot be found, THEN\n         > Return false (forum is not accessible)\n   - Check category accessibility:\n      * Verify if the user has access to the category containing the forum\n      * IF category is not accessible to the user, THEN\n         > Return false (forum is not accessible)\n\n4. Core Operation Execution:\n   - Retrieve forum from category:\n      * Using the categoryId and forumId, attempt to retrieve the forum for the specific user\n      * The retrieval process applies user-specific access controls\n   - Determine accessibility:\n      * IF forum retrieval returns a non-null result, THEN\n         > User has access to the forum\n      * ELSE\n         > User does not have access to the forum\n\n5. Response Generation:\n   - Return accessibility status:\n      * Return boolean value: true if forum is accessible, false otherwise\n   - No additional information is provided in the response",
    "databaseEntities": [
      "jforum_users",
      "jforum_forums",
      "jforum_categories",
      "jforum_user_groups",
      "jforum_groups"
    ],
    "validationRules": [
      "User ID must be a valid positive integer",
      "Forum ID must be a valid positive integer",
      "Forum must exist in the system",
      "User must have access rights to the forum's category",
      "User must have appropriate permissions to access the forum"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "User": {
        "id": "number",
        "username": "string"
      },
      "Forum": {
        "id": "number",
        "name": "string",
        "categoryId": "number"
      },
      "Category": {
        "id": "number",
        "name": "string"
      }
    }
  },
  {
    "featureName": "AddForum",
    "description": "Adds a new forum to the cache repository.",
    "inputValues": [
      "forum-object-Forum"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the Forum object with the following required attributes:\n     * id (number): Unique identifier for the forum\n     * categoryId (number): ID of the category this forum belongs to\n     * name (string): Name of the forum\n     * description (string): Description of the forum\n     * order (number): Display order of the forum within its category\n   - System will use the following system-generated fields:\n     * totalTopics (number): Initialized to 0\n     * totalPosts (number): Initialized to 0\n     * lastPostInfo (object): Initialized to null\n\n2. Data Validation:\n   - Validate Forum object structure:\n     * Verify forum id is a positive integer\n     * Verify categoryId is a positive integer\n     * Verify name is not empty\n     * Verify order is a non-negative integer\n   - IF any validation fails THEN:\n     * Generate appropriate error message\n     * Abort the operation\n\n3. Business Rule Processing:\n   - Verify the category exists in the cache:\n     * Retrieve category by ID from cache\n     * IF category not found THEN:\n       * Generate error message: \"Category not found\"\n       * Abort the operation\n   - Verify forum ID is unique:\n     * Check if forum ID already exists in the relation map\n     * IF forum ID exists THEN:\n       * Generate error message: \"Forum with this ID already exists\"\n       * Abort the operation\n   - Verify category is accessible:\n     * Check if the category is accessible to the current user\n     * IF category is not accessible THEN:\n       * Generate error message: \"Category is not accessible\"\n       * Abort the operation\n\n4. Core Operation Execution:\n   - Retrieve the category object from cache using categoryId\n   - Add the forum to the category:\n     * Update the category's forum collection to include the new forum\n     * Update the category in the cache\n   - Update the relation map:\n     * Add mapping between forum ID and category ID\n     * Update the relation map in the cache\n   - Update the categories set in the cache:\n     * Retrieve the current categories set\n     * Update the cache with the modified set\n   - Initialize forum statistics:\n     * Set totalTopics to 0\n     * Set totalPosts to 0\n     * Set lastPostInfo to null\n\n5. Response Generation:\n   - IF operation successful THEN:\n     * Return success status\n     * Include the added forum details\n     * Include the updated category information\n   - IF operation fails at any point THEN:\n     * Return error status\n     * Include specific error message\n     * Include guidance for resolving the issue",
    "databaseEntities": [
      "jforum_forums",
      "jforum_categories"
    ],
    "validationRules": [
      "Forum ID must be a positive integer",
      "Category ID must be a positive integer",
      "Forum name must not be empty",
      "Forum order must be a non-negative integer",
      "Category must exist in the system",
      "Forum ID must be unique"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Forum": {
        "id": "number",
        "categoryId": "number",
        "name": "string",
        "description": "string",
        "order": "number",
        "totalTopics": "number",
        "totalPosts": "number",
        "lastPostInfo": {
          "type": "object",
          "properties": {
            "postId": "number",
            "postDate": "string",
            "postTimeMillis": "number",
            "topicId": "number",
            "topicReplies": "number",
            "userId": "number",
            "username": "string"
          }
        }
      },
      "Category": {
        "id": "number",
        "name": "string",
        "order": "number",
        "forums": "array"
      }
    }
  },
  {
    "featureName": "RemoveForum",
    "description": "Removes a forum from the cache system.",
    "inputValues": [
      "forum-object-Forum"
    ],
    "businessLogic": "1. Input Collection\n   - Collect the Forum object that needs to be removed from the cache\n     1.1. Ensure the Forum object contains at least the forum ID\n     1.2. Ensure the Forum object contains the category ID it belongs to\n\n2. Data Validation\n   - Validate the forum object and its properties\n     2.1. Verify the forum object is not null\n     2.2. Verify the forum ID is a valid positive integer\n     2.3. Verify the category ID is a valid positive integer\n     2.4. IF any validation fails, THEN generate appropriate error message and terminate the operation\n\n3. Business Rule Processing\n   - Check if the forum exists in the cache\n     3.1. Retrieve the relation map from the cache\n     3.2. Check if the forum ID exists as a key in the relation map\n     3.3. IF the forum ID does not exist in the relation map, THEN generate a \"Forum not found\" message and terminate the operation\n\n4. Core Operation Execution\n   - Remove the forum from the cache system\n     4.1. Convert the forum ID to string format for cache operations\n     4.2. Retrieve the relation map from the cache\n     4.3. Remove the forum ID entry from the relation map\n     4.4. Update the relation map in the cache\n     4.5. Convert the category ID to string format\n     4.6. Retrieve the category object from the cache using the category ID\n     4.7. Remove the forum from the category's forum collection\n     4.8. Update the category object in the cache\n     4.9. Retrieve the categories set from the cache\n     4.10. Update the categories set in the cache to reflect the changes\n\n5. Response Generation\n   - Complete the operation and provide appropriate feedback\n     5.1. IF all operations completed successfully, THEN generate success message indicating the forum was successfully removed from the cache\n     5.2. IF any errors occurred during the removal process, THEN generate appropriate error message with details about what went wrong\n     5.3. Return the operation status to the caller",
    "databaseEntities": [
      "jforum_forums",
      "jforum_categories"
    ],
    "validationRules": [
      "Forum object must not be null",
      "Forum ID must be a positive integer",
      "Category ID must be a positive integer",
      "Forum must exist in the cache system",
      "Category must exist in the cache system"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Forum": {
        "id": "number",
        "categoryId": "number",
        "name": "string",
        "description": "string",
        "order": "number",
        "totalTopics": "number",
        "totalPosts": "number",
        "lastPostInfo": "object"
      },
      "Category": {
        "id": "number",
        "name": "string",
        "order": "number",
        "forums": "array"
      }
    }
  },
  {
    "featureName": "ReloadForum",
    "description": "Reloads forum information in the cache to ensure data consistency and up-to-date forum details.",
    "inputValues": [
      "forumId-number-Forum"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect forumId (mandatory) - Numeric identifier of the forum to reload\n   - System will generate current timestamp (system-generated)\n\n2. Data Validation:\n   - Validate forumId:\n     a. Check if forumId is provided\n     b. Verify forumId is a positive integer\n     c. Return appropriate error message if validation fails\n   - Verify forum exists:\n     a. Check if the forum with given forumId exists in the system\n     b. Return appropriate error message if forum does not exist\n\n3. Business Rule Processing:\n   - Check user permissions:\n     a. Verify if current user has permission to reload forum data\n     b. IF user lacks permission THEN\n        i. Generate access denied error\n        ii. Log unauthorized access attempt\n        iii. Return error response\n   - Check system state:\n     a. Verify if cache system is operational\n     b. IF cache system is not available THEN\n        i. Log system error\n        ii. Return system unavailable error\n\n4. Core Operation Execution:\n   - Retrieve latest forum data:\n     a. Fetch complete forum information from the database using forumId\n     b. IF database retrieval fails THEN\n        i. Log retrieval error\n        ii. Attempt retry (maximum 3 attempts)\n        iii. Return system error if all attempts fail\n   - Update cache with new forum data:\n     a. Acquire synchronization lock to prevent concurrent modifications\n     b. Check if forum exists in cache relation mapping\n     c. IF forum exists in cache THEN\n        i. Retrieve associated category for the forum\n        ii. Reset forum's last post information\n        iii. Fetch updated last post information\n        iv. Update forum in the category\n        v. Update category in cache\n        vi. Update categories set in cache\n     d. Update total message count in the system\n     e. Release synchronization lock\n   - Handle related data:\n     a. Update any dependent cache entries\n     b. Ensure consistency across related data objects\n\n5. Response Generation:\n   - Success response:\n     a. Generate confirmation message\n     b. Include timestamp of cache refresh\n     c. Include summary of updated forum information\n   - Error response:\n     a. Include specific error code and message\n     b. Provide troubleshooting information\n     c. Suggest alternative actions if applicable",
    "databaseEntities": [
      "jforum_forums",
      "jforum_categories",
      "jforum_topics",
      "jforum_posts"
    ],
    "validationRules": [
      "Forum ID must be a positive integer",
      "Forum must exist in the system",
      "User must have permission to reload forum data",
      "Cache system must be operational",
      "Database connection must be available"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Forum": {
        "id": "number",
        "name": "string",
        "description": "string",
        "categoryId": "number",
        "lastPostInfo": "object",
        "totalTopics": "number",
        "totalPosts": "number"
      },
      "Category": {
        "id": "number",
        "name": "string",
        "order": "number",
        "forums": "array"
      },
      "LastPostInfo": {
        "postId": "number",
        "postDate": "string",
        "postTimeMillis": "number",
        "topicId": "number",
        "topicReplies": "number",
        "userId": "number",
        "username": "string"
      }
    }
  },
  {
    "featureName": "UpdateForumStats",
    "description": "Updates forum statistics when a new post is added to a topic.",
    "inputValues": [
      "topic-object-Topic",
      "user-object-User",
      "post-object-Post"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect Topic object with forum ID and topic details\n   - Collect User object with user information\n   - Collect Post object with post content and timestamp\n   - System will use the current date/time format from system configuration\n\n2. Data Validation:\n   - Validate Topic object:\n      * Ensure topic ID is valid and greater than zero\n      * Verify forum ID exists and is greater than zero\n      * Confirm topic replies count is valid and not negative\n   - Validate User object:\n      * Ensure user ID is valid and greater than zero\n      * Verify username is not empty\n   - Validate Post object:\n      * Ensure post ID is valid and greater than zero\n      * Verify post timestamp is valid and not null\n   - IF any validation fails, THEN:\n      * Generate appropriate error message\n      * Abort the update process\n\n3. Business Rule Processing:\n   - Verify forum exists in the system:\n      * Retrieve forum using topic's forum ID\n      * IF forum not found, THEN abort operation with error message\n   - Check user permissions:\n      * Verify user has permission to post in the specified forum\n      * IF user lacks permission, THEN abort operation with error message\n   - Verify category accessibility:\n      * Check if the forum's category is accessible\n      * IF category not accessible, THEN abort operation with error message\n\n4. Core Operation Execution:\n   - Retrieve current forum information:\n      * Get forum by ID from the topic\n      * Retrieve the forum's last post information\n   - Create or update last post information:\n      * IF last post info doesn't exist, THEN create new last post info object\n      * Set post ID, post date, and post timestamp\n      * Set topic ID and topic replies count\n      * Set user ID and username\n   - Update forum statistics:\n      * IF topic replies count is zero (new topic), THEN:\n         > Increment forum's total topics count by 1\n      * Increment forum's total posts count by 1\n   - Update category information:\n      * Retrieve the category containing the forum\n      * Update the forum within the category\n      * Refresh the category data\n\n5. Response Generation:\n   - Success response:\n      * Confirmation that forum statistics were updated successfully\n      * Updated forum information including new post counts and last post details\n   - Error response:\n      * Specific error message indicating what validation or business rule failed\n      * Suggestion for corrective action if applicable",
    "databaseEntities": [
      "jforum_forums",
      "jforum_topics",
      "jforum_posts",
      "jforum_users",
      "jforum_categories"
    ],
    "validationRules": [
      "Topic ID must be greater than zero",
      "Forum ID must be greater than zero",
      "User ID must be greater than zero",
      "Post ID must be greater than zero",
      "Username must not be empty",
      "Post timestamp must be valid",
      "Topic replies count must not be negative",
      "Forum must exist in the system",
      "User must have permission to post in the forum",
      "Forum's category must be accessible"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Topic": {
        "id": "number",
        "forumId": "number",
        "totalReplies": "number"
      },
      "User": {
        "id": "number",
        "username": "string"
      },
      "Post": {
        "id": "number",
        "time": "date"
      },
      "LastPostInfo": {
        "postId": "number",
        "postDate": "string",
        "postTimeMillis": "number",
        "topicId": "number",
        "topicReplies": "number",
        "userId": "number",
        "username": "string"
      },
      "Forum": {
        "id": "number",
        "categoryId": "number",
        "totalTopics": "number",
        "totalPosts": "number",
        "lastPostInfo": "object"
      },
      "Category": {
        "id": "number",
        "forums": "array"
      }
    }
  },
  {
    "featureName": "ClearModeratorList",
    "description": "Clears the cached moderator list from the system.",
    "inputValues": [],
    "businessLogic": "1. Input Collection:\n   - No user inputs required\n   - System identifies the moderator cache to be cleared\n\n2. Data Validation:\n   - Verify current user has appropriate permissions to clear moderator cache\n   - IF user does not have required permissions THEN\n     - Generate access denied error\n     - Terminate operation\n   - END IF\n\n3. Business Rule Processing:\n   - Check if system is in a state where cache clearing is allowed\n   - IF system is currently processing critical moderator-related operations THEN\n     - Queue the clear request for later execution\n     - Notify user that request is queued\n     - Terminate operation\n   - END IF\n\n4. Core Operation Execution:\n   - Identify the moderator cache storage location\n   - Remove all entries from the moderator cache\n   - Release any resources associated with the cache\n   - IF cache clearing fails THEN\n     - Log the failure reason\n     - Attempt alternative cache clearing method if available\n     - IF alternative method fails THEN\n       - Generate system error\n       - Terminate operation\n     - END IF\n   - END IF\n\n5. Response Generation:\n   - Generate success notification indicating moderator cache was cleared\n   - Include timestamp of when cache was cleared\n   - Provide information about when new moderator data will be loaded\n   - Return success status to caller",
    "databaseEntities": [
      "jforum_moderator_groups",
      "jforum_forums",
      "jforum_users"
    ],
    "validationRules": [
      "User must have administrator privileges to clear moderator cache",
      "System must not be in maintenance mode when clearing cache",
      "Cache clearing operation must complete within system timeout limits"
    ],
    "dbSeedingOperations": [],
    "schema": {}
  },
  {
    "featureName": "SetLastRegisteredUser",
    "description": "Updates the most recently registered user in the system.",
    "inputValues": [
      "user-object-User"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the User object with the following attributes:\n     - userId (mandatory): Unique identifier for the user\n     - username (mandatory): Display name of the user\n     - registrationDate (mandatory): Date when the user registered\n     - Additional user profile information (optional)\n\n2. Data Validation:\n   - Validate User object:\n     - Check if User object is not null\n     - Verify userId is a valid positive integer\n     - Ensure username is not empty\n     - Confirm registrationDate is a valid date\n     - Verify username follows system naming conventions\n   - IF any validation fails THEN:\n     - Generate appropriate error message\n     - Abort the operation\n\n3. Business Rule Processing:\n   - Check system state:\n     - Verify the cache system is operational\n     - Ensure the user repository is accessible\n   - Verify user exists in the system:\n     - IF user does not exist in the database THEN:\n       - Generate error: \"Cannot set non-existent user as last registered\"\n       - Abort the operation\n   - Check user account status:\n     - IF user account is not active THEN:\n       - Generate error: \"Cannot set inactive user as last registered\"\n       - Abort the operation\n\n4. Core Operation Execution:\n   - Retrieve the current cache storage mechanism\n   - Store the user object in the cache:\n     - Use the appropriate cache key for last registered user\n     - Replace any existing last registered user information\n   - Update related statistics if necessary:\n     - IF this is a new registration THEN:\n       - Increment the total users count in the system\n   - Ensure cache consistency:\n     - Verify the user object is properly stored in cache\n     - Update any dependent cache entries if needed\n\n5. Response Generation:\n   - IF operation succeeds THEN:\n     - Return success status\n     - Include confirmation that the last registered user was updated\n   - IF operation fails THEN:\n     - Return failure status\n     - Include specific error message explaining the failure reason\n     - Provide guidance on how to resolve the issue",
    "databaseEntities": [
      "jforum_users"
    ],
    "validationRules": [
      "User object must not be null",
      "User ID must be a positive integer",
      "Username must not be empty",
      "Registration date must be a valid date",
      "User must exist in the system",
      "User account must be active"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "User": {
        "type": "object",
        "properties": {
          "id": {
            "type": "integer",
            "description": "Unique identifier for the user"
          },
          "username": {
            "type": "string",
            "description": "Display name of the user"
          },
          "registrationDate": {
            "type": "string",
            "format": "date-time",
            "description": "Date and time when the user registered"
          },
          "email": {
            "type": "string",
            "description": "Email address of the user"
          },
          "active": {
            "type": "boolean",
            "description": "Whether the user account is active"
          }
        },
        "required": [
          "id",
          "username",
          "registrationDate"
        ]
      }
    }
  },
  {
    "featureName": "GetTotalUsers",
    "description": "Retrieves the total number of users in the forum.",
    "inputValues": [],
    "businessLogic": "1. Input Collection:\n   - No user inputs required for this feature\n   - System will use internal state to retrieve user count\n\n2. Data Validation:\n   - No input validation required as there are no user inputs\n   - System will verify that the cache repository is accessible\n     - IF cache repository is not accessible THEN\n       - Generate appropriate error response\n       - End process\n\n3. Business Rule Processing:\n   - Verify user has permission to view user statistics\n     - IF current user does not have permission THEN\n       - Generate access denied response\n       - End process\n   - Check if total users count is already available in cache\n     - IF total users count exists in cache THEN\n       - Proceed to retrieve cached value\n     - ELSE\n       - System will need to calculate the count from database\n\n4. Core Operation Execution:\n   - Retrieve total users count\n     - IF count is available in cache THEN\n       - Retrieve the Integer value from cache repository\n     - ELSE\n       - Query the database for total number of registered users\n       - Store result in cache for future use\n   - Format the count value for display\n     - Convert Integer to appropriate display format\n     - Prepare count for inclusion in response\n\n5. Response Generation:\n   - Create success response containing:\n     - Total number of users in the system\n     - Status indicator showing successful retrieval\n   - IF any errors occurred during processing THEN\n     - Generate appropriate error response with:\n       - Error code\n       - Error description\n       - Suggested resolution steps",
    "databaseEntities": [
      "jforum_users"
    ],
    "validationRules": [
      "User must have permission to view forum statistics"
    ],
    "dbSeedingOperations": [],
    "schema": {}
  },
  {
    "featureName": "IncrementTotalUsers",
    "description": "Increments the total user count when a new user registers.",
    "inputValues": [
      "user-object-User"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the User object containing the new user information\n   - System retrieves current total user count from cache\n\n2. Data Validation:\n   - Verify the User object is not null\n   - Ensure the User object contains valid user information\n   - Verify the user is a new registration (not an update to existing user)\n\n3. Business Rule Processing:\n   - Check if the total user count cache entry exists\n     IF total user count cache entry does not exist THEN\n       Initialize total user count to 0\n   - Verify the cache system is operational and accessible\n   - Ensure the user has not been counted previously\n\n4. Core Operation Execution:\n   - Retrieve the current total user count from cache\n   - Increment the total user count by 1\n   - Store the updated total user count back in the cache\n   - Update the last registered user information in cache\n\n5. Response Generation:\n   - Return success status indicating the user count was incremented\n   - Make updated total user count available for display purposes\n   - Ensure the updated count is immediately visible in the system",
    "databaseEntities": [
      "jforum_users"
    ],
    "validationRules": [
      "User object must not be null",
      "User must be a new registration",
      "Cache system must be operational",
      "Total user count must be a non-negative integer"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "User": {
        "type": "object",
        "properties": {
          "id": {
            "type": "integer",
            "description": "Unique identifier for the user"
          },
          "username": {
            "type": "string",
            "description": "Username of the registered user"
          },
          "registrationDate": {
            "type": "date",
            "description": "Date when the user registered"
          }
        },
        "required": [
          "id",
          "username",
          "registrationDate"
        ]
      }
    }
  },
  {
    "featureName": "IncrementTotalMessages",
    "description": "Increases the total message count in the forum by one.",
    "inputValues": [],
    "businessLogic": "1. Input Collection:\n   - No user inputs required as this is a system-triggered operation\n   - System will use the current message count stored in the cache\n\n2. Data Validation:\n   - Verify cache availability\n     a. Check if the cache system is operational\n     b. IF cache is not available THEN\n        i. Log system error\n        ii. Terminate operation with appropriate error message\n     c. Check if total message count exists in cache\n     d. IF total message count is not found in cache THEN\n        i. Retrieve total message count from database\n        ii. Initialize cache with retrieved value\n\n3. Business Rule Processing:\n   - Verify message count integrity\n     a. Ensure current message count is a non-negative integer\n     b. IF current message count is invalid THEN\n        i. Log data integrity error\n        ii. Retrieve correct count from database\n        iii. Reset cache with correct value\n   - Check for concurrent modification issues\n     a. Implement synchronization to prevent race conditions\n     b. Ensure atomic operation for incrementing the counter\n\n4. Core Operation Execution:\n   - Retrieve current message count from cache\n     a. Access the cache using appropriate identifiers\n     b. Extract the integer value representing total messages\n   - Increment the message count\n     a. Add one to the current message count\n     b. Create new integer object with updated count\n   - Update the cache with new value\n     a. Store the incremented value back to cache\n     b. Ensure the update operation completes successfully\n   - Handle potential failures\n     a. IF cache update fails THEN\n        i. Retry operation\n        ii. IF retry fails THEN log error and notify system administrator\n\n5. Response Generation:\n   - No direct user response required\n   - System should record the successful increment operation\n   - Update any dependent displays or counters in the forum interface",
    "databaseEntities": [
      "jforum_posts",
      "jforum_topics",
      "jforum_forums"
    ],
    "validationRules": [
      "Cache system must be operational",
      "Total message count must be a non-negative integer",
      "Increment operation must be performed atomically to prevent race conditions"
    ],
    "dbSeedingOperations": [],
    "schema": {}
  },
  {
    "featureName": "GetMostUsersEverOnline",
    "description": "Retrieves statistics about the highest number of users ever online simultaneously.",
    "inputValues": [],
    "businessLogic": "1. Input Collection:\n   - No user inputs required for this feature\n   - System will use internal data sources\n\n2. Data Validation:\n   - Verify system access permissions\n     - IF user does not have permission to view statistics\n       THEN return appropriate error message\n     - IF system is in maintenance mode\n       THEN return appropriate error message\n\n3. Business Rule Processing:\n   - Check cache availability\n     - IF cache system is operational\n       THEN proceed with cache-based retrieval\n     - ELSE notify administrator about cache system failure\n       AND proceed with direct database retrieval\n\n4. Core Operation Execution:\n   - Attempt to retrieve most users ever online data from cache\n     - IF data exists in cache\n       THEN retrieve MostUsersEverOnline object from cache\n     - ELSE\n       - Synchronize access to prevent concurrent database queries\n       - Check cache again (double-check locking pattern)\n         - IF data now exists in cache\n           THEN retrieve MostUsersEverOnline object from cache\n         - ELSE\n           - Load MostUsersEverOnline data from configuration database\n           - Store retrieved data in cache for future use\n   - Extract relevant statistics from MostUsersEverOnline object:\n     - Total number of users that were online simultaneously\n     - Date and time when this record occurred\n\n5. Response Generation:\n   - Format the statistics data for presentation\n     - Include the total number of users\n     - Include the formatted date and time of the record\n   - Return the formatted statistics to the requester\n     - IF successful retrieval\n       THEN return complete statistics with success status\n     - ELSE return error information with appropriate message",
    "databaseEntities": [
      "jforum_sessions",
      "jforum_users"
    ],
    "validationRules": [
      "User must have permission to view statistics",
      "Cache system must be operational for optimal performance",
      "Database must contain valid configuration entries for user statistics"
    ],
    "dbSeedingOperations": [
      "Ensure configuration entries exist for MOST_USERS_EVER_ONLINE and MOST_USER_EVER_ONLINE_DATE"
    ],
    "schema": {
      "MostUsersEverOnline": {
        "type": "object",
        "properties": {
          "total": {
            "type": "integer",
            "description": "The highest number of users ever online simultaneously"
          },
          "timeInMillis": {
            "type": "integer",
            "description": "The timestamp (in milliseconds) when the record occurred"
          }
        },
        "required": [
          "total",
          "timeInMillis"
        ]
      }
    }
  },
  {
    "featureName": "UpdateMostUsersEverOnline",
    "description": "Updates the record for highest number of concurrent online users.",
    "inputValues": [
      "totalUsers-number-MostUsersEverOnline",
      "timeInMillis-number-MostUsersEverOnline"
    ],
    "businessLogic": "1. Input Collection\n   - Collect the following inputs:\n     1.1. totalUsers (number, mandatory): The new count of concurrent online users\n     1.2. timeInMillis (number, mandatory): The timestamp when this count was recorded\n\n2. Data Validation\n   2.1. Validate totalUsers input\n       - Check if totalUsers is provided\n       - Verify totalUsers is a positive integer\n       - IF totalUsers is missing or invalid THEN\n         - Generate error message: \"Total users count must be a positive integer\"\n         - Abort operation\n   2.2. Validate timeInMillis input\n       - Check if timeInMillis is provided\n       - Verify timeInMillis is a valid timestamp (positive long value)\n       - IF timeInMillis is missing or invalid THEN\n         - Generate error message: \"Timestamp must be a valid date/time value\"\n         - Abort operation\n\n3. Business Rule Processing\n   3.1. Retrieve current record of most users ever online\n       - Get the existing record from the system\n       - IF no existing record exists THEN\n         - Set comparison value to 0\n       - ELSE\n         - Set comparison value to the current record's total users count\n   3.2. Compare new value with existing record\n       - IF new totalUsers is less than or equal to comparison value THEN\n         - Generate message: \"New value is not greater than the current record\"\n         - Abort operation\n       - ELSE\n         - Continue to next step\n\n4. Core Operation Execution\n   4.1. Create record object\n       - Create a new MostUsersEverOnline object with provided values\n       - Set the total users count to the new value\n       - Set the timestamp to the provided timeInMillis\n   4.2. Persist the record\n       - IF no existing record exists THEN\n         - Create new configuration entries for total users and timestamp\n       - ELSE\n         - Update existing configuration entries with new values\n   4.3. Update cache\n       - Store the updated record in the system cache\n       - Ensure the cached value reflects the new record\n\n5. Response Generation\n   5.1. Generate success response\n       - Include the new total users count in the response\n       - Include the timestamp when the record was set\n       - Include a message indicating successful update\n   5.2. Handle potential errors\n       - IF any database operation fails THEN\n         - Generate appropriate error message\n         - Include details about the failure\n         - Provide guidance for resolving the issue",
    "databaseEntities": [
      "jforum_sessions"
    ],
    "validationRules": [
      "Total users count must be a positive integer",
      "Timestamp must be a valid date/time value",
      "New total users count must be greater than the current record"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "MostUsersEverOnline": {
        "type": "object",
        "properties": {
          "total": {
            "type": "number",
            "description": "The total number of concurrent users online"
          },
          "timeInMillis": {
            "type": "number",
            "description": "The timestamp when the record was set"
          }
        },
        "required": [
          "total",
          "timeInMillis"
        ]
      }
    }
  },
  {
    "featureName": "GetListAllowedForums",
    "description": "Generates a comma-separated list of accessible forum IDs for the current user.",
    "inputValues": [],
    "businessLogic": "1. Input Collection:\n   - No explicit user inputs required\n   - System will use current user context from the session\n\n2. Data Validation:\n   - Verify current user session exists and is valid\n     - IF session is invalid or expired THEN\n       - Return error indicating authentication required\n     - END IF\n\n3. Business Rule Processing:\n   - Verify forum data is available\n     - IF forum repository is not initialized THEN\n       - Initialize forum repository\n     - END IF\n   - Check user permissions against forum access rules\n     - Retrieve user's group memberships\n     - Determine access permissions based on group memberships\n\n4. Core Operation Execution:\n   - Initialize empty result string and counter\n   - Retrieve all categories from the system\n   - FOR each category in the system:\n     - Retrieve all forums within the category\n     - FOR each forum in the category:\n       - Check if current user has access to the forum\n         - IF user has access to forum THEN\n           - IF counter is greater than zero THEN\n             - Append comma separator to result string\n           - END IF\n           - Append forum ID to result string\n           - Increment counter\n         - END IF\n     - END FOR\n   - END FOR\n   - IF no accessible forums were found (counter equals zero) THEN\n     - Set result string to \"-1\" to indicate no accessible forums\n   - END IF\n\n5. Response Generation:\n   - Return the comma-separated list of forum IDs\n   - IF no forums are accessible, return \"-1\"\n   - Format: \"1,2,5,8\" (example of accessible forum IDs)",
    "databaseEntities": [
      "jforum_categories",
      "jforum_forums",
      "jforum_user_groups",
      "jforum_groups"
    ],
    "validationRules": [
      "User must have a valid session to access forum list",
      "Forum access is determined by user group permissions",
      "If no forums are accessible, return '-1' instead of empty string",
      "Forum IDs must be separated by commas with no spaces"
    ],
    "dbSeedingOperations": [],
    "schema": {}
  },
  {
    "featureName": "RemovePost",
    "description": "Removes a specific post from a topic in the cache.",
    "inputValues": [
      "topicId-number-Topic",
      "postId-number-Post"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect topicId (mandatory, number): The identifier of the topic containing the post\n   - Collect postId (mandatory, number): The identifier of the post to be removed\n   - System will use these identifiers to locate and remove the specific post\n\n2. Data Validation:\n   - Validate topicId:\n     * Ensure topicId is provided\n     * Verify topicId is a positive integer\n     * Confirm topicId exists in the system\n     * If validation fails, generate appropriate error message\n   - Validate postId:\n     * Ensure postId is provided\n     * Verify postId is a positive integer\n     * Confirm postId exists in the system\n     * If validation fails, generate appropriate error message\n\n3. Business Rule Processing:\n   - Check if the topic exists in the cache:\n     * IF topic is not found in cache, no action is needed\n     * IF topic is found, continue with removal process\n   - Verify user permissions:\n     * Ensure the current user has permission to remove posts from this topic\n     * IF user lacks permission, generate access denied error\n   - Check system state:\n     * Ensure the system is not in maintenance mode\n     * Verify the cache system is operational\n\n4. Core Operation Execution:\n   - Acquire synchronization lock to prevent concurrent modifications\n   - Convert topicId to string format for cache lookup\n   - Retrieve the list of posts for the specified topic from cache\n   - IF post list exists in cache:\n     * Create a temporary post object with the specified postId\n     * Remove the matching post from the list\n     * Update the cache with the modified post list\n     * Release synchronization lock\n   - IF post list does not exist in cache:\n     * No action needed as the post is not cached\n     * Release synchronization lock\n\n5. Response Generation:\n   - For successful removal:\n     * Generate success response indicating post was removed from cache\n     * Include topicId and postId in the response for reference\n   - For unsuccessful removal:\n     * Generate appropriate error response\n     * Include reason for failure (post not found, topic not cached, etc.)\n     * Provide guidance for next steps if applicable",
    "databaseEntities": [
      "jforum_topics",
      "jforum_posts",
      "jforum_posts_text"
    ],
    "validationRules": [
      "Topic ID must be a positive integer",
      "Post ID must be a positive integer",
      "Topic must exist in the system",
      "Post must exist within the specified topic",
      "User must have permission to remove posts from the topic"
    ],
    "dbSeedingOperations": [],
    "schema": {}
  },
  {
    "featureName": "AppendPost",
    "description": "Adds a new post to a topic in the cache if it doesn't already exist.",
    "inputValues": [
      "topicId-number-Topic",
      "post-object-Post"
    ],
    "businessLogic": "1. Input Collection\n   - Collect the following inputs:\n     1.1. topicId (number, mandatory): The identifier of the topic to which the post will be added\n     1.2. post (object, mandatory): The post object to be added to the topic\n         1.2.1. Must contain at minimum an id property\n         1.2.2. Must contain all required post content and metadata\n\n2. Data Validation\n   - Validate all input parameters:\n     2.1. Validate topicId:\n         2.1.1. Ensure topicId is provided\n         2.1.2. Ensure topicId is a positive integer\n         2.1.3. IF topicId is invalid, THEN return an error message indicating invalid topic identifier\n     2.2. Validate post object:\n         2.2.1. Ensure post object is provided\n         2.2.2. Ensure post has a valid id property\n         2.2.3. Ensure post contains all required content fields\n         2.2.4. IF post object is invalid, THEN return an error message indicating invalid post data\n\n3. Business Rule Processing\n   - Process business rules related to post addition:\n     3.1. Check if the topic exists in the system\n         3.1.1. IF topic does not exist, THEN return an error message indicating topic not found\n     3.2. Convert topicId to string format for cache operations\n     3.3. Retrieve the current list of posts for the specified topic from cache\n         3.3.1. IF posts list is null, THEN no action is needed (cache miss scenario)\n     3.4. Check if the post already exists in the topic's post list\n         3.4.1. Use post's id to determine if it already exists in the list\n         3.4.2. IF post already exists in the list, THEN no action is needed\n\n4. Core Operation Execution\n   - Execute the post addition operation:\n     4.1. IF the post list exists for the topic AND the post is not already in the list:\n         4.1.1. Add the post to the topic's post list\n         4.1.2. Update the cache with the modified post list\n         4.1.3. Ensure the post is properly prepared for display if needed\n     4.2. IF any error occurs during the addition process:\n         4.2.1. Log the error details\n         4.2.2. Return appropriate error message\n\n5. Response Generation\n   - Generate appropriate response:\n     5.1. IF post was successfully added to cache:\n         5.1.1. Return success status\n         5.1.2. Include confirmation that post was added to the topic cache\n     5.2. IF post was not added (already exists):\n         5.2.1. Return neutral status indicating no action was taken\n         5.2.2. Include information that post already exists in cache\n     5.3. IF operation failed due to errors:\n         5.3.1. Return error status\n         5.3.2. Include detailed error information\n         5.3.3. Provide guidance on resolving the issue",
    "databaseEntities": [
      "jforum_topics",
      "jforum_posts",
      "jforum_posts_text"
    ],
    "validationRules": [
      "Topic ID must be a positive integer",
      "Post object must contain a valid ID",
      "Post must not already exist in the topic's post list",
      "Topic must exist in the system"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Post": {
        "type": "object",
        "properties": {
          "id": {
            "type": "number",
            "description": "Unique identifier for the post"
          },
          "text": {
            "type": "string",
            "description": "Content of the post"
          },
          "userId": {
            "type": "number",
            "description": "ID of the user who created the post"
          },
          "time": {
            "type": "string",
            "format": "date-time",
            "description": "Timestamp when the post was created"
          }
        },
        "required": [
          "id"
        ]
      }
    }
  },
  {
    "featureName": "ClearTopicCache",
    "description": "Clears the cache for a specific topic to ensure that the latest data is retrieved from the database on subsequent requests.",
    "inputValues": [
      "topicId-number-Topic"
    ],
    "businessLogic": "1. Input Collection\n   - Collect the topicId (number) of the topic whose cache needs to be cleared\n   - Verify that topicId is provided as a mandatory field\n   - No default values are applicable for this operation\n\n2. Data Validation\n   - Validate that topicId is a positive integer\n     * IF topicId is not a positive integer THEN\n       - Generate an error message indicating invalid topic ID format\n       - Abort the operation\n     * END IF\n   - Verify that topicId represents an existing topic\n     * IF topic does not exist THEN\n       - Generate an error message indicating topic not found\n       - Abort the operation\n     * END IF\n\n3. Business Rule Processing\n   - Check if the topic has cached data\n     * IF no cached data exists for the topic THEN\n       - Log information that no cache exists for the specified topic\n       - Skip to Response Generation with appropriate message\n     * END IF\n   - Verify user has appropriate permissions to clear cache\n     * IF user does not have required permissions THEN\n       - Generate an error message indicating insufficient permissions\n       - Abort the operation\n     * END IF\n   - Check if caching is enabled in the system\n     * IF topic caching is disabled THEN\n       - Log information that caching is disabled\n       - Skip to Response Generation with appropriate message\n     * END IF\n\n4. Core Operation Execution\n   - Identify the cache storage location for the topic\n     * Determine the cache key based on the topic ID\n     * Locate the cache entry in the system cache\n   - Remove the topic's cached data from the cache storage\n     * Delete all cached posts associated with the topic ID\n     * Update cache metadata to reflect the removal\n   - Log the cache clearing operation\n     * Record the topic ID, timestamp, and user who performed the operation\n     * Include the reason for cache clearing if provided\n\n5. Response Generation\n   - Generate success response\n     * Include confirmation that the topic cache was successfully cleared\n     * Provide the topic ID that was affected\n     * Include timestamp of when the operation was completed\n   - IF operation failed at any point THEN\n     * Generate error response with specific failure reason\n     * Include guidance on how to resolve the issue\n     * Provide support contact information if needed\n   - END IF",
    "databaseEntities": [
      "jforum_topics",
      "jforum_posts"
    ],
    "validationRules": [
      "Topic ID must be a positive integer",
      "Topic must exist in the system",
      "User must have appropriate permissions to clear cache",
      "Cache operation must be logged for audit purposes",
      "System must have topic caching enabled for operation to be meaningful"
    ],
    "dbSeedingOperations": [],
    "schema": {}
  },
  {
    "featureName": "GetCachedTopics",
    "description": "Retrieves a collection of all cached topics from the system cache.",
    "inputValues": [],
    "businessLogic": "1. Input Collection:\n   - No user inputs required for this operation\n   - System will use internal cache references\n\n2. Data Validation:\n   - Verify cache engine is properly initialized\n   - IF cache engine is not initialized THEN\n     - Return empty collection\n   - END IF\n\n3. Business Rule Processing:\n   - Check cache availability\n   - IF cache is unavailable THEN\n     - Return empty collection\n   - END IF\n   - Determine if topics map exists in cache\n   - IF topics map does not exist in cache THEN\n     - Return empty collection\n   - END IF\n\n4. Core Operation Execution:\n   - Retrieve topics map from cache using the defined cache key\n   - Extract all topic identifiers (keys) from the map\n   - Create a collection to hold the topic identifiers\n   - FOR EACH topic identifier in the map\n     - Add the identifier to the collection\n   - END FOR\n   - IF no topics are found THEN\n     - Return empty collection\n   - END IF\n\n5. Response Generation:\n   - Return the collection of topic identifiers\n   - IF collection is empty THEN\n     - Return an empty collection object rather than null\n   - END IF",
    "databaseEntities": [
      "jforum_topics",
      "jforum_posts"
    ],
    "validationRules": [
      "Cache engine must be properly initialized",
      "Return empty collection instead of null when no topics are found"
    ],
    "dbSeedingOperations": [],
    "schema": {}
  },
  {
    "featureName": "GetCacheSize",
    "description": "Returns the total number of cached topics or posts within a specific topic.",
    "inputValues": [
      "topicId-number-Topic"
    ],
    "businessLogic": "1. Input Collection\n   - Collect the following inputs:\n     a. topicId (number, optional): The identifier of the specific topic to check cache size for\n\n2. Data Validation\n   - Validate the topicId input:\n     a. IF topicId is provided:\n        i. Check that topicId is a positive integer\n        ii. IF topicId is not a positive integer THEN\n            - Generate an error message indicating invalid topic ID format\n            - Terminate the operation\n\n3. Business Rule Processing\n   - Check cache system availability:\n     a. Verify that the cache system is properly initialized\n     b. IF cache system is not available THEN\n        i. Generate an error message indicating cache system unavailability\n        ii. Terminate the operation\n\n4. Core Operation Execution\n   - Determine the type of cache size request:\n     a. IF topicId is provided THEN\n        i. Retrieve the collection of posts for the specified topic from cache\n        ii. IF collection exists THEN\n            - Count the number of posts in the collection\n            - Store this count as the result\n        iii. ELSE\n            - Set result to zero (indicating no cached posts for this topic)\n     b. ELSE (no topicId provided)\n        i. Retrieve the entire cache map of all topics\n        ii. IF map exists THEN\n            - Count the number of topics in the cache map\n            - Store this count as the result\n        iii. ELSE\n            - Set result to zero (indicating no cached topics)\n\n5. Response Generation\n   - Prepare the response with the cache size information:\n     a. IF topicId was provided THEN\n        i. Format response to indicate the number of cached posts for the specified topic\n     b. ELSE\n        i. Format response to indicate the total number of cached topics\n     c. Return the cache size result to the caller",
    "databaseEntities": [
      "jforum_topics",
      "jforum_posts"
    ],
    "validationRules": [
      "Topic ID must be a positive integer if provided",
      "Cache system must be properly initialized"
    ],
    "dbSeedingOperations": [],
    "schema": {}
  },
  {
    "featureName": "InitModulesMapping",
    "description": "Loads and initializes module mappings from configuration files.",
    "inputValues": [
      "baseDir-string-System"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect baseDir (string): The directory path where module mapping configuration files are located\n   - This input is mandatory and must be provided by the system\n   - No default value is provided; a valid directory path must be specified\n\n2. Data Validation:\n   - Validate baseDir input:\n     a. Check if baseDir is not null or empty\n        IF baseDir is null or empty THEN\n          Generate error: \"Base directory path cannot be empty\"\n     b. Check if baseDir represents a valid directory path\n        IF baseDir is not a valid directory path THEN\n          Generate error: \"Invalid directory path provided\"\n     c. Check if baseDir is accessible\n        IF baseDir is not accessible THEN\n          Generate error: \"Directory is not accessible\"\n\n3. Business Rule Processing:\n   - Verify configuration file existence:\n     a. Check if the modules mapping configuration file exists in the specified directory\n        IF configuration file does not exist THEN\n          Generate error: \"Modules mapping configuration file not found\"\n   - Verify configuration file format:\n     a. Check if the configuration file is in the correct format\n        IF configuration file format is invalid THEN\n          Generate error: \"Invalid configuration file format\"\n   - Check system state:\n     a. Verify if the system is in a state where module mapping can be initialized\n        IF system is not in proper state THEN\n          Generate error: \"System not ready for module mapping initialization\"\n\n4. Core Operation Execution:\n   - Load modules mapping configuration:\n     a. Open the modules mapping configuration file from the specified baseDir\n     b. Read all module name to class name mappings from the configuration file\n     c. Create a properties collection to store the mappings\n   - Cache the loaded mappings:\n     a. Store the properties collection in the system cache with key \"entries\"\n     b. Ensure the cache is properly initialized and accessible\n     c. IF any error occurs during caching THEN\n          Log the error details\n          Roll back any partial cache updates\n          Generate error: \"Failed to cache module mappings\"\n\n5. Response Generation:\n   - Success response:\n     a. Return confirmation that module mappings have been successfully loaded and cached\n     b. Include the number of module mappings that were loaded\n   - Error response:\n     a. Provide detailed error information if the operation failed\n     b. Include suggestions for resolving the issue\n     c. Provide information about the current state of the module mappings",
    "databaseEntities": [],
    "validationRules": [
      "Base directory path must be valid and accessible",
      "Modules mapping configuration file must exist in the specified directory",
      "Modules mapping configuration file must be in the correct format",
      "System must be in a proper state for module mapping initialization"
    ],
    "dbSeedingOperations": [],
    "schema": {}
  },
  {
    "featureName": "GetModuleClass",
    "description": "Retrieves the fully qualified class name for a given module name.",
    "inputValues": [
      "moduleName-string-Module"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the following inputs:\n     a. moduleName (string, mandatory): The name of the module to look up\n\n2. Data Validation:\n   - Validate the module name input:\n     a. Check if moduleName is not null\n     b. Check if moduleName is not empty\n     c. IF validation fails, prepare appropriate error message\n\n3. Business Rule Processing:\n   - Check system state requirements:\n     a. Verify that the modules repository has been initialized\n     b. Verify that the cache contains the entries mapping\n     c. IF the cache is not initialized or entries mapping is missing:\n        i. Log an error with the requested module name and current request information\n        ii. Prepare system error response\n\n4. Core Operation Execution:\n   - Retrieve the module class name:\n     a. Access the properties collection from the cache using the 'entries' key\n     b. Look up the property value using the provided moduleName as the key\n     c. IF the property is found:\n        i. Store the fully qualified class name for return\n     d. ELSE:\n        i. Return null to indicate the module was not found\n\n5. Response Generation:\n   - Prepare the response:\n     a. IF a class name was found:\n        i. Return the fully qualified class name as a string\n     b. ELSE:\n        i. Return null to indicate no matching module was found\n     c. Include appropriate status information",
    "databaseEntities": [],
    "validationRules": [
      "Module name must not be null",
      "Module name must not be empty",
      "Modules repository must be initialized before lookup",
      "Cache must contain valid entries mapping"
    ],
    "dbSeedingOperations": [],
    "schema": {}
  },
  {
    "featureName": "LoadRanks",
    "description": "Loads all ranking data from the database into the cache for efficient access.",
    "inputValues": [],
    "businessLogic": "1. Input Collection:\n   - No user inputs required as this is a system operation\n   - System will use internal database connection credentials\n   - Operation triggered by system startup or manual refresh request\n\n2. Data Validation:\n   - Verify database connection is available\n     * IF connection is unavailable THEN generate connection error\n     * IF connection timeout occurs THEN generate timeout error\n   - Verify cache system is initialized\n     * IF cache is not initialized THEN initialize cache system\n     * IF cache initialization fails THEN generate cache error\n\n3. Business Rule Processing:\n   - Check if ranking data already exists in cache\n     * IF ranking data exists in cache THEN clear existing data\n     * IF clearing cache fails THEN log warning and continue\n   - Verify ranking data access permissions\n     * IF system lacks permission to access ranking data THEN generate permission error\n     * IF ranking table is locked THEN implement retry mechanism\n\n4. Core Operation Execution:\n   - Retrieve all ranking records from database\n     * Query the ranking data storage for all ranking entries\n     * Sort rankings by minimum post count in ascending order\n     * Group rankings by type (special vs regular)\n   - Process retrieved ranking data\n     * Format ranking titles for display\n     * Associate minimum post requirements with each rank\n     * Identify special ranks that are manually assigned\n   - Store processed ranking data in cache\n     * Organize data in cache using appropriate structure\n     * Set cache expiration policy if applicable\n     * Ensure atomic update of cache to prevent partial data issues\n\n5. Response Generation:\n   - Generate success response\n     * Include count of rankings loaded\n     * Include timestamp of data refresh\n   - Handle potential errors\n     * IF database error occurs THEN generate detailed error with database state\n     * IF cache storage error occurs THEN generate cache system error\n     * IF data format error occurs THEN generate data integrity error\n   - Log operation completion\n     * Record success or failure status\n     * Include performance metrics (load time, data size)",
    "databaseEntities": [
      "jforum_ranks"
    ],
    "validationRules": [
      "Database connection must be available",
      "Cache system must be properly initialized",
      "Ranking data must be retrievable from database",
      "Cache must have sufficient capacity for ranking data",
      "Ranking data must include title and minimum post count"
    ],
    "dbSeedingOperations": [],
    "schema": {}
  },
  {
    "featureName": "GetRankTitle",
    "description": "Retrieves the appropriate rank title based on user's rank ID or post count.",
    "inputValues": [
      "rankId-number-Ranking",
      "total-number-PostCount"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect rankId (number, optional) - The specific rank identifier if user has a special rank\n   - Collect total (number, required) - The total number of posts made by the user\n   - Both inputs are used to determine the appropriate rank title\n\n2. Data Validation:\n   - Validate rankId:\n     * IF rankId is provided, ensure it is a positive integer\n     * IF rankId is not provided or is zero/negative, it will be ignored\n   - Validate total:\n     * Ensure total is a non-negative integer\n     * IF total is negative, treat as zero\n\n3. Business Rule Processing:\n   - Check if system has loaded rank information:\n     * IF rank information is not loaded in cache, load all ranks from data source\n     * Ensure ranks are sorted by minimum post requirements\n   - Determine rank retrieval method:\n     * IF rankId is greater than 0, attempt to retrieve rank by ID first\n     * IF rankId is 0 or negative, skip to post count based ranking\n\n4. Core Operation Execution:\n   - Special Rank Retrieval (if applicable):\n     * IF rankId is greater than 0:\n       - Search for rank with matching ID in the rank list\n       - IF found, store the rank title\n       - IF not found, set title to null\n   - Post-based Rank Retrieval:\n     * IF no special rank was found or rankId was not valid:\n       - Iterate through all ranks in the system\n       - Track the last valid rank encountered\n       - For each rank:\n         > IF total exactly matches rank's minimum post requirement AND rank is not special:\n           * Return this rank's title immediately\n         > IF total is between last rank's minimum and current rank's minimum:\n           * Return the last rank's title\n       - IF no matching rank found in iterations, return the last rank's title\n\n5. Response Generation:\n   - Return the determined rank title as a string\n   - IF no appropriate rank could be determined, return null\n   - The returned title represents the user's current rank in the system",
    "databaseEntities": [
      "jforum_users"
    ],
    "validationRules": [
      "Rank ID must be a positive integer if provided",
      "Post count must be a non-negative integer",
      "System must have loaded rank information before retrieval"
    ],
    "dbSeedingOperations": [
      "Ensure ranking data is loaded in the system cache"
    ],
    "schema": {
      "Ranking": {
        "id": "number",
        "title": "string",
        "min": "number",
        "special": "boolean"
      }
    }
  },
  {
    "featureName": "GetRankingSize",
    "description": "Returns the total number of rankings available in the system.",
    "inputValues": [],
    "businessLogic": "1. Input Collection:\n   - No user inputs required for this feature\n   - System will use internal data sources\n\n2. Data Validation:\n   - Verify system initialization\n     - IF ranking cache is not initialized THEN\n       - Trigger ranking cache initialization\n     - END IF\n\n3. Business Rule Processing:\n   - Verify cache availability\n     - IF cache engine is not available THEN\n       - Generate appropriate error response\n       - Exit process\n     - END IF\n   - Verify ranking data existence\n     - IF ranking entries collection is null THEN\n       - Generate appropriate error response\n       - Exit process\n     - END IF\n\n4. Core Operation Execution:\n   - Access the ranking entries collection from the cache\n   - Calculate the total number of ranking entries in the collection\n   - Store the count value for response\n\n5. Response Generation:\n   - Return the calculated count value\n   - IF any errors occurred during processing THEN\n     - Return appropriate error information\n   - END IF",
    "databaseEntities": [
      "jforum_users"
    ],
    "validationRules": [
      "Cache system must be initialized before accessing ranking data",
      "Ranking data must exist in the cache"
    ],
    "dbSeedingOperations": [],
    "schema": {}
  },
  {
    "featureName": "GetGroupRoles",
    "description": "Retrieves role collections for a specific group from the cache.",
    "inputValues": [
      "groupId-number-Group"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the following inputs:\n     - groupId (mandatory): A unique identifier for the group\n   - System will use the cache engine that was previously configured\n\n2. Data Validation:\n   - Validate groupId:\n     - Ensure groupId is provided\n     - Verify groupId is a positive integer\n     - IF groupId is invalid or missing THEN\n       - Generate appropriate error message\n       - Terminate process and return error\n\n3. Business Rule Processing:\n   - Check cache availability:\n     - Verify the cache engine is properly initialized\n     - IF cache engine is not available THEN\n       - Log system error\n       - Prepare fallback mechanism or error response\n   - Determine cache retrieval approach:\n     - IF single groupId is provided THEN\n       - Prepare to retrieve roles for single group\n     - IF multiple groupIds are provided THEN\n       - Prepare to retrieve merged roles for multiple groups\n\n4. Core Operation Execution:\n   - Retrieve roles from cache:\n     - Convert groupId to appropriate cache key format\n     - Query the cache using the FQN (fully qualified name) and the group identifier\n     - IF roles are found in cache THEN\n       - Retrieve the RoleCollection object\n     - ELSE\n       - Return null to indicate no roles found\n   - Handle any exceptions during retrieval:\n     - IF exception occurs during cache access THEN\n       - Log the error details\n       - Return appropriate error response\n\n5. Response Generation:\n   - Format the response:\n     - IF roles were successfully retrieved THEN\n       - Return the RoleCollection object containing all roles for the requested group(s)\n     - ELSE\n       - Return null to indicate no roles were found\n       - Include appropriate status information\n   - Provide context for response:\n     - Include information about the group(s) queried\n     - Include timestamp of when the data was retrieved",
    "databaseEntities": [
      "jforum_groups",
      "jforum_user_groups"
    ],
    "validationRules": [
      "Group ID must be a positive integer",
      "Cache engine must be properly initialized before retrieval",
      "Role collection may be null if no roles exist for the specified group"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "RoleCollection": {
        "type": "object",
        "properties": {
          "roles": {
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "name": {
                  "type": "string"
                },
                "value": {
                  "type": "string"
                }
              }
            }
          }
        }
      }
    }
  },
  {
    "featureName": "GetMergedGroupRoles",
    "description": "Retrieves and merges role collections from multiple security groups.",
    "inputValues": [
      "groupIds-object-GroupIds"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the following inputs:\n     a. groupIds (mandatory): Array of integer group identifiers\n   - System will use these identifiers to locate and merge role collections\n\n2. Data Validation:\n   - Validate groupIds input:\n     a. Verify the array is not null or empty\n     b. Verify each group ID is a valid positive integer\n     c. IF any validation fails, THEN generate appropriate error message\n\n3. Business Rule Processing:\n   - Check system state requirements:\n     a. Verify the cache system is properly initialized\n     b. Verify the roles repository is accessible\n   - Check group existence:\n     a. FOR each group ID in the input array\n        i. Verify the group exists in the system\n        ii. IF any group does not exist, THEN record as invalid group\n     b. IF any invalid groups found, THEN generate appropriate warning\n\n4. Core Operation Execution:\n   - Convert group IDs to appropriate cache key format:\n     a. Transform the array of integers into a standardized string representation\n     b. This string will serve as the lookup key in the cache system\n   - Check if merged roles already exist in cache:\n     a. Attempt to retrieve role collection using the generated key\n     b. IF roles found in cache, THEN return the cached role collection\n     c. ELSE proceed to role merging process\n   - Perform role merging process (when not in cache):\n     a. Initialize an empty result role collection\n     b. FOR each group ID in the input array:\n        i. Retrieve individual group role collection\n        ii. IF group role collection exists, THEN merge with result collection\n     c. Store the merged role collection in cache using the generated key\n     d. Return the merged role collection\n\n5. Response Generation:\n   - Success response:\n     a. Return the merged role collection containing all permissions from all specified groups\n     b. Include metadata about which groups contributed to the collection\n   - Error response:\n     a. For validation errors, return specific validation failure messages\n     b. For system errors, return appropriate error information\n     c. Include suggestions for resolving the issue",
    "databaseEntities": [
      "jforum_groups",
      "jforum_user_groups"
    ],
    "validationRules": [
      "Group IDs array must not be null or empty",
      "Each group ID must be a positive integer",
      "All specified groups must exist in the system",
      "Cache system must be properly initialized"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "GroupIds": {
        "type": "array",
        "items": {
          "type": "integer",
          "description": "Unique identifier for a security group"
        },
        "minItems": 1,
        "description": "Array of group identifiers to merge roles from"
      }
    }
  },
  {
    "featureName": "AddGroupRoles",
    "description": "Adds merged roles for specified groups to the cache.",
    "inputValues": [
      "groupIds-object-GroupIds",
      "roles-object-RoleCollection"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the following inputs:\n     a. groupIds (mandatory): Array of integer group identifiers\n     b. roles (mandatory): Collection of role definitions to be cached\n     c. cacheKey (system-generated): Generated from the group IDs\n\n2. Data Validation:\n   - Validate group IDs:\n     a. Verify the groupIds array is not null\n     b. Verify the groupIds array is not empty\n     c. Verify each group ID is a positive integer\n     d. IF any validation fails, THEN display appropriate error message\n   - Validate roles collection:\n     a. Verify the roles collection is not null\n     b. Verify the roles collection contains at least one role\n     c. IF validation fails, THEN display appropriate error message\n\n3. Business Rule Processing:\n   - Check cache system availability:\n     a. Verify the cache engine is initialized\n     b. IF cache engine is not available, THEN report system error\n   - Generate cache key:\n     a. Convert the array of group IDs into a string representation\n     b. Use this string as the cache key for storing the roles\n\n4. Core Operation Execution:\n   - Prepare cache storage:\n     a. Identify the cache namespace (FQN) for roles\n     b. Format the cache key using the group IDs string representation\n   - Store roles in cache:\n     a. Add the roles collection to the cache using the namespace and key\n     b. IF cache operation fails, THEN handle the exception and report error\n     c. IF cache operation succeeds, THEN proceed to response generation\n\n5. Response Generation:\n   - Success response:\n     a. Confirm that roles have been successfully cached\n     b. Provide information about the groups whose roles were cached\n   - Error response:\n     a. Provide details about the nature of the error\n     b. Suggest possible remediation steps",
    "databaseEntities": [
      "jforum_groups",
      "jforum_user_groups"
    ],
    "validationRules": [
      "Group IDs array must not be null",
      "Group IDs array must not be empty",
      "Each group ID must be a positive integer",
      "Roles collection must not be null",
      "Roles collection must contain at least one role",
      "Cache engine must be initialized before storing roles"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "GroupIds": {
        "type": "array",
        "items": {
          "type": "integer",
          "description": "Unique identifier for a group"
        }
      },
      "RoleCollection": {
        "type": "object",
        "properties": {
          "roles": {
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "name": {
                  "type": "string",
                  "description": "Name of the role"
                },
                "permissions": {
                  "type": "array",
                  "items": {
                    "type": "string",
                    "description": "Permission identifier"
                  }
                }
              }
            }
          }
        }
      }
    }
  },
  {
    "featureName": "ClearRolesCache",
    "description": "Clears the system roles cache to ensure role information is refreshed from the database.",
    "inputValues": [],
    "businessLogic": "1. Input Collection:\n   - No user inputs required for this operation\n   - This is a system-level operation that doesn't require external parameters\n\n2. Data Validation:\n   - Verify system user has appropriate permissions to clear cache\n      * IF user does not have administrative privileges THEN\n        - Generate access denied error\n        - Terminate operation\n      * END IF\n   - Verify cache system is operational\n      * IF cache system is not available or initialized THEN\n        - Log system error\n        - Generate appropriate error message\n        - Terminate operation\n      * END IF\n\n3. Business Rule Processing:\n   - Check if cache clearing operation is allowed at current time\n      * IF system is currently processing critical operations THEN\n        - Queue cache clearing request for later execution\n        - Notify user that request has been queued\n        - Terminate current operation\n      * END IF\n   - Determine impact of clearing roles cache\n      * IF active user sessions depend on roles cache THEN\n        - Prepare notification for affected users\n      * END IF\n\n4. Core Operation Execution:\n   - Identify the roles cache storage location\n   - Mark cache as invalid to prevent further reads\n   - Remove all role entries from cache\n      * Set the roles cache root node to null\n      * This effectively invalidates all cached role data\n   - Log cache clearing operation with timestamp and initiator information\n   - Prepare system for subsequent role data reloading\n      * Flag system to reload roles on next access\n\n5. Response Generation:\n   - Generate success confirmation\n      * Include timestamp of operation\n      * Include count of cleared cache entries if available\n   - Provide information about expected system behavior\n      * Notify that roles will be reloaded from database on next access\n      * Indicate potential temporary performance impact during reload\n   - Return operation status to caller",
    "databaseEntities": [
      "jforum_groups",
      "jforum_user_groups"
    ],
    "validationRules": [
      "User must have administrative privileges to clear roles cache",
      "Cache system must be operational before attempting to clear cache",
      "System should not be performing critical operations when clearing cache"
    ],
    "dbSeedingOperations": [],
    "schema": {}
  },
  {
    "featureName": "LoadUserPermissions",
    "description": "Loads security roles and permissions for a user from the database.",
    "inputValues": [
      "userId-number-User"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect userId (number, mandatory) to identify the user\n   - Determine if force reload is required (boolean, optional, default: false)\n\n2. Data Validation:\n   - Validate userId:\n     a. Check if userId is provided\n     b. Verify userId is a positive integer\n     c. If validation fails, prepare appropriate error message\n\n3. Business Rule Processing:\n   - Check cache availability:\n     a. IF cache is available AND force reload is false:\n        i. Check if user permissions already exist in cache\n        ii. IF permissions exist in cache, skip database retrieval\n     b. ELSE proceed with database retrieval\n\n4. Core Operation Execution:\n   - Retrieve user information:\n     a. Query user data using userId\n     b. IF user not found:\n        i. Log error event\n        ii. Prepare user not found error\n     c. ELSE continue processing\n   - Load user's security roles:\n     a. Retrieve all groups the user belongs to\n     b. For EACH user group:\n        i. Load associated roles and permissions\n        ii. Combine permissions from multiple groups\n     c. Create permission control object with loaded roles\n   - Cache the permissions:\n     a. Store permission control object in cache using userId as key\n     b. Set appropriate cache expiration policy\n\n5. Response Generation:\n   - Return permission control object containing:\n     a. All roles associated with the user\n     b. Access control information for each role\n     c. Role-value pairs for granular permissions\n   - IF any errors occurred during processing:\n     a. Generate appropriate error response\n     b. Include error details and suggestions for resolution",
    "databaseEntities": [
      "jforum_users",
      "jforum_groups",
      "jforum_user_groups"
    ],
    "validationRules": [
      "User ID must be a positive integer",
      "User must exist in the system",
      "User must belong to at least one group"
    ],
    "dbSeedingOperations": [
      "Ensure at least one default group exists in the system",
      "Ensure default permissions are assigned to the default group"
    ],
    "schema": {
      "PermissionControl": {
        "roles": {
          "type": "object",
          "description": "Collection of roles and their associated permissions"
        },
        "methods": {
          "canAccess": {
            "parameters": [
              "roleName",
              "roleValue"
            ],
            "returns": "boolean",
            "description": "Checks if the user has access to a specific role with optional value"
          }
        }
      }
    }
  },
  {
    "featureName": "CheckUserAccess",
    "description": "Verifies if a user has access to a specific role or permission.",
    "inputValues": [
      "userId-number-User",
      "roleName-string-Role",
      "roleValue-string-Role"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the following inputs:\n     - userId (number, mandatory): The identifier of the user to check permissions for\n     - roleName (string, mandatory): The name of the role/permission to verify\n     - roleValue (string, optional): The specific value related to the role to check\n\n2. Data Validation:\n   - Validate userId:\n     - Ensure userId is a positive integer\n     - Verify userId exists in the system\n     - If invalid, generate appropriate error message\n   - Validate roleName:\n     - Ensure roleName is not empty\n     - Verify roleName is a recognized permission in the system\n     - If invalid, generate appropriate error message\n   - Validate roleValue (if provided):\n     - Ensure roleValue is appropriate for the specified roleName\n     - If invalid, generate appropriate error message\n\n3. Business Rule Processing:\n   - Check system state:\n     - Verify the permission system is properly initialized\n     - Ensure the security repository is accessible\n   - Check user state:\n     - Verify if the user is active in the system\n     - If user is disabled or banned, deny access automatically\n   - Handle special cases:\n     - IF user is an administrator or has super-user status\n       THEN grant access automatically\n     - IF checking anonymous access\n       THEN apply special anonymous permission rules\n\n4. Core Operation Execution:\n   - Retrieve user's permission control:\n     - Check if user's permissions are already cached\n     - IF not cached or cache is expired\n       THEN load permissions from the database\n       - Retrieve user's group memberships\n       - Load all roles associated with these groups\n       - Create permission control object with these roles\n       - Store in cache for future use\n     - ELSE use cached permission control\n   - Evaluate access:\n     - IF roleValue is provided\n       THEN check if user has access to the specific role with the given value\n     - ELSE check if user has access to the role in general\n   - Record access attempt (optional, for audit purposes)\n\n5. Response Generation:\n   - Generate success response:\n     - Return boolean result (true if access granted, false if denied)\n     - Include reason for access decision if debugging is enabled\n   - Generate error response (if applicable):\n     - Provide clear error message for any failures during the process\n     - Include guidance for resolving permission issues\n     - Log security exceptions for administrative review",
    "databaseEntities": [
      "jforum_users",
      "jforum_groups",
      "jforum_user_groups",
      "jforum_roles",
      "jforum_role_values"
    ],
    "validationRules": [
      "User ID must be a positive integer",
      "User must exist in the system",
      "Role name must not be empty",
      "Role name must be a valid system permission",
      "Role value must be appropriate for the specified role"
    ],
    "dbSeedingOperations": [
      "Ensure basic roles are defined in the system",
      "Ensure administrator group has all permissions"
    ],
    "schema": {
      "User": {
        "id": "number",
        "username": "string",
        "isActive": "boolean"
      },
      "Role": {
        "name": "string",
        "value": "string"
      },
      "PermissionControl": {
        "roles": "object",
        "userId": "number"
      }
    }
  },
  {
    "featureName": "ManageSecurityCache",
    "description": "Manages caching of user security permissions with add, remove and clean operations.",
    "inputValues": [
      "userId-number-User",
      "permissionControl-object-PermissionControl",
      "roleName-string-Role",
      "roleValue-string-Role",
      "forceReload-boolean-System"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect userId (mandatory): Numeric identifier for the user\n   - Collect permissionControl (optional): Object containing user permissions\n   - Collect roleName (optional): String identifier for the permission role\n   - Collect roleValue (optional): String value associated with the role\n   - Collect forceReload (optional): Boolean flag to force cache refresh\n\n2. Data Validation:\n   - Validate userId:\n     * Ensure userId is a positive integer\n     * Verify userId exists in the system\n     * Return error if validation fails\n   - Validate roleName (when provided):\n     * Ensure roleName is not empty\n     * Verify roleName exists in the system\n     * Return error if validation fails\n   - Validate permissionControl (when provided):\n     * Ensure permissionControl contains valid role definitions\n     * Return error if validation fails\n\n3. Business Rule Processing:\n   - Check cache availability:\n     * Verify cache system is operational\n     * Ensure cache has been properly initialized\n     * Return error if cache system is unavailable\n   - Determine operation type based on inputs:\n     * Load operation: When userId is provided without permissionControl\n     * Add operation: When both userId and permissionControl are provided\n     * Remove operation: When only userId is provided with remove flag\n     * Clean operation: When no specific userId is provided with clean flag\n     * Access check operation: When userId and roleName are provided\n\n4. Core Operation Execution:\n   - FOR Load Operation:\n     * Check if user permissions exist in cache\n     * IF permissions not in cache OR forceReload is true THEN\n       - Retrieve user data from database\n       - Load user's group associations\n       - Create new PermissionControl object\n       - Load roles for user based on their groups\n       - Store PermissionControl in cache with userId as key\n     * Return cached PermissionControl object\n   - FOR Add Operation:\n     * Store provided permissionControl in cache with userId as key\n     * Return confirmation of successful addition\n   - FOR Remove Operation:\n     * Remove cached permissions for specified userId\n     * Return confirmation of successful removal\n   - FOR Clean Operation:\n     * Remove all entries from the security cache\n     * Return confirmation of successful cache clearing\n   - FOR Access Check Operation:\n     * Retrieve PermissionControl for specified userId\n     * IF PermissionControl not found THEN\n       - Load permissions for user\n     * Check if user has access to specified role\n     * IF roleValue is provided THEN\n       - Check if user has access to role with specific value\n     * ELSE\n       - Check if user has access to role regardless of value\n     * Return boolean result of access check\n\n5. Response Generation:\n   - FOR Load Operation:\n     * Return PermissionControl object with user's permissions\n     * Include status indicating if permissions were freshly loaded or from cache\n   - FOR Add Operation:\n     * Return success confirmation message\n   - FOR Remove Operation:\n     * Return success confirmation message\n   - FOR Clean Operation:\n     * Return success confirmation message\n   - FOR Access Check Operation:\n     * Return boolean indicating whether access is granted or denied\n     * Include details about the checked permission if verbose mode is enabled\n   - FOR Any Error Condition:\n     * Return appropriate error message\n     * Include error details and suggested resolution steps",
    "databaseEntities": [
      "jforum_users",
      "jforum_groups",
      "jforum_user_groups"
    ],
    "validationRules": [
      "User ID must be a positive integer",
      "User ID must exist in the system",
      "Role name must not be empty when performing access checks",
      "Cache engine must be initialized before operations",
      "Permission Control object must contain valid role definitions when adding to cache"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "PermissionControl": {
        "type": "object",
        "properties": {
          "roles": {
            "type": "object",
            "description": "Collection of roles and their associated permissions"
          }
        },
        "required": [
          "roles"
        ]
      }
    }
  },
  {
    "featureName": "GetUserPermissionControl",
    "description": "Retrieves permission control schema for a specific user.",
    "inputValues": [
      "userId-number-User"
    ],
    "businessLogic": "1. Input Collection\n   - Collect the following inputs:\n     - userId (number, mandatory): The unique identifier of the user\n   - System will determine if force reload is required (boolean, optional, default: false)\n\n2. Data Validation\n   - Validate userId:\n     - IF userId is null or not a positive integer THEN\n       - Return error message \"Invalid user identifier provided\"\n     - END IF\n\n3. Business Rule Processing\n   - Check cache availability:\n     - IF cache system is not initialized THEN\n       - Log error \"Cache system not available\"\n       - Return error message \"System configuration error\"\n     - END IF\n   - Determine if permission control needs to be loaded:\n     - IF force reload is true OR user's permission control is not in cache THEN\n       - Mark permission control for loading\n     - ELSE\n       - Use cached permission control\n     - END IF\n\n4. Core Operation Execution\n   - IF permission control needs to be loaded THEN\n     - Retrieve user information:\n       - Query user data using userId\n       - IF user not found THEN\n         - Log error \"User not found\"\n         - Return error message \"User does not exist\"\n       - END IF\n     - Create new permission control instance\n     - Load user's roles and permissions:\n       - Retrieve all groups the user belongs to\n       - For each group:\n         - Load associated roles and permissions\n         - Add to permission control schema\n     - Store permission control in cache:\n       - Associate with userId for future retrieval\n       - Set appropriate cache expiration\n   - ELSE\n     - Retrieve existing permission control from cache\n   - END IF\n   - Verify permission control integrity:\n     - IF permission control is null or invalid THEN\n       - Log error \"Failed to load security roles\"\n       - Return error message \"Unable to retrieve user permissions\"\n     - END IF\n\n5. Response Generation\n   - Prepare permission control response:\n     - Include all roles associated with the user\n     - Include all permission values for each role\n     - Format according to system requirements\n   - Return the complete permission control schema\n   - Log successful retrieval of permission control",
    "databaseEntities": [
      "jforum_users",
      "jforum_groups",
      "jforum_user_groups"
    ],
    "validationRules": [
      "User ID must be a positive integer",
      "User must exist in the system",
      "Permission control must be successfully loaded or retrieved from cache"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "PermissionControl": {
        "type": "object",
        "properties": {
          "roles": {
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "name": {
                  "type": "string"
                },
                "values": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                }
              }
            }
          }
        }
      }
    }
  },
  {
    "featureName": "LoadSmilies",
    "description": "Loads all smilies from the database into the cache for system-wide use.",
    "inputValues": [],
    "businessLogic": "1. Input Collection:\n   - No user inputs required for this feature\n   - System will automatically trigger this process\n\n2. Data Validation:\n   - Verify cache system is properly initialized\n   - Check that database connection is available\n   - Ensure smilie data access components are functional\n\n3. Business Rule Processing:\n   3.1. Check if cache engine is properly configured\n      - IF cache engine is not initialized THEN\n         - Log error condition\n         - Abort operation\n      - END IF\n   3.2. Verify database access layer is available\n      - IF database access is unavailable THEN\n         - Record system error\n         - Abort operation with appropriate message\n      - END IF\n\n4. Core Operation Execution:\n   4.1. Retrieve all smilies from database\n      - Access smilie data store\n      - Retrieve complete list of smilie records\n      - IF retrieval fails THEN\n         - Generate smilie load exception\n         - Include error details in exception message\n         - Abort operation\n      - END IF\n   4.2. Store smilies in cache\n      - Add retrieved smilie collection to cache under designated key\n      - Reset context flag to indicate fresh cache load\n   4.3. Process context-specific URL formatting\n      - When smilies are requested (not during initial load):\n         - IF context formatting not yet applied THEN\n            - Retrieve system configuration for forum link\n            - FOR EACH smilie in the collection:\n               - Replace placeholder patterns in URL with actual forum link\n               - Clean up any escape characters in URL\n            - END FOR\n            - Update cache with context-formatted smilies\n            - Mark context formatting as completed\n         - END IF\n\n5. Response Generation:\n   5.1. For successful operation:\n      - Cache is populated with smilie data\n      - No explicit response needed as this is a system operation\n   5.2. For failed operation:\n      - Throw exception with detailed error information\n      - Include original error cause in exception message",
    "databaseEntities": [
      "jforum_smilies"
    ],
    "validationRules": [
      "Cache engine must be properly initialized",
      "Database connection must be available",
      "Smilie data access components must be functional",
      "All smilie records must be successfully retrieved from database"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Smilie": {
        "type": "object",
        "properties": {
          "id": {
            "type": "number",
            "description": "Unique identifier for the smilie"
          },
          "code": {
            "type": "string",
            "description": "Text code that represents the smilie"
          },
          "url": {
            "type": "string",
            "description": "Path to the smilie image file"
          },
          "diskName": {
            "type": "string",
            "description": "Filename of the smilie on disk"
          }
        }
      }
    }
  },
  {
    "featureName": "GetSmilies",
    "description": "Retrieves the list of smilies with properly formatted URLs for display in the forum.",
    "inputValues": [],
    "businessLogic": "1. Input Collection:\n   - No user inputs required for this feature\n   - System will use internal configuration values\n\n2. Data Validation:\n   - Verify cache system is properly initialized\n   - IF cache is not initialized THEN\n     - Log error\n     - Prepare error response\n   - END IF\n\n3. Business Rule Processing:\n   - Check if smilies are already loaded in cache\n   - IF smilies are not in cache THEN\n     - Trigger smilies loading process\n   - END IF\n   - Check if URLs in smilies need context formatting\n   - IF context formatting is needed THEN\n     - Mark for URL processing in next step\n   - END IF\n\n4. Core Operation Execution:\n   - Retrieve smilies list from cache storage\n   - IF smilies list is empty THEN\n     - Log warning about missing smilies\n     - Return empty list\n   - END IF\n   - IF context formatting is needed THEN\n     - Retrieve forum link from system configuration\n     - FOR EACH smilie in the list\n       - Replace context placeholders in URL with actual forum link\n       - Remove escape characters from URL\n     - END FOR\n     - Update cache with contextualized smilies\n     - Mark smilies as contextualized\n   - END IF\n\n5. Response Generation:\n   - Prepare response with complete list of smilies\n   - Each smilie in response contains:\n     - Smilie ID\n     - Smilie code (text representation)\n     - Properly formatted URL to smilie image\n     - Display information\n   - Return formatted smilies list to caller",
    "databaseEntities": [
      "jforum_smilies"
    ],
    "validationRules": [
      "Cache system must be properly initialized",
      "Forum link configuration must be available for URL formatting",
      "Smilies must be loaded from database before retrieval"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Smilie": {
        "id": "number",
        "code": "string",
        "url": "string",
        "diskName": "string"
      }
    }
  },
  {
    "featureName": "GetRecentTopics",
    "description": "Retrieves a list of the most recent forum topics from cache or database.",
    "inputValues": [
      "limit-number-TopicLimit"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the maximum number of topics to retrieve (limit)\n   - If limit is not provided, use system configuration value for recent topics\n\n2. Data Validation:\n   - Validate that limit is a positive integer\n   - IF limit is negative or zero THEN\n     - Set limit to default system configuration value\n   - IF limit exceeds maximum allowed value THEN\n     - Cap limit to maximum allowed value\n\n3. Business Rule Processing:\n   - Check if topic caching is enabled in system configuration\n   - IF caching is enabled THEN\n     - Check if recent topics are already cached\n   - ELSE\n     - Skip cache check and proceed to database retrieval\n\n4. Core Operation Execution:\n   - IF caching is enabled AND recent topics exist in cache THEN\n     - Retrieve recent topics list from cache\n     - Return a copy of the cached list to prevent modification of cached data\n   - ELSE\n     - Query database for most recent topics\n     - Sort topics by last post date in descending order\n     - Limit results to requested number of topics\n     - IF caching is enabled THEN\n       - Store retrieved topics in cache for future use\n     - Return the list of recent topics\n\n5. Response Generation:\n   - Format the list of topics for display\n   - Include for each topic:\n     - Topic ID\n     - Topic title\n     - Forum ID\n     - Creation date\n     - Last post date\n     - Number of replies\n     - Number of views\n     - Topic starter information\n     - Last poster information\n   - Return the formatted list of recent topics",
    "databaseEntities": [
      "jforum_topics",
      "jforum_forums",
      "jforum_users",
      "jforum_posts"
    ],
    "validationRules": [
      "Limit must be a positive integer",
      "Limit cannot exceed system-defined maximum value",
      "User must have permission to view topics",
      "Only topics from publicly accessible forums should be included",
      "Topics from restricted forums should only be visible to authorized users"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Topic": {
        "id": "number",
        "title": "string",
        "forumId": "number",
        "creationDate": "date",
        "lastPostDate": "date",
        "replies": "number",
        "views": "number",
        "starter": "object",
        "lastPoster": "object"
      }
    }
  },
  {
    "featureName": "GetHottestTopics",
    "description": "Retrieves a list of the most popular forum topics from cache or database.",
    "inputValues": [
      "limit-number-Integer"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the following inputs:\n     - limit (number): Maximum number of topics to retrieve (optional, system will use default if not provided)\n   - System will use configuration value for HOTTEST_TOPICS if limit is not provided\n\n2. Data Validation:\n   - Validate limit parameter:\n     - IF limit is provided THEN\n       - Verify limit is a positive integer\n       - IF limit is negative or zero THEN\n         - Return error message indicating limit must be positive\n     - ELSE\n       - Use system default value for hottest topics limit\n\n3. Business Rule Processing:\n   - Check system configuration:\n     - Verify if topic caching is enabled in system configuration\n     - Determine appropriate data source (cache or database) based on configuration\n   - Check cache status:\n     - IF topic caching is enabled THEN\n       - Check if hottest topics are already cached\n       - IF cache is empty or invalid THEN\n         - Mark cache as requiring refresh\n\n4. Core Operation Execution:\n   - Retrieve hottest topics:\n     - IF cache is valid and contains hottest topics THEN\n       - Retrieve topics list from cache\n     - ELSE\n       - Query database for hottest topics:\n         - Sort topics by popularity metrics (view count, reply count)\n         - Limit results to requested number of topics\n         - Format topic data for response\n       - IF caching is enabled THEN\n         - Store retrieved topics in cache for future requests\n         - Set cache expiration according to system configuration\n   - Process topic list:\n     - Ensure each topic contains required information:\n       - Topic ID\n       - Topic title\n       - Forum ID\n       - Creation date\n       - Last post date\n       - Number of replies\n       - Number of views\n       - Topic starter information\n       - Last poster information\n     - Create a new list to avoid modifying cached data\n\n5. Response Generation:\n   - Format response with hottest topics:\n     - Return list of topics sorted by popularity\n     - Include all relevant topic information\n   - Handle error cases:\n     - IF database access fails THEN\n       - Return appropriate error message\n       - Log system error\n     - IF no topics are found THEN\n       - Return empty list\n       - Include message indicating no hot topics are available",
    "databaseEntities": [
      "jforum_topics",
      "jforum_forums",
      "jforum_posts",
      "jforum_users"
    ],
    "validationRules": [
      "Limit parameter must be a positive integer if provided",
      "System must have access to topic data either through cache or database",
      "Topic cache must be refreshed if empty or invalid",
      "Each topic must contain complete information including popularity metrics"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Topic": {
        "id": "number",
        "title": "string",
        "forumId": "number",
        "creationDate": "date",
        "lastPostDate": "date",
        "replies": "number",
        "views": "number",
        "starter": {
          "id": "number",
          "username": "string"
        },
        "lastPoster": {
          "id": "number",
          "username": "string"
        }
      }
    }
  },
  {
    "featureName": "AddTopicToCache",
    "description": "Adds a forum topic to the cache with proper sorting and management.",
    "inputValues": [
      "topic-object-Topic",
      "forumId-number-Forum"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the Topic object containing all topic details\n   - Obtain the forumId associated with the topic\n   - System configuration parameters:\n     * Topic cache enabled flag\n     * Maximum items per page setting\n\n2. Data Validation:\n   - Validate Topic object:\n     * Ensure topic is not null\n     * Verify topic ID is valid (greater than 0)\n     * Confirm topic has valid forumId associated\n   - Validate system state:\n     * Check if topic caching is enabled in system configuration\n     * IF caching is disabled, THEN exit the process\n\n3. Business Rule Processing:\n   - Check cache availability:\n     * Verify cache engine is properly initialized\n     * Ensure forum cache structure exists\n   - Determine topic placement:\n     * Check if topic already exists in cache\n     * Determine if topic should be added to recent topics list\n     * Determine if topic should be added to forum-specific topic list\n\n4. Core Operation Execution:\n   - Synchronize access to forum cache:\n     * Retrieve current forum topic list from cache using forumId\n     * IF list doesn't exist:\n       * Create new empty list\n       * Add topic to the list\n     * ELSE:\n       * Check if topic already exists in list\n       * IF topic exists:\n         * Remove existing topic instance\n       * IF list size would exceed maximum items after adding:\n         * Remove oldest topic from list\n       * Add new topic to list\n       * Sort list according to topic type priority\n   - Update topic-forum relationship map:\n     * Retrieve current relationship map from cache\n     * IF map doesn't exist:\n       * Create new relationship map\n     * Add or update mapping between topic ID and forum ID\n     * Store updated map back to cache\n   - Update recent topics list if applicable:\n     * IF topic is new or recently updated:\n       * Add to recent topics cache with proper ordering\n\n5. Response Generation:\n   - Return success indicator:\n     * Confirm topic was successfully added to cache\n     * Provide updated cache status information\n   - Handle any exceptions:\n     * Log cache operation failures\n     * Return appropriate error information",
    "databaseEntities": [
      "Topic",
      "Forum"
    ],
    "validationRules": [
      "Topic object must not be null",
      "Topic ID must be greater than zero",
      "Forum ID must be valid and greater than zero",
      "Topic cache must be enabled in system configuration",
      "Cache engine must be properly initialized"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Topic": {
        "id": "number",
        "forumId": "number",
        "title": "string",
        "postTime": "date",
        "lastPostTime": "date",
        "type": "number",
        "status": "number",
        "totalReplies": "number",
        "totalViews": "number",
        "userId": "number"
      }
    }
  },
  {
    "featureName": "UpdateCachedTopic",
    "description": "Updates an existing topic in the cache while maintaining cache integrity.",
    "inputValues": [
      "topic-object-Topic"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the Topic object with updated information\n   - Required fields: topic ID, forum ID, and updated topic properties\n   - System will use the cache configuration settings from system preferences\n\n2. Data Validation:\n   - Validate Topic object exists\n     * IF Topic object is null THEN return error \"Topic object cannot be null\"\n     * IF Topic ID is not set or invalid THEN return error \"Invalid Topic ID\"\n     * IF Forum ID is not set or invalid THEN return error \"Invalid Forum ID\"\n   - Validate cache is enabled\n     * IF topic caching is disabled in system preferences THEN exit process without error (no action needed)\n\n3. Business Rule Processing:\n   - Check if topic exists in cache\n     * IF topic is not in cache THEN no update is needed\n   - Verify forum relationship\n     * IF topic's forum ID has changed THEN handle as a topic move operation\n     * IF forum cache is not initialized THEN initialize forum cache\n\n4. Core Operation Execution:\n   - Acquire synchronization lock to prevent concurrent modifications\n     * Lock the forum cache to ensure thread safety\n   - Locate the topic in the cache\n     * Retrieve the forum's topic list from cache using forum ID\n     * Find the topic's index in the list using topic ID\n     * IF topic found in list THEN:\n       > Replace the old topic instance with the updated topic instance\n       > Maintain the topic's position in the list\n       > Ensure topic type ordering is preserved\n     * IF topic not found in list THEN:\n       > No action required as topic is not cached\n   - Update related cache entries\n     * Update any relationship mappings if needed\n     * Update recent topics list if applicable\n   - Release synchronization lock\n\n5. Response Generation:\n   - Return success indicator\n   - No specific response data needed as this is a cache maintenance operation\n   - Log cache update operation if logging is enabled",
    "databaseEntities": [
      "jforum_topics",
      "jforum_forums"
    ],
    "validationRules": [
      "Topic object must not be null",
      "Topic ID must be valid",
      "Forum ID must be valid",
      "Cache must be enabled for operation to proceed"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Topic": {
        "type": "object",
        "properties": {
          "id": {
            "type": "number",
            "description": "Unique identifier for the topic"
          },
          "forumId": {
            "type": "number",
            "description": "ID of the forum this topic belongs to"
          },
          "title": {
            "type": "string",
            "description": "Title of the topic"
          },
          "lastPostId": {
            "type": "number",
            "description": "ID of the last post in this topic"
          },
          "lastPostTime": {
            "type": "date",
            "description": "Date and time of the last post"
          },
          "type": {
            "type": "number",
            "description": "Type of the topic for sorting purposes"
          },
          "totalReplies": {
            "type": "number",
            "description": "Count of replies in this topic"
          },
          "status": {
            "type": "number",
            "description": "Current status of the topic"
          }
        },
        "required": [
          "id",
          "forumId"
        ]
      }
    }
  },
  {
    "featureName": "GetCachedTopic",
    "description": "Retrieves a specific topic from the cache based on topic and forum identifiers.",
    "inputValues": [
      "topicId-number-Topic",
      "forumId-number-Forum",
      "topic-object-Topic"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the Topic object which should contain at minimum:\n     * topicId (mandatory): Unique identifier for the topic\n     * forumId (optional): Identifier for the forum containing the topic\n   - System configuration settings are automatically retrieved:\n     * TOPIC_CACHE_ENABLED: Boolean flag indicating if topic caching is enabled\n\n2. Data Validation:\n   - Validate topic input:\n     * IF topic object is null THEN\n       - Return null as there is nothing to retrieve\n     * IF topicId is not provided or invalid THEN\n       - Return null as the topic cannot be identified\n     * IF TOPIC_CACHE_ENABLED setting is false THEN\n       - Return null as caching is disabled\n\n3. Business Rule Processing:\n   - Check forum identification:\n     * IF forumId is not provided (equals 0) THEN\n       - Attempt to retrieve the forumId from the relation mapping cache\n       - IF forumId is found in relation mapping THEN\n         - Set the forumId in the topic object\n       - ELSE\n         - Return null as the forum cannot be determined\n     * IF forumId is still 0 after relation lookup THEN\n       - Return null as the forum cannot be determined\n\n4. Core Operation Execution:\n   - Retrieve the list of topics for the identified forum from cache\n   - IF the topic list is null THEN\n     - Return null as no topics are cached for this forum\n   - Search for the requested topic in the cached list:\n     * Find the index of the topic in the list based on topic ID\n     * IF topic is not found (index equals -1) THEN\n       - Return null as the topic is not in the cache\n     * ELSE\n       - Retrieve the topic from the list at the found index\n\n5. Response Generation:\n   - Return the retrieved topic object with all its cached properties\n   - IF topic was not found in cache THEN\n     - Return null to indicate cache miss",
    "databaseEntities": [
      "jforum_topics",
      "jforum_forums"
    ],
    "validationRules": [
      "Topic object must not be null",
      "Topic ID must be a valid positive integer",
      "Topic caching must be enabled in system settings",
      "Forum ID must be determinable either from input or relation cache"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Topic": {
        "id": "number",
        "forumId": "number",
        "title": "string",
        "lastPostId": "number",
        "firstPostId": "number",
        "type": "number",
        "lastPostTime": "date",
        "lastPostBy": "string",
        "status": "number",
        "totalViews": "number",
        "totalReplies": "number"
      }
    }
  },
  {
    "featureName": "GetForumTopics",
    "description": "Retrieves all cached topics related to a specific forum.",
    "inputValues": [
      "forumId-number-Forum"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect forumId (mandatory): numeric identifier of the forum\n   - System will use cache configuration settings (optional, system-generated)\n\n2. Data Validation:\n   - Validate forumId:\n      a. Check if forumId is provided\n      b. Verify forumId is a positive integer\n      c. Return error message if validation fails\n   - Verify cache status:\n      a. Check if topic caching is enabled in system settings\n      b. If caching is disabled, proceed with alternative retrieval method\n\n3. Business Rule Processing:\n   - Check cache status for requested forum:\n      a. IF forum topics are already loaded in cache:\n         i. Proceed to retrieve from cache\n      b. ELSE:\n         i. Mark forum as not cached\n   - Verify access permissions:\n      a. Check if current user has permission to view the forum\n      b. Return error if user lacks necessary permissions\n\n4. Core Operation Execution:\n   - Retrieve topics based on cache status:\n      a. IF topics for the forum are cached:\n         i. Get topic list from cache using forumId as key\n         ii. Create a copy of the cached list to avoid modifying cache\n      b. ELSE:\n         i. Return empty list\n   - Process retrieved topics:\n      a. IF list is empty:\n         i. Return empty result set\n      b. ELSE:\n         i. Prepare topics for display\n\n5. Response Generation:\n   - Format response with topic data:\n      a. For each topic include:\n         i. Topic ID\n         ii. Topic title\n         iii. Creation date\n         iv. Last post information\n         v. View count\n         vi. Reply count\n         vii. Topic type (normal, sticky, announcement)\n   - Return the formatted topic list\n   - Include metadata:\n      a. Total number of topics\n      b. Cache status (whether results came from cache)",
    "databaseEntities": [
      "jforum_forums",
      "jforum_topics"
    ],
    "validationRules": [
      "Forum ID must be a positive integer",
      "User must have permission to view the forum",
      "Topic cache must be properly configured"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Topic": {
        "id": "number",
        "title": "string",
        "forumId": "number",
        "creationDate": "date",
        "lastPostDate": "date",
        "viewCount": "number",
        "replyCount": "number",
        "type": "number",
        "firstPosterId": "number",
        "lastPosterId": "number"
      },
      "Forum": {
        "id": "number",
        "name": "string",
        "description": "string",
        "categoryId": "number",
        "lastPostDate": "date",
        "totalTopics": "number",
        "totalPosts": "number"
      }
    }
  },
  {
    "featureName": "ClearForumCache",
    "description": "Clears the topic cache for a specific forum.",
    "inputValues": [
      "forumId-number-Forum"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect forumId (number, mandatory) - The identifier of the forum whose cache needs to be cleared\n\n2. Data Validation:\n   - Validate forumId:\n     a. Check if forumId is provided\n     b. Verify forumId is a positive integer\n     c. IF forumId is missing or invalid THEN\n        i. Generate an error message indicating invalid forum identifier\n        ii. Terminate the process\n\n3. Business Rule Processing:\n   - Check system configuration:\n     a. Verify if topic caching is enabled in the system\n     b. IF topic caching is not enabled THEN\n        i. Log information that caching is disabled\n        ii. Skip to Response Generation with appropriate message\n     c. Check if the forum exists in the system\n        i. IF forum does not exist THEN\n           1. Generate an error message indicating forum not found\n           2. Terminate the process\n\n4. Core Operation Execution:\n   - Acquire synchronization lock to prevent concurrent modifications\n     a. Locate the cache storage for the specified forum\n     b. Create an empty collection to replace existing cached topics\n     c. Remove any topic-to-forum relationship mappings for this forum\n     d. Update the cache with the empty collection\n     e. Mark the forum's cache as cleared in the system\n     f. Release the synchronization lock\n\n5. Response Generation:\n   - IF cache clearing operation was successful THEN\n     a. Generate success response indicating the forum cache was cleared\n     b. Include the forum identifier in the response\n     c. Include timestamp of when the operation was performed\n   - ELSE\n     a. Generate error response with details about what went wrong\n     b. Include any system error messages\n     c. Provide suggestions for troubleshooting",
    "databaseEntities": [
      "jforum_forums",
      "jforum_topics"
    ],
    "validationRules": [
      "Forum ID must be a positive integer",
      "Forum must exist in the system",
      "Topic caching must be enabled for this operation to have effect"
    ],
    "dbSeedingOperations": [],
    "schema": {}
  },
  {
    "featureName": "LoadMostRecentTopics",
    "description": "Loads the most recent topics from the database and adds them to the cache.",
    "inputValues": [
      "limit-number-Topic"
    ],
    "businessLogic": "1. Input Collection\n   - Retrieve system configuration for topic cache settings\n     - Determine if topic caching is enabled\n     - Get the configured limit for recent topics\n   - No user inputs required as this is a system operation\n\n2. Data Validation\n   - Validate system configuration\n     - IF topic cache is disabled THEN exit the process\n     - IF limit value is not a positive integer THEN use default value\n   - Check cache state\n     - IF cache engine is not initialized THEN report system error\n\n3. Business Rule Processing\n   - Determine cache refresh conditions\n     - IF cache is empty OR cache does not exist THEN proceed with loading\n     - IF forced refresh is requested THEN proceed regardless of current cache state\n   - Verify data access permissions\n     - Ensure system has proper access to topic data\n     - Verify cache write permissions\n\n4. Core Operation Execution\n   - Connect to data source\n     - Obtain data access object for topics\n     - Prepare query parameters including limit value\n   - Retrieve most recent topics\n     - Query database for topics ordered by creation date\n     - Limit results to configured maximum number\n   - Process retrieved topics\n     - Create a new linked list to store the topics\n     - Add all retrieved topics to the list\n   - Update cache\n     - Store the linked list in the cache under appropriate key\n     - Set cache expiration according to system configuration\n   - Handle any failures\n     - IF database connection fails THEN log error and return empty list\n     - IF cache update fails THEN log warning but return retrieved data\n\n5. Response Generation\n   - Prepare response\n     - Return the list of most recent topics\n     - Include metadata about cache status\n   - Log operation completion\n     - Record number of topics loaded\n     - Record timestamp of cache refresh",
    "databaseEntities": [
      "jforum_topics",
      "jforum_forums"
    ],
    "validationRules": [
      "Topic cache must be enabled in system configuration",
      "Recent topics limit must be a positive integer",
      "Cache engine must be properly initialized",
      "Data access objects must be available"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Topic": {
        "type": "object",
        "properties": {
          "id": {
            "type": "number",
            "description": "Unique identifier for the topic"
          },
          "forumId": {
            "type": "number",
            "description": "Identifier of the forum this topic belongs to"
          },
          "title": {
            "type": "string",
            "description": "Title of the topic"
          },
          "creationDate": {
            "type": "date",
            "description": "Date when the topic was created"
          },
          "lastPostDate": {
            "type": "date",
            "description": "Date of the last post in this topic"
          },
          "type": {
            "type": "number",
            "description": "Type classification of the topic"
          }
        },
        "required": [
          "id",
          "forumId",
          "title",
          "creationDate"
        ]
      }
    }
  },
  {
    "featureName": "LoadHottestTopics",
    "description": "Loads the most popular topics from the database and adds them to the cache.",
    "inputValues": [
      "limit-number-Topic"
    ],
    "businessLogic": "1. Input Collection\n   - Retrieve the maximum number of hottest topics to load (limit) from system configuration\n   - System-generated input: cache engine reference for storing results\n\n2. Data Validation\n   - Validate that the limit is a positive integer\n     - IF limit <= 0 THEN\n       - Use default value from system configuration\n     - END IF\n   - Verify cache engine is properly initialized\n     - IF cache engine is null THEN\n       - Initialize cache engine\n     - END IF\n\n3. Business Rule Processing\n   - Check if topic caching is enabled in system configuration\n     - IF topic caching is disabled THEN\n       - Skip caching operations but still retrieve topics\n     - END IF\n   - Determine if hottest topics are already cached\n     - IF hottest topics exist in cache AND cache is valid THEN\n       - Return cached topics without database access\n     - END IF\n\n4. Core Operation Execution\n   - Access data layer to retrieve hottest topics\n     - Create data access object for topics\n     - Query database for topics with highest view or reply counts\n     - Limit results to specified maximum number\n   - Process retrieved topics\n     - Sort topics by popularity metrics (views, replies)\n     - Convert to appropriate data structure for caching\n   - Store topics in cache\n     - Add topics to cache with appropriate cache key\n     - Set expiration time according to system configuration\n   - Update cache status indicators\n     - Mark hottest topics as loaded in cache\n\n5. Response Generation\n   - Return the list of hottest topics\n   - Include metadata about cache status (freshly loaded or from cache)\n   - IF error occurs during processing THEN\n     - Return empty list\n     - Log error details\n   - END IF",
    "databaseEntities": [
      "jforum_topics",
      "jforum_forums"
    ],
    "validationRules": [
      "Topic limit must be a positive integer",
      "Cache engine must be properly initialized before use",
      "Topic caching must be enabled in system configuration for caching operations"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Topic": {
        "type": "object",
        "properties": {
          "id": {
            "type": "number",
            "description": "Unique identifier for the topic"
          },
          "forumId": {
            "type": "number",
            "description": "Forum identifier the topic belongs to"
          },
          "title": {
            "type": "string",
            "description": "Title of the topic"
          },
          "postCount": {
            "type": "number",
            "description": "Number of posts in the topic"
          },
          "viewCount": {
            "type": "number",
            "description": "Number of views the topic has received"
          },
          "lastPostDate": {
            "type": "date",
            "description": "Date of the last post in the topic"
          },
          "type": {
            "type": "number",
            "description": "Type classification of the topic"
          }
        }
      }
    }
  },
  {
    "featureName": "LoadTemplateConfiguration",
    "description": "Loads HTML template mappings from a properties file into the cache.",
    "inputValues": [
      "filename-string-ConfigFile"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the filename (string) of the properties file containing HTML template mappings\n   - The filename must include the complete path to the file\n   - The file must be accessible by the system\n\n2. Data Validation:\n   - Validate that the filename is not empty or null\n   - Verify that the file exists at the specified path\n   - Confirm the file has read permissions\n   - Ensure the file is in a valid properties format\n   - IF any validation fails, THEN prepare appropriate error message\n\n3. Business Rule Processing:\n   - Check if the cache system is properly initialized\n   - Verify the cache has sufficient capacity for storing template mappings\n   - Ensure no conflicting operations are modifying the same cache region\n\n4. Core Operation Execution:\n   - Initialize a properties container to hold the template mappings\n   - Open the specified file for reading\n   - Load all key-value pairs from the properties file\n   - FOR each key-value pair in the properties file:\n     - Extract the template key (identifier)\n     - Extract the corresponding template filename/path value\n     - Store the mapping in the cache using the template key as identifier\n   - Close the file resource properly\n   - IF any error occurs during loading:\n     - Log the error details\n     - Clean up any partially loaded data\n     - Prepare appropriate exception with error context\n\n5. Response Generation:\n   - IF operation completes successfully:\n     - Return success status\n     - Provide summary of loaded template mappings\n   - IF operation fails:\n     - Return failure status with detailed error information\n     - Include suggestions for resolving common issues\n     - Provide information about the current state of the cache",
    "databaseEntities": [],
    "validationRules": [
      "The template configuration file must exist",
      "The template configuration file must be readable",
      "The template configuration file must be in valid properties format",
      "The cache system must be properly initialized before loading templates",
      "Each template key must be unique within the cache"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "ConfigFile": {
        "type": "object",
        "properties": {
          "path": {
            "type": "string",
            "description": "Complete file path to the properties file"
          },
          "format": {
            "type": "string",
            "description": "File format (must be properties)"
          }
        },
        "required": [
          "path"
        ]
      }
    }
  },
  {
    "featureName": "GetTemplateName",
    "description": "Retrieves a template filename from the cache using a configuration key.",
    "inputValues": [
      "key-string-TemplateKey"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the template key (key-string-TemplateKey) from the user or system request\n   - The key is mandatory and represents the identifier for the template in the cache\n   - No default values are provided; the key must be explicitly specified\n\n2. Data Validation:\n   - Validate the template key:\n     a. Check if the key is not null or empty\n     b. Verify the key format follows the system's naming convention\n     c. If validation fails, prepare appropriate error message indicating invalid key format\n\n3. Business Rule Processing:\n   - Check system state:\n     a. Verify the cache system is initialized and available\n     b. Confirm the templates have been loaded into the cache\n     c. IF cache is not initialized or templates are not loaded:\n        i. Log the system state issue\n        ii. Prepare error response indicating system is not ready\n\n4. Core Operation Execution:\n   - Retrieve the template filename from cache:\n     a. Access the cache using the template namespace (\"templates\")\n     b. Look up the provided key in the cache\n     c. IF the key exists in cache:\n        i. Retrieve the associated template filename\n     d. ELSE IF the key does not exist:\n        i. Log the missing template key\n        ii. Prepare error response indicating template not found\n\n5. Response Generation:\n   - Success response:\n     a. Return the retrieved template filename\n     b. Include status indicating successful retrieval\n   - Error response:\n     a. Return error code and descriptive message\n     b. Include the original key in the response\n     c. Provide guidance on available template keys if possible",
    "databaseEntities": [],
    "validationRules": [
      "Template key must not be null or empty",
      "Cache system must be initialized before template retrieval",
      "Templates must be loaded into cache before retrieval"
    ],
    "dbSeedingOperations": [],
    "schema": {}
  },
  {
    "featureName": "PerformContentSearch",
    "description": "Executes a search operation based on provided keywords and returns matching posts.",
    "inputValues": [
      "keywords-string-SearchArgs",
      "searchArgs-object-SearchArgs"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the following inputs:\n     - keywords (string array): Search terms provided by the user (mandatory)\n     - searchArgs (object): Contains search configuration parameters including:\n       - Forum selection criteria (optional)\n       - Date range filters (optional)\n       - User filters (optional)\n       - Sort order preference (optional)\n       - Results per page (optional, system default if not provided)\n\n2. Data Validation:\n   - Validate search keywords:\n     - IF keywords array is empty THEN\n       - Return empty result set with count of 0\n       - Skip search execution\n     - ELSE\n       - Verify keywords meet minimum length requirements\n       - Remove any special characters that could cause search issues\n       - Normalize keywords for consistent searching\n   - Validate search arguments:\n     - Ensure date ranges are valid (start date before end date)\n     - Verify forum IDs exist in the system\n     - Confirm user IDs are valid if user filtering is applied\n\n3. Business Rule Processing:\n   - Check user permissions:\n     - Verify current user has permission to search content\n     - Filter out forums the user doesn't have access to view\n   - Apply content visibility rules:\n     - Exclude private content not accessible to the current user\n     - Apply forum-specific visibility rules\n   - Prepare search execution parameters:\n     - Format keywords for optimal search performance\n     - Set up pagination parameters if applicable\n     - Configure result ordering based on user preferences\n\n4. Core Operation Execution:\n   - Execute the search operation:\n     - IF keywords array has content THEN\n       - Perform search using the search facility\n       - Collect matching posts that meet all criteria\n       - Track total number of matching records\n     - ELSE\n       - Return empty result set\n   - Process search results:\n     - Store the result collection for later use\n     - Organize results according to requested sort order\n     - Apply pagination if required\n\n5. Response Generation:\n   - Prepare posts for display:\n     - Format post content for proper rendering\n     - Highlight matching keywords in results\n     - Include relevant metadata (author, date, forum)\n   - Generate response:\n     - Include list of matching posts\n     - Include total record count\n     - Provide pagination information if applicable\n     - Return appropriate view template reference\n     - Include forum IDs for each result for permission checking",
    "databaseEntities": [
      "jforum_posts",
      "jforum_posts_text",
      "jforum_forums",
      "jforum_topics",
      "jforum_users"
    ],
    "validationRules": [
      "Search keywords must be provided for search execution",
      "User must have permission to view the forums being searched",
      "Search results must only include posts from forums the user has access to",
      "Posts must be prepared for display before being returned to the user",
      "Forum IDs must be extractable from search results"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "SearchArgs": {
        "type": "object",
        "properties": {
          "keywords": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Array of search terms"
          },
          "forumId": {
            "type": "integer",
            "description": "Optional forum ID to restrict search"
          },
          "startDate": {
            "type": "date",
            "description": "Optional start date for filtering results"
          },
          "endDate": {
            "type": "date",
            "description": "Optional end date for filtering results"
          },
          "userId": {
            "type": "integer",
            "description": "Optional user ID to filter results by author"
          },
          "sortBy": {
            "type": "string",
            "description": "Field to sort results by"
          },
          "sortOrder": {
            "type": "string",
            "description": "Direction of sort (ascending/descending)"
          },
          "resultsPerPage": {
            "type": "integer",
            "description": "Number of results to return per page"
          }
        }
      }
    }
  },
  {
    "featureName": "PrepareSearchResultsForDisplay",
    "description": "Processes search results to prepare posts for display in the user interface.",
    "inputValues": [
      "searchResults-object-SearchResult",
      "posts-object-PostList"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect search results containing post records\n   - Identify if the search results are from a keyword search or empty search\n   - Determine if formatting is required for display purposes\n\n2. Data Validation:\n   - Verify search results are not null\n   - Check if the results collection contains valid post objects\n   - Validate that each post has the required attributes for display\n   - Ensure the post content is accessible and can be formatted\n   - IF any post is invalid or corrupted:\n      - Log the issue\n      - Skip the problematic post\n      - Continue processing valid posts\n\n3. Business Rule Processing:\n   - Check user permissions for viewing each post\n   - Filter out posts from restricted forums if applicable\n   - Determine if content should be censored based on system settings\n   - Apply content visibility rules based on user access level\n   - IF user lacks permission to view certain posts:\n      - Remove those posts from the results\n      - Update the total count accordingly\n\n4. Core Operation Execution:\n   - FOR EACH post in the search results:\n      - Format post text for HTML display\n      - Process any BBCode or markup in the post content\n      - Convert URLs to clickable links\n      - Format code blocks for proper display\n      - Process emoticons/smilies in the content\n      - Highlight search keywords in the post content if applicable\n      - Prepare post metadata (author, date, forum) for display\n      - Add any required display flags to the post object\n   - Organize posts in the appropriate display order\n   - Calculate pagination information if needed\n\n5. Response Generation:\n   - Prepare the final collection of formatted posts\n   - Include total count of matching posts\n   - Include pagination details if applicable\n   - Provide forum context information for each post\n   - Return the prepared results for rendering in the user interface",
    "databaseEntities": [
      "jforum_posts",
      "jforum_posts_text",
      "jforum_forums",
      "jforum_topics",
      "jforum_users"
    ],
    "validationRules": [
      "Search results must contain valid post objects",
      "Each post must have accessible content for formatting",
      "User must have permission to view the posts",
      "Posts must belong to accessible forums",
      "Post content must be properly sanitized for display"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "SearchResult": {
        "type": "object",
        "properties": {
          "records": {
            "type": "array",
            "items": {
              "type": "object",
              "ref": "Post"
            }
          },
          "totalRecords": {
            "type": "number"
          }
        }
      },
      "PostList": {
        "type": "array",
        "items": {
          "type": "object",
          "ref": "Post"
        }
      },
      "Post": {
        "type": "object",
        "properties": {
          "id": {
            "type": "number"
          },
          "forumId": {
            "type": "number"
          },
          "topicId": {
            "type": "number"
          },
          "userId": {
            "type": "number"
          },
          "text": {
            "type": "string"
          },
          "subject": {
            "type": "string"
          },
          "postDate": {
            "type": "date"
          }
        }
      }
    }
  },
  {
    "featureName": "ExtractForumIdFromPost",
    "description": "Retrieves the forum ID from a post object in search results.",
    "inputValues": [
      "post-object-Post"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the post object (mandatory)\n   - The post object must contain forum ID information\n\n2. Data Validation:\n   - Validate that the post object is not null\n     * IF post object is null THEN return error message indicating invalid input\n   - Validate that the post object is of the correct type\n     * IF post object is not of type Post THEN return error message indicating type mismatch\n   - Validate that the post object contains forum ID information\n     * IF forum ID is missing THEN return error message indicating incomplete post data\n\n3. Business Rule Processing:\n   - Check if the user has permission to access the forum ID\n     * IF user does not have permission THEN return appropriate error message\n   - Verify that the forum associated with the ID exists in the system\n     * IF forum does not exist THEN return error indicating invalid forum reference\n\n4. Core Operation Execution:\n   - Extract the forum ID from the post object\n   - Format the forum ID as an integer value\n   - Prepare the forum ID for return\n\n5. Response Generation:\n   - Return the extracted forum ID\n   - IF extraction was successful THEN return the forum ID value\n   - IF any errors occurred during extraction THEN return appropriate error message\n   - Include context information about which post the forum ID belongs to",
    "databaseEntities": [
      "jforum_posts",
      "jforum_forums"
    ],
    "validationRules": [
      "Post object must not be null",
      "Post object must be of the correct type",
      "Post object must contain a valid forum ID",
      "Forum ID must reference an existing forum",
      "User must have permission to access the forum"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Post": {
        "type": "object",
        "properties": {
          "id": {
            "type": "number",
            "description": "Unique identifier for the post"
          },
          "forumId": {
            "type": "number",
            "description": "ID of the forum containing this post"
          },
          "topicId": {
            "type": "number",
            "description": "ID of the topic containing this post"
          },
          "userId": {
            "type": "number",
            "description": "ID of the user who created the post"
          },
          "subject": {
            "type": "string",
            "description": "Subject of the post"
          },
          "text": {
            "type": "string",
            "description": "Content of the post"
          },
          "postDate": {
            "type": "date",
            "description": "Date when the post was created"
          }
        },
        "required": [
          "id",
          "forumId",
          "topicId",
          "userId"
        ]
      }
    }
  },
  {
    "featureName": "CollectSearchResults",
    "description": "Collects and processes search results from the search index, retrieving post data and highlighting matched content.",
    "inputValues": [
      "searchArgs-object-SearchArgs",
      "searchHits-object-Hits",
      "searchQuery-object-Query"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect search arguments (searchArgs) containing:\n     * startFrom: starting position for results\n     * fetchCount: number of results to retrieve\n   - Collect search hits (searchHits) containing:\n     * Document references matching the search criteria\n     * Total number of matches available\n   - Collect search query (searchQuery) containing:\n     * The original search terms and parameters\n\n2. Data Validation:\n   - Validate search arguments:\n     * Ensure startFrom is a non-negative integer\n     * Ensure fetchCount is a positive integer\n     * IF either validation fails, THEN return appropriate error message\n   - Validate search hits:\n     * Ensure search hits object is not null\n     * Ensure hits length is accessible\n     * IF validation fails, THEN return appropriate error message\n   - Validate search query:\n     * Ensure query object is properly formed\n     * IF validation fails, THEN return appropriate error message\n\n3. Business Rule Processing:\n   - Determine actual number of results to process:\n     * Calculate effective fetch count as minimum of requested fetch count and available hits\n     * IF effective fetch count is zero, THEN return empty result list\n   - Prepare for post ID extraction:\n     * Initialize array to store post IDs\n     * Calculate end index for iteration\n\n4. Core Operation Execution:\n   - Extract post IDs from search hits:\n     * FOR each document from startFrom to (startFrom + fetchCount) or hits length (whichever is smaller):\n       * Retrieve document from hits collection\n       * Extract post ID from document\n       * Store post ID in array\n   - Retrieve complete post data:\n     * Query database to get full post information for all extracted post IDs\n     * FOR each retrieved post:\n       * Create text highlighter using the search query\n       * Process post text to identify matching fragments\n       * IF matching fragment found, THEN replace post text with highlighted fragment\n       * ELSE keep original post text\n\n5. Response Generation:\n   - Prepare final result list containing:\n     * Post objects with highlighted text showing search term matches\n     * Each post containing its ID, text, and associated metadata\n   - Return the processed post list to the caller\n   - IF any exceptions occur during processing, THEN:\n     * Capture exception details\n     * Generate appropriate error response\n     * Include support information for troubleshooting",
    "databaseEntities": [
      "jforum_posts",
      "jforum_posts_text"
    ],
    "validationRules": [
      "Search arguments must contain valid startFrom and fetchCount values",
      "Search hits object must not be null",
      "Search query must be properly formed",
      "Post IDs must be valid integers",
      "Retrieved posts must contain text content for highlighting"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "SearchArgs": {
        "type": "object",
        "properties": {
          "startFrom": {
            "type": "number",
            "description": "Starting position for results"
          },
          "fetchCount": {
            "type": "number",
            "description": "Number of results to retrieve"
          }
        }
      },
      "Hits": {
        "type": "object",
        "properties": {
          "length": {
            "type": "number",
            "description": "Total number of hits found"
          },
          "doc": {
            "type": "function",
            "description": "Method to retrieve document at specified index"
          }
        }
      },
      "Query": {
        "type": "object",
        "description": "Search query containing search terms and parameters"
      }
    }
  },
  {
    "featureName": "RetrievePostsWithHighlighting",
    "description": "Retrieves post data from database and applies text highlighting to search matches in post content.",
    "inputValues": [
      "searchQuery-string-SearchQuery",
      "searchArgs-object-SearchArgs"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect search query string (mandatory)\n   - Collect search arguments (mandatory) containing:\n     - startFrom: starting position for pagination\n     - fetchCount: number of results to retrieve\n   - System will use search index to find matching posts\n\n2. Data Validation:\n   - Validate search query is not empty\n     - IF search query is empty THEN return error message \"Search query cannot be empty\"\n   - Validate search arguments\n     - IF startFrom is negative THEN set to default value 0\n     - IF fetchCount is less than 1 THEN set to default value 10\n     - IF fetchCount exceeds maximum allowed THEN limit to maximum value\n\n3. Business Rule Processing:\n   - Check user permissions for searching\n     - IF user does not have search permission THEN return error message \"Insufficient permissions to perform search\"\n   - Check system search availability\n     - IF search functionality is disabled THEN return error message \"Search is currently unavailable\"\n   - Determine search scope based on user access levels\n     - Restrict search to only forums the user has access to\n\n4. Core Operation Execution:\n   - Execute search query against search index\n     - Retrieve matching document hits from search index\n     - Limit results based on startFrom and fetchCount parameters\n     - Extract post IDs from search results\n   - Retrieve complete post data from database using extracted post IDs\n     - Fetch post content, author information, and metadata\n   - Apply text highlighting to each post's content\n     - For each post:\n       - Create a scorer based on the search query\n       - Create a highlighter using the scorer\n       - Tokenize the post content\n       - Generate highlighted text fragments containing search terms\n       - Replace original post content with highlighted version if fragments exist\n       - IF no fragments found THEN keep original post content\n\n5. Response Generation:\n   - Prepare response with highlighted post data\n     - Include post ID, title, content with highlighting, author information, and posting date\n     - Include total number of matching results found\n     - Include pagination information (current page, total pages)\n   - Return formatted post collection with highlighting\n     - IF no results found THEN return appropriate message \"No matching posts found\"\n     - IF error occurred during processing THEN return error details",
    "databaseEntities": [
      "jforum_posts",
      "jforum_posts_text",
      "jforum_users",
      "jforum_topics",
      "jforum_forums"
    ],
    "validationRules": [
      "Search query must not be empty",
      "Start position must be zero or positive",
      "Fetch count must be greater than zero",
      "User must have permission to search",
      "Search must be performed only in forums accessible to the user"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "SearchArgs": {
        "type": "object",
        "properties": {
          "startFrom": {
            "type": "number",
            "description": "Starting position for pagination"
          },
          "fetchCount": {
            "type": "number",
            "description": "Number of results to retrieve"
          }
        },
        "required": [
          "startFrom",
          "fetchCount"
        ]
      }
    }
  },
  {
    "featureName": "BatchCreatePostIndex",
    "description": "Adds a post to the search index in batch mode using RAM directory.",
    "inputValues": [
      "post-object-Post"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the Post object containing all post information\n     - Post ID (mandatory)\n     - Forum ID (mandatory)\n     - Topic ID (mandatory)\n     - User ID (mandatory)\n     - Post date/time (mandatory)\n     - Post subject (mandatory)\n     - Post text content (mandatory)\n\n2. Data Validation:\n   - Validate Post object\n     - Verify Post object is not null\n     - Verify Post ID is a valid positive integer\n     - Verify Forum ID is a valid positive integer\n     - Verify Topic ID is a valid positive integer\n     - Verify User ID is a valid positive integer\n     - Verify post date/time is a valid date format\n     - Verify post subject is not empty\n     - Verify post text content is not empty\n   - IF any validation fails THEN\n     - Generate appropriate error message\n     - Abort indexing process\n\n3. Business Rule Processing:\n   - Check system resources\n     - Verify RAM directory is initialized\n     - Verify RAM writer is available\n     - IF RAM directory or writer is not initialized THEN\n       - Initialize RAM directory and writer\n   - Check concurrent access\n     - Acquire synchronization lock to prevent concurrent modifications\n     - IF lock cannot be acquired THEN\n       - Wait for lock or timeout after predefined period\n       - IF timeout occurs THEN\n         - Generate error message about system busy\n         - Abort indexing process\n\n4. Core Operation Execution:\n   - Create search document\n     - Extract post metadata (IDs, date)\n     - Prepare post content (subject and text)\n     - Format data according to search index requirements\n     - Create document with appropriate fields and indexing settings\n   - Add document to RAM index\n     - Add the created document to RAM directory\n     - Update document count in RAM index\n   - Check RAM directory threshold\n     - IF number of documents in RAM exceeds configured threshold THEN\n       - Flush RAM directory to persistent storage\n       - Create new RAM directory and writer\n       - Reset document count\n   - Release synchronization lock\n\n5. Response Generation:\n   - Success response\n     - Indicate post was successfully added to search index\n     - Return confirmation of indexing operation\n   - Error response\n     - Provide detailed error information if indexing failed\n     - Include error type and suggested resolution steps",
    "databaseEntities": [
      "jforum_posts",
      "jforum_posts_text",
      "jforum_topics",
      "jforum_forums",
      "jforum_users"
    ],
    "validationRules": [
      "Post object must not be null",
      "Post ID must be a positive integer",
      "Forum ID must be a positive integer",
      "Topic ID must be a positive integer",
      "User ID must be a positive integer",
      "Post date/time must be a valid date format",
      "Post subject must not be empty",
      "Post text content must not be empty",
      "RAM directory must be initialized before adding documents",
      "System must have sufficient memory for RAM directory operations"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Post": {
        "type": "object",
        "properties": {
          "id": {
            "type": "integer",
            "description": "Unique identifier for the post"
          },
          "forumId": {
            "type": "integer",
            "description": "ID of the forum containing this post"
          },
          "topicId": {
            "type": "integer",
            "description": "ID of the topic containing this post"
          },
          "userId": {
            "type": "integer",
            "description": "ID of the user who created the post"
          },
          "time": {
            "type": "string",
            "format": "date-time",
            "description": "Date and time when the post was created"
          },
          "subject": {
            "type": "string",
            "description": "Subject/title of the post"
          },
          "text": {
            "type": "string",
            "description": "Main content of the post"
          }
        },
        "required": [
          "id",
          "forumId",
          "topicId",
          "userId",
          "time",
          "subject",
          "text"
        ]
      }
    }
  },
  {
    "featureName": "CreatePostIndex",
    "description": "Indexes a single forum post for search functionality.",
    "inputValues": [
      "post-object-Post"
    ],
    "businessLogic": "1. Input Collection\n   - Collect the Post object with the following attributes:\n     - id: Unique identifier for the post\n     - forumId: Identifier of the forum containing the post\n     - topicId: Identifier of the topic containing the post\n     - userId: Identifier of the user who created the post\n     - time: Date and time when the post was created\n     - subject: Title or subject of the post\n     - text: Content or body of the post\n\n2. Data Validation\n   - Validate Post object integrity\n     - Verify the Post object is not null\n     - Verify the Post ID is valid and greater than zero\n     - Verify the Forum ID is valid and greater than zero\n     - Verify the Topic ID is valid and greater than zero\n     - Verify the User ID is valid and greater than zero\n     - Verify the post subject is not null\n     - Verify the post text is not null\n   - IF any validation fails THEN\n     - Generate appropriate error message\n     - Terminate the indexing process\n\n3. Business Rule Processing\n   - Check if search indexing is enabled in the system\n     - IF search indexing is disabled THEN\n       - Log information about skipped indexing\n       - Exit the process successfully without indexing\n   - Check if the post is eligible for indexing\n     - IF post is in a forum that should not be indexed THEN\n       - Skip the indexing process\n       - Log information about skipped indexing\n       - Exit the process successfully\n   - Check if the search index directory is accessible\n     - IF directory is not accessible THEN\n       - Log error about inaccessible index directory\n       - Terminate the indexing process with appropriate error\n   - Check if there are any existing lock files on the index\n     - IF lock file exists THEN\n       - Attempt to remove the lock file\n       - IF lock removal fails THEN\n         - Log error about locked index\n         - Terminate the indexing process with appropriate error\n\n4. Core Operation Execution\n   - Create a document for indexing\n     - Extract post ID and store it as a keyword field\n     - Extract forum ID and store it as a keyword field\n     - Extract topic ID and store it as a keyword field\n     - Extract user ID and store it as a keyword field\n     - Format and store the post creation date\n     - Combine post subject and text for content indexing\n   - Add the document to the search index\n     - Acquire synchronization lock to prevent concurrent modifications\n     - Open the index writer\n     - Add the document to the index\n     - IF the number of documents reaches optimization threshold THEN\n       - Perform index optimization\n     - Flush and close the index writer\n   - Update related index statistics\n     - Increment the count of indexed documents\n     - Update last indexing timestamp\n\n5. Response Generation\n   - Notify registered listeners about the new indexed document\n   - IF indexing was successful THEN\n     - Log successful indexing operation\n     - Return success status\n   - ELSE\n     - Log details about indexing failure\n     - Return failure status with error information",
    "databaseEntities": [
      "jforum_posts",
      "jforum_posts_text",
      "jforum_forums",
      "jforum_topics",
      "jforum_users"
    ],
    "validationRules": [
      "Post object must not be null",
      "Post ID must be a positive integer",
      "Forum ID must be a positive integer",
      "Topic ID must be a positive integer",
      "User ID must be a positive integer",
      "Post subject must not be null",
      "Post text must not be null",
      "Search indexing must be enabled in system settings",
      "Search index directory must be accessible",
      "Index must not be locked by another process"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Post": {
        "id": "number",
        "forumId": "number",
        "topicId": "number",
        "userId": "number",
        "time": "date",
        "subject": "string",
        "text": "string"
      }
    }
  },
  {
    "featureName": "UpdatePostIndex",
    "description": "Updates the search index for a modified forum post.",
    "inputValues": [
      "post-object-Post"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the modified post object containing:\n     a. Post ID (mandatory)\n     b. Forum ID (mandatory)\n     c. Topic ID (mandatory)\n     d. User ID (mandatory)\n     e. Post date/time (mandatory)\n     f. Post subject (mandatory)\n     g. Post text content (mandatory)\n\n2. Data Validation:\n   - Validate post object completeness:\n     a. Verify post ID is present and valid\n        IF post ID is missing or invalid THEN\n          Generate error message: \"Invalid post identifier\"\n          Exit process\n        END IF\n     b. Verify forum ID is present and valid\n        IF forum ID is missing or invalid THEN\n          Generate error message: \"Invalid forum identifier\"\n          Exit process\n        END IF\n     c. Verify topic ID is present and valid\n        IF topic ID is missing or invalid THEN\n          Generate error message: \"Invalid topic identifier\"\n          Exit process\n        END IF\n     d. Verify user ID is present and valid\n        IF user ID is missing or invalid THEN\n          Generate error message: \"Invalid user identifier\"\n          Exit process\n        END IF\n     e. Verify post date/time is present\n        IF post date/time is missing THEN\n          Generate error message: \"Missing post timestamp\"\n          Exit process\n        END IF\n     f. Verify post subject and text are not empty\n        IF post subject AND text are both empty THEN\n          Generate error message: \"Post must contain subject or content\"\n          Exit process\n        END IF\n\n3. Business Rule Processing:\n   - Check if search indexing is enabled\n     IF search indexing is disabled THEN\n       Log information: \"Search indexing is disabled, skipping index update\"\n       Exit process with success status\n     END IF\n   - Check if post is in an indexable state\n     IF post is marked as not indexable THEN\n       Log information: \"Post is marked as not indexable, skipping index update\"\n       Exit process with success status\n     END IF\n   - Check if post belongs to a restricted forum\n     IF post's forum is restricted from search indexing THEN\n       Log information: \"Post belongs to a restricted forum, skipping index update\"\n       Exit process with success status\n     END IF\n   - Check if search index is locked\n     IF index is locked THEN\n       Attempt to remove lock\n       IF lock removal fails THEN\n         Generate error message: \"Search index is currently locked\"\n         Exit process\n       END IF\n     END IF\n\n4. Core Operation Execution:\n   - Acquire exclusive lock on search index to prevent concurrent modifications\n   - Remove existing document for this post from the index\n     a. Locate document using post ID as unique identifier\n     b. Delete document if found\n     c. Log deletion operation\n   - Create new document for the post\n     a. Extract required fields from post object\n     b. Format date/time according to system standards\n     c. Combine subject and text for content indexing\n     d. Create document with all required fields\n   - Add new document to search index\n     a. Add document to index\n     b. Check if index optimization is needed\n        IF document count threshold reached THEN\n          Perform index optimization\n          Log optimization completion\n        END IF\n     c. Commit changes to ensure durability\n   - Release exclusive lock on search index\n   - Notify observers about index update\n     FOR EACH registered observer DO\n       Send notification about updated document\n     END FOR\n\n5. Response Generation:\n   - Generate success response\n     a. Include post identifier\n     b. Include timestamp of indexing operation\n     c. Include status message: \"Post successfully indexed\"\n   - In case of failure:\n     a. Include error details\n     b. Include suggestion for retry if appropriate\n     c. Log detailed error information for administrators",
    "databaseEntities": [
      "jforum_posts",
      "jforum_posts_text",
      "jforum_forums",
      "jforum_topics"
    ],
    "validationRules": [
      "Post ID must be a valid positive integer",
      "Forum ID must be a valid positive integer",
      "Topic ID must be a valid positive integer",
      "User ID must be a valid positive integer",
      "Post must have a timestamp",
      "Post must have either subject or text content",
      "Post must belong to an indexable forum",
      "Search index must not be locked or lock must be removable"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Post": {
        "type": "object",
        "properties": {
          "id": {
            "type": "number",
            "description": "Unique identifier for the post"
          },
          "forumId": {
            "type": "number",
            "description": "Identifier of the forum containing the post"
          },
          "topicId": {
            "type": "number",
            "description": "Identifier of the topic containing the post"
          },
          "userId": {
            "type": "number",
            "description": "Identifier of the user who created the post"
          },
          "time": {
            "type": "date",
            "description": "Date and time when the post was created"
          },
          "subject": {
            "type": "string",
            "description": "Subject or title of the post"
          },
          "text": {
            "type": "string",
            "description": "Main content of the post"
          }
        },
        "required": [
          "id",
          "forumId",
          "topicId",
          "userId",
          "time",
          "subject",
          "text"
        ]
      }
    }
  },
  {
    "featureName": "DeletePostIndex",
    "description": "Removes a post from the search index to ensure it no longer appears in search results.",
    "inputValues": [
      "postId-number-Post"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the following required inputs:\n     a. postId (number, mandatory): The unique identifier of the post to be removed from the search index\n\n2. Data Validation:\n   - Validate the post identifier:\n     a. Check if postId is provided\n        IF postId is missing or null THEN\n          Return error: \"Post ID is required\"\n     b. Verify postId is a valid number\n        IF postId is not a valid number THEN\n          Return error: \"Post ID must be a valid number\"\n     c. Verify postId is positive\n        IF postId is less than or equal to 0 THEN\n          Return error: \"Post ID must be a positive number\"\n\n3. Business Rule Processing:\n   - Verify post exists in the system:\n     a. Check if the post with the given ID exists in the database\n        IF post does not exist THEN\n          Return error: \"Post not found\"\n     b. Check if the post is already indexed\n        IF post is not in the search index THEN\n          Return notification: \"Post is not currently indexed\"\n          Exit process successfully\n   - Verify search system availability:\n     a. Check if the search index is accessible\n        IF search index is not accessible THEN\n          Return error: \"Search index is currently unavailable\"\n\n4. Core Operation Execution:\n   - Remove the post from the search index:\n     a. Acquire synchronization lock to prevent concurrent modifications\n     b. Open the search index for reading\n     c. Locate the document in the index using the post ID as the search term\n     d. Delete the document from the index\n     e. Release resources and close the index reader\n     f. IF deletion fails THEN\n          Log the error details\n          Return error: \"Failed to remove post from search index\"\n     g. Update any related caches or in-memory structures\n        IF cache update fails THEN\n          Log warning but continue process\n\n5. Response Generation:\n   - Generate success response:\n     a. Create a success message indicating the post was successfully removed from the search index\n     b. Include the post ID in the response\n     c. Return success status with confirmation message\n     d. Include timestamp of when the deletion occurred",
    "databaseEntities": [
      "jforum_posts",
      "jforum_posts_text",
      "jforum_topics",
      "jforum_forums"
    ],
    "validationRules": [
      "Post ID must be provided",
      "Post ID must be a valid positive number",
      "Post must exist in the database",
      "Search index must be accessible for modification"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Post": {
        "id": "number",
        "forumId": "number",
        "topicId": "number",
        "userId": "number",
        "subject": "string",
        "text": "string",
        "time": "date"
      }
    }
  },
  {
    "featureName": "FlushRAMDirectory",
    "description": "Commits indexed documents from RAM to persistent storage.",
    "inputValues": [],
    "businessLogic": "1. Input Collection:\n   - No explicit user inputs required\n   - System-generated trigger based on threshold or manual call\n\n2. Data Validation:\n   - Verify RAM directory exists and is accessible\n   - Check if RAM writer is properly initialized\n   - Validate that persistent storage directory is available\n   - Ensure analyzer is properly configured\n\n3. Business Rule Processing:\n   - Check if RAM directory contains any documents to flush\n   - IF RAM directory is empty THEN\n      - Skip the flush operation\n      - Return success with no changes made\n   - Verify system has sufficient resources to perform the operation\n   - Check if any concurrent indexing operations are in progress\n   - IF concurrent operations detected THEN\n      - Apply synchronization mechanism to prevent conflicts\n\n4. Core Operation Execution:\n   - Acquire synchronization lock to prevent concurrent modifications\n   - Initialize persistent storage writer\n   - Copy all documents from RAM directory to persistent storage\n   - Optimize the persistent index for better search performance\n   - Close the persistent storage writer after flushing\n   - Recreate empty RAM directory and writer for future operations\n   - Release synchronization lock\n   - Notify any registered listeners about the new documents added\n\n5. Response Generation:\n   - IF operation completes successfully THEN\n      - Return success status\n      - Include statistics about number of documents flushed\n   - IF any errors occur during the process THEN\n      - Generate appropriate error message\n      - Include details about the failure point\n      - Provide recovery suggestions if applicable",
    "databaseEntities": [
      "jforum_posts",
      "jforum_topics",
      "jforum_forums"
    ],
    "validationRules": [
      "RAM directory must be properly initialized before flushing",
      "Persistent storage directory must be accessible",
      "Synchronization lock must be acquired before flushing",
      "All documents must be successfully transferred to persistent storage",
      "RAM directory must be recreated after flushing"
    ],
    "dbSeedingOperations": [],
    "schema": {}
  },
  {
    "featureName": "WatchNewDocumentAdded",
    "description": "Registers listeners to be notified when new documents are indexed.",
    "inputValues": [
      "listener-object-NewDocumentAdded"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the NewDocumentAdded listener object\n     - This listener must implement the required notification interface\n     - The listener is mandatory for registration\n\n2. Data Validation:\n   - Validate the listener object\n     - Verify the listener is not null\n     - Ensure the listener implements the required notification methods\n     - Check if the listener has a valid notification handler\n   - IF validation fails THEN\n     - Generate appropriate error message\n     - Abort the registration process\n\n3. Business Rule Processing:\n   - Check if the system is in a valid state for listener registration\n     - Verify the indexing system is properly initialized\n     - Ensure the notification mechanism is active\n   - Verify listener registration constraints\n     - Check if there's a maximum allowed number of listeners\n     - Determine if duplicate listeners are allowed\n     - IF duplicate listeners are not allowed THEN\n       - Check if the listener is already registered\n       - IF listener already exists THEN\n         - Generate duplicate listener error\n         - Abort registration process\n\n4. Core Operation Execution:\n   - Add the listener to the notification list\n     - Store reference to the listener in the notification registry\n     - Update internal counters for registered listeners\n     - Set up any required context information for the listener\n   - Initialize listener with current system state if needed\n     - Provide initial state information to the listener\n     - Set up any required resources for the listener\n\n5. Response Generation:\n   - Confirm successful registration\n     - Return registration status to the caller\n     - Include listener identification information\n   - Provide usage instructions if applicable\n     - Information about when notifications will occur\n     - Details about notification payload format",
    "databaseEntities": [
      "jforum_posts"
    ],
    "validationRules": [
      "Listener object must not be null",
      "Listener must implement the NewDocumentAdded interface",
      "Indexing system must be properly initialized before registering listeners"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "NewDocumentAdded": {
        "type": "object",
        "properties": {
          "newDocumentAdded": {
            "type": "method",
            "description": "Method called when new documents are added to the index"
          }
        },
        "required": [
          "newDocumentAdded"
        ]
      }
    }
  },
  {
    "featureName": "InitializeSearchManager",
    "description": "Initializes the search manager with analyzer and directory settings.",
    "inputValues": [
      "analyzerClassName-string-AnalyzerConfig",
      "indexDirectoryPath-string-DirectoryConfig",
      "searchSettings-object-SearchSettings"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect analyzerClassName (mandatory): The fully qualified class name of the analyzer to use\n   - Collect indexDirectoryPath (mandatory): The file system path where search indexes will be stored\n   - Collect searchSettings (optional): Configuration settings for the search functionality\n      - If not provided, use system default settings\n\n2. Data Validation:\n   - Validate analyzerClassName:\n      - Verify it is not empty or null\n      - Verify it represents a valid and accessible class\n      - Verify the class implements the required analyzer interface\n      - IF validation fails, THEN generate appropriate error message\n   - Validate indexDirectoryPath:\n      - Verify it is not empty or null\n      - Verify the path exists or can be created\n      - Verify the system has read/write permissions to the path\n      - IF validation fails, THEN generate appropriate error message\n   - Validate searchSettings if provided:\n      - Verify all required properties are present\n      - Verify property values are within acceptable ranges\n      - IF validation fails, THEN generate appropriate error message\n\n3. Business Rule Processing:\n   - Check if search functionality is enabled in the system\n      - IF search is disabled, THEN exit initialization process\n   - Check for existing lock files in the index directory\n      - IF lock files exist, THEN determine if they should be removed\n         - Check if the lock is stale (system crash or improper shutdown)\n         - IF lock is stale, THEN mark for removal\n   - Verify system resources are sufficient for search operations\n      - Check available disk space for index storage\n      - Check memory allocation for search operations\n      - IF resources are insufficient, THEN generate warning or error\n\n4. Core Operation Execution:\n   - Create analyzer instance:\n      - Instantiate the analyzer class using the provided class name\n      - Configure the analyzer with any provided settings\n   - Initialize search settings:\n      - Create settings object with the instantiated analyzer\n      - Configure the file system directory using the provided path\n   - Remove any stale lock files if identified in step 3\n   - Initialize the indexer component:\n      - Create indexer with the configured settings\n      - Set up document processing rules\n   - Initialize the search component:\n      - Create search processor with the configured settings\n      - Create content collector for search results\n   - Connect indexer and search components:\n      - Set up notification system for new document additions\n   - Store settings in global configuration for system-wide access\n\n5. Response Generation:\n   - IF initialization completes successfully:\n      - Return success status\n      - Provide reference to the initialized search manager\n   - IF initialization fails at any point:\n      - Generate detailed error information\n      - Include specific component that failed\n      - Include troubleshooting suggestions\n      - Return failure status with error details",
    "databaseEntities": [
      "jforum_posts",
      "jforum_posts_text"
    ],
    "validationRules": [
      "Analyzer class must exist and be instantiable",
      "Index directory path must be valid and accessible",
      "System must have read/write permissions to the index directory",
      "Lock files must be checked and removed if stale"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "SearchSettings": {
        "type": "object",
        "properties": {
          "analyzer": {
            "type": "object",
            "description": "The text analyzer configuration"
          },
          "directory": {
            "type": "object",
            "description": "The directory configuration for index storage"
          },
          "maxResults": {
            "type": "number",
            "description": "Maximum number of search results to return"
          },
          "resultCacheSize": {
            "type": "number",
            "description": "Size of the search result cache"
          }
        }
      }
    }
  },
  {
    "featureName": "RemoveLuceneLockFile",
    "description": "Removes index lock files to prevent access conflicts in the search system.",
    "inputValues": [
      "indexDirectory-string-Directory"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect indexDirectory (string, mandatory): The directory path where the index files are stored\n   - System will use default directory if not explicitly provided\n\n2. Data Validation:\n   - Validate indexDirectory existence:\n     a. Check if the directory path exists\n     b. Verify the system has read/write permissions to the directory\n     c. IF directory does not exist or is not accessible, THEN generate appropriate error message\n   - Validate index structure:\n     a. Verify the directory contains valid index files\n     b. IF directory does not contain valid index structure, THEN log warning but continue process\n\n3. Business Rule Processing:\n   - Check lock status:\n     a. Determine if the index is currently locked\n     b. IF index is not locked, THEN no action is needed, proceed to success response\n     c. IF index is locked, THEN proceed with lock removal\n   - Verify system state:\n     a. Check if any indexing operations are currently in progress\n     b. IF operations are in progress, THEN evaluate if force unlock is appropriate\n     c. Log the lock removal attempt with reason\n\n4. Core Operation Execution:\n   - Lock file identification:\n     a. Locate the lock file in the index directory\n     b. Verify the lock file is a valid index lock and not another file type\n   - Lock removal process:\n     a. Attempt to unlock the index\n     b. Handle potential file system errors during unlock operation\n     c. IF unlock fails, THEN retry with escalated permissions if possible\n     d. IF unlock still fails after retry, THEN prepare detailed error information\n   - Post-removal verification:\n     a. Verify the lock has been successfully removed\n     b. Update system state to reflect unlocked status\n     c. IF verification fails, THEN log the issue and prepare error response\n\n5. Response Generation:\n   - Success response:\n     a. Generate confirmation that lock file was successfully removed\n     b. Include timestamp of the operation\n     c. Provide information about the unlocked index\n   - Error response:\n     a. Generate detailed error information if lock removal failed\n     b. Include specific error codes and messages\n     c. Provide troubleshooting suggestions based on error type\n     d. Include system administrator contact information if applicable",
    "databaseEntities": [],
    "validationRules": [
      "Index directory must exist and be accessible",
      "System must have appropriate permissions to modify the index directory",
      "Lock file must be a valid index lock file",
      "No active indexing operations should be in progress during lock removal"
    ],
    "dbSeedingOperations": [],
    "schema": {}
  },
  {
    "featureName": "SearchPosts",
    "description": "Performs a search against indexed forum posts using provided search arguments.",
    "inputValues": [
      "keywords-string-SearchArgs",
      "forumIds-number-SearchArgs",
      "startDate-date-SearchArgs",
      "endDate-date-SearchArgs",
      "searchType-string-SearchArgs",
      "orderBy-string-SearchArgs",
      "searchIn-object-SearchOptions"
    ],
    "businessLogic": "1. Input Collection:\n   1.1. Collect search parameters from user:\n       - keywords: The text to search for (mandatory)\n       - forumIds: List of forum IDs to search within (optional)\n       - startDate: Beginning date range for posts (optional)\n       - endDate: Ending date range for posts (optional)\n       - searchType: Type of search to perform (optional, default: 'all words')\n       - orderBy: Result ordering preference (optional, default: 'relevance')\n       - searchIn: Options for where to search (optional)\n          - title: Whether to search in post titles (default: true)\n          - content: Whether to search in post content (default: true)\n\n2. Data Validation:\n   2.1. Validate keywords input:\n       - IF keywords is empty or null THEN\n           - Return error message: \"Search keywords cannot be empty\"\n       - IF keywords length is less than minimum allowed characters THEN\n           - Return error message: \"Search keywords must be at least [minimum] characters long\"\n       - IF keywords contains invalid characters THEN\n           - Return error message: \"Search keywords contain invalid characters\"\n\n   2.2. Validate date range:\n       - IF both startDate and endDate are provided THEN\n           - IF startDate is after endDate THEN\n               - Return error message: \"Start date cannot be after end date\"\n\n   2.3. Validate forum selection:\n       - IF forumIds is provided THEN\n           - FOR EACH forumId in forumIds DO\n               - IF forumId does not exist in the system THEN\n                   - Remove invalid forumId from the list\n           - IF all forumIds were invalid THEN\n               - Return error message: \"No valid forums selected for search\"\n\n   2.4. Validate search options:\n       - IF searchType is provided THEN\n           - IF searchType is not one of the valid options (all words, any words, exact phrase) THEN\n               - Set searchType to default value\n       - IF orderBy is provided THEN\n           - IF orderBy is not one of the valid options (relevance, date) THEN\n               - Set orderBy to default value\n\n3. Business Rule Processing:\n   3.1. Check user permissions:\n       - IF user is not logged in AND search requires authentication THEN\n           - Return error message: \"You must be logged in to perform a search\"\n       - IF user is logged in THEN\n           - FOR EACH forumId in forumIds DO\n               - IF user does not have access to the forum THEN\n                   - Remove forumId from the list\n\n   3.2. Check search frequency limits:\n       - IF user has performed a search within the cooldown period THEN\n           - Return error message: \"Please wait [remaining time] before performing another search\"\n\n   3.3. Prepare search context:\n       - Create search arguments object with validated parameters\n       - Set default values for any missing optional parameters\n       - Determine search scope based on user's forum access permissions\n\n4. Core Operation Execution:\n   4.1. Prepare search index access:\n       - Initialize the search index reader\n       - Prepare query based on search parameters\n       - Apply forum filters to the query\n       - Apply date range filters to the query\n\n   4.2. Execute search operation:\n       - Perform the search against the index\n       - Collect matching document references\n       - Calculate relevance scores for results\n       - Sort results according to orderBy parameter\n\n   4.3. Process search results:\n       - Retrieve post details for each matching document\n       - Filter results based on user's access permissions\n       - Paginate results if necessary\n       - Highlight matching keywords in result snippets\n\n   4.4. Handle search exceptions:\n       - IF index is corrupted or unavailable THEN\n           - Log error details\n           - Return error message: \"Search is temporarily unavailable\"\n       - IF search times out THEN\n           - Log timeout information\n           - Return error message: \"Search operation timed out. Please refine your search criteria.\"\n\n5. Response Generation:\n   5.1. Prepare success response:\n       - Format the list of matching posts\n       - Include post metadata (author, date, forum, etc.)\n       - Include highlighted snippets showing keyword context\n       - Include pagination information\n       - Include search statistics (total matches, search time)\n\n   5.2. Prepare error response:\n       - IF any errors occurred during search THEN\n           - Include specific error message\n           - Include suggestions for improving search\n\n   5.3. Return search results to user:\n       - Display formatted results\n       - Provide options for refining search\n       - Provide links to matching posts",
    "databaseEntities": [
      "jforum_posts",
      "jforum_posts_text",
      "jforum_topics",
      "jforum_forums",
      "jforum_users"
    ],
    "validationRules": [
      "Search keywords cannot be empty",
      "Search keywords must meet minimum length requirements",
      "Date range must be valid (start date before end date)",
      "User must have permission to access selected forums",
      "Search frequency must not exceed system limits",
      "At least one valid forum must be selected if forum filtering is used",
      "Search indexing must be enabled in system configuration"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "SearchOptions": {
        "type": "object",
        "properties": {
          "title": {
            "type": "boolean",
            "description": "Whether to search in post titles"
          },
          "content": {
            "type": "boolean",
            "description": "Whether to search in post content"
          }
        }
      },
      "SearchResult": {
        "type": "object",
        "properties": {
          "results": {
            "type": "array",
            "description": "List of matching posts"
          },
          "totalRecords": {
            "type": "number",
            "description": "Total number of matching records"
          }
        }
      }
    }
  },
  {
    "featureName": "ReindexSearchContent",
    "description": "Reindexes forum content in the search engine with options for full or incremental updates.",
    "inputValues": [
      "fromDate-date-ReindexCriteria",
      "toDate-date-ReindexCriteria",
      "firstPostId-number-ReindexCriteria",
      "lastPostId-number-ReindexCriteria",
      "filterByMessage-boolean-ReindexCriteria",
      "avoidDuplicatedRecords-boolean-ReindexCriteria",
      "recreateIndex-boolean-ReindexCriteria",
      "backgroundProcess-boolean-ReindexCriteria"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect reindexing criteria:\n     a. fromDate (optional): The starting date for content to be reindexed\n     b. toDate (optional): The ending date for content to be reindexed\n     c. firstPostId (optional): The starting post ID for reindexing\n     d. lastPostId (optional): The ending post ID for reindexing\n     e. filterByMessage (mandatory): Flag to determine if filtering by post ID range\n     f. avoidDuplicatedRecords (mandatory): Flag to prevent reindexing already indexed content\n     g. recreateIndex (mandatory): Flag to determine if the index should be recreated from scratch\n     h. backgroundProcess (mandatory): Flag to determine if the process should run in the background\n\n2. Data Validation:\n   - Validate date range if provided:\n     a. IF fromDate is provided, ensure it is a valid date format\n     b. IF toDate is provided, ensure it is a valid date format\n     c. IF both fromDate and toDate are provided, ensure fromDate is before toDate\n   - Validate post ID range if provided:\n     a. IF firstPostId is provided, ensure it is a positive integer\n     b. IF lastPostId is provided, ensure it is a positive integer\n     c. IF both firstPostId and lastPostId are provided, ensure firstPostId is less than lastPostId\n   - Validate boolean flags:\n     a. Ensure filterByMessage is a boolean value\n     b. Ensure avoidDuplicatedRecords is a boolean value\n     c. Ensure recreateIndex is a boolean value\n     d. Ensure backgroundProcess is a boolean value\n\n3. Business Rule Processing:\n   - Check system state for reindexing:\n     a. IF another indexing process is already running, display warning message and abort\n     b. IF recreateIndex is true, verify write permissions to the index directory\n     c. Check available disk space for index creation\n   - Determine reindexing scope:\n     a. IF filterByMessage is true, use firstPostId and lastPostId to determine scope\n     b. IF filterByMessage is false, use fromDate and toDate to determine scope\n     c. IF no filters are provided, prepare for full reindexing of all content\n\n4. Core Operation Execution:\n   - Initialize reindexing process:\n     a. IF recreateIndex is true, create new empty index directory\n     b. Set up batch processing parameters (fetch count, etc.)\n     c. Set indexing status flag to indicate process is running\n   - Determine post range for processing:\n     a. IF filterByMessage is true, use provided firstPostId and lastPostId\n     b. ELSE determine firstPostId and lastPostId based on fromDate and toDate\n     c. Adjust firstPostId if it's less than the actual first post ID in the database\n   - Process posts in batches:\n     a. WHILE there are more posts to process:\n       i. Fetch next batch of posts within the current ID range\n       ii. FOR each post in the batch:\n           1. IF avoidDuplicatedRecords is true, check if post is already indexed\n           2. IF post is not already indexed or avoidDuplicatedRecords is false, index the post\n           3. Increment counter for processed posts\n       iii. Update firstPostId for next batch\n       iv. IF user cancels operation, set hasMorePosts to false and break loop\n   - Finalize indexing:\n     a. Flush any remaining documents in memory to the index\n     b. Set indexing status flag to indicate process is complete\n     c. Record performance metrics (total time, documents indexed)\n\n5. Response Generation:\n   - Generate success response:\n     a. Total number of documents indexed\n     b. Time taken for indexing process\n     c. Index status information\n   - Generate error response if applicable:\n     a. Error details and reason for failure\n     b. Suggestions for resolving the issue\n     c. Current state of the index",
    "databaseEntities": [
      "jforum_posts",
      "jforum_posts_text",
      "jforum_topics",
      "jforum_forums"
    ],
    "validationRules": [
      "If filtering by date, fromDate must be before toDate",
      "If filtering by post ID, firstPostId must be less than lastPostId",
      "Post IDs must be positive integers",
      "Date values must be in valid format",
      "Boolean flags must have valid boolean values",
      "System must not already be performing an indexing operation",
      "Sufficient disk space must be available for index creation",
      "Write permissions must exist for the index directory"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "ReindexCriteria": {
        "type": "object",
        "properties": {
          "fromDate": {
            "type": "date",
            "description": "Starting date for content to be reindexed"
          },
          "toDate": {
            "type": "date",
            "description": "Ending date for content to be reindexed"
          },
          "firstPostId": {
            "type": "number",
            "description": "Starting post ID for reindexing"
          },
          "lastPostId": {
            "type": "number",
            "description": "Ending post ID for reindexing"
          },
          "filterByMessage": {
            "type": "boolean",
            "description": "Flag to determine if filtering by post ID range"
          },
          "avoidDuplicatedRecords": {
            "type": "boolean",
            "description": "Flag to prevent reindexing already indexed content"
          },
          "recreateIndex": {
            "type": "boolean",
            "description": "Flag to determine if the index should be recreated from scratch"
          },
          "backgroundProcess": {
            "type": "boolean",
            "description": "Flag to determine if the process should run in the background"
          }
        }
      }
    }
  },
  {
    "featureName": "StartBackgroundIndexing",
    "description": "Initiates search indexing as a background process to avoid blocking the main application.",
    "inputValues": [
      "settings-object-LuceneSettings",
      "args-object-LuceneReindexArgs",
      "recreate-boolean-Boolean"
    ],
    "businessLogic": "1. Input Collection\n   - Collect LuceneSettings object containing indexing configuration\n   - Collect LuceneReindexArgs object containing indexing parameters\n   - Collect recreate flag (boolean) indicating whether to recreate the index\n   - System will use configuration values for batch size and index paths\n\n2. Data Validation\n   - Validate LuceneSettings object is properly initialized\n     * Verify index directory paths are valid\n     * Ensure write permissions exist for index locations\n   - Validate LuceneReindexArgs object\n     * Verify date ranges if filtering by date\n     * Verify post ID ranges if filtering by message\n   - Validate system resources\n     * Check available memory for indexing operations\n     * Verify disk space for index storage\n\n3. Business Rule Processing\n   - Check if indexing is already in progress\n     * IF another indexing process is running THEN\n       * Generate appropriate notification\n       * Exit the process\n     * ELSE\n       * Set indexing status flag to active\n   - Determine indexing approach based on parameters\n     * IF recreate flag is true THEN\n       * Plan for complete index recreation\n     * ELSE\n       * Plan for incremental index update\n   - Calculate resource requirements\n     * Estimate memory usage based on batch size\n     * Estimate disk space requirements\n\n4. Core Operation Execution\n   - Create background thread for indexing process\n     * Initialize new thread with indexing task\n     * Set thread priority to minimize impact on main application\n   - Start background indexing process\n     * Launch thread to execute independently\n     * Store thread reference for status checking\n   - Set system status indicators\n     * Update system configuration to indicate indexing is in progress\n     * Record start time of indexing process\n   - Implement monitoring mechanism\n     * Create status tracking for progress reporting\n     * Set up cancellation capability\n\n5. Response Generation\n   - Generate success response\n     * Confirm background process has started\n     * Provide process identifier for status checking\n   - Provide estimated completion information\n     * Include approximate time to completion if calculable\n     * Include number of records to be processed\n   - Include status checking instructions\n     * How to check indexing progress\n     * How to cancel indexing if needed",
    "databaseEntities": [
      "jforum_posts",
      "jforum_posts_text"
    ],
    "validationRules": [
      "Indexing process must not already be running",
      "Index directory must be writable",
      "Sufficient disk space must be available for index creation",
      "Date ranges must be valid if filtering by date",
      "Post ID ranges must be valid if filtering by message"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "LuceneSettings": {
        "type": "object",
        "properties": {
          "indexDirectory": {
            "type": "string",
            "description": "Path to the index directory"
          },
          "writeDirectory": {
            "type": "string",
            "description": "Path to the write directory for index creation"
          }
        }
      },
      "LuceneReindexArgs": {
        "type": "object",
        "properties": {
          "fromDate": {
            "type": "date",
            "description": "Start date for filtering posts to index"
          },
          "toDate": {
            "type": "date",
            "description": "End date for filtering posts to index"
          },
          "firstPostId": {
            "type": "number",
            "description": "First post ID to include in indexing"
          },
          "lastPostId": {
            "type": "number",
            "description": "Last post ID to include in indexing"
          },
          "filterByMessage": {
            "type": "boolean",
            "description": "Whether to filter by message ID range"
          },
          "avoidDuplicatedRecords": {
            "type": "boolean",
            "description": "Whether to check for and avoid duplicate records"
          }
        }
      }
    }
  },
  {
    "featureName": "RecreateSearchIndex",
    "description": "Creates a new search index directory when performing a full reindex operation.",
    "inputValues": [
      "settings-object-LuceneSettings",
      "args-object-LuceneReindexArgs",
      "recreate-boolean-Boolean"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect LuceneSettings object containing index configuration\n   - Collect LuceneReindexArgs object containing reindexing parameters\n   - Collect recreate flag (boolean) to determine if index should be recreated\n   - System will use configuration values for index paths and fetch count\n\n2. Data Validation:\n   - Validate LuceneSettings object is properly initialized\n     * Ensure index directory paths are valid\n     * Verify write permissions to index locations\n   - Validate LuceneReindexArgs object\n     * If filtering by date, ensure fromDate and toDate are valid\n     * If filtering by message, ensure firstPostId and lastPostId are valid\n   - Verify recreate flag is a valid boolean value\n\n3. Business Rule Processing:\n   - Check if system is already performing indexing operation\n     * IF system is already indexing, THEN prevent duplicate indexing processes\n   - Determine indexing mode (background or foreground)\n     * IF background mode requested, THEN prepare thread for asynchronous processing\n   - Calculate indexing scope based on provided arguments\n     * IF filtering by message, THEN use firstPostId and lastPostId from args\n     * IF filtering by date, THEN query for post IDs within date range\n\n4. Core Operation Execution:\n   - IF recreate flag is true, THEN:\n     * Create new index directory at configured location\n     * Initialize empty index structure\n   - Set indexing status flag to indicate process is running\n   - Initialize data access components for retrieving posts\n   - Calculate post ID range for processing\n     * Determine first post ID based on filter criteria\n     * Determine last post ID based on filter criteria\n   - Process posts in batches:\n     * WHILE more posts exist to process:\n       * Fetch next batch of posts (limited by configured fetch count)\n       * FOR each post in batch:\n         * IF avoiding duplicates AND post already indexed, THEN skip post\n         * Add post content to search index\n         * Update progress counters\n       * IF indexing canceled, THEN exit processing loop\n   - Flush any remaining documents to the index\n   - Update system status to indicate indexing is complete\n\n5. Response Generation:\n   - Record total indexing time and document count\n   - IF any errors occurred during indexing:\n     * Generate error response with details about failure point\n     * Ensure index is left in consistent state\n   - IF indexing completed successfully:\n     * Generate success response with statistics\n     * Include total documents indexed\n     * Include total processing time",
    "databaseEntities": [
      "jforum_posts",
      "jforum_posts_text"
    ],
    "validationRules": [
      "Index directory path must be valid and writable",
      "Post ID ranges must be valid integers",
      "Date ranges must be valid date formats if filtering by date",
      "System must not already be performing an indexing operation",
      "Fetch count must be a positive integer"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "LuceneSettings": {
        "properties": {
          "indexDirectory": {
            "type": "string",
            "description": "Path to the search index directory"
          },
          "writeEnabled": {
            "type": "boolean",
            "description": "Whether writing to the index is enabled"
          }
        }
      },
      "LuceneReindexArgs": {
        "properties": {
          "fromDate": {
            "type": "date",
            "description": "Start date for filtering posts by date"
          },
          "toDate": {
            "type": "date",
            "description": "End date for filtering posts by date"
          },
          "firstPostId": {
            "type": "number",
            "description": "First post ID when filtering by message"
          },
          "lastPostId": {
            "type": "number",
            "description": "Last post ID when filtering by message"
          },
          "filterByMessage": {
            "type": "boolean",
            "description": "Whether to filter by message IDs instead of dates"
          },
          "avoidDuplicatedRecords": {
            "type": "boolean",
            "description": "Whether to check for and skip already indexed posts"
          }
        }
      }
    }
  },
  {
    "featureName": "SearchForumContent",
    "description": "Searches forum content based on keywords, forum ID, and date range criteria.",
    "inputValues": [
      "keywords-string-SearchCriteria",
      "forumId-number-Forum",
      "fromDate-date-SearchCriteria",
      "toDate-date-SearchCriteria",
      "matchAllKeywords-boolean-SearchCriteria",
      "orderBy-string-SearchCriteria",
      "orderDir-string-SearchCriteria"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the following inputs:\n     a. keywords (string, mandatory): Search terms entered by the user\n     b. forumId (number, optional): Specific forum to search within\n     c. fromDate (date, optional): Start date for the search range\n     d. toDate (date, optional): End date for the search range\n     e. matchAllKeywords (boolean, optional): Whether to match all keywords (true) or any keyword (false)\n     f. orderBy (string, optional): Field to sort results by (default: relevance, alternative: time)\n     g. orderDir (string, optional): Direction of sorting (ASC or DESC)\n\n2. Data Validation:\n   a. Keywords validation:\n      - IF keywords is empty or null THEN\n        * Return error message indicating keywords are required\n      - IF keywords contains only whitespace THEN\n        * Return error message indicating valid keywords are required\n      - Sanitize keywords to prevent any malicious input\n\n   b. Forum ID validation:\n      - IF forumId is provided THEN\n        * Verify forumId exists in the system\n        * Verify user has permission to access the specified forum\n        * IF forum does not exist or user lacks permission THEN\n          - Return appropriate error message\n\n   c. Date range validation:\n      - IF fromDate is provided THEN\n        * Verify fromDate is a valid date format\n        * IF toDate is not provided THEN\n          - Set toDate to current date\n      - IF both fromDate and toDate are provided THEN\n        * Verify fromDate is before or equal to toDate\n        * IF fromDate is after toDate THEN\n          - Return error message for invalid date range\n\n   d. Order parameters validation:\n      - IF orderBy is provided THEN\n        * Verify orderBy is one of the allowed values (relevance, time)\n        * IF invalid THEN\n          - Set to default (relevance)\n      - IF orderDir is provided THEN\n        * Verify orderDir is one of the allowed values (ASC, DESC)\n        * IF invalid THEN\n          - Set to default (DESC)\n\n3. Business Rule Processing:\n   a. Permission verification:\n      - Verify user has general search permissions\n      - IF user does not have search permissions THEN\n        * Return error message indicating insufficient permissions\n\n   b. Search scope determination:\n      - IF forumId is provided THEN\n        * Limit search to the specified forum\n      - ELSE\n        * Search across all forums the user has access to\n\n   c. Keyword processing:\n      - Analyze and tokenize keywords for effective searching\n      - Remove common words (stop words) if necessary\n      - IF matchAllKeywords is true THEN\n        * Configure search to require all keywords\n      - ELSE\n        * Configure search to match any keyword\n\n4. Core Operation Execution:\n   a. Construct search query:\n      - Build query criteria based on validated inputs\n      - Apply forum filter if forumId is specified\n      - Apply keyword search conditions\n      - Apply date range filter if dates are specified\n\n   b. Execute search operation:\n      - Perform search using constructed query\n      - Apply sorting based on orderBy and orderDir parameters\n      - Track search performance metrics\n\n   c. Process search results:\n      - Collect matching content items\n      - Extract relevant information from each result\n      - Format results for display\n      - IF no results found THEN\n        * Prepare empty result set with appropriate message\n\n5. Response Generation:\n   a. Success response:\n      - Return search results containing:\n        * List of matching content items with:\n          - Post/topic title\n          - Content snippet showing matched keywords\n          - Author information\n          - Forum information\n          - Post date\n          - Relevance score or ranking\n        * Total count of matching items\n        * Pagination information if applicable\n\n   b. Error response:\n      - Return appropriate error message based on validation failures\n      - Include suggestions for improving search if no results found",
    "databaseEntities": [
      "jforum_forums",
      "jforum_topics",
      "jforum_posts",
      "jforum_posts_text",
      "jforum_users"
    ],
    "validationRules": [
      "Keywords must not be empty",
      "Forum ID must exist in the system if provided",
      "From date must be before or equal to to date if both are provided",
      "Order by parameter must be either 'relevance' or 'time'",
      "Order direction must be either 'ASC' or 'DESC'",
      "User must have permission to search forums",
      "User must have permission to access the specified forum if forum ID is provided"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "SearchCriteria": {
        "type": "object",
        "properties": {
          "keywords": {
            "type": "string",
            "description": "Search terms entered by the user"
          },
          "forumId": {
            "type": "number",
            "description": "ID of the specific forum to search within"
          },
          "fromDate": {
            "type": "string",
            "format": "date",
            "description": "Start date for the search range"
          },
          "toDate": {
            "type": "string",
            "format": "date",
            "description": "End date for the search range"
          },
          "matchAllKeywords": {
            "type": "boolean",
            "description": "Whether to match all keywords (true) or any keyword (false)"
          },
          "orderBy": {
            "type": "string",
            "enum": [
              "relevance",
              "time"
            ],
            "description": "Field to sort results by"
          },
          "orderDir": {
            "type": "string",
            "enum": [
              "ASC",
              "DESC"
            ],
            "description": "Direction of sorting"
          }
        },
        "required": [
          "keywords"
        ]
      },
      "Forum": {
        "type": "object",
        "properties": {
          "id": {
            "type": "number",
            "description": "Unique identifier for the forum"
          },
          "name": {
            "type": "string",
            "description": "Name of the forum"
          }
        }
      }
    }
  },
  {
    "featureName": "FindDocumentByPostId",
    "description": "Retrieves a specific document from the search index using a post ID.",
    "inputValues": [
      "postId-number-Post"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect postId (number, mandatory) from the request\n   - No optional fields are required\n   - No default values are needed\n\n2. Data Validation:\n   - Validate postId:\n     a. Check if postId is provided\n     b. Verify postId is a positive integer\n     c. If validation fails, prepare appropriate error message\n\n3. Business Rule Processing:\n   - Check if search index is accessible\n   - Verify search functionality is properly initialized\n   - IF search index is not available THEN\n     a. Log the error\n     b. Prepare system unavailable message\n     c. Return error response\n\n4. Core Operation Execution:\n   - Create a search term using the provided postId\n   - Execute search operation against the index\n   - IF search returns results THEN\n     a. Retrieve the first document from results (as postId should be unique)\n     b. Extract document details from the search result\n   - ELSE\n     a. Set document result to null\n     b. Prepare not found message\n\n5. Response Generation:\n   - IF document was found THEN\n     a. Format document data for response\n     b. Include all relevant document fields\n     c. Return success response with document data\n   - ELSE\n     a. Return appropriate not found response\n     b. Include search parameters in response for debugging\n     c. Suggest alternative actions to the user",
    "databaseEntities": [
      "jforum_posts",
      "jforum_posts_text"
    ],
    "validationRules": [
      "Post ID must be a positive integer",
      "Post ID must reference an existing post in the system",
      "Search index must be available and accessible"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Document": {
        "type": "object",
        "properties": {
          "postId": {
            "type": "number",
            "description": "Unique identifier of the post"
          },
          "content": {
            "type": "string",
            "description": "Content of the post"
          },
          "forumId": {
            "type": "number",
            "description": "ID of the forum containing the post"
          },
          "date": {
            "type": "string",
            "description": "Date when the post was created"
          }
        }
      }
    }
  },
  {
    "featureName": "HandleNewDocumentAddition",
    "description": "Updates the search index when new documents are added to maintain search accuracy.",
    "inputValues": [
      "document-object-Document"
    ],
    "businessLogic": "1. Input Collection\n   - Collect the following inputs:\n     1.1. document (mandatory): The new document that has been added to the system\n     1.2. indexDirectory (system-generated): The directory where the search index is stored\n     1.3. analyzer (system-generated): The text analyzer used for processing document content\n\n2. Data Validation\n   - Validate the inputs:\n     2.1. Check if document is not null\n        IF document is null THEN\n          Generate error: \"Document cannot be null\"\n     2.2. Verify document has required fields\n        IF required fields are missing THEN\n          Generate error: \"Document is missing required fields\"\n     2.3. Verify indexDirectory is accessible\n        IF indexDirectory is not accessible THEN\n          Generate error: \"Search index directory is not accessible\"\n\n3. Business Rule Processing\n   - Verify system state for indexing:\n     3.1. Check if search functionality is enabled\n        IF search is disabled THEN\n          Exit process without error\n     3.2. Check if index is locked by another operation\n        IF index is locked THEN\n          Wait for lock to be released or timeout after predefined period\n          IF timeout occurs THEN\n            Generate error: \"Index is currently locked by another operation\"\n     3.3. Check available disk space for index update\n        IF insufficient disk space THEN\n          Generate error: \"Insufficient disk space for index update\"\n\n4. Core Operation Execution\n   - Update the search index:\n     4.1. Close existing search resources\n        Close current index searcher to release resources\n        IF closing fails THEN\n          Log error but continue process\n     4.2. Open new search index\n        Create new index searcher with updated index directory\n        IF opening fails THEN\n          Generate error: \"Failed to open updated search index\"\n          Attempt to restore previous search state\n     4.3. Update search-related caches\n        Clear any cached search results that may be affected\n        Update any statistics related to indexed content\n     4.4. Verify index integrity\n        Perform quick validation of index structure\n        IF index is corrupted THEN\n          Log warning and flag for maintenance\n\n5. Response Generation\n   - Generate appropriate response:\n     5.1. For successful index update:\n        Return success status\n        Include timestamp of index update\n     5.2. For failed index update:\n        Return failure status\n        Include specific error details\n        Provide guidance on resolving the issue\n        Include support information if problem persists",
    "databaseEntities": [
      "jforum_posts",
      "jforum_posts_text",
      "jforum_topics",
      "jforum_forums"
    ],
    "validationRules": [
      "Document must not be null",
      "Search index directory must be accessible",
      "Search functionality must be enabled",
      "Index must not be locked by another operation",
      "Sufficient disk space must be available for index update"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Document": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "Unique identifier for the document"
          },
          "contents": {
            "type": "string",
            "description": "The textual content to be indexed"
          },
          "postId": {
            "type": "number",
            "description": "Associated post identifier"
          },
          "forumId": {
            "type": "number",
            "description": "Forum where the document belongs"
          },
          "date": {
            "type": "string",
            "format": "date-time",
            "description": "Date when the document was created"
          }
        },
        "required": [
          "id",
          "contents",
          "postId"
        ]
      }
    }
  },
  {
    "featureName": "ConfigureLuceneRAMDirectory",
    "description": "Configures Lucene to use RAM-based directory for indexing operations.",
    "inputValues": [
      "analyzer-object-Analyzer"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect Analyzer object (mandatory)\n   - System will use the provided Analyzer for text analysis during indexing\n\n2. Data Validation:\n   - Verify Analyzer object is not null\n     * IF Analyzer is null THEN\n       - Generate error message: \"Analyzer cannot be null for Lucene configuration\"\n       - Abort operation\n     * END IF\n\n3. Business Rule Processing:\n   - Check system resources availability\n     * Verify sufficient memory is available for RAM-based indexing\n     * IF memory is insufficient THEN\n       - Log warning about potential performance issues\n     * END IF\n   - Determine if existing index data needs migration\n     * IF existing index exists in another storage type THEN\n       - Prepare for migration of indexed data\n     * END IF\n\n4. Core Operation Execution:\n   - Initialize RAM Directory\n     * Create new RAM Directory instance\n     * Store directory reference in system configuration\n   - Create initial index structure\n     * Create new index writer using the RAM directory and provided analyzer\n     * Set index writer to create mode (overwrite any existing data)\n     * Initialize empty index structure\n     * Close index writer to commit changes\n   - Register RAM directory as active directory for search operations\n     * Update system configuration to use RAM directory for all search operations\n\n5. Response Generation:\n   - Success response\n     * Return confirmation that RAM directory has been successfully configured\n     * Include memory usage statistics for the newly created index\n   - Error response\n     * If configuration fails, provide detailed error information\n     * Include suggestions for troubleshooting common issues",
    "databaseEntities": [],
    "validationRules": [
      "Analyzer object must not be null",
      "System must have sufficient memory for RAM-based indexing",
      "RAM directory must be properly initialized before use"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Analyzer": {
        "type": "object",
        "description": "Text analysis component that processes text for indexing"
      }
    }
  },
  {
    "featureName": "ConfigureLuceneFSDirectory",
    "description": "Configures Lucene to use filesystem-based directory for indexing operations.",
    "inputValues": [
      "indexDirectory-string-LuceneSettings"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect indexDirectory (string, mandatory): The file system path where the index will be stored\n   - System will use an existing analyzer instance (mandatory, system-provided)\n\n2. Data Validation:\n   - Validate indexDirectory:\n     a. Check if indexDirectory is not empty or null\n     b. Verify indexDirectory is a valid file system path\n     c. Ensure the application has read/write permissions to the specified path\n     d. If validation fails, generate appropriate error message\n\n3. Business Rule Processing:\n   - Check if index already exists at the specified location:\n     a. IF index exists at the specified location:\n        i. Prepare to use the existing index\n     b. ELSE (index does not exist):\n        i. Prepare to create a new index directory\n   - Verify system resources:\n     a. Check if sufficient disk space is available\n     b. Verify file system permissions\n     c. IF resources are insufficient, generate resource error\n\n4. Core Operation Execution:\n   - IF index does not exist at the specified location:\n     a. Create a new index directory at the specified path\n     b. Initialize the directory with required index structures\n     c. IF creation fails, generate directory creation error\n   - Configure the system to use the filesystem-based directory:\n     a. Set up the directory handler to point to the specified path\n     b. Initialize the directory access mechanism\n     c. Connect the analyzer to the directory\n     d. IF configuration fails, generate configuration error and revert to previous state\n\n5. Response Generation:\n   - IF operation is successful:\n     a. Return success status\n     b. Include information about the configured directory location\n     c. Include index status (newly created or existing)\n   - IF operation fails:\n     a. Return error status\n     b. Include detailed error information\n     c. Provide troubleshooting suggestions based on error type",
    "databaseEntities": [],
    "validationRules": [
      "Index directory path must not be empty",
      "Index directory must be accessible with read/write permissions",
      "System must have sufficient disk space for index operations",
      "Index directory path must be a valid file system location"
    ],
    "dbSeedingOperations": [],
    "schema": {}
  },
  {
    "featureName": "CreateLuceneIndexDirectory",
    "description": "Creates a new Lucene index directory in the filesystem for search functionality.",
    "inputValues": [
      "directoryPath-string-IndexDirectory"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the required directory path (string) where the index will be created\n   - Validate that the directory path is provided and not empty\n   - System will use the configured analyzer for index creation\n\n2. Data Validation:\n   - Validate directory path format:\n     a. Check if the directory path is not null or empty\n     b. Verify the path string has valid filesystem path format\n     c. Ensure the path has appropriate read/write permissions\n     d. IF validation fails, THEN generate appropriate error message\n   - Validate system state:\n     a. Check if the system has necessary resources to create directory\n     b. Verify that no conflicting operations are in progress\n     c. IF system state validation fails, THEN abort operation and report error\n\n3. Business Rule Processing:\n   - Check if an index already exists at the specified location:\n     a. IF index exists at the specified path, THEN\n        i. Abort operation to prevent overwriting existing index\n        ii. Generate appropriate error message about existing index\n     b. ELSE continue with directory creation\n   - Verify storage capacity:\n     a. Check if sufficient disk space is available for index creation\n     b. IF insufficient space, THEN abort and report error\n\n4. Core Operation Execution:\n   - Prepare for index directory creation:\n     a. Initialize the filesystem directory object\n     b. Configure the index writer with the system analyzer\n     c. Set index creation flag to true (indicating new index creation)\n   - Create the index directory:\n     a. Create physical directory structure if it doesn't exist\n     b. Initialize empty index with required metadata\n     c. Write initial index structure to disk\n     d. Close the index writer to release resources\n   - Handle potential failures:\n     a. IF any I/O errors occur during creation, THEN\n        i. Clean up any partially created files\n        ii. Log detailed error information\n        iii. Generate appropriate error response\n\n5. Response Generation:\n   - For successful creation:\n     a. Generate success confirmation message\n     b. Include the path of the newly created index directory\n     c. Provide information about the index status (empty, ready for use)\n   - For failed creation:\n     a. Generate detailed error message explaining the failure reason\n     b. Provide troubleshooting suggestions based on error type\n     c. Include system contact information for further assistance",
    "databaseEntities": [],
    "validationRules": [
      "Directory path must not be empty",
      "Directory path must be a valid filesystem path",
      "System must have read/write permissions for the specified directory",
      "Index must not already exist at the specified location",
      "Sufficient disk space must be available for index creation"
    ],
    "dbSeedingOperations": [],
    "schema": {}
  },
  {
    "featureName": "FormatDateTimeForLucene",
    "description": "Formats date objects into string format suitable for Lucene indexing.",
    "inputValues": [
      "date-date-Date"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the date object (mandatory) to be formatted\n   - No optional fields are required\n   - No default values are used\n\n2. Data Validation:\n   - Validate that the provided date is not null\n     * IF date is null THEN\n       - Generate an error indicating that a valid date is required\n       - Terminate the process\n     * END IF\n   - Validate that the provided date is a valid date object\n     * IF date is invalid THEN\n       - Generate an error indicating that the date format is incorrect\n       - Terminate the process\n     * END IF\n\n3. Business Rule Processing:\n   - Determine the required date format for Lucene indexing\n     * The format must be consistent with Lucene's date handling requirements\n     * The format must ensure proper sorting and searching capabilities\n     * The format must not contain any special characters that could interfere with indexing\n\n4. Core Operation Execution:\n   - Create a date formatter with the pattern \"yyyyMMddHHmmss\"\n     * This format includes year (4 digits), month (2 digits), day (2 digits), hour (2 digits), minute (2 digits), and second (2 digits)\n     * The format contains no separators to ensure clean indexing\n   - Apply the formatter to the input date object\n   - Convert the formatted date to a string representation\n\n5. Response Generation:\n   - Return the formatted date string\n   - IF any errors occurred during processing THEN\n     * Return appropriate error information\n   - END IF",
    "databaseEntities": [],
    "validationRules": [
      "Input date must not be null",
      "Input must be a valid date object"
    ],
    "dbSeedingOperations": [],
    "schema": {}
  },
  {
    "featureName": "PerformNewMessagesSearch",
    "description": "Searches for topics within a specified date range and returns the results.",
    "inputValues": [
      "dateRange-object-DateRange",
      "userId-number-User"
    ],
    "businessLogic": "1. Input Collection\n   1.1. Collect date range parameters\n       1.1.1. Start date (mandatory)\n       1.1.2. End date (mandatory)\n   1.2. Collect user identifier (mandatory)\n       1.2.1. System retrieves current user ID if not explicitly provided\n   1.3. Collect optional search parameters\n       1.3.1. Forum filters (optional)\n       1.3.2. Results per page (optional, default: system-defined value)\n       1.3.3. Sort order (optional, default: descending by date)\n\n2. Data Validation\n   2.1. Validate date range parameters\n       2.1.1. Verify start date is a valid date format\n       2.1.2. Verify end date is a valid date format\n       2.1.3. Verify start date is before or equal to end date\n       2.1.4. IF dates are invalid, THEN generate appropriate error message\n   2.2. Validate user identifier\n       2.2.1. Verify user exists in the system\n       2.2.2. IF user does not exist, THEN generate user not found error\n   2.3. Validate forum filters if provided\n       2.3.1. Verify each forum ID exists\n       2.3.2. Verify user has access permissions to specified forums\n       2.3.3. IF any forum is invalid or inaccessible, THEN remove from filter list\n\n3. Business Rule Processing\n   3.1. Check user permissions\n       3.1.1. Verify user has permission to search topics\n       3.1.2. Determine which forums the user has access to view\n       3.1.3. IF user lacks search permission, THEN generate permission denied error\n   3.2. Apply system constraints\n       3.2.1. Check if search functionality is enabled in system settings\n       3.2.2. Verify search request doesn't exceed system resource limits\n       3.2.3. Apply rate limiting if user has performed multiple searches recently\n       3.2.4. IF any system constraint is violated, THEN generate appropriate error message\n\n4. Core Operation Execution\n   4.1. Construct search query parameters\n       4.1.1. Format date range for database query\n       4.1.2. Apply forum filters if specified\n       4.1.3. Apply user access permissions to limit searchable forums\n   4.2. Execute search operation\n       4.2.1. Query database for topics within the specified date range\n       4.2.2. Filter results based on user's forum access permissions\n       4.2.3. Sort results according to specified sort order\n       4.2.4. Apply pagination if results exceed the maximum per page\n   4.3. Process search results\n       4.3.1. For each topic found, collect basic information (title, forum, date, etc.)\n       4.3.2. Format topics for display with relevant metadata\n       4.3.3. Calculate total number of matching topics\n\n5. Response Generation\n   5.1. Prepare success response\n       5.1.1. Include list of matching topics with their details\n       5.1.2. Include pagination information if applicable\n       5.1.3. Include total count of matching topics\n   5.2. Handle empty results case\n       5.2.1. IF no topics match the criteria, THEN generate appropriate message\n       5.2.2. Provide suggestions for broadening search parameters\n   5.3. Format response for display\n       5.3.1. Organize topics by relevance or date as specified\n       5.3.2. Include navigation elements for result pages if applicable\n       5.3.3. Include search parameter summary for user reference",
    "databaseEntities": [
      "jforum_topics",
      "jforum_forums",
      "jforum_users",
      "jforum_posts"
    ],
    "validationRules": [
      "Start date must be a valid date format",
      "End date must be a valid date format",
      "Start date must be before or equal to end date",
      "User must exist in the system",
      "User must have permission to search topics",
      "Forum IDs must be valid if specified",
      "User must have access to the forums being searched"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "DateRange": {
        "type": "object",
        "properties": {
          "startDate": {
            "type": "string",
            "format": "date-time",
            "description": "The beginning date for the search range"
          },
          "endDate": {
            "type": "string",
            "format": "date-time",
            "description": "The ending date for the search range"
          },
          "forumFilters": {
            "type": "array",
            "items": {
              "type": "number"
            },
            "description": "Optional list of forum IDs to filter the search"
          },
          "resultsPerPage": {
            "type": "number",
            "description": "Number of results to display per page"
          },
          "sortOrder": {
            "type": "string",
            "enum": [
              "ascending",
              "descending"
            ],
            "description": "Order to sort the results by date"
          }
        },
        "required": [
          "startDate",
          "endDate"
        ]
      }
    }
  },
  {
    "featureName": "PrepareTopicsForDisplay",
    "description": "Processes topic search results to prepare them for display in the UI.",
    "inputValues": [
      "topics-object-TopicList",
      "userSession-object-UserSession",
      "systemSettings-object-SystemSettings"
    ],
    "businessLogic": "1. Input Collection:\n   1.1. Collect topic list containing topic information\n      1.1.1. Verify the topic list is not null\n      1.1.2. Determine if the list contains any topics\n   1.2. Collect user session information\n      1.2.1. Retrieve user's last visit timestamp\n      1.2.2. Retrieve user's read topics history\n      1.2.3. Retrieve user's read forums history\n   1.3. Collect system settings\n      1.3.1. Retrieve posts per page setting\n      1.3.2. Retrieve hot topic threshold setting\n      1.3.3. Determine if user is anonymous\n\n2. Data Validation:\n   2.1. Validate topic list structure\n      2.1.1. Ensure each topic entry contains required fields (id, title, forum id, post dates)\n      2.1.2. Verify topic metadata is complete\n      2.1.3. IF any topic is missing required fields, mark for special handling\n   2.2. Validate user session\n      2.2.1. Ensure user session contains valid last visit timestamp\n      2.2.2. Ensure topics read time map is accessible\n      2.2.3. IF session is invalid, use default processing rules\n\n3. Business Rule Processing:\n   3.1. Apply read status determination rules\n      3.1.1. IF user is anonymous, mark all topics as read\n      3.1.2. FOR each topic, check if forum was read after last post\n      3.1.3. FOR each topic, check if last post is older than user's last visit\n      3.1.4. FOR each topic, check if topic was specifically read by user\n   3.2. Apply pagination rules for topics\n      3.2.1. FOR each topic, calculate if pagination is needed based on reply count\n      3.2.2. IF topic has more replies than posts per page setting, enable pagination\n      3.2.3. Calculate total pages for topics requiring pagination\n   3.3. Apply hot topic rules\n      3.3.1. FOR each topic, check if reply count exceeds hot topic threshold\n      3.3.2. Mark topics exceeding threshold as hot topics\n\n4. Core Operation Execution:\n   4.1. Process each topic in the list\n      4.1.1. Create a new list to hold processed topics\n      4.1.2. FOR each topic in the original list:\n         4.1.2.1. Determine read status based on business rules\n         4.1.2.2. Calculate pagination requirements\n         4.1.2.3. Set hot topic status\n         4.1.2.4. Add processed topic to new list\n   4.2. Prepare topic display attributes\n      4.2.1. Set visual indicators for read/unread status\n      4.2.2. Set visual indicators for hot topics\n      4.2.3. Set pagination information for multi-page topics\n   4.3. Apply topic type classification\n      4.3.1. Identify and mark announcement topics\n      4.3.2. Identify and mark sticky topics\n      4.3.3. Identify and mark normal topics\n\n5. Response Generation:\n   5.1. Assemble display-ready topic list\n      5.1.1. Organize processed topics in appropriate structure for UI rendering\n      5.1.2. Include metadata about topic types and statuses\n      5.1.3. Include pagination information for topics\n   5.2. Prepare empty state handling\n      5.2.1. IF no topics match criteria, prepare appropriate message\n      5.2.2. Include suggestions for broadening search\n   5.3. Finalize response\n      5.3.1. Ensure all topics are properly formatted with display attributes\n      5.3.2. Return the prepared topic list",
    "databaseEntities": [
      "jforum_topics",
      "jforum_forums",
      "jforum_users",
      "jforum_posts",
      "jforum_categories"
    ],
    "validationRules": [
      "Topic list must contain valid topic objects",
      "Each topic must have a valid ID",
      "Each topic must have a title",
      "Each topic must have a forum ID",
      "Each topic must have last post date information",
      "User session must contain valid last visit timestamp",
      "System settings must include valid posts per page value",
      "System settings must include valid hot topic threshold"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "TopicList": {
        "type": "array",
        "items": {
          "type": "object",
          "properties": {
            "id": {
              "type": "number",
              "description": "Unique identifier for the topic"
            },
            "title": {
              "type": "string",
              "description": "Title of the topic"
            },
            "forumId": {
              "type": "number",
              "description": "ID of the forum containing this topic"
            },
            "lastPostDate": {
              "type": "string",
              "format": "date-time",
              "description": "Date of the last post in the topic"
            },
            "totalReplies": {
              "type": "number",
              "description": "Number of replies in the topic"
            },
            "type": {
              "type": "number",
              "description": "Type of the topic (normal, sticky, announcement)"
            },
            "status": {
              "type": "number",
              "description": "Status of the topic (locked, unlocked)"
            },
            "read": {
              "type": "boolean",
              "description": "Whether the topic has been read by the user"
            },
            "hot": {
              "type": "boolean",
              "description": "Whether the topic is considered 'hot' based on reply count"
            },
            "paginate": {
              "type": "boolean",
              "description": "Whether the topic needs pagination"
            },
            "totalPages": {
              "type": "number",
              "description": "Total number of pages for the topic"
            }
          },
          "required": [
            "id",
            "title",
            "forumId",
            "lastPostDate",
            "totalReplies"
          ]
        }
      },
      "UserSession": {
        "type": "object",
        "properties": {
          "userId": {
            "type": "number",
            "description": "ID of the current user"
          },
          "lastVisit": {
            "type": "string",
            "format": "date-time",
            "description": "Timestamp of user's last visit"
          },
          "topicsReadTime": {
            "type": "object",
            "description": "Map of topic IDs to timestamps when they were last read"
          },
          "topicsReadTimeByForum": {
            "type": "object",
            "description": "Map of forum IDs to timestamps when they were last read"
          }
        },
        "required": [
          "userId",
          "lastVisit"
        ]
      },
      "SystemSettings": {
        "type": "object",
        "properties": {
          "postsPerPage": {
            "type": "number",
            "description": "Number of posts to display per page"
          },
          "hotTopicThreshold": {
            "type": "number",
            "description": "Minimum number of replies for a topic to be considered 'hot'"
          },
          "anonymousUserId": {
            "type": "number",
            "description": "User ID representing anonymous users"
          }
        },
        "required": [
          "postsPerPage",
          "hotTopicThreshold",
          "anonymousUserId"
        ]
      }
    }
  },
  {
    "featureName": "GetNewMessagesTemplate",
    "description": "Returns the template key for rendering new messages search results.",
    "inputValues": [
      "searchArgs-object-SearchArgs"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect search arguments from the system\n     1.1. Verify that searchArgs object is provided\n     1.2. Extract date range parameters from searchArgs\n     1.3. Identify user context for the search request\n\n2. Data Validation:\n   - Validate search parameters\n     2.1. Verify date range is valid\n        2.1.1. IF start date is after end date THEN\n              Return error message \"Invalid date range\"\n     2.2. Verify user has permission to search for new messages\n        2.2.1. IF user does not have permission THEN\n              Return error message \"Insufficient permissions\"\n\n3. Business Rule Processing:\n   - Process search request according to business rules\n     3.1. Determine which forums the user has access to\n        3.1.1. Filter out private forums where user lacks access\n     3.2. Apply system-wide search limitations\n        3.2.1. Check if search functionality is enabled\n        3.2.2. Verify search request doesn't exceed system limits\n\n4. Core Operation Execution:\n   - Execute search operation\n     4.1. Retrieve topics based on date range\n        4.1.1. Query topics created within the specified date range\n        4.1.2. Filter topics based on user permissions\n     4.2. Prepare topics for display\n        4.2.1. Format topic metadata for presentation\n        4.2.2. Sort topics according to relevance or date\n     4.3. Store search results for rendering\n        4.3.1. Save formatted topics in results collection\n\n5. Response Generation:\n   - Generate template key for rendering\n     5.1. Determine appropriate template for new messages\n        5.1.1. Return the template key for new messages search results\n     5.2. Ensure template key is valid\n        5.2.1. Verify template exists in the system\n        5.2.2. IF template doesn't exist THEN\n              Return default search template key",
    "databaseEntities": [
      "jforum_topics",
      "jforum_forums",
      "jforum_users",
      "jforum_posts"
    ],
    "validationRules": [
      "User must have permission to search for new messages",
      "Date range for search must be valid",
      "Search functionality must be enabled in the system",
      "User must have access to at least one forum"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "SearchArgs": {
        "type": "object",
        "properties": {
          "startDate": {
            "type": "date",
            "description": "Start date for the search range"
          },
          "endDate": {
            "type": "date",
            "description": "End date for the search range"
          },
          "userId": {
            "type": "number",
            "description": "ID of the user performing the search"
          },
          "forumIds": {
            "type": "array",
            "items": {
              "type": "number"
            },
            "description": "List of forum IDs to search within"
          },
          "orderBy": {
            "type": "string",
            "description": "Field to order results by"
          },
          "orderDirection": {
            "type": "string",
            "description": "Direction to order results (ascending/descending)"
          }
        }
      }
    }
  },
  {
    "featureName": "ExtractForumIdFromTopic",
    "description": "Extracts the forum ID from a Topic object for permission checking.",
    "inputValues": [
      "topic-object-Topic"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the Topic object\n     - The Topic object is required\n     - No default values are provided\n\n2. Data Validation:\n   - Validate Topic object\n     - Check if Topic object is not null\n     - IF Topic object is null THEN\n       - Generate error message: \"Topic object cannot be null\"\n       - Return error response\n     - END IF\n     - Check if Topic object has valid structure\n     - IF Topic object structure is invalid THEN\n       - Generate error message: \"Invalid Topic object structure\"\n       - Return error response\n     - END IF\n\n3. Business Rule Processing:\n   - Verify Topic object contains forum ID\n     - Check if forumId property exists in the Topic object\n     - IF forumId property does not exist THEN\n       - Generate error message: \"Topic object does not contain forum ID\"\n       - Return error response\n     - END IF\n     - Check if forumId is a valid identifier\n     - IF forumId is not a valid identifier THEN\n       - Generate error message: \"Invalid forum ID in Topic object\"\n       - Return error response\n     - END IF\n\n4. Core Operation Execution:\n   - Extract forum ID from Topic object\n     - Retrieve the forumId value from the Topic object\n     - Store the extracted forum ID for return\n\n5. Response Generation:\n   - Return the extracted forum ID\n     - Format the forum ID as an integer value\n     - IF extraction was successful THEN\n       - Return success response with forum ID\n     - ELSE\n       - Return error response with appropriate message\n     - END IF",
    "databaseEntities": [
      "jforum_topics",
      "jforum_forums"
    ],
    "validationRules": [
      "Topic object must not be null",
      "Topic object must contain a valid forum ID",
      "Forum ID must be a positive integer"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Topic": {
        "type": "object",
        "properties": {
          "id": {
            "type": "integer",
            "description": "Unique identifier for the topic"
          },
          "forumId": {
            "type": "integer",
            "description": "Identifier of the forum this topic belongs to"
          },
          "title": {
            "type": "string",
            "description": "Title of the topic"
          }
        },
        "required": [
          "id",
          "forumId"
        ]
      }
    }
  },
  {
    "featureName": "ConfigureSearchParameters",
    "description": "Configures search parameters including keywords, author, forum, date range, and result ordering.",
    "inputValues": [
      "keywords-string-SearchArgs",
      "author-number-SearchArgs",
      "forumId-number-SearchArgs",
      "matchAllKeywords-boolean-SearchArgs",
      "orderBy-string-SearchArgs",
      "orderDir-string-SearchArgs",
      "fromDate-date-SearchArgs",
      "toDate-date-SearchArgs",
      "matchType-string-SearchArgs",
      "initialRecord-number-SearchArgs"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the following search parameters:\n     a. keywords (string, optional): Search terms entered by the user\n     b. author (number, optional): User ID of the content author to filter by\n     c. forumId (number, optional): Specific forum ID to limit search to\n     d. matchAllKeywords (boolean, optional, default: false): Whether to match all keywords or any keyword\n     e. orderBy (string, optional): Field to sort results by\n     f. orderDir (string, optional, default: \"DESC\"): Sort direction (\"ASC\" or \"DESC\")\n     g. fromDate (date, optional): Start date for date range filtering\n     h. toDate (date, optional): End date for date range filtering\n     i. matchType (string, optional): Type of matching to perform\n     j. initialRecord (number, optional, default: 0): Starting record for pagination\n\n2. Data Validation:\n   - Validate keywords parameter:\n     a. IF keywords is provided THEN\n        i. Trim whitespace from beginning and end\n        ii. Check if keywords contains any non-whitespace characters\n     b. IF keywords is empty or contains only whitespace THEN\n        i. Set keywords to empty string or null\n        ii. Note that search will return no keyword-specific results\n   - Validate author parameter:\n     a. IF author is provided THEN\n        i. Verify author is a positive integer\n        ii. Check if author exists in the system\n     b. IF author is invalid THEN\n        i. Set author to default (0 or -1) indicating no author filter\n   - Validate forumId parameter:\n     a. IF forumId is provided THEN\n        i. Verify forumId is a positive integer\n        ii. Check if forum exists in the system\n     b. IF forumId is invalid THEN\n        i. Set forumId to default (0 or -1) indicating no forum filter\n   - Validate orderDir parameter:\n     a. IF orderDir is provided THEN\n        i. Verify orderDir is either \"ASC\" or \"DESC\" (case-sensitive)\n     b. IF orderDir is invalid THEN\n        i. Set orderDir to default \"DESC\"\n   - Validate date range parameters:\n     a. IF fromDate is provided THEN\n        i. Verify fromDate is a valid date\n     b. IF toDate is provided THEN\n        i. Verify toDate is a valid date\n     c. IF both fromDate and toDate are provided THEN\n        i. Verify fromDate is before or equal to toDate\n        ii. IF fromDate is after toDate THEN\n            - Swap fromDate and toDate values\n   - Validate initialRecord parameter:\n     a. IF initialRecord is provided THEN\n        i. Verify initialRecord is a non-negative integer\n     b. IF initialRecord is invalid THEN\n        i. Set initialRecord to 0\n\n3. Business Rule Processing:\n   - Process keyword matching rules:\n     a. IF keywords is provided THEN\n        i. Split keywords into individual terms by whitespace\n        ii. Remove any empty terms\n        iii. IF matchAllKeywords is true THEN\n            - Configure search to require all terms to be present\n        iv. ELSE\n            - Configure search to match any of the terms\n   - Process ordering rules:\n     a. IF orderBy is not provided THEN\n        i. Set orderBy to system default (typically relevance or date)\n     b. Ensure orderDir is properly set to either \"ASC\" or \"DESC\"\n   - Process pagination rules:\n     a. Determine the number of results per page from system configuration\n     b. Calculate the ending record based on initialRecord and results per page\n   - Process date range rules:\n     a. IF date range is provided THEN\n        i. Format dates according to system requirements\n        ii. Prepare date range filter parameters\n\n4. Core Operation Execution:\n   - Create search configuration object:\n     a. Set all validated parameters in the search configuration\n     b. Apply default values for any missing parameters\n     c. Calculate any derived parameters needed for search execution\n   - Prepare search execution context:\n     a. Format keywords according to search engine requirements\n     b. Set up pagination parameters\n     c. Configure sorting parameters\n     d. Set up filtering parameters (author, forum, dates)\n   - Store search configuration:\n     a. Save the configured search parameters for execution\n     b. Prepare for passing to search execution component\n\n5. Response Generation:\n   - Return configured search parameters object:\n     a. Include all processed and validated parameters\n     b. Include any calculated or derived values\n     c. Include pagination information\n     d. Include any warnings about ignored or modified parameters\n   - Provide confirmation of search configuration:\n     a. Indicate that search parameters have been successfully configured\n     b. Return the complete search configuration for execution",
    "databaseEntities": [
      "jforum_users",
      "jforum_forums",
      "jforum_topics",
      "jforum_posts",
      "jforum_posts_text"
    ],
    "validationRules": [
      "Keywords must be properly formatted and split into individual terms",
      "Order direction must be either 'ASC' or 'DESC'",
      "Author ID must be a positive integer if provided",
      "Forum ID must be a positive integer if provided",
      "From date must be before or equal to to date if both are provided",
      "Initial record must be a non-negative integer",
      "Results per page must match system configuration"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "SearchArgs": {
        "type": "object",
        "properties": {
          "keywords": {
            "type": "string",
            "description": "Search terms entered by the user"
          },
          "author": {
            "type": "integer",
            "description": "User ID of the content author to filter by"
          },
          "forumId": {
            "type": "integer",
            "description": "Specific forum ID to limit search to"
          },
          "matchAllKeywords": {
            "type": "boolean",
            "description": "Whether to match all keywords or any keyword"
          },
          "orderBy": {
            "type": "string",
            "description": "Field to sort results by"
          },
          "orderDir": {
            "type": "string",
            "description": "Sort direction (ASC or DESC)",
            "default": "DESC"
          },
          "fromDate": {
            "type": "string",
            "format": "date",
            "description": "Start date for date range filtering"
          },
          "toDate": {
            "type": "string",
            "format": "date",
            "description": "End date for date range filtering"
          },
          "matchType": {
            "type": "string",
            "description": "Type of matching to perform"
          },
          "initialRecord": {
            "type": "integer",
            "description": "Starting record for pagination",
            "default": 0
          }
        }
      }
    }
  },
  {
    "featureName": "ProcessSearchKeywords",
    "description": "Processes search keywords with options for exact matching or partial matching.",
    "inputValues": [
      "keywords-string-SearchArgs",
      "matchType-string-SearchArgs",
      "matchAllKeywords-boolean-SearchArgs",
      "author-number-SearchArgs",
      "forumId-number-SearchArgs",
      "orderBy-string-SearchArgs",
      "orderDir-string-SearchArgs",
      "fromDate-date-SearchArgs",
      "toDate-date-SearchArgs",
      "initialRecord-number-SearchArgs"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect search parameters from the user:\n     a. keywords (string): The search terms entered by the user\n     b. matchType (string): The type of matching to perform (exact or partial)\n     c. matchAllKeywords (boolean): Whether all keywords must be present in results\n     d. author (number): Optional ID of the post author to filter by\n     e. forumId (number): Optional forum ID to restrict search to\n     f. orderBy (string): Field to sort results by\n     g. orderDir (string): Direction of sorting (ascending or descending)\n     h. fromDate (date): Optional start date for filtering results\n     i. toDate (date): Optional end date for filtering results\n     j. initialRecord (number): Starting point for pagination\n\n2. Data Validation:\n   - Validate keywords input:\n     a. IF keywords is null or empty THEN\n        i. Set keywords array to empty\n        ii. Set raw keywords to empty string\n     b. ELSE\n        i. Trim whitespace from keywords\n        ii. Store original trimmed keywords as raw keywords\n   - Validate matchType parameter:\n     a. Ensure matchType is a valid option\n   - Validate matchAllKeywords parameter:\n     a. Ensure matchAllKeywords is a boolean value\n   - Validate author parameter:\n     a. IF author is provided THEN\n        i. Ensure author ID exists in the system\n   - Validate forumId parameter:\n     a. IF forumId is provided THEN\n        i. Ensure forum ID exists in the system\n   - Validate ordering parameters:\n     a. IF orderDir is not \"ASC\" or \"DESC\" THEN\n        i. Set orderDir to default value \"DESC\"\n     b. Ensure orderBy is a valid field name\n   - Validate date range:\n     a. IF fromDate is provided THEN\n        i. Ensure it is a valid date format\n     b. IF toDate is provided THEN\n        i. Ensure it is a valid date format\n        ii. Ensure toDate is not earlier than fromDate\n   - Validate initialRecord:\n     a. Ensure initialRecord is a non-negative number\n\n3. Business Rule Processing:\n   - Process keywords based on matching preferences:\n     a. IF keywords is not empty THEN\n        i. Split keywords string into an array by spaces\n        ii. IF matchAllKeywords is true THEN\n            1. Set search mode to require all terms\n        iii. ELSE\n            1. Set search mode to match any terms\n     b. IF matchType is specified THEN\n        i. Apply the specified matching strategy (exact or partial)\n   - Apply search filters:\n     a. IF author is specified THEN\n        i. Add author filter to search criteria\n     b. IF forumId is specified THEN\n        i. Add forum filter to search criteria\n     c. IF date range is specified THEN\n        i. Add date range filter to search criteria\n   - Determine result ordering:\n     a. Apply orderBy and orderDir to result set configuration\n   - Configure pagination:\n     a. Set starting record position to initialRecord\n     b. Calculate maximum records to fetch based on system configuration\n\n4. Core Operation Execution:\n   - Prepare search query:\n     a. Construct search parameters based on validated inputs\n     b. Apply all filters and constraints\n     c. Configure result ordering\n     d. Set pagination parameters\n   - Execute search operation:\n     a. Process keywords according to matchType and matchAllKeywords settings\n     b. Apply all filters (author, forum, date range)\n     c. Retrieve matching records\n     d. Sort results according to orderBy and orderDir\n     e. Apply pagination to limit result set\n   - Handle potential search execution issues:\n     a. IF search execution fails THEN\n        i. Capture error details\n        ii. Prepare error response\n\n5. Response Generation:\n   - Format search results:\n     a. Compile list of matching items\n     b. Include pagination information\n     c. Include total result count\n   - Generate response:\n     a. IF search was successful THEN\n        i. Return formatted search results\n        ii. Include search metadata (filters applied, sorting, etc.)\n     b. ELSE\n        i. Return appropriate error message\n        ii. Include guidance for refining search",
    "databaseEntities": [
      "jforum_topics",
      "jforum_posts",
      "jforum_posts_text",
      "jforum_forums",
      "jforum_users"
    ],
    "validationRules": [
      "Keywords must be properly formatted for searching",
      "Match type must be a valid option",
      "Order direction must be either 'ASC' or 'DESC'",
      "If date range is provided, toDate must not be earlier than fromDate",
      "Initial record must be a non-negative number",
      "Author ID must exist in the system if specified",
      "Forum ID must exist in the system if specified"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "SearchArgs": {
        "type": "object",
        "properties": {
          "keywords": {
            "type": "string",
            "description": "Search terms entered by the user"
          },
          "matchType": {
            "type": "string",
            "description": "Type of matching to perform (exact or partial)"
          },
          "matchAllKeywords": {
            "type": "boolean",
            "description": "Whether all keywords must be present in results"
          },
          "author": {
            "type": "number",
            "description": "ID of the post author to filter by"
          },
          "forumId": {
            "type": "number",
            "description": "Forum ID to restrict search to"
          },
          "orderBy": {
            "type": "string",
            "description": "Field to sort results by"
          },
          "orderDir": {
            "type": "string",
            "description": "Direction of sorting (ascending or descending)"
          },
          "fromDate": {
            "type": "string",
            "format": "date",
            "description": "Start date for filtering results"
          },
          "toDate": {
            "type": "string",
            "format": "date",
            "description": "End date for filtering results"
          },
          "initialRecord": {
            "type": "number",
            "description": "Starting point for pagination"
          }
        }
      }
    }
  },
  {
    "featureName": "ManageSearchPagination",
    "description": "Manages pagination of search results with configurable starting position and count.",
    "inputValues": [
      "initialRecord-number-SearchArgs",
      "fetchCount-number-SearchArgs",
      "keywords-string-SearchArgs",
      "matchAllKeywords-boolean-SearchArgs",
      "author-number-SearchArgs",
      "forumId-number-SearchArgs",
      "orderBy-string-SearchArgs",
      "orderDir-string-SearchArgs",
      "fromDate-date-SearchArgs",
      "toDate-date-SearchArgs",
      "matchType-string-SearchArgs"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect search parameters:\n     a. initialRecord (number): Starting position for pagination (mandatory)\n     b. fetchCount (number): Number of results per page (system-generated from configuration)\n     c. keywords (string): Search terms entered by user (optional)\n     d. matchAllKeywords (boolean): Whether to match all keywords or any keyword (optional, default: false)\n     e. author (number): ID of the post author to filter by (optional)\n     f. forumId (number): ID of the forum to search within (optional)\n     g. orderBy (string): Field to sort results by (optional)\n     h. orderDir (string): Direction of sorting (optional, default: \"DESC\")\n     i. fromDate (date): Start date for filtering results (optional)\n     j. toDate (date): End date for filtering results (optional)\n     k. matchType (string): Type of matching to perform (optional)\n\n2. Data Validation:\n   - Validate initialRecord:\n     a. Check if initialRecord is a non-negative integer\n     b. IF initialRecord is negative, set to 0\n     c. Error message: \"Starting position must be a non-negative number\"\n   - Validate fetchCount:\n     a. Ensure fetchCount is a positive integer\n     b. IF fetchCount is not provided or invalid, retrieve from system configuration\n     c. Error message: \"Results per page must be a positive number\"\n   - Validate keywords:\n     a. Check if keywords string is properly formatted\n     b. Trim whitespace from keywords\n     c. Split keywords into array for processing\n     d. Error message: \"Invalid keyword format\"\n   - Validate orderDir:\n     a. Check if orderDir is either \"ASC\" or \"DESC\"\n     b. IF invalid, default to \"DESC\"\n     c. Error message: \"Sort direction must be either ASC or DESC\"\n   - Validate date range:\n     a. IF both fromDate and toDate are provided, ensure fromDate is before toDate\n     b. Error message: \"Start date must be before end date\"\n\n3. Business Rule Processing:\n   - Process pagination parameters:\n     a. Calculate end record position (initialRecord + fetchCount)\n     b. Ensure pagination boundaries are within available results\n     c. IF end record exceeds total results, adjust accordingly\n   - Process search constraints:\n     a. IF forumId is provided, verify forum exists and user has access permissions\n     b. IF author is provided, verify author exists in the system\n     c. IF date range is provided, apply as filter criteria\n   - Process keyword matching rules:\n     a. IF matchAllKeywords is true, configure search to require all terms\n     b. IF matchAllKeywords is false, configure search to match any term\n     c. Apply matchType rules to keyword processing\n\n4. Core Operation Execution:\n   - Prepare search query:\n     a. Incorporate all validated parameters into search criteria\n     b. Apply forum filtering if forumId is specified\n     c. Apply author filtering if author is specified\n     d. Apply date range filtering if dates are specified\n   - Execute paginated search:\n     a. Retrieve only the specified range of results (from initialRecord to initialRecord + fetchCount)\n     b. Apply specified sorting (orderBy and orderDir)\n     c. Format results for display\n   - Handle search execution errors:\n     a. IF search execution fails, prepare error information\n     b. Log search failure details\n     c. Prepare fallback response\n\n5. Response Generation:\n   - Generate success response:\n     a. Include array of search results within requested pagination range\n     b. Include pagination metadata (current page, total pages, total results)\n     c. Include search parameters used for the query\n     d. Format response according to display requirements\n   - Generate error response if needed:\n     a. Include specific error code and message\n     b. Include guidance for correcting search parameters\n     c. Provide alternative search suggestions when appropriate",
    "databaseEntities": [
      "jforum_topics",
      "jforum_posts",
      "jforum_posts_text",
      "jforum_forums",
      "jforum_users"
    ],
    "validationRules": [
      "Initial record position must be a non-negative integer",
      "Fetch count must be a positive integer",
      "Order direction must be either ASC or DESC",
      "If date range is provided, start date must be before end date",
      "Forum ID must reference an existing forum",
      "Author ID must reference an existing user"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "SearchArgs": {
        "type": "object",
        "properties": {
          "keywords": {
            "type": "string",
            "description": "Space-separated search terms"
          },
          "author": {
            "type": "integer",
            "description": "ID of the post author"
          },
          "orderDir": {
            "type": "string",
            "enum": [
              "ASC",
              "DESC"
            ],
            "description": "Direction of result sorting"
          },
          "orderBy": {
            "type": "string",
            "description": "Field to sort results by"
          },
          "matchAllKeywords": {
            "type": "boolean",
            "description": "Whether to match all keywords or any keyword"
          },
          "forumId": {
            "type": "integer",
            "description": "ID of the forum to search within"
          },
          "initialRecord": {
            "type": "integer",
            "description": "Starting position for pagination"
          },
          "fromDate": {
            "type": "string",
            "format": "date",
            "description": "Start date for filtering results"
          },
          "toDate": {
            "type": "string",
            "format": "date",
            "description": "End date for filtering results"
          },
          "matchType": {
            "type": "string",
            "description": "Type of matching to perform"
          }
        }
      }
    }
  },
  {
    "featureName": "InitSearchManager",
    "description": "Initializes the search manager implementation based on system configuration.",
    "inputValues": [
      "configSettings-object-SystemConfiguration"
    ],
    "businessLogic": "1. Input Collection:\n   - Retrieve system configuration settings (configSettings)\n     - Search indexing enabled flag (mandatory)\n     - Search implementation class name (mandatory if search is enabled)\n\n2. Data Validation:\n   - Validate search configuration settings\n     - Check if search indexing is enabled\n       - If disabled, log information message about disabled search indexing\n     - Validate search implementation class name\n       - IF implementation class name is empty or null THEN\n         - Log information message about missing implementation\n         - Skip further initialization\n       - END IF\n\n3. Business Rule Processing:\n   - Determine search manager initialization approach\n     - IF search is disabled THEN\n       - Prepare for potential runtime configuration changes\n       - Log appropriate information message\n     - END IF\n     - Verify system readiness for search functionality\n       - Check for required dependencies\n       - Ensure system has appropriate permissions\n\n4. Core Operation Execution:\n   - Initialize search manager instance\n     - TRY to instantiate the search manager implementation\n       - Load the implementation class using the provided class name\n       - Create a new instance of the implementation class\n       - Cast the instance to the appropriate search manager type\n     - CATCH any exceptions during instantiation\n       - Log warning with exception details\n       - Throw appropriate exception with descriptive message\n     - END TRY-CATCH\n     - Initialize the search manager instance\n       - Call initialization method on the search manager\n       - Set up required resources and connections\n\n5. Response Generation:\n   - Finalize search manager initialization\n     - Store the initialized search manager instance for future use\n     - Log successful initialization\n   - Handle initialization failures\n     - Provide clear error messages for troubleshooting\n     - Suggest possible solutions for common initialization problems",
    "databaseEntities": [
      "jforum_posts"
    ],
    "validationRules": [
      "Search indexing enabled flag must be a boolean value",
      "Search implementation class name must not be empty when search is enabled",
      "Search implementation class must implement the SearchManager interface",
      "Search implementation class must be accessible and instantiable"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "SystemConfiguration": {
        "type": "object",
        "properties": {
          "searchIndexingEnabled": {
            "type": "boolean",
            "description": "Flag indicating if search indexing is enabled"
          },
          "searchImplementationClass": {
            "type": "string",
            "description": "Fully qualified class name of the search manager implementation"
          }
        },
        "required": [
          "searchIndexingEnabled",
          "searchImplementationClass"
        ]
      }
    }
  },
  {
    "featureName": "CreateSearchIndex",
    "description": "Creates a search index entry for a forum post.",
    "inputValues": [
      "post-object-Post"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the Post object containing:\n     - Post ID (system-generated)\n     - Post content (mandatory)\n     - Post title (mandatory)\n     - Author information (mandatory)\n     - Creation timestamp (system-generated)\n     - Forum and topic references (mandatory)\n\n2. Data Validation:\n   - Validate Post object:\n     - Verify Post object is not null\n     - Check that Post ID is valid\n     - Ensure post content is not empty\n     - Verify post belongs to a valid topic and forum\n     - Confirm author information is present\n   - IF any validation fails THEN:\n     - Generate appropriate error message\n     - Abort indexing process\n     - Log validation failure\n\n3. Business Rule Processing:\n   - Check if search indexing is enabled in system settings\n     - IF indexing is disabled THEN:\n       - Skip the indexing process\n       - Log that indexing was skipped due to system settings\n       - Return without creating index\n   - Verify search manager is properly initialized\n     - IF search manager is not initialized THEN:\n       - Log error about search manager unavailability\n       - Abort indexing process\n   - Check post visibility and permissions\n     - IF post is in a restricted forum THEN:\n       - Include appropriate access control information in the index\n\n4. Core Operation Execution:\n   - Extract indexable content from the post:\n     - Parse post content to extract plain text\n     - Include post title in indexable content\n     - Add metadata (author, date, forum, topic)\n   - Create search document:\n     - Generate unique document ID based on post ID\n     - Structure document with all extracted content\n     - Add relevance boosting factors where appropriate\n   - Add document to search index:\n     - Pass document to search manager for indexing\n     - Handle any indexing errors that occur\n     - Ensure document is properly committed to the index\n   - Update index statistics:\n     - Increment document count if necessary\n     - Update last indexed timestamp\n\n5. Response Generation:\n   - For successful indexing:\n     - Log successful index creation\n     - Return success status\n   - For failed indexing:\n     - Log detailed error information\n     - Return failure status with reason\n     - Provide information for potential retry",
    "databaseEntities": [
      "Post",
      "Topic",
      "Forum",
      "User"
    ],
    "validationRules": [
      "Post object must not be null",
      "Post ID must be a valid identifier",
      "Post content must not be empty",
      "Post must belong to a valid topic",
      "Post must have valid author information",
      "Search indexing must be enabled in system settings",
      "Search manager must be properly initialized"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Post": {
        "type": "object",
        "properties": {
          "id": {
            "type": "number",
            "description": "Unique identifier for the post"
          },
          "text": {
            "type": "string",
            "description": "Content of the post"
          },
          "subject": {
            "type": "string",
            "description": "Title or subject of the post"
          },
          "userId": {
            "type": "number",
            "description": "ID of the post author"
          },
          "topicId": {
            "type": "number",
            "description": "ID of the topic this post belongs to"
          },
          "forumId": {
            "type": "number",
            "description": "ID of the forum this post belongs to"
          },
          "time": {
            "type": "date",
            "description": "Timestamp when the post was created"
          }
        },
        "required": [
          "id",
          "text",
          "userId",
          "topicId",
          "forumId",
          "time"
        ]
      }
    }
  },
  {
    "featureName": "UpdateSearchIndex",
    "description": "Updates the search index for a modified forum post.",
    "inputValues": [
      "post-object-Post"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the modified Post object with the following attributes:\n     - Post ID (system-generated identifier)\n     - Post content (mandatory text content)\n     - Post title (mandatory text content)\n     - Author information (mandatory user reference)\n     - Topic reference (mandatory topic identifier)\n     - Forum reference (mandatory forum identifier)\n     - Timestamp of modification (system-generated)\n\n2. Data Validation:\n   - Validate Post object:\n     - Verify Post object is not null\n     - Verify Post ID exists and is valid\n     - Verify Post content is not empty\n     - Verify Post has valid references to Topic and Forum\n     - IF any validation fails, THEN:\n       - Generate appropriate error message\n       - Terminate the update process\n       - Log validation failure\n\n3. Business Rule Processing:\n   - Check if search indexing is enabled in system configuration:\n     - Retrieve system configuration for search indexing status\n     - IF search indexing is disabled, THEN:\n       - Log that indexing is skipped due to system configuration\n       - Exit the process gracefully without error\n       - Return success with no action taken\n     - ELSE continue with the update process\n   - Verify search manager is properly initialized:\n     - Check if search manager instance exists\n     - IF search manager is not initialized, THEN:\n       - Log error about missing search manager\n       - Attempt to initialize search manager\n       - IF initialization fails, THEN terminate with error\n\n4. Core Operation Execution:\n   - Prepare post data for indexing:\n     - Extract searchable content from post (title, body text)\n     - Format metadata (author, dates, topic/forum references)\n   - Remove existing index entries for this post:\n     - Locate existing index entries using Post ID\n     - Delete all found entries to prevent duplication\n   - Create new index entries:\n     - Generate index entries for the post content\n     - Associate metadata with index entries\n     - Optimize index if necessary based on system rules\n   - Handle any exceptions during indexing:\n     - IF index update fails, THEN:\n       - Log detailed error information\n       - Attempt rollback of partial updates if possible\n       - Mark post for reindexing in background process\n\n5. Response Generation:\n   - For successful update:\n     - Log successful index update with post identifier\n     - Return success status\n   - For failed update:\n     - Return error status with failure reason\n     - Include suggestions for manual reindexing if appropriate\n     - Provide reference to logs for detailed error information",
    "databaseEntities": [
      "jforum_posts",
      "jforum_posts_text",
      "jforum_topics",
      "jforum_forums"
    ],
    "validationRules": [
      "Post object must not be null",
      "Post ID must be a valid identifier",
      "Post content must not be empty",
      "Post must have valid references to Topic and Forum",
      "Search indexing must be enabled in system configuration",
      "Search manager must be properly initialized"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Post": {
        "type": "object",
        "properties": {
          "id": {
            "type": "number",
            "description": "Unique identifier for the post"
          },
          "content": {
            "type": "string",
            "description": "Text content of the post"
          },
          "title": {
            "type": "string",
            "description": "Title of the post"
          },
          "authorId": {
            "type": "number",
            "description": "User ID of the post author"
          },
          "topicId": {
            "type": "number",
            "description": "ID of the topic this post belongs to"
          },
          "forumId": {
            "type": "number",
            "description": "ID of the forum this post belongs to"
          },
          "creationDate": {
            "type": "date",
            "description": "Date when the post was created"
          },
          "modificationDate": {
            "type": "date",
            "description": "Date when the post was last modified"
          }
        },
        "required": [
          "id",
          "content",
          "authorId",
          "topicId",
          "forumId"
        ]
      }
    }
  },
  {
    "featureName": "DeleteSearchIndex",
    "description": "Removes a post from the search index to ensure it no longer appears in search results.",
    "inputValues": [
      "post-object-Post"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the Post object that needs to be removed from the search index\n     1.1. Verify Post object is provided and contains required identifier\n     1.2. Check if Post contains all necessary metadata for search index operations\n\n2. Data Validation:\n   - Validate the Post object and system state\n     2.1. Verify Post object is not null\n     2.2. Verify Post contains valid identifier\n     2.3. Check if search functionality is enabled in the system\n        2.3.1. IF search is disabled, THEN exit the process without attempting deletion\n        2.3.2. IF search manager is not initialized, THEN log error and exit process\n\n3. Business Rule Processing:\n   - Check system conditions for search index deletion\n     3.1. Verify search manager is properly initialized\n     3.2. Check if the Post exists in the search index\n        3.2.1. IF Post does not exist in index, log information and exit process\n     3.3. Verify user has appropriate permissions to modify search index\n     3.4. Check if any system-wide indexing operations are in progress\n        3.4.1. IF indexing is in progress, queue deletion for later processing\n\n4. Core Operation Execution:\n   - Remove the Post from search index\n     4.1. Prepare deletion request with Post identifier\n     4.2. Submit deletion request to search manager\n     4.3. Wait for confirmation of deletion\n     4.4. IF deletion fails, retry operation up to configured number of attempts\n        4.4.1. IF all retries fail, log error and notify administrator\n     4.5. Update related indices that may reference the deleted Post\n     4.6. Perform cleanup of any temporary resources\n\n5. Response Generation:\n   - Generate appropriate response based on operation outcome\n     5.1. IF deletion was successful:\n        5.1.1. Log successful deletion with Post identifier\n        5.1.2. Return success status\n     5.2. IF deletion failed:\n        5.2.1. Log failure with specific error details\n        5.2.2. Return error status with appropriate message\n     5.3. Include timestamp of operation in response",
    "databaseEntities": [
      "jforum_posts",
      "jforum_posts_text",
      "jforum_topics"
    ],
    "validationRules": [
      "Post object must not be null",
      "Post must have a valid identifier",
      "Search functionality must be enabled in the system",
      "Search manager must be properly initialized",
      "User must have appropriate permissions to modify search index"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Post": {
        "type": "object",
        "properties": {
          "id": {
            "type": "number",
            "description": "Unique identifier for the post"
          },
          "subject": {
            "type": "string",
            "description": "Subject/title of the post"
          },
          "text": {
            "type": "string",
            "description": "Content of the post"
          },
          "userId": {
            "type": "number",
            "description": "Identifier of the user who created the post"
          },
          "topicId": {
            "type": "number",
            "description": "Identifier of the topic this post belongs to"
          },
          "forumId": {
            "type": "number",
            "description": "Identifier of the forum this post belongs to"
          },
          "postDate": {
            "type": "date",
            "description": "Date when the post was created"
          }
        },
        "required": [
          "id"
        ]
      }
    }
  },
  {
    "featureName": "InitializeSearch",
    "description": "Initializes the search functionality for the forum system.",
    "inputValues": [
      "searchConfiguration-object-SearchConfig"
    ],
    "businessLogic": "1. Input Collection:\n   - searchConfiguration (object, mandatory): Contains configuration parameters for the search functionality\n     - indexLocation (string, mandatory): Directory path where search indexes will be stored\n     - analyzerType (string, optional): Type of text analyzer to use, defaults to standard analyzer\n     - maxResults (number, optional): Maximum number of results to return per search, defaults to 100\n     - cacheSize (number, optional): Size of the search cache in MB, defaults to system recommended value\n\n2. Data Validation:\n   - Validate searchConfiguration object:\n     - IF indexLocation is empty or null THEN\n       - Generate error: \"Index location must be specified\"\n     - IF indexLocation is not a valid directory path THEN\n       - Generate error: \"Invalid index location path\"\n     - IF analyzerType is provided but not a supported type THEN\n       - Generate error: \"Unsupported analyzer type\"\n     - IF maxResults is provided and less than 1 THEN\n       - Generate error: \"Maximum results must be greater than zero\"\n     - IF cacheSize is provided and less than minimum required value THEN\n       - Generate error: \"Cache size too small for operation\"\n\n3. Business Rule Processing:\n   - Check system prerequisites:\n     - Verify sufficient disk space for index storage\n       - IF available disk space < required minimum THEN\n         - Generate error: \"Insufficient disk space for search indexes\"\n     - Verify write permissions to index location\n       - IF write permissions not available THEN\n         - Generate error: \"Cannot write to index location\"\n     - Check for existing search index:\n       - IF index exists THEN\n         - Determine if index needs rebuilding based on version compatibility\n         - IF index version incompatible THEN\n           - Flag index for rebuilding\n\n4. Core Operation Execution:\n   - Initialize search engine components:\n     - Create or open index storage at specified location\n     - Configure analyzer with specified or default settings\n     - Initialize document parser for forum content\n     - Set up result formatter\n     - Configure search cache with specified or default size\n   - Prepare search functionality:\n     - Register content types for indexing (posts, topics, etc.)\n     - Set up field mappings for searchable content\n     - Initialize query parser\n     - Configure result ranking mechanism\n   - IF index flagged for rebuilding or no index exists THEN\n     - Create empty index structure\n     - Flag system for background indexing of existing content\n\n5. Response Generation:\n   - IF initialization successful THEN\n     - Return success status\n     - Include search engine information (version, capabilities)\n     - Include index statistics (if existing index was loaded)\n     - Include notification if background indexing was scheduled\n   - ELSE\n     - Return failure status\n     - Include specific error details\n     - Include troubleshooting information\n     - Include recovery suggestions",
    "databaseEntities": [
      "jforum_posts",
      "jforum_posts_text",
      "jforum_topics",
      "jforum_forums",
      "jforum_categories"
    ],
    "validationRules": [
      "Search index location must be specified",
      "Search index location must be a valid directory path with write permissions",
      "Analyzer type must be supported by the system",
      "Maximum results setting must be greater than zero",
      "Cache size must meet minimum system requirements",
      "Sufficient disk space must be available for index creation"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "SearchConfig": {
        "type": "object",
        "properties": {
          "indexLocation": {
            "type": "string",
            "description": "Directory path where search indexes will be stored"
          },
          "analyzerType": {
            "type": "string",
            "description": "Type of text analyzer to use for indexing"
          },
          "maxResults": {
            "type": "number",
            "description": "Maximum number of results to return per search"
          },
          "cacheSize": {
            "type": "number",
            "description": "Size of the search cache in MB"
          }
        },
        "required": [
          "indexLocation"
        ]
      }
    }
  },
  {
    "featureName": "DeleteFromSearchIndex",
    "description": "Removes a post from the search index.",
    "inputValues": [
      "post-object-Post"
    ],
    "businessLogic": "1. Input Collection\n   - Collect the Post object to be removed from the search index\n     1.1. Verify the Post object is provided\n     1.2. Extract the post identifier from the Post object\n     1.3. Identify any associated metadata needed for removal\n\n2. Data Validation\n   - Validate the Post object and its properties\n     2.1. Verify the Post object is not null\n     2.2. Verify the Post has a valid identifier\n     2.3. IF the Post identifier is invalid or missing THEN\n          2.3.1. Generate appropriate validation error\n          2.3.2. Terminate the deletion process\n     2.4. Verify the Post exists in the search index\n     2.5. IF the Post does not exist in the search index THEN\n          2.5.1. Log a warning message\n          2.5.2. Exit the process successfully (no action needed)\n\n3. Business Rule Processing\n   - Check business rules related to search index deletion\n     3.1. Verify the user has permission to remove content from the search index\n     3.2. Check if the post is part of any special content that should remain indexed\n     3.3. Determine if any related content should also be removed from the index\n     3.4. IF any business rule is violated THEN\n          3.4.1. Generate appropriate business rule violation error\n          3.4.2. Terminate the deletion process\n\n4. Core Operation Execution\n   - Remove the post from the search index\n     4.1. Locate the post in the search index using its identifier\n     4.2. Remove all indexed content related to the post\n     4.3. Remove any associated metadata or references\n     4.4. IF removal fails THEN\n          4.4.1. Log the error details\n          4.4.2. Attempt to restore any partial changes\n          4.4.3. Generate appropriate system error\n          4.4.4. Terminate the deletion process\n     4.5. Update any related indices or references\n     4.6. Commit the changes to ensure persistence\n\n5. Response Generation\n   - Generate appropriate response based on the operation outcome\n     5.1. IF deletion was successful THEN\n          5.1.1. Generate success response\n          5.1.2. Include confirmation of removal\n     5.2. ELSE\n          5.2.1. Generate failure response\n          5.2.2. Include error details and reason for failure\n     5.3. Return the response to the caller",
    "databaseEntities": [
      "jforum_posts",
      "jforum_posts_text"
    ],
    "validationRules": [
      "Post object must not be null",
      "Post must have a valid identifier",
      "Post must exist in the search index",
      "User must have permission to remove content from the search index"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Post": {
        "type": "object",
        "properties": {
          "id": {
            "type": "number",
            "description": "Unique identifier for the post"
          },
          "subject": {
            "type": "string",
            "description": "Subject or title of the post"
          },
          "text": {
            "type": "string",
            "description": "Content of the post"
          },
          "userId": {
            "type": "number",
            "description": "Identifier of the user who created the post"
          },
          "topicId": {
            "type": "number",
            "description": "Identifier of the topic the post belongs to"
          },
          "forumId": {
            "type": "number",
            "description": "Identifier of the forum the post belongs to"
          },
          "postDate": {
            "type": "date",
            "description": "Date when the post was created"
          }
        },
        "required": [
          "id"
        ]
      }
    }
  },
  {
    "featureName": "PerformSearch",
    "description": "Executes search operations based on provided search arguments and returns filtered results.",
    "inputValues": [
      "searchArgs-object-SearchArgs",
      "results-object-List"
    ],
    "businessLogic": "1. Input Collection:\n   1.1. Collect search arguments from the user\n      1.1.1. Search keywords (mandatory)\n      1.1.2. Search scope (optional, default: all forums)\n      1.1.3. Search filters (optional)\n      1.1.4. Sort options (optional, default: relevance)\n      1.1.5. Pagination parameters (optional, default: page 1, standard page size)\n   1.2. System generates search execution timestamp\n\n2. Data Validation:\n   2.1. Validate search keywords\n      2.1.1. Check if search keywords are provided\n      2.1.2. Verify minimum keyword length requirements\n      2.1.3. IF keywords do not meet requirements, THEN display appropriate error message\n   2.2. Validate search scope\n      2.2.1. IF specific forums are selected, THEN verify user has access to those forums\n      2.2.2. IF user lacks access to selected forums, THEN exclude those forums from search scope\n   2.3. Validate pagination parameters\n      2.3.1. Ensure page number is positive\n      2.3.2. Ensure page size is within allowed limits\n\n3. Business Rule Processing:\n   3.1. Check search frequency limitations\n      3.1.1. Verify if user has performed searches recently\n      3.1.2. IF search frequency exceeds allowed limit, THEN return error message about rate limiting\n   3.2. Apply forum access control\n      3.2.1. Determine forums the user has permission to search in\n      3.2.2. Filter search scope to include only accessible forums\n   3.3. Determine search operation type based on arguments\n      3.3.1. Analyze search arguments to select appropriate search strategy\n      3.3.2. Prepare search execution plan based on selected strategy\n\n4. Core Operation Execution:\n   4.1. Execute the search operation\n      4.1.1. Process search keywords according to search strategy\n      4.1.2. Apply forum scope filters to the search\n      4.1.3. Apply any additional filters specified in search arguments\n      4.1.4. Execute the search and collect initial results\n   4.2. Process search results\n      4.2.1. Filter results based on forum access permissions\n         4.2.1.1. For each result, extract the forum ID\n         4.2.1.2. Check if forum exists and user has access to it\n         4.2.1.3. IF forum is valid, add the result to filtered list\n         4.2.1.4. IF forum is valid, associate forum information with the result\n      4.2.2. Sort filtered results according to specified sort options\n      4.2.3. Apply pagination to the sorted results\n   4.3. Calculate total record count\n      4.3.1. Determine total number of matching records before pagination\n      4.3.2. Store count for pagination display purposes\n\n5. Response Generation:\n   5.1. Prepare results for display\n      5.1.1. Format each result item for presentation\n      5.1.2. Include relevant metadata with each result\n      5.1.3. Add highlighting to matched keywords if applicable\n   5.2. Generate search summary information\n      5.2.1. Include total number of results found\n      5.2.2. Include search execution time\n      5.2.3. Include pagination information\n   5.3. Return search results\n      5.3.1. Package filtered and formatted results\n      5.3.2. Include view template information for display\n      5.3.3. Return complete search result object to caller",
    "databaseEntities": [
      "jforum_forums",
      "jforum_topics",
      "jforum_posts",
      "jforum_posts_text",
      "jforum_users"
    ],
    "validationRules": [
      "Search keywords must not be empty",
      "Search keywords must meet minimum length requirements",
      "User must have access permissions to forums being searched",
      "Search frequency must not exceed rate limits",
      "Page number must be positive",
      "Page size must be within allowed limits"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "SearchArgs": {
        "type": "object",
        "properties": {
          "keywords": {
            "type": "string",
            "description": "Search terms provided by user"
          },
          "forumIds": {
            "type": "array",
            "description": "List of forum IDs to search within",
            "items": {
              "type": "integer"
            }
          },
          "startDate": {
            "type": "date",
            "description": "Optional start date for filtering results"
          },
          "endDate": {
            "type": "date",
            "description": "Optional end date for filtering results"
          },
          "sortBy": {
            "type": "string",
            "description": "Field to sort results by"
          },
          "sortOrder": {
            "type": "string",
            "description": "Sort direction (ascending or descending)"
          },
          "pageNumber": {
            "type": "integer",
            "description": "Page number for pagination"
          },
          "pageSize": {
            "type": "integer",
            "description": "Number of results per page"
          }
        },
        "required": [
          "keywords"
        ]
      },
      "List": {
        "type": "array",
        "description": "Collection of search result items",
        "items": {
          "type": "object"
        }
      },
      "SearchResult": {
        "type": "object",
        "properties": {
          "results": {
            "type": "array",
            "description": "List of search result items"
          },
          "totalRecords": {
            "type": "integer",
            "description": "Total number of matching records"
          },
          "viewTemplate": {
            "type": "string",
            "description": "Template identifier for displaying results"
          }
        }
      }
    }
  },
  {
    "featureName": "FilterSearchResults",
    "description": "Filters search results based on forum access permissions and enriches with forum data.",
    "inputValues": [
      "searchResults-object-SearchResultList",
      "forumRepository-object-ForumRepository"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect search results list containing items with forum references\n   - Each result item must contain a forum identifier\n   - System will use the forum repository to access forum data\n\n2. Data Validation:\n   - Validate that the search results list is not null\n   - Verify each search result item contains a valid forum identifier\n   - IF any result item has an invalid forum identifier THEN mark for exclusion\n   - Ensure the forum repository is accessible and operational\n\n3. Business Rule Processing:\n   - Create an empty filtered results list to store valid results\n   - Create a forum cache map to avoid redundant forum lookups\n   - FOR each search result item in the input list:\n     a. Extract the forum identifier from the current result item\n     b. Check if the forum has already been processed in this session\n        - IF forum not in cache:\n          i. Retrieve forum information using the forum identifier\n          ii. Determine if the forum is valid and accessible\n          iii. Store forum status and information in the cache\n     c. Check forum access permissions\n        - IF forum is valid and accessible:\n          i. Enrich the search result with complete forum information\n          ii. Add the enriched result to the filtered results list\n        - ELSE:\n          i. Skip the current result item (exclude from output)\n\n4. Core Operation Execution:\n   - Process all search result items according to the business rules\n   - Maintain the original order of results where possible\n   - Ensure forum data is properly attached to each valid result\n   - Remove any results that reference invalid or inaccessible forums\n\n5. Response Generation:\n   - Return the filtered and enriched search results list\n   - Ensure the response maintains the expected structure\n   - Include only results that passed the forum validation checks\n   - Preserve any metadata about the search operation",
    "databaseEntities": [
      "jforum_forums",
      "jforum_posts",
      "jforum_topics"
    ],
    "validationRules": [
      "Search results must not be null",
      "Each search result must contain a valid forum identifier",
      "Forums must exist in the system to be included in results",
      "User must have access permission to the forum to see its content in search results"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "SearchResultList": {
        "type": "array",
        "items": {
          "type": "object",
          "properties": {
            "forumId": {
              "type": "integer",
              "description": "Identifier of the forum containing the search result"
            },
            "content": {
              "type": "string",
              "description": "Content matching the search criteria"
            },
            "metadata": {
              "type": "object",
              "description": "Additional information about the search result"
            }
          }
        }
      },
      "ForumRepository": {
        "type": "object",
        "properties": {
          "forums": {
            "type": "object",
            "description": "Collection of forums indexed by forum identifier"
          }
        }
      }
    }
  },
  {
    "featureName": "ManageRolePermissions",
    "description": "Manages security roles and permissions for forum users and groups.",
    "inputValues": [
      "roleId-number-Role",
      "roleName-string-Role",
      "groupId-number-Group",
      "permissions-object-PermissionSet",
      "roleValues-object-RoleValueCollection"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the following inputs:\n     a. groupId (mandatory): The identifier of the group to manage permissions for\n     b. roleId (optional): The identifier of the role when modifying an existing role\n     c. roleName (mandatory when creating a new role): The name of the permission role\n     d. permissions (mandatory): The set of permissions to assign\n     e. roleValues (mandatory): Collection of specific values for the role permissions\n\n2. Data Validation:\n   - Validate groupId:\n     a. VERIFY groupId is a positive integer\n     b. VERIFY groupId corresponds to an existing group in the system\n     c. IF validation fails, THEN return error message \"Invalid group identifier\"\n   - Validate roleName (when creating a new role):\n     a. VERIFY roleName is not empty\n     b. VERIFY roleName follows naming conventions\n     c. VERIFY roleName is unique within the system\n     d. IF validation fails, THEN return error message \"Invalid role name\"\n   - Validate permissions object:\n     a. VERIFY permissions contains valid permission types\n     b. VERIFY all required permission attributes are present\n     c. IF validation fails, THEN return error message \"Invalid permission configuration\"\n   - Validate roleValues collection:\n     a. VERIFY roleValues contains valid entries\n     b. VERIFY roleValues match the expected format for the role type\n     c. IF validation fails, THEN return error message \"Invalid role values\"\n\n3. Business Rule Processing:\n   - Check user authorization:\n     a. VERIFY current user has administrator privileges\n     b. IF user lacks required privileges, THEN return error message \"Insufficient permissions to manage roles\"\n   - Verify system constraints:\n     a. CHECK if the system allows the requested permission combination\n     b. VERIFY the requested permissions do not conflict with system security policies\n     c. IF constraints are violated, THEN return error message \"Permission configuration violates system constraints\"\n   - Check role dependencies:\n     a. IDENTIFY any dependent roles or permissions that might be affected\n     b. VERIFY changes won't break existing permission structures\n     c. IF dependencies are compromised, THEN return error message \"Operation would break existing permission dependencies\"\n\n4. Core Operation Execution:\n   - Determine operation type:\n     a. IF roleId is provided, THEN prepare for role update\n     b. IF roleId is not provided but roleName is, THEN prepare for role creation\n     c. IF operation type cannot be determined, THEN return error message \"Invalid operation parameters\"\n   - Process role management:\n     a. FOR creating a new role:\n        i. CREATE new Role object with provided roleName\n        ii. ASSIGN the Role to the specified group\n        iii. ADD all roleValues to the Role\n        iv. STORE the new Role in the system\n     b. FOR updating an existing role:\n        i. RETRIEVE the existing Role using roleId\n        ii. IF role not found, THEN return error message \"Role not found\"\n        iii. UPDATE the Role with new permissions and values\n        iv. STORE the updated Role in the system\n     c. FOR deleting all roles from a group:\n        i. VERIFY deletion is explicitly requested\n        ii. REMOVE all roles associated with the specified group\n   - Handle transaction integrity:\n     a. ENSURE all changes are applied atomically\n     b. IF any operation fails, THEN revert all changes\n     c. LOG all permission changes for audit purposes\n\n5. Response Generation:\n   - For successful operations:\n     a. GENERATE success message with operation details\n     b. INCLUDE summary of applied permission changes\n     c. RETURN updated role information\n   - For failed operations:\n     a. GENERATE detailed error message\n     b. INCLUDE specific validation or business rule violation details\n     c. PROVIDE guidance on how to correct the issue",
    "databaseEntities": [
      "jforum_groups",
      "jforum_users",
      "jforum_user_groups",
      "jforum_roles",
      "jforum_role_values"
    ],
    "validationRules": [
      "Group ID must reference an existing group",
      "Role name must be unique within the system",
      "Role name cannot be empty",
      "User must have administrator privileges to manage roles",
      "Permission configuration must not violate system security constraints",
      "Role values must be valid for the specified role type",
      "Permission changes must not break existing role dependencies"
    ],
    "dbSeedingOperations": [
      "Insert default system roles",
      "Insert default administrator role with full permissions",
      "Insert default moderator role with limited permissions",
      "Insert default registered user role with basic permissions",
      "Insert default guest role with minimal permissions"
    ],
    "schema": {
      "PermissionSet": {
        "type": "object",
        "properties": {
          "canAccess": {
            "type": "boolean",
            "description": "Determines if the role has basic access permission"
          },
          "roleTypes": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "List of permission types assigned to the role"
          }
        }
      },
      "RoleValueCollection": {
        "type": "object",
        "properties": {
          "values": {
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "name": {
                  "type": "string",
                  "description": "Name of the role value"
                },
                "value": {
                  "type": "string",
                  "description": "Actual value for the role"
                }
              }
            },
            "description": "Collection of role values"
          }
        }
      }
    }
  },
  {
    "featureName": "CheckAccessPermission",
    "description": "Verifies if a user has access to specific forum features based on assigned roles.",
    "inputValues": [
      "roleName-string-Role",
      "roleValue-string-RoleValue",
      "userRoles-object-RoleCollection"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the following inputs:\n     a. roleName (mandatory): String identifier for the permission being checked\n     b. roleValue (optional): Specific value for the role if checking granular permissions\n     c. userRoles (mandatory): Collection of roles assigned to the current user\n\n2. Data Validation:\n   - Validate roleName input:\n     a. IF roleName is empty or null THEN\n        i. Return error message indicating role name is required\n        ii. Terminate permission check process\n     b. IF userRoles collection is null or empty THEN\n        i. Return error message indicating no roles are available for checking\n        ii. Terminate permission check process with access denied\n     c. IF roleValue is provided THEN\n        i. Validate that roleValue is not empty or null\n        ii. IF validation fails THEN return error message indicating invalid role value\n\n3. Business Rule Processing:\n   - Process permission check based on input parameters:\n     a. IF only roleName is provided (basic permission check) THEN\n        i. Check if the user has the specified role in their role collection\n        ii. IF role exists in collection THEN mark as authorized\n        iii. ELSE mark as unauthorized\n     b. IF both roleName and roleValue are provided (granular permission check) THEN\n        i. Check if the user has the specified role in their role collection\n        ii. IF role exists THEN\n            1. Retrieve the role's value collection\n            2. Check if the specified roleValue exists in the role's value collection\n            3. IF roleValue exists in collection THEN mark as authorized\n            4. ELSE mark as unauthorized\n        iii. ELSE mark as unauthorized\n\n4. Core Operation Execution:\n   - Based on the permission check results:\n     a. IF user is authorized THEN\n        i. Record successful permission check in system logs (if logging is enabled)\n        ii. Allow access to the requested feature or resource\n     b. ELSE (user is unauthorized)\n        i. Record failed permission check in system logs (if logging is enabled)\n        ii. Deny access to the requested feature or resource\n\n5. Response Generation:\n   - Generate appropriate response based on permission check outcome:\n     a. IF permission check was successful THEN\n        i. Return boolean value 'true' indicating user has permission\n        ii. Allow system to proceed with requested operation\n     b. ELSE (permission check failed)\n        i. Return boolean value 'false' indicating user lacks permission\n        ii. System should prevent access to the requested feature",
    "databaseEntities": [
      "jforum_users",
      "jforum_groups",
      "jforum_user_groups"
    ],
    "validationRules": [
      "Role name must not be empty",
      "User must have at least one assigned role",
      "When checking specific role values, the role must exist in user's role collection",
      "When checking specific role values, the role value must exist in the role's value collection"
    ],
    "dbSeedingOperations": [
      "Ensure default roles are created in the system",
      "Ensure administrator role has all permissions assigned"
    ],
    "schema": {
      "RoleCollection": {
        "type": "object",
        "properties": {
          "roles": {
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "name": {
                  "type": "string",
                  "description": "Unique identifier for the role"
                },
                "values": {
                  "type": "array",
                  "items": {
                    "type": "string",
                    "description": "Specific permission values associated with this role"
                  }
                }
              }
            }
          }
        }
      }
    }
  },
  {
    "featureName": "ValidateRoleValueAccess",
    "description": "Checks if a user has permission for specific role values within a role category.",
    "inputValues": [
      "roleName-string-Role",
      "roleValue-string-RoleValue",
      "userRoles-object-RoleCollection"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the following inputs:\n     a. roleName (string, mandatory): The name of the role category to check\n     b. roleValue (string, mandatory): The specific permission value to verify\n     c. userRoles (object, mandatory): Collection of roles assigned to the user\n\n2. Data Validation:\n   a. Validate roleName:\n      - IF roleName is empty or null THEN\n        - Return validation error: \"Role name must be provided\"\n      - END IF\n   b. Validate roleValue:\n      - IF roleValue is empty or null THEN\n        - Return validation error: \"Role value must be provided\"\n      - END IF\n   c. Validate userRoles:\n      - IF userRoles is null THEN\n        - Return validation error: \"User roles collection must be provided\"\n      - END IF\n\n3. Business Rule Processing:\n   a. Check if role exists:\n      - IF userRoles does not contain the specified roleName THEN\n        - Set accessGranted to FALSE\n        - Skip to Response Generation\n      - END IF\n   b. Retrieve role details:\n      - Get the Role object associated with roleName from userRoles\n      - IF Role object is null THEN\n        - Set accessGranted to FALSE\n        - Skip to Response Generation\n      - END IF\n\n4. Core Operation Execution:\n   a. Check role value permission:\n      - Get the RoleValues collection from the Role object\n      - Create a RoleValue object using the provided roleValue\n      - Check if the RoleValues collection contains the created RoleValue object\n      - IF RoleValues collection contains the RoleValue THEN\n        - Set accessGranted to TRUE\n      - ELSE\n        - Set accessGranted to FALSE\n      - END IF\n\n5. Response Generation:\n   a. Return access result:\n      - Return the accessGranted boolean value\n      - IF accessGranted is TRUE THEN\n        - Include success message: \"User has permission for the specified role value\"\n      - ELSE\n        - Include denial message: \"User does not have permission for the specified role value\"\n      - END IF",
    "databaseEntities": [
      "jforum_groups",
      "jforum_user_groups"
    ],
    "validationRules": [
      "Role name must not be empty",
      "Role value must not be empty",
      "User roles collection must be provided",
      "Role must exist in the user's role collection",
      "Role value must exist in the role's value collection to grant access"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "RoleCollection": {
        "type": "object",
        "properties": {
          "roles": {
            "type": "array",
            "items": {
              "$ref": "#/definitions/Role"
            }
          }
        },
        "required": [
          "roles"
        ]
      },
      "Role": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string"
          },
          "values": {
            "type": "array",
            "items": {
              "$ref": "#/definitions/RoleValue"
            }
          }
        },
        "required": [
          "name",
          "values"
        ]
      },
      "RoleValue": {
        "type": "object",
        "properties": {
          "value": {
            "type": "string"
          }
        },
        "required": [
          "value"
        ]
      }
    }
  },
  {
    "featureName": "AddSecurityRole",
    "description": "Adds security roles to users or groups with optional role values.",
    "inputValues": [
      "id-number-Entity",
      "role-object-Role",
      "roleValues-object-RoleValueCollection"
    ],
    "businessLogic": "1. Input Collection:\n   1.1. Collect the entity ID (required):\n       - Entity ID must be a positive integer representing a user or group\n       - System must determine if ID belongs to a user or group entity\n   1.2. Collect the role information (required):\n       - Role name must be provided as a non-empty string\n       - Role type must be specified (access, modification, administration, etc.)\n   1.3. Collect role values (optional):\n       - Collection of specific permissions or settings associated with the role\n       - Each role value must have a name and may have additional attributes\n\n2. Data Validation:\n   2.1. Validate entity ID:\n       - VERIFY that ID is a positive integer\n       - VERIFY that ID corresponds to an existing user or group in the system\n       - IF ID is invalid or not found, THEN return appropriate error message\n   2.2. Validate role information:\n       - VERIFY that role name is not empty\n       - VERIFY that role name follows system naming conventions\n       - VERIFY that role type is valid according to system definitions\n       - IF role information is invalid, THEN return appropriate error message\n   2.3. Validate role values (if provided):\n       - VERIFY that each role value has a valid name\n       - VERIFY that role values are compatible with the specified role\n       - IF any role value is invalid, THEN return appropriate error message\n\n3. Business Rule Processing:\n   3.1. Check for role assignment permissions:\n       - VERIFY that the current user has permission to assign roles\n       - VERIFY that the current user has access to the specified role\n       - IF permission check fails, THEN return authorization error\n   3.2. Check for role conflicts:\n       - VERIFY that the new role doesn't conflict with existing roles\n       - VERIFY that the role is appropriate for the entity type (user or group)\n       - IF conflicts exist, THEN return conflict error with details\n   3.3. Check system constraints:\n       - VERIFY that adding this role doesn't violate system constraints\n       - VERIFY that maximum number of roles per entity is not exceeded\n       - IF constraints are violated, THEN return constraint violation error\n\n4. Core Operation Execution:\n   4.1. Determine operation type based on inputs:\n       - IF only ID and role are provided, THEN perform basic role assignment\n       - IF ID, role, and role values are provided, THEN perform role assignment with values\n   4.2. Execute role assignment:\n       - FOR basic role assignment:\n           * Create association between entity and role\n           * Set default values for role if applicable\n       - FOR role assignment with values:\n           * Create association between entity and role\n           * Assign provided role values to the role\n   4.3. Update security cache:\n       - Refresh security permissions for affected entity\n       - Update any dependent security relationships\n   4.4. Log role assignment:\n       - Record role assignment details for audit purposes\n       - Include timestamp, entity ID, role details, and assigning user\n\n5. Response Generation:\n   5.1. Generate success response:\n       - Include confirmation message of successful role assignment\n       - Include summary of assigned role and values\n       - Include entity information that received the role\n   5.2. Generate error response (if needed):\n       - Include specific error code and message\n       - Include guidance on how to resolve the issue\n       - Include support reference information if applicable",
    "databaseEntities": [
      "jforum_users",
      "jforum_groups",
      "jforum_user_groups"
    ],
    "validationRules": [
      "Entity ID must be a positive integer",
      "Entity ID must correspond to an existing user or group",
      "Role name must not be empty",
      "Role name must follow system naming conventions",
      "Role values must be compatible with the specified role",
      "Current user must have permission to assign roles",
      "New role must not conflict with existing roles",
      "Maximum number of roles per entity must not be exceeded"
    ],
    "dbSeedingOperations": [
      "Ensure default roles exist in the system",
      "Ensure role types are properly defined"
    ],
    "schema": {
      "Role": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "description": "Unique name identifying the role"
          },
          "type": {
            "type": "string",
            "description": "Category or type of the role"
          },
          "description": {
            "type": "string",
            "description": "Detailed description of the role's purpose"
          }
        },
        "required": [
          "name"
        ]
      },
      "RoleValueCollection": {
        "type": "object",
        "properties": {
          "values": {
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "name": {
                  "type": "string",
                  "description": "Name of the role value"
                },
                "value": {
                  "type": "string",
                  "description": "Actual value or setting"
                }
              },
              "required": [
                "name"
              ]
            }
          }
        }
      }
    }
  },
  {
    "featureName": "AddPermission",
    "description": "Adds a permission item to a permission section.",
    "inputValues": [
      "permissionItem-object-PermissionItem",
      "permissionSection-object-PermissionSection"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the following inputs:\n     - permissionItem (mandatory): The permission item to be added\n     - permissionSection (mandatory): The permission section to which the item will be added\n\n2. Data Validation:\n   - Validate permissionItem:\n     - IF permissionItem is NULL THEN\n       - Generate error: \"Permission item cannot be null\"\n     - VERIFY permissionItem has valid id\n     - VERIFY permissionItem has valid name\n   - Validate permissionSection:\n     - IF permissionSection is NULL THEN\n       - Generate error: \"Permission section cannot be null\"\n     - VERIFY permissionSection has valid sectionId\n     - VERIFY permissionSection has valid sectionName\n     - VERIFY permissionSection has initialized permissions list\n\n3. Business Rule Processing:\n   - Check for duplicate permissions:\n     - FOR EACH existingItem IN permissionSection's permissions list\n       - IF existingItem.id equals permissionItem.id THEN\n         - Generate warning: \"Permission with this ID already exists in the section\"\n         - RETURN without adding (to prevent duplicates)\n   - Verify system state:\n     - VERIFY system is in a state that allows permission modifications\n     - VERIFY current user has authority to modify permissions\n\n4. Core Operation Execution:\n   - Add the permission item to the section:\n     - Append permissionItem to permissionSection's permissions list\n     - Update any internal indices or references\n   - IF addition fails due to system error THEN\n     - Revert any partial changes\n     - Generate error: \"Failed to add permission to section\"\n\n5. Response Generation:\n   - On success:\n     - Return updated permissionSection with newly added permission\n     - Include confirmation message: \"Permission successfully added to section\"\n   - On failure:\n     - Return appropriate error message\n     - Include guidance for resolving the issue",
    "databaseEntities": [
      "jforum_groups"
    ],
    "validationRules": [
      "Permission item must not be null",
      "Permission section must not be null",
      "Permission item must have a valid ID",
      "Permission item must have a valid name",
      "Permission section must have a valid section ID",
      "Permission section must have a valid section name",
      "Permission section must have an initialized permissions list",
      "Duplicate permission items are not allowed in the same section"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "PermissionItem": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "Unique identifier for the permission item"
          },
          "name": {
            "type": "string",
            "description": "Display name of the permission item"
          }
        },
        "required": [
          "id",
          "name"
        ]
      },
      "PermissionSection": {
        "type": "object",
        "properties": {
          "sectionId": {
            "type": "string",
            "description": "Unique identifier for the permission section"
          },
          "sectionName": {
            "type": "string",
            "description": "Display name of the permission section"
          },
          "permissionItems": {
            "type": "array",
            "items": {
              "$ref": "#/PermissionItem"
            },
            "description": "List of permission items in this section"
          }
        },
        "required": [
          "sectionId",
          "sectionName",
          "permissionItems"
        ]
      }
    }
  },
  {
    "featureName": "GetPermissions",
    "description": "Retrieves the list of permission items in a section.",
    "inputValues": [
      "sectionId-string-PermissionSection",
      "sectionName-string-PermissionSection"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect sectionId (mandatory): Unique identifier for the permission section\n   - Collect sectionName (mandatory): Display name of the permission section\n   - System will use an internal list to store permission items (system-generated)\n\n2. Data Validation:\n   - Validate sectionId:\n     a. Check if sectionId is not empty\n     b. Verify sectionId follows the required format\n     c. If validation fails, generate appropriate error message\n   - Validate sectionName:\n     a. Check if sectionName is not empty\n     b. If validation fails, generate appropriate error message\n\n3. Business Rule Processing:\n   - Verify system state:\n     a. Check if the permission system is properly initialized\n     b. Verify the user has access to view permissions\n   - Check section existence:\n     a. IF sectionId exists in the system\n        THEN proceed with retrieval\n     b. ELSE return appropriate error message\n\n4. Core Operation Execution:\n   - Retrieve permission items:\n     a. Access the internal list of permission items for the specified section\n     b. Prepare the list for return\n     c. IF no permission items exist\n        THEN return an empty list\n        ELSE return the complete list of permission items\n   - Handle any retrieval errors:\n     a. Log the error details\n     b. Prepare appropriate error response\n\n5. Response Generation:\n   - Success response:\n     a. Return the list of permission items\n     b. Include section metadata (sectionId, sectionName)\n     c. Format the response according to system requirements\n   - Error response:\n     a. Include error code and message\n     b. Provide guidance on how to resolve the issue\n     c. Include support reference if applicable",
    "databaseEntities": [
      "jforum_users",
      "jforum_groups"
    ],
    "validationRules": [
      "Section ID must not be empty",
      "Section name must not be empty",
      "User must have permission to view the section"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "PermissionItem": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "Unique identifier for the permission item"
          },
          "name": {
            "type": "string",
            "description": "Display name of the permission item"
          },
          "description": {
            "type": "string",
            "description": "Detailed description of the permission item"
          }
        },
        "required": [
          "id",
          "name"
        ]
      },
      "PermissionSection": {
        "type": "object",
        "properties": {
          "sectionId": {
            "type": "string",
            "description": "Unique identifier for the section"
          },
          "sectionName": {
            "type": "string",
            "description": "Display name of the section"
          },
          "permissions": {
            "type": "array",
            "items": {
              "$ref": "#/PermissionItem"
            },
            "description": "List of permission items in this section"
          }
        },
        "required": [
          "sectionId",
          "sectionName",
          "permissions"
        ]
      }
    }
  },
  {
    "featureName": "GetSectionId",
    "description": "Retrieves the identifier of a permission section.",
    "inputValues": [
      "sectionId-string-PermissionSection"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the following inputs:\n     - sectionId (string, mandatory): The identifier of the permission section to retrieve\n\n2. Data Validation:\n   - Validate sectionId input:\n     - Check if sectionId is not null or empty\n     - IF sectionId is null or empty THEN\n       - Generate validation error message: \"Section identifier cannot be empty\"\n       - Return error response\n     - END IF\n\n3. Business Rule Processing:\n   - Verify permission section exists:\n     - Check if the requested permission section exists in the system\n     - IF permission section does not exist THEN\n       - Generate error message: \"Permission section not found\"\n       - Return error response\n     - END IF\n   - Verify user has access rights to view permission section:\n     - Check if the current user has sufficient privileges to access the section\n     - IF user lacks necessary access rights THEN\n       - Generate error message: \"Insufficient privileges to access this permission section\"\n       - Return error response\n     - END IF\n\n4. Core Operation Execution:\n   - Retrieve section identifier:\n     - Locate the permission section using the provided sectionId\n     - Extract the section identifier from the permission section\n     - Store the section identifier for response\n\n5. Response Generation:\n   - Prepare success response:\n     - Include the retrieved section identifier\n     - Include section metadata if available (such as section name)\n   - Handle potential errors:\n     - If section identifier could not be retrieved, provide appropriate error message\n     - Include support information for troubleshooting",
    "databaseEntities": [
      "jforum_groups"
    ],
    "validationRules": [
      "Section identifier must not be null or empty",
      "Permission section must exist in the system",
      "User must have sufficient privileges to access the permission section"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "PermissionSection": {
        "type": "object",
        "properties": {
          "sectionId": {
            "type": "string",
            "description": "Unique identifier for the permission section"
          },
          "sectionName": {
            "type": "string",
            "description": "Display name of the permission section"
          },
          "permissions": {
            "type": "array",
            "items": {
              "type": "object",
              "description": "Permission items associated with this section"
            }
          }
        },
        "required": [
          "sectionId",
          "sectionName"
        ]
      }
    }
  },
  {
    "featureName": "GetSectionName",
    "description": "Retrieves the name of a permission section from the system.",
    "inputValues": [
      "sectionId-string-PermissionSection"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect sectionId (string, mandatory) to identify the permission section\n   - System will use the current permission section context if available\n\n2. Data Validation:\n   - Validate sectionId:\n     a. Check if sectionId is not null or empty\n     b. Verify sectionId format follows system naming conventions\n     c. IF validation fails, THEN prepare appropriate error message\n\n3. Business Rule Processing:\n   - Check system state:\n     a. Verify permission system is initialized\n     b. Ensure user has access rights to view permission information\n   - Check section existence:\n     a. Verify the requested section exists in the system\n     b. IF section does not exist, THEN prepare 'section not found' error\n\n4. Core Operation Execution:\n   - Retrieve section information:\n     a. Locate the permission section using the provided sectionId\n     b. Extract the section name from the found section\n     c. IF section retrieval fails, THEN prepare system error message\n\n5. Response Generation:\n   - Success response:\n     a. Return the section name as a string value\n     b. Include section metadata if requested\n   - Error response:\n     a. Return appropriate error code and message\n     b. Include troubleshooting information if applicable",
    "databaseEntities": [
      "jforum_groups"
    ],
    "validationRules": [
      "Section ID must not be empty",
      "Section must exist in the system",
      "User must have permission to view section information"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "PermissionSection": {
        "type": "object",
        "properties": {
          "sectionName": {
            "type": "string",
            "description": "The display name of the permission section"
          },
          "sectionId": {
            "type": "string",
            "description": "The unique identifier for the permission section"
          },
          "permissionItems": {
            "type": "array",
            "description": "List of permission items belonging to this section",
            "items": {
              "type": "object",
              "properties": {
                "name": {
                  "type": "string"
                },
                "id": {
                  "type": "string"
                }
              }
            }
          }
        },
        "required": [
          "sectionName",
          "sectionId"
        ]
      }
    }
  },
  {
    "featureName": "GetRole",
    "description": "Retrieves a security role by name from the collection of roles.",
    "inputValues": [
      "roleName-string-Role"
    ],
    "businessLogic": "1. Input Collection\n   - Collect the following input:\n     - roleName (string, mandatory): The name of the role to retrieve\n   - No default values are provided\n   - No system-generated fields are required\n\n2. Data Validation\n   - Validate roleName input:\n     - Check if roleName is provided\n       IF roleName is null or empty THEN\n         Generate an error message: \"Role name must be provided\"\n     - Check if roleName is a valid string\n       IF roleName is not a valid string THEN\n         Generate an error message: \"Role name must be a valid string\"\n\n3. Business Rule Processing\n   - Check if the role collection is initialized\n     IF role collection is not initialized THEN\n       Generate an error message: \"Role collection is not available\"\n   - Verify that the system is in a valid state to retrieve roles\n     IF system is not in a valid state THEN\n       Generate an error message: \"System is not ready to perform role operations\"\n\n4. Core Operation Execution\n   - Search for the requested role in the collection\n     - Look up the role using the provided roleName as the key\n     - IF role is found THEN\n       - Prepare the role data for return\n     - ELSE\n       - Set result to null indicating role was not found\n\n5. Response Generation\n   - IF role was found THEN\n     - Return the role object with its properties\n     - Include the role name and associated permissions\n   - ELSE\n     - Return null or appropriate indicator that role was not found\n     - Provide information that the requested role does not exist in the collection",
    "databaseEntities": [
      "jforum_users",
      "jforum_groups",
      "jforum_user_groups"
    ],
    "validationRules": [
      "Role name must not be empty",
      "Role collection must be initialized before retrieval",
      "System must be in a valid state to perform role operations"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Role": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "description": "The unique name of the security role"
          },
          "permissions": {
            "type": "array",
            "description": "List of permissions associated with this role",
            "items": {
              "type": "string"
            }
          }
        },
        "required": [
          "name"
        ]
      }
    }
  },
  {
    "featureName": "DisplayRoles",
    "description": "Generates a string representation of all roles in the collection.",
    "inputValues": [
      "roleCollection-object-RoleCollection"
    ],
    "businessLogic": "1. Input Collection:\n   - Obtain the roleCollection object containing all roles\n   - Verify the roleCollection is not null\n\n2. Data Validation:\n   - Validate that the roleCollection is properly initialized\n   - Verify that the roleCollection contains at least one role\n   - IF roleCollection is null THEN\n     - Return an appropriate error message\n   - IF roleCollection is empty THEN\n     - Return an empty string representation\n\n3. Business Rule Processing:\n   - Determine the appropriate string format for role representation\n   - Verify that each role in the collection has a valid name\n   - Ensure sufficient buffer capacity for the string representation\n   - Prepare for sequential processing of all roles\n\n4. Core Operation Execution:\n   - Initialize a string buffer with appropriate capacity\n   - Retrieve an iterator for all values in the roleCollection\n   - WHILE there are more roles in the iterator DO\n     - Get the next role from the iterator\n     - Append the string representation of the role to the buffer\n     - Append a newline character after each role\n   - END WHILE\n   - Convert the buffer to a string\n\n5. Response Generation:\n   - Return the generated string representation of all roles\n   - Ensure the string contains one role per line\n   - Verify the string accurately represents all roles in the collection",
    "databaseEntities": [
      "jforum_groups",
      "jforum_user_groups"
    ],
    "validationRules": [
      "RoleCollection must not be null",
      "Each Role must have a valid name",
      "String representation must include all roles in the collection",
      "Each role must be on a separate line in the output"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "RoleCollection": {
        "type": "object",
        "properties": {
          "roles": {
            "type": "array",
            "items": {
              "$ref": "#/definitions/Role"
            }
          }
        },
        "definitions": {
          "Role": {
            "type": "object",
            "properties": {
              "name": {
                "type": "string"
              },
              "actions": {
                "type": "array",
                "items": {
                  "type": "string"
                }
              }
            }
          }
        }
      }
    }
  },
  {
    "featureName": "GetRoleValueByName",
    "description": "Retrieves a RoleValue object by its name from the collection.",
    "inputValues": [
      "valueName-string-RoleValue"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the following inputs:\n     a. valueName (string, mandatory): The name of the RoleValue to retrieve\n\n2. Data Validation:\n   - Validate the valueName input:\n     a. Check if valueName is provided\n        IF valueName is null or empty THEN\n          Return appropriate error message indicating valueName is required\n     b. Check if valueName is of valid format\n        IF valueName format is invalid THEN\n          Return appropriate error message indicating invalid format\n\n3. Business Rule Processing:\n   - Verify collection access:\n     a. Check if the RoleValue collection is accessible\n        IF collection is not accessible THEN\n          Return appropriate error message indicating collection access issue\n     b. Check if the user has permission to access the collection\n        IF user lacks permission THEN\n          Return appropriate error message indicating permission issue\n\n4. Core Operation Execution:\n   - Search for the requested RoleValue:\n     a. Initialize result variable to null\n     b. Iterate through each item in the collection:\n        FOR each item in the collection DO\n          IF current item is a RoleValue object THEN\n            IF current item's value matches the requested valueName THEN\n              Set result to current item\n              Exit the loop\n        END FOR\n     c. Handle search completion:\n        IF no matching RoleValue was found THEN\n          Prepare null result\n\n5. Response Generation:\n   - Generate appropriate response:\n     a. IF a matching RoleValue was found THEN\n          Return the found RoleValue object with its properties\n     b. ELSE\n          Return null to indicate no matching RoleValue was found\n     c. Include any relevant metadata about the search operation\n        (e.g., time taken, number of items searched)",
    "databaseEntities": [],
    "validationRules": [
      "The valueName parameter must not be null or empty",
      "The collection must be accessible",
      "Only RoleValue objects can be added to the collection"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "RoleValue": {
        "type": "object",
        "properties": {
          "value": {
            "type": "string",
            "description": "The name/value of the role value"
          }
        },
        "required": [
          "value"
        ]
      }
    }
  },
  {
    "featureName": "AddMultipleRoleValues",
    "description": "Adds multiple RoleValue objects from another collection to the current RoleValueCollection.",
    "inputValues": [
      "sourceCollection-object-Collection"
    ],
    "businessLogic": "1. Input Collection:\n   1.1. Collect the source collection containing RoleValue objects\n       1.1.1. The source collection is mandatory\n       1.1.2. The source collection must implement the Collection interface\n\n2. Data Validation:\n   2.1. Validate the source collection\n       2.1.1. Check if the source collection is not null\n       2.1.2. IF source collection is null THEN\n             - Generate an error indicating invalid input\n             - Abort the operation\n       2.1.3. Check if the source collection is not empty\n       2.1.4. IF source collection is empty THEN\n             - No action needed, return success with no changes made\n\n3. Business Rule Processing:\n   3.1. Verify compatibility of source collection items\n       3.1.1. FOR EACH item in the source collection DO\n             - Check if the item is an instance of RoleValue\n             - IF item is not a RoleValue THEN\n               * Flag the item as invalid\n               * Prepare appropriate error message\n       3.1.2. IF any invalid items were found THEN\n             - Generate an error indicating incompatible collection items\n             - Abort the operation\n\n4. Core Operation Execution:\n   4.1. Process each item in the source collection\n       4.1.1. Initialize a status flag to track overall success\n       4.1.2. FOR EACH item in the source collection DO\n             - Attempt to add the item to the current collection\n             - IF addition fails (e.g., duplicate item) THEN\n               * Update status flag to indicate partial success\n       4.1.3. Track the number of successfully added items\n\n5. Response Generation:\n   5.1. Generate appropriate response based on operation outcome\n       5.1.1. IF all items were added successfully THEN\n             - Return true indicating complete success\n       5.1.2. IF some items failed to be added THEN\n             - Return status flag indicating partial success\n       5.1.3. Include count of successfully added items in the response",
    "databaseEntities": [],
    "validationRules": [
      "Source collection must not be null",
      "All items in source collection must be RoleValue objects",
      "Duplicate RoleValue objects will not be added again"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Collection": {
        "type": "object",
        "description": "A collection of RoleValue objects",
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/RoleValue"
            }
          }
        }
      },
      "RoleValue": {
        "type": "object",
        "description": "Represents a security role value",
        "properties": {
          "value": {
            "type": "string",
            "description": "The name or identifier of the role value"
          }
        }
      }
    }
  },
  {
    "featureName": "LoadPermissionConfigurations",
    "description": "Loads permission configurations from XML file and builds a structured permission hierarchy.",
    "inputValues": [
      "xmlFilePath-string-Configuration",
      "permissionControl-object-PermissionControl"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect xmlFilePath (string): Path to the XML configuration file\n   - Collect permissionControl (object): Current permission control system\n   - System will initialize empty lists and maps for storing configuration data\n\n2. Data Validation:\n   - Validate xmlFilePath:\n     * Check if the path is not empty\n     * Verify the file exists or is accessible as a resource\n     * Ensure the file has valid XML format\n   - Validate permissionControl:\n     * Verify the permission control object is properly initialized\n     * Ensure it contains necessary methods for permission management\n   - IF any validation fails THEN:\n     * Generate appropriate error message\n     * Terminate the process\n\n3. Business Rule Processing:\n   - Check system readiness:\n     * Verify XML parsing capabilities are available\n     * Ensure internationalization system is initialized for translating permission titles\n     * Verify database connection is available if SQL references are used\n   - Prepare data structures:\n     * Initialize section list for organizing permissions\n     * Create permission data collection for storing permission items\n     * Set up query cache for database-driven permission options\n\n4. Core Operation Execution:\n   - Parse XML Configuration File:\n     * Initialize XML parser\n     * Process XML file content using SAX parsing\n     * FOR each section element encountered:\n       > Create new permission section with translated title\n       > Store section ID for reference\n     * FOR each permission element encountered:\n       > Extract and translate permission title\n       > Store permission ID and type\n       > Process child elements (SQL or option tags)\n     * FOR each SQL element:\n       > IF reference name is provided THEN:\n         # Execute the referenced query\n         # Store results in query cache using reference name\n       > IF reference attribute is provided THEN:\n         # Retrieve cached query results\n         # Compare with current role values\n         # Create form selection data with appropriate selection state\n     * FOR each option element:\n       > Determine if option should be selected based on permission type\n       > Create form selection data with translated description\n     * Add completed permission items to their respective sections\n   - Build Permission Hierarchy:\n     * Organize all parsed sections into a structured hierarchy\n     * Link permissions to their parent sections\n     * Establish relationships between permissions\n\n5. Response Generation:\n   - Return structured permission configuration:\n     * List of section objects containing permission items\n     * Each permission item containing selection options\n     * Selection state for each option based on current permissions\n   - IF parsing errors occurred THEN:\n     * Return error details with parsing failure information\n     * Include line and position of XML syntax errors if applicable\n   - IF system errors occurred THEN:\n     * Return error details with system failure information\n     * Include suggestions for resolving configuration issues",
    "databaseEntities": [
      "jforum_groups",
      "jforum_users",
      "jforum_user_groups"
    ],
    "validationRules": [
      "XML file path must not be empty",
      "XML file must exist or be accessible as a resource",
      "XML file must contain valid permission configuration format",
      "Permission control object must be properly initialized",
      "Section elements must have title and id attributes",
      "Permission elements must have title, id, and type attributes",
      "SQL elements must have valid reference or query attributes"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "PermissionControl": {
        "type": "object",
        "properties": {
          "role": {
            "type": "object",
            "description": "Current role being evaluated"
          },
          "canAccess": {
            "type": "function",
            "description": "Method to check if a permission is granted"
          },
          "getRole": {
            "type": "function",
            "description": "Method to retrieve role information by permission ID"
          }
        }
      },
      "PermissionSection": {
        "type": "object",
        "properties": {
          "title": {
            "type": "string",
            "description": "Translated section title"
          },
          "id": {
            "type": "string",
            "description": "Unique section identifier"
          },
          "permissions": {
            "type": "array",
            "description": "List of permission items in this section",
            "items": {
              "$ref": "#/PermissionItem"
            }
          }
        }
      },
      "PermissionItem": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "description": "Translated permission name"
          },
          "id": {
            "type": "string",
            "description": "Unique permission identifier"
          },
          "type": {
            "type": "string",
            "description": "Permission type (single or multiple)"
          },
          "data": {
            "type": "array",
            "description": "Selection options for this permission",
            "items": {
              "$ref": "#/FormSelectedData"
            }
          }
        }
      },
      "FormSelectedData": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "description": "Option display name"
          },
          "value": {
            "type": "string",
            "description": "Option value"
          },
          "selected": {
            "type": "boolean",
            "description": "Whether this option is selected"
          }
        }
      }
    }
  },
  {
    "featureName": "ParsePermissionSections",
    "description": "Parses XML permission sections with their associated permission items and settings.",
    "inputValues": [
      "xmlFile-string-PermissionFile",
      "permissionControl-object-PermissionControl"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the XML file path (xmlFile) containing permission definitions\n   - Obtain reference to the permission control system (permissionControl)\n   - Initialize empty lists to store sections, permission data, and queries\n\n2. Data Validation:\n   - Validate that the XML file exists and is accessible\n     - IF file does not exist as a direct file path, attempt to load it as a resource\n     - IF file cannot be accessed, generate appropriate error message\n   - Validate that the XML file contains valid permission structure\n     - Ensure XML has proper format with section and permission elements\n     - Verify required attributes are present in XML elements\n\n3. Business Rule Processing:\n   - Initialize XML parser with appropriate settings\n     - Configure SAX parser factory\n     - Set validation mode to false\n   - Create section collection structure to hold parsed data\n   - Verify permission control system is properly initialized\n   - Check system state for internationalization support\n\n4. Core Operation Execution:\n   - Parse XML file using SAX parser\n     - FOR each 'section' element encountered:\n       - Extract section title (translate if internationalized)\n       - Extract section identifier\n       - Create new permission section object\n     - FOR each 'permission' element within a section:\n       - Extract permission title, id, and type\n       - Initialize permission data collection\n       - Process child elements based on their type:\n         - IF element is 'sql':\n           - IF element has 'refName' attribute:\n             - Execute referenced query\n             - Store results for later use\n           - ELSE IF element has 'ref' attribute:\n             - Retrieve previously stored query results\n             - Compare with current role values\n             - Create selection data based on comparison\n         - IF element is 'option':\n           - Determine if option should be selected based on permission type\n           - Add option to permission data collection\n       - Create permission item with collected data\n       - Add permission item to current section\n     - Add completed section to sections list\n   - Handle any exceptions during parsing process\n\n5. Response Generation:\n   - Return the complete list of permission sections\n   - Each section contains:\n     - Section title and identifier\n     - Collection of permission items\n     - Each permission item contains:\n       - Permission name, id, and type\n       - Associated permission data with selection status\n   - IF errors occurred during parsing, provide error details\n   - Include any warnings about unsupported features",
    "databaseEntities": [
      "jforum_groups",
      "jforum_user_groups"
    ],
    "validationRules": [
      "XML file must exist and be accessible",
      "XML file must contain valid permission structure",
      "Section elements must have title and id attributes",
      "Permission elements must have title, id, and type attributes",
      "SQL references must point to valid query definitions",
      "Permission types must be supported (single or multiple)"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "PermissionControl": {
        "type": "object",
        "properties": {
          "role": {
            "type": "object",
            "description": "Current role being evaluated"
          },
          "canAccess": {
            "type": "function",
            "description": "Function to check if permission is granted"
          },
          "getRole": {
            "type": "function",
            "description": "Function to retrieve role information"
          }
        }
      },
      "PermissionSection": {
        "type": "object",
        "properties": {
          "title": {
            "type": "string",
            "description": "Section title"
          },
          "id": {
            "type": "string",
            "description": "Section identifier"
          },
          "permissions": {
            "type": "array",
            "description": "Collection of permission items",
            "items": {
              "$ref": "#/PermissionItem"
            }
          }
        }
      },
      "PermissionItem": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "description": "Permission name"
          },
          "id": {
            "type": "string",
            "description": "Permission identifier"
          },
          "type": {
            "type": "string",
            "description": "Permission type (single or multiple)"
          },
          "data": {
            "type": "array",
            "description": "Permission selection data",
            "items": {
              "$ref": "#/FormSelectedData"
            }
          }
        }
      },
      "FormSelectedData": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "description": "Display name"
          },
          "value": {
            "type": "string",
            "description": "Value identifier"
          },
          "selected": {
            "type": "boolean",
            "description": "Selection status"
          }
        }
      }
    }
  },
  {
    "featureName": "RetrieveRoleBasedPermissions",
    "description": "Retrieves and processes role-based permissions from database using SQL templates.",
    "inputValues": [
      "roleId-string-Role",
      "permissionId-string-Permission",
      "permissionType-string-Permission"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect roleId (mandatory): The identifier of the role to retrieve permissions for\n   - Collect permissionId (mandatory): The identifier of the permission to check\n   - Collect permissionType (mandatory): The type of permission (e.g., 'single', 'multiple')\n   - System will use predefined SQL templates for permission retrieval\n\n2. Data Validation:\n   - Validate roleId:\n     a. Check if roleId is not empty\n     b. Verify roleId exists in the system\n     c. Return error if roleId is invalid: \"Invalid role identifier provided\"\n   - Validate permissionId:\n     a. Check if permissionId is not empty\n     b. Verify permissionId exists in the permission registry\n     c. Return error if permissionId is invalid: \"Invalid permission identifier provided\"\n   - Validate permissionType:\n     a. Check if permissionType is either 'single' or 'multiple'\n     b. Return error if permissionType is invalid: \"Permission type must be 'single' or 'multiple'\"\n\n3. Business Rule Processing:\n   - Check system state:\n     a. Verify permission system is initialized\n     b. Verify database connection is available\n     c. IF permission system is not initialized, THEN initialize it\n   - Verify permission configuration:\n     a. Check if XML permission definitions are loaded\n     b. IF not loaded, THEN load XML permission configurations\n     c. Verify the requested permission exists in the configuration\n   - Determine query template:\n     a. Select appropriate SQL template based on permissionId and permissionType\n     b. IF template does not exist, THEN return error: \"Permission query template not found\"\n\n4. Core Operation Execution:\n   - Retrieve role information:\n     a. Load role data using roleId\n     b. Extract role values collection from the role\n     c. IF role not found, THEN create empty role values collection\n   - Execute permission query:\n     a. Prepare SQL query using the selected template\n     b. Execute query to retrieve permission data\n     c. Process query results into permission data structure\n     d. For each result row:\n        i. Extract value field and caption field\n        ii. Create selection data entry\n        iii. Check if the permission is granted for the role\n        iv. Mark selection as selected based on permission status\n   - Build permission section:\n     a. Create permission section with appropriate title and identifier\n     b. Add permission items to the section\n     c. Associate permission data with each permission item\n\n5. Response Generation:\n   - Prepare success response:\n     a. Format permission data into structured response\n     b. Include section information (title, id)\n     c. Include permission items (name, id, type)\n     d. Include selection options with selected status\n   - Handle potential errors:\n     a. Database connection errors: \"Unable to connect to permission database\"\n     b. XML parsing errors: \"Error parsing permission configuration\"\n     c. Permission retrieval errors: \"Error retrieving role permissions\"\n   - Return complete permission data structure",
    "databaseEntities": [
      "jforum_users",
      "jforum_groups",
      "jforum_user_groups"
    ],
    "validationRules": [
      "Role identifier must exist in the system",
      "Permission identifier must exist in the permission registry",
      "Permission type must be either 'single' or 'multiple'",
      "XML permission configuration must be properly formatted",
      "Database connection must be available for permission retrieval"
    ],
    "dbSeedingOperations": [
      "Ensure basic role types exist (Administrator, Moderator, User)",
      "Ensure permission types are defined in the system",
      "Ensure permission-role relationships are initialized"
    ],
    "schema": {
      "Role": {
        "id": "string",
        "name": "string",
        "values": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "id": "string",
              "value": "string"
            }
          }
        }
      },
      "Permission": {
        "id": "string",
        "name": "string",
        "type": "string",
        "options": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "name": "string",
              "value": "string",
              "selected": "boolean"
            }
          }
        }
      },
      "PermissionSection": {
        "title": "string",
        "id": "string",
        "permissions": {
          "type": "array",
          "items": {
            "$ref": "#/Permission"
          }
        }
      }
    }
  },
  {
    "featureName": "ValidateLDAPLogin",
    "description": "Authenticates users against LDAP server using provided credentials.",
    "inputValues": [
      "username-string-User",
      "password-string-User",
      "extraParams-object-Parameters"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect username (string, mandatory)\n   - Collect password (string, mandatory)\n   - Collect extraParams (object, optional)\n\n2. Data Validation:\n   - Validate username:\n     a. Check if username is not empty\n     b. Check if username follows allowed format\n     c. Generate error message if validation fails\n   - Validate password:\n     a. Check if password is not empty\n     b. Generate error message if validation fails\n\n3. Business Rule Processing:\n   - Prepare LDAP environment:\n     a. Set up initial context factory\n     b. Configure provider URL\n     c. Set security protocol if specified\n     d. Set authentication method if specified\n   - Construct principal identifier:\n     a. Combine login prefix with username\n     b. Append login suffix\n   - Set security credentials:\n     a. Add principal to environment\n     b. Add password to environment\n\n4. Core Operation Execution:\n   - Attempt LDAP authentication:\n     a. Create directory context using environment settings\n     b. IF authentication fails:\n        i. Return authentication failure result\n     c. IF authentication succeeds:\n        i. Determine lookup parameters\n        ii. Set lookup prefix to login prefix if not specified\n        iii. Set lookup suffix to login suffix if not specified\n        iv. Construct lookup principal\n        v. Retrieve user email attribute from directory\n   - Process authenticated user:\n     a. Check if user exists in local system\n     b. IF user does not exist:\n        i. Extract email from attributes (use default if not available)\n        ii. Register new user in the system\n     c. Retrieve complete user information\n\n5. Response Generation:\n   - Success response:\n     a. Return authenticated user object with all relevant details\n   - Error response:\n     a. Return authentication failure indicator\n     b. Include appropriate error message\n   - Cleanup:\n     a. Close directory context connection",
    "databaseEntities": [
      "jforum_users",
      "jforum_user_groups"
    ],
    "validationRules": [
      "Username must not be empty",
      "Password must not be empty",
      "LDAP server connection must be available",
      "LDAP configuration must be properly set",
      "User principal must be correctly formatted"
    ],
    "dbSeedingOperations": [
      "Ensure LDAP configuration settings are present in system configuration"
    ],
    "schema": {
      "Parameters": {
        "type": "object",
        "properties": {
          "additionalSettings": {
            "type": "object",
            "description": "Optional additional parameters for authentication"
          }
        }
      },
      "User": {
        "type": "object",
        "properties": {
          "id": {
            "type": "number",
            "description": "User identifier"
          },
          "username": {
            "type": "string",
            "description": "User login name"
          },
          "email": {
            "type": "string",
            "description": "User email address"
          },
          "groups": {
            "type": "array",
            "description": "User group memberships",
            "items": {
              "type": "object"
            }
          }
        }
      }
    }
  },
  {
    "featureName": "RegisterLDAPUser",
    "description": "Registers new users in the system when authenticated via LDAP but not existing locally.",
    "inputValues": [
      "username-string-User",
      "password-string-User",
      "ldapAttributes-object-LDAPAttributes"
    ],
    "businessLogic": "1. Input Collection\n   1.1. Collect user credentials\n      1.1.1. Obtain username (mandatory)\n      1.1.2. Obtain password (mandatory)\n   1.2. Prepare LDAP connection parameters\n      1.2.1. Set LDAP server connection details from system configuration\n      1.2.2. Set authentication method from system configuration\n      1.2.3. Set security protocol if configured\n\n2. Data Validation\n   2.1. Validate username\n      2.1.1. Verify username is not empty\n      2.1.2. Check username format according to system requirements\n   2.2. Validate password\n      2.2.1. Verify password is not empty\n      2.2.2. Check password meets minimum complexity requirements\n\n3. Business Rule Processing\n   3.1. Authenticate against LDAP server\n      3.1.1. Construct user principal using configured prefix and suffix\n      3.1.2. Attempt connection to LDAP server with provided credentials\n      3.1.3. IF authentication fails, THEN\n         3.1.3.1. Return authentication failure\n      3.1.4. IF authentication succeeds, THEN\n         3.1.4.1. Proceed to user verification\n   3.2. Check if user exists in local system\n      3.2.1. Query local database for username\n      3.2.2. IF user exists locally, THEN\n         3.2.2.1. Skip registration process\n      3.2.3. IF user does not exist locally, THEN\n         3.2.3.1. Proceed to user registration\n\n4. Core Operation Execution\n   4.1. Retrieve user attributes from LDAP\n      4.1.1. Construct lookup principal using configured prefix and suffix\n      4.1.2. Retrieve email attribute from LDAP directory\n      4.1.3. IF email attribute is not found, THEN\n         4.1.3.1. Use default \"noemail\" value\n   4.2. Register new user in local system\n      4.2.1. Create new user record with username\n      4.2.2. Set user email from LDAP attributes\n      4.2.3. Set authentication type as \"ldap\"\n      4.2.4. Set default user role and permissions\n      4.2.5. Set account status as active\n      4.2.6. Save user to database\n      4.2.7. IF saving fails, THEN\n         4.2.7.1. Log error details\n         4.2.7.2. Return registration failure\n\n5. Response Generation\n   5.1. Generate success response\n      5.1.1. Include user information in response\n      5.1.2. Set authentication status as successful\n      5.1.3. Include registration status (new or existing user)\n   5.2. Handle error responses\n      5.2.1. For authentication failures, return appropriate error message\n      5.2.2. For registration failures, return appropriate error message\n      5.2.3. For system errors, return general error message with support information",
    "databaseEntities": [
      "jforum_users",
      "jforum_user_groups"
    ],
    "validationRules": [
      "Username must not be empty",
      "Password must not be empty",
      "LDAP authentication must succeed before user registration",
      "User must not already exist in the local system before registration",
      "Email must be retrieved from LDAP or set to default value"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "LDAPAttributes": {
        "type": "object",
        "properties": {
          "email": {
            "type": "string",
            "description": "User's email address retrieved from LDAP"
          },
          "fullName": {
            "type": "string",
            "description": "User's full name from LDAP directory"
          },
          "additionalAttributes": {
            "type": "object",
            "description": "Any additional attributes retrieved from LDAP"
          }
        }
      }
    }
  },
  {
    "featureName": "AuthenticateRemoteUser",
    "description": "Authenticates users by verifying their identity through remote user information and validates active sessions.",
    "inputValues": [
      "request-object-RequestContext",
      "userSession-object-UserSession"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the RequestContext object which contains user request information\n   - Collect the UserSession object for session validation (optional, used only for session validation)\n   - System will retrieve anonymous user ID from system configuration\n\n2. Data Validation:\n   - Verify the RequestContext object is not null\n     * IF RequestContext is null THEN return authentication failure\n   - For session validation, verify UserSession object is not null\n     * IF UserSession is null AND session validation is requested THEN return session invalid\n\n3. Business Rule Processing:\n   3.1. For user authentication:\n     - Extract remote user information from the request\n     - No additional processing required for the remote user value\n   \n   3.2. For session validation:\n     - Extract remote user information from the request\n     - Retrieve current user ID from the session\n     - Retrieve anonymous user ID from system configuration\n     - Compare the following conditions:\n       * IF remote user is null AND current user is not anonymous THEN\n         - User has logged out since session creation\n         - Session is invalid\n       * ELSE IF remote user is not null AND current user is anonymous THEN\n         - User has logged in since session creation\n         - Session is invalid\n       * ELSE IF remote user is not null AND remote user does not match session username THEN\n         - User identity has changed\n         - Session is invalid\n       * ELSE\n         - Session is valid\n\n4. Core Operation Execution:\n   4.1. For user authentication:\n     - Return the extracted remote user identifier\n     - No data modifications are performed\n   \n   4.2. For session validation:\n     - Return boolean result indicating if the session is valid\n     - No data modifications are performed\n\n5. Response Generation:\n   5.1. For user authentication:\n     - Return username string if authentication successful\n     - Return null if no remote user is found\n   \n   5.2. For session validation:\n     - Return true if session is valid\n     - Return false if session is invalid",
    "databaseEntities": [
      "jforum_users",
      "jforum_sessions"
    ],
    "validationRules": [
      "Request context must not be null",
      "User session must not be null for session validation",
      "Session is invalid if remote user is null but session user is not anonymous",
      "Session is invalid if remote user exists but session user is anonymous",
      "Session is invalid if remote user exists but doesn't match session username"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "RequestContext": {
        "type": "object",
        "properties": {
          "remoteUser": {
            "type": "string",
            "description": "The remote user identifier"
          }
        }
      },
      "UserSession": {
        "type": "object",
        "properties": {
          "userId": {
            "type": "number",
            "description": "The user identifier"
          },
          "username": {
            "type": "string",
            "description": "The username associated with the session"
          }
        }
      }
    }
  },
  {
    "featureName": "ValidateUserSession",
    "description": "Validates if a user session is still valid based on remote user information.",
    "inputValues": [
      "userSession-object-UserSession",
      "request-object-RequestContext"
    ],
    "businessLogic": "1. Input Collection\n   - Collect the following inputs:\n     - userSession (mandatory): Contains current user session information\n     - request (mandatory): Contains the current request context\n\n2. Data Validation\n   - Validate userSession input:\n     - IF userSession is null THEN\n       - Return validation failure\n       - Include error message indicating session information is required\n     - END IF\n   - Validate request input:\n     - IF request is null THEN\n       - Return validation failure\n       - Include error message indicating request context is required\n     - END IF\n\n3. Business Rule Processing\n   - Extract remote user information:\n     - Retrieve remoteUser value from the request context\n     - Retrieve current userId from userSession\n     - Retrieve anonymousUserId from system configuration\n     - Retrieve username from userSession\n\n4. Core Operation Execution\n   - Determine session validity based on the following conditions:\n     - IF remoteUser is null AND userId is not equal to anonymousUserId THEN\n       - Session is invalid (user has logged out)\n       - Return false\n     - ELSE IF remoteUser is not null AND userId equals anonymousUserId THEN\n       - Session is invalid (user has logged in)\n       - Return false\n     - ELSE IF remoteUser is not null AND remoteUser does not equal username THEN\n       - Session is invalid (user has changed)\n       - Return false\n     - ELSE\n       - Session is valid\n       - Return true\n     - END IF\n\n5. Response Generation\n   - Return session validity result (boolean):\n     - true: Session is valid and can continue\n     - false: Session is invalid and requires re-authentication",
    "databaseEntities": [
      "jforum_users",
      "jforum_sessions"
    ],
    "validationRules": [
      "UserSession object must not be null",
      "RequestContext object must not be null",
      "Session is invalid if remote user is null but session user is not anonymous",
      "Session is invalid if remote user exists but session user is anonymous",
      "Session is invalid if remote user exists but doesn't match session username"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "UserSession": {
        "type": "object",
        "properties": {
          "userId": {
            "type": "number",
            "description": "The user ID associated with this session"
          },
          "username": {
            "type": "string",
            "description": "The username associated with this session"
          }
        },
        "required": [
          "userId",
          "username"
        ]
      },
      "RequestContext": {
        "type": "object",
        "properties": {
          "remoteUser": {
            "type": [
              "string",
              "null"
            ],
            "description": "The remote user identifier, null if not authenticated"
          }
        }
      }
    }
  },
  {
    "featureName": "CheckUserExists",
    "description": "Verifies if a user exists in the database by username.",
    "inputValues": [
      "username-string-User"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the username (string, mandatory) from the requester\n   - No default values are provided\n   - No system-generated fields are required\n\n2. Data Validation:\n   - Validate username:\n     a. Check if username is provided\n     b. Check if username is not empty or null\n     c. If validation fails, prepare appropriate error message\n\n3. Business Rule Processing:\n   - Verify system state:\n     a. Check if the user database is accessible\n     b. Verify that the user lookup functionality is available\n   - No additional dependencies or constraints to verify\n\n4. Core Operation Execution:\n   - Search for the user:\n     a. Query the user database using the provided username\n     b. Retrieve the complete user record if found\n     c. Set the existence flag based on search results (true if found, false if not found)\n   - Store the user information:\n     a. If user is found, maintain reference to the complete user record\n     b. If user is not found, maintain reference to null user record\n   - No modifications to the database are performed\n\n5. Response Generation:\n   - Success response:\n     a. Return boolean result indicating whether the user exists\n     b. Make the complete user record available if the user was found\n   - Error response:\n     a. Return appropriate error message if the database could not be accessed\n     b. Return appropriate error message if the username validation failed",
    "databaseEntities": [
      "jforum_users"
    ],
    "validationRules": [
      "Username must not be empty or null",
      "User database must be accessible"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "User": {
        "type": "object",
        "properties": {
          "id": {
            "type": "number"
          },
          "username": {
            "type": "string"
          },
          "password": {
            "type": "string"
          },
          "email": {
            "type": "string"
          },
          "active": {
            "type": "number"
          }
        },
        "required": [
          "username"
        ]
      }
    }
  },
  {
    "featureName": "RegisterSsoUser",
    "description": "Creates a new user account with provided credentials for SSO integration.",
    "inputValues": [
      "username-string-User",
      "password-string-User",
      "email-string-User"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the following user information:\n     1.1. username (mandatory): User's unique identifier\n     1.2. password (mandatory): User's authentication credential\n     1.3. email (mandatory): User's contact email address\n\n2. Data Validation:\n   2.1. Validate username:\n      2.1.1. Check if username is not empty\n      2.1.2. Check if username meets minimum length requirements\n      2.1.3. Check if username contains only allowed characters\n      2.1.4. Generate appropriate error message if validation fails\n   2.2. Validate password:\n      2.2.1. Check if password is not empty\n      2.2.2. Check if password meets minimum length and complexity requirements\n      2.2.3. Generate appropriate error message if validation fails\n   2.3. Validate email:\n      2.3.1. Check if email is not empty\n      2.3.2. Check if email is in valid format\n      2.3.3. Generate appropriate error message if validation fails\n\n3. Business Rule Processing:\n   3.1. Check if user already exists:\n      3.1.1. Search for existing user with the provided username\n      3.1.2. IF user exists:\n         3.1.2.1. Set user existence flag to true\n         3.1.2.2. Retrieve existing user information\n         3.1.2.3. Skip registration process\n      3.1.3. ELSE:\n         3.1.3.1. Set user existence flag to false\n         3.1.3.2. Proceed to user registration\n\n4. Core Operation Execution:\n   4.1. IF user does not exist:\n      4.1.1. Create new user record:\n         4.1.1.1. Set username to provided value\n         4.1.1.2. Set password to provided value\n         4.1.1.3. Set email to provided value\n         4.1.1.4. Set user status to active\n      4.1.2. Save new user to database\n      4.1.3. Assign default user groups and permissions\n   4.2. Handle any errors during user creation:\n      4.2.1. Log error details\n      4.2.2. Prepare error response\n      4.2.3. Rollback any partial changes if necessary\n\n5. Response Generation:\n   5.1. IF registration successful:\n      5.1.1. Return success status\n      5.1.2. Include user identifier information\n      5.1.3. Include any additional user information needed for SSO\n   5.2. ELSE:\n      5.2.1. Return error status\n      5.2.2. Include specific error messages\n      5.2.3. Include any guidance for resolving the issue",
    "databaseEntities": [
      "jforum_users",
      "jforum_user_groups"
    ],
    "validationRules": [
      "Username must not be empty",
      "Password must not be empty",
      "Email must be in valid format",
      "Username must be unique in the system"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "User": {
        "type": "object",
        "properties": {
          "username": {
            "type": "string",
            "description": "Unique identifier for the user"
          },
          "password": {
            "type": "string",
            "description": "User's authentication credential"
          },
          "email": {
            "type": "string",
            "description": "User's contact email address"
          },
          "active": {
            "type": "integer",
            "description": "User's account status (1 for active)"
          }
        },
        "required": [
          "username",
          "password",
          "email"
        ]
      }
    }
  },
  {
    "featureName": "GetSsoUser",
    "description": "Retrieves user information associated with the current SSO authentication context.",
    "inputValues": [
      "username-string-User"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the username (string) from the SSO context\n   - Username is mandatory for this operation\n   - No default values are provided\n\n2. Data Validation:\n   - Validate username input:\n     a. Check if username is not empty or null\n     b. Verify username format meets system requirements\n     c. Generate appropriate error message if validation fails\n\n3. Business Rule Processing:\n   - Verify system is configured for SSO authentication\n   - Check if the current session has valid SSO credentials\n   - Determine if the system should create new users automatically if not found\n\n4. Core Operation Execution:\n   - Check if user exists in the system database:\n     a. Search for user by the provided username\n     b. IF user is found:\n        i. Retrieve complete user profile information\n        ii. Update last access timestamp if required\n     c. IF user is not found:\n        i. Mark user as non-existent in the system\n        ii. Prepare system for potential user registration\n   - Handle any exceptions during user retrieval process\n\n5. Response Generation:\n   - IF user exists:\n     a. Return complete user information including:\n        i. User identification details\n        ii. User profile information\n        iii. User permissions and group memberships\n   - IF user does not exist:\n     a. Return user existence status as false\n     b. Provide information that registration may be required\n   - Include operation status in the response",
    "databaseEntities": [
      "jforum_users",
      "jforum_user_groups"
    ],
    "validationRules": [
      "Username must not be empty",
      "Username must exist in the system for successful retrieval",
      "SSO authentication must be properly configured",
      "User session must have valid SSO context"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "User": {
        "type": "object",
        "properties": {
          "id": {
            "type": "number",
            "description": "Unique identifier for the user"
          },
          "username": {
            "type": "string",
            "description": "User's login name"
          },
          "email": {
            "type": "string",
            "description": "User's email address"
          },
          "active": {
            "type": "number",
            "description": "Flag indicating if user account is active"
          }
        },
        "required": [
          "username"
        ]
      }
    }
  },
  {
    "featureName": "ExecuteSummaryJob",
    "description": "Executes scheduled job to send post summaries to recipients by retrieving users and sending email digests.",
    "inputValues": [
      "jobContext-object-JobContext"
    ],
    "businessLogic": "1. Input Collection:\n   - Retrieve JobContext containing execution parameters\n   - Identify system-generated timestamp for the current execution\n   - No user inputs required as this is an automated scheduled job\n\n2. Data Validation:\n   - Verify job execution context is valid\n   - Check if summary generation is enabled in system settings\n   - Validate that the current time is appropriate for sending summaries\n   - Ensure database connections are available\n   - IF any validation fails, THEN log error and terminate job execution\n\n3. Business Rule Processing:\n   - Determine summary period (daily, weekly) based on system configuration\n   - Calculate time range for posts to include in summary\n   - Check system resources availability for processing\n   - Verify email service availability\n   - IF email service is unavailable, THEN log error and terminate job\n\n4. Core Operation Execution:\n   - Retrieve list of recipients who have subscribed to summaries\n   - FOR each recipient:\n     a. Determine recipient's preferences (forums, categories subscribed to)\n     b. Retrieve relevant posts made since last summary\n     c. IF no new posts exist for recipient, THEN skip to next recipient\n     d. Format post data into digestible summary format\n     e. Generate personalized email content with summary data\n     f. Send email to recipient\n     g. IF email sending fails, THEN log error and continue to next recipient\n     h. Update recipient's last summary timestamp\n   - Record job execution statistics (recipients processed, emails sent, failures)\n   - Update system with timestamp of last successful execution\n\n5. Response Generation:\n   - Generate job execution summary report\n   - Record total recipients processed\n   - Record total emails successfully sent\n   - Record any errors or exceptions encountered\n   - Log completion status of the job\n   - IF critical errors occurred, THEN generate admin notification",
    "databaseEntities": [
      "jforum_users",
      "jforum_posts",
      "jforum_posts_text",
      "jforum_topics",
      "jforum_forums",
      "jforum_categories"
    ],
    "validationRules": [
      "Job execution context must be valid",
      "Summary generation must be enabled in system settings",
      "Email service must be available",
      "Recipients must have valid email addresses",
      "Summary period must be properly configured",
      "Post data must exist for the configured time period"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "JobContext": {
        "type": "object",
        "properties": {
          "executionTime": {
            "type": "date",
            "description": "The timestamp when the job is being executed"
          },
          "parameters": {
            "type": "object",
            "description": "Additional parameters for job execution"
          }
        }
      }
    }
  },
  {
    "featureName": "SendPostsSummary",
    "description": "Sends weekly summary emails of recent forum posts to subscribed recipients.",
    "inputValues": [
      "recipients-object-RecipientList",
      "daysBefore-number-Integer",
      "currentDate-date-Date"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect list of recipients (mandatory)\n   - Retrieve configuration for days before (system-generated from configuration)\n   - Get current date (system-generated)\n\n2. Data Validation:\n   - Validate recipients list:\n      * Check if recipients list is not null\n      * Verify recipients list is not empty\n      * Ensure each recipient has a valid email format\n      * IF any validation fails, THEN log error and abort process\n   - Validate days before value:\n      * Ensure days before is a positive integer\n      * Verify days before is within acceptable range (1-30)\n      * IF validation fails, THEN use default value or log error\n\n3. Business Rule Processing:\n   - Calculate date range for post selection:\n      * Calculate start date by subtracting days before from current date\n      * Use current date as end date\n      * Verify date range is valid (start date before end date)\n   - Check system readiness:\n      * Verify email service is available\n      * Ensure template for summary exists\n      * IF any system dependency is unavailable, THEN log error and abort\n\n4. Core Operation Execution:\n   - Retrieve posts within date range:\n      * Query database for posts created between start date and end date\n      * Sort posts by relevant criteria (date, popularity)\n      * Group posts by forums or categories if needed\n      * IF no posts found, THEN log information and abort process\n   - Prepare email content:\n      * Load email template\n      * Populate template with posts data\n      * Include forum URL and other required parameters\n      * Generate subject line for email\n   - Send emails to recipients:\n      * Convert recipient email addresses to user objects\n      * Process each recipient individually\n      * Track successful and failed deliveries\n      * Handle any sending errors appropriately\n      * Implement retry mechanism for failed deliveries if needed\n\n5. Response Generation:\n   - Generate operation summary:\n      * Count of emails successfully sent\n      * Count of posts included in summary\n      * Date range covered by the summary\n      * List of any delivery failures\n   - Log completion status:\n      * Record timestamp of operation completion\n      * Document any errors or exceptions encountered\n      * Store metrics about processing time and resource usage",
    "databaseEntities": [
      "jforum_users",
      "jforum_posts",
      "jforum_posts_text",
      "jforum_topics",
      "jforum_forums"
    ],
    "validationRules": [
      "Recipients list must not be empty",
      "Each recipient must have a valid email address",
      "Days before value must be a positive integer",
      "Start date must be before end date",
      "Email template must exist and be valid",
      "Forum URL must be properly configured"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "RecipientList": {
        "type": "array",
        "items": {
          "type": "string",
          "format": "email"
        },
        "description": "List of email addresses to receive the summary"
      }
    }
  },
  {
    "featureName": "ListPosts",
    "description": "Retrieves forum posts from a specified date range for inclusion in summaries.",
    "inputValues": [
      "firstDate-date-Date",
      "lastDate-date-Date"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the following inputs:\n     - firstDate (mandatory): The start date of the period to retrieve posts from\n     - lastDate (mandatory): The end date of the period to retrieve posts from\n     - If not explicitly provided, system will calculate default values:\n       - firstDate: Current date minus configurable number of days (default: 7 days)\n       - lastDate: Current date\n\n2. Data Validation:\n   - Validate firstDate:\n     - Must be a valid date format\n     - Must not be null\n     - Must be earlier than or equal to lastDate\n     - Error message if invalid: \"First date must be a valid date and earlier than or equal to last date\"\n   - Validate lastDate:\n     - Must be a valid date format\n     - Must not be null\n     - Must be later than or equal to firstDate\n     - Error message if invalid: \"Last date must be a valid date and later than or equal to first date\"\n\n3. Business Rule Processing:\n   - Check system configuration for summary settings:\n     - Verify summary feature is enabled\n     - Retrieve configured number of days for default period if needed\n   - Verify database connection is available\n   - Check if there are any forum categories or sections excluded from summaries\n   - Apply any configured post filters (e.g., excluding posts from certain users or with specific flags)\n\n4. Core Operation Execution:\n   - Query the database for posts within the specified date range:\n     - Filter posts created between firstDate and lastDate (inclusive)\n     - Sort posts by date (newest first) or by configured preference\n     - Apply any additional filtering based on system configuration\n   - Process retrieved posts:\n     - Format post data for presentation\n     - Group posts by relevant categories (forums, topics, etc.)\n     - Apply any content transformations required for summary display\n   - Handle potential failure scenarios:\n     - If database query fails, log error and return empty result\n     - If post processing fails, attempt to return raw post data\n\n5. Response Generation:\n   - For successful execution:\n     - Return the list of posts matching the criteria\n     - Include metadata such as total count and date range\n     - Format according to required output structure\n   - For error scenarios:\n     - Return appropriate error message\n     - Include error code and description\n     - Provide guidance on resolving the issue",
    "databaseEntities": [
      "jforum_posts",
      "jforum_posts_text",
      "jforum_topics",
      "jforum_forums",
      "jforum_users"
    ],
    "validationRules": [
      "First date must be a valid date format",
      "Last date must be a valid date format",
      "First date must be earlier than or equal to last date",
      "Last date must be later than or equal to first date",
      "Date range must not exceed system-configured maximum period"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Post": {
        "type": "object",
        "properties": {
          "id": {
            "type": "number",
            "description": "Unique identifier for the post"
          },
          "title": {
            "type": "string",
            "description": "Title of the post"
          },
          "content": {
            "type": "string",
            "description": "Content of the post"
          },
          "creationDate": {
            "type": "date",
            "description": "Date when the post was created"
          },
          "authorId": {
            "type": "number",
            "description": "ID of the user who created the post"
          },
          "authorName": {
            "type": "string",
            "description": "Name of the user who created the post"
          },
          "forumId": {
            "type": "number",
            "description": "ID of the forum where the post was created"
          },
          "forumName": {
            "type": "string",
            "description": "Name of the forum where the post was created"
          },
          "topicId": {
            "type": "number",
            "description": "ID of the topic the post belongs to"
          },
          "topicTitle": {
            "type": "string",
            "description": "Title of the topic the post belongs to"
          }
        }
      }
    }
  },
  {
    "featureName": "GenerateCaptchaImage",
    "description": "Creates CAPTCHA images with random words, fonts, and backgrounds for user verification.",
    "inputValues": [
      "width-number-CaptchaConfig",
      "height-number-CaptchaConfig",
      "minWords-number-CaptchaConfig",
      "maxWords-number-CaptchaConfig",
      "minFontSize-number-CaptchaConfig",
      "maxFontSize-number-CaptchaConfig",
      "ignoreCase-boolean-CaptchaConfig"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect configuration parameters for CAPTCHA generation:\n     - width: The width of the CAPTCHA image (mandatory)\n     - height: The height of the CAPTCHA image (mandatory)\n     - minWords: Minimum number of characters in the CAPTCHA (mandatory)\n     - maxWords: Maximum number of characters in the CAPTCHA (mandatory)\n     - minFontSize: Minimum font size for CAPTCHA text (mandatory)\n     - maxFontSize: Maximum font size for CAPTCHA text (mandatory)\n     - ignoreCase: Whether case sensitivity should be ignored (optional, default: false)\n\n2. Data Validation:\n   - Validate width parameter:\n     - Ensure width is a positive number\n     - Ensure width is within reasonable bounds (e.g., 100-500)\n     - If invalid, generate error message: \"Width must be a positive number within acceptable range\"\n   - Validate height parameter:\n     - Ensure height is a positive number\n     - Ensure height is within reasonable bounds (e.g., 30-200)\n     - If invalid, generate error message: \"Height must be a positive number within acceptable range\"\n   - Validate minWords parameter:\n     - Ensure minWords is a positive number\n     - Ensure minWords is less than or equal to maxWords\n     - If invalid, generate error message: \"Minimum word count must be positive and not exceed maximum word count\"\n   - Validate maxWords parameter:\n     - Ensure maxWords is a positive number\n     - Ensure maxWords is greater than or equal to minWords\n     - If invalid, generate error message: \"Maximum word count must be positive and at least equal to minimum word count\"\n   - Validate font size parameters:\n     - Ensure minFontSize is a positive number\n     - Ensure maxFontSize is greater than or equal to minFontSize\n     - If invalid, generate error message: \"Font size parameters must be positive with maximum at least equal to minimum\"\n\n3. Business Rule Processing:\n   - Determine character set based on configuration:\n     - IF ignoreCase is TRUE, THEN\n       - Use simplified character set excluding easily confused characters (e.g., use \"123456789abcdefghijlmnopkrstuvxzyk@#%^\")\n     - ELSE\n       - Use full character set including uppercase and lowercase letters (e.g., use \"123456789ABCDEFGHJLKMNPRSTWXYZabcdefghijlmnopkrstuvxzyk@#%^\")\n   - Initialize background generators:\n     - Create list of background generators with various color combinations\n     - Each generator should use the specified width and height\n     - Include gradient backgrounds with different color pairs\n   - Initialize text pasters:\n     - Create list of text pasters with different text colors\n     - Configure each paster with the specified minWords and maxWords parameters\n   - Initialize font generators:\n     - Create font generator with the specified minFontSize and maxFontSize\n     - Configure font generator to produce twisted and sheared fonts for security\n   - Check user session:\n     - Verify user session exists\n     - If no session exists, create a new session\n\n4. Core Operation Execution:\n   - Generate random verification word:\n     - Create random word generator using the determined character set\n     - Generate random word of appropriate length\n   - Create CAPTCHA image:\n     - Select random background generator from the list\n     - Select random text paster from the list\n     - Select font generator\n     - Combine selected components to create word-to-image converter\n     - Apply the random word to the converter to generate CAPTCHA image\n   - Store CAPTCHA information:\n     - Store the generated word in the user's session for later verification\n     - Store the generated image in the user's session for display\n   - Set content type:\n     - Configure response to use image/jpg content type\n     - Enable custom content handling for image output\n\n5. Response Generation:\n   - Prepare image for output:\n     - Set appropriate content type for image (image/jpg)\n     - Write image data to output stream\n   - Handle success scenario:\n     - Return success status if image generation is successful\n     - Include image dimensions and format in response metadata\n   - Handle error scenarios:\n     - If any error occurs during image generation, return appropriate error message\n     - Include support information for troubleshooting",
    "databaseEntities": [
      "jforum_sessions"
    ],
    "validationRules": [
      "Width must be a positive number within acceptable range",
      "Height must be a positive number within acceptable range",
      "Minimum word count must be positive and not exceed maximum word count",
      "Maximum word count must be positive and at least equal to minimum word count",
      "Font size parameters must be positive with maximum at least equal to minimum",
      "CAPTCHA word must be stored in user session for verification",
      "CAPTCHA image must be stored in user session for display",
      "User session must exist or be created before CAPTCHA generation",
      "Content type must be set to image/jpg for proper display"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "CaptchaConfig": {
        "type": "object",
        "properties": {
          "width": {
            "type": "number",
            "description": "Width of the CAPTCHA image"
          },
          "height": {
            "type": "number",
            "description": "Height of the CAPTCHA image"
          },
          "minWords": {
            "type": "number",
            "description": "Minimum number of characters in the CAPTCHA"
          },
          "maxWords": {
            "type": "number",
            "description": "Maximum number of characters in the CAPTCHA"
          },
          "minFontSize": {
            "type": "number",
            "description": "Minimum font size for CAPTCHA text"
          },
          "maxFontSize": {
            "type": "number",
            "description": "Maximum font size for CAPTCHA text"
          },
          "ignoreCase": {
            "type": "boolean",
            "description": "Whether case sensitivity should be ignored"
          }
        },
        "required": [
          "width",
          "height",
          "minWords",
          "maxWords",
          "minFontSize",
          "maxFontSize"
        ]
      }
    }
  },
  {
    "featureName": "WriteCaptchaImage",
    "description": "Outputs the generated CAPTCHA image to the response stream for display to users.",
    "inputValues": [
      "userSession-object-UserSession"
    ],
    "businessLogic": "1. Input Collection:\n   - Retrieve the current user session\n   - The user session should contain a previously generated CAPTCHA image\n   - No direct user inputs are required for this feature\n\n2. Data Validation:\n   - Verify that the user session exists and is valid\n   - Check if the CAPTCHA image exists in the user session\n     * IF the CAPTCHA image is null or invalid\n       THEN terminate the process and return without generating output\n     * IF the CAPTCHA image is valid\n       THEN proceed to the next step\n\n3. Business Rule Processing:\n   - Verify that the system is configured to use CAPTCHA functionality\n   - Check if the current user is exempt from CAPTCHA requirements based on system rules\n     * IF user is exempt\n       THEN log this information and continue anyway (for consistency)\n   - Determine the appropriate image format to use (default: JPEG)\n\n4. Core Operation Execution:\n   - Prepare the system response for image output\n     * Set the appropriate content type for image data\n     * Clear any existing output buffers if necessary\n   - Retrieve the CAPTCHA image from the user session\n   - Open an output stream to the response object\n   - Write the image data to the output stream in the selected format\n   - Ensure all data is flushed to the client\n   - Handle any errors during the writing process\n     * IF an error occurs during writing\n       THEN log the error details\n       AND ensure resources are properly released\n\n5. Response Generation:\n   - Close the output stream after successful writing\n   - No explicit success message is returned as this is a binary image output\n   - In case of errors:\n     * Log detailed error information\n     * Ensure the client receives appropriate HTTP error status if image cannot be generated",
    "databaseEntities": [
      "jforum_sessions"
    ],
    "validationRules": [
      "User session must be valid and active",
      "CAPTCHA image must exist in the user session",
      "Output stream must be available for writing"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "UserSession": {
        "type": "object",
        "properties": {
          "captchaImage": {
            "type": "object",
            "description": "BufferedImage containing the generated CAPTCHA challenge"
          },
          "sessionId": {
            "type": "string",
            "description": "Unique identifier for the user session"
          }
        },
        "required": [
          "captchaImage",
          "sessionId"
        ]
      }
    }
  },
  {
    "featureName": "CompareCategoryOrder",
    "description": "Compares two Category objects by their order and name for sorting purposes.",
    "inputValues": [
      "firstCategory-object-Category",
      "secondCategory-object-Category"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect two Category objects for comparison:\n     - firstCategory (mandatory): The first Category object to compare\n     - secondCategory (mandatory): The second Category object to compare\n   - No default values are provided\n   - Both inputs must be valid Category objects\n\n2. Data Validation:\n   - Validate firstCategory input:\n     - Check if firstCategory is not null\n     - Verify that firstCategory has valid order property (numeric value)\n     - Verify that firstCategory has valid name property (non-empty string)\n     - If validation fails, return error message indicating invalid first category\n   - Validate secondCategory input:\n     - Check if secondCategory is not null\n     - Verify that secondCategory has valid order property (numeric value)\n     - Verify that secondCategory has valid name property (non-empty string)\n     - If validation fails, return error message indicating invalid second category\n\n3. Business Rule Processing:\n   - No additional system state validations required\n   - No dependencies to verify\n   - No resource availability checks needed\n   - No additional business constraints to validate\n\n4. Core Operation Execution:\n   - Compare the order property of both categories:\n     - IF firstCategory.order > secondCategory.order THEN\n       - Return positive value (1) indicating firstCategory should come after secondCategory\n     - ELSE IF firstCategory.order < secondCategory.order THEN\n       - Return negative value (-1) indicating firstCategory should come before secondCategory\n     - ELSE (when order values are equal)\n       - Compare the name property of both categories lexicographically\n       - Return the result of name comparison (negative if first comes before second alphabetically, positive if after, zero if identical)\n   - No rollback procedures needed as this is a read-only comparison operation\n\n5. Response Generation:\n   - Success response:\n     - Return comparison result as an integer value:\n       - Positive value (1): firstCategory should be placed after secondCategory\n       - Negative value (-1): firstCategory should be placed before secondCategory\n       - Zero (0): Categories are equivalent in sorting order (same order and name)\n   - No error responses needed beyond initial validation failures",
    "databaseEntities": [
      "jforum_categories"
    ],
    "validationRules": [
      "Both category objects must not be null",
      "Both category objects must have valid order properties",
      "Both category objects must have valid name properties"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Category": {
        "type": "object",
        "properties": {
          "order": {
            "type": "number",
            "description": "The display order of the category"
          },
          "name": {
            "type": "string",
            "description": "The name of the category"
          }
        },
        "required": [
          "order",
          "name"
        ]
      }
    }
  },
  {
    "featureName": "CloseResultSetAndStatement",
    "description": "Safely closes both ResultSet and Statement objects to prevent resource leaks in database operations.",
    "inputValues": [
      "resultSet-object-ResultSet",
      "statement-object-Statement"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect ResultSet object (optional)\n   - Collect Statement object (optional)\n   - Both inputs may be null, which indicates no action is needed for that resource\n\n2. Data Validation:\n   - Check if ResultSet object is null\n     - IF ResultSet is null, skip ResultSet closing operations\n     - IF ResultSet is not null, proceed with ResultSet closing\n   - Check if Statement object is null\n     - IF Statement is null, skip Statement closing operations\n     - IF Statement is not null, proceed with Statement closing\n\n3. Business Rule Processing:\n   - Verify system state allows for resource closing\n   - Ensure closing resources won't impact ongoing operations\n   - Determine proper closing sequence (ResultSet must be closed before its associated Statement)\n\n4. Core Operation Execution:\n   - Close ResultSet (if not null):\n     a. Attempt to close the ResultSet object\n     b. Suppress and handle any exceptions that occur during closing\n     c. Ensure ResultSet is properly released regardless of exceptions\n   - Close Statement (if not null):\n     a. Clear any warnings associated with the Statement\n     b. Attempt to close the Statement object\n     c. Suppress and handle any exceptions that occur during closing\n     d. Ensure Statement is properly released regardless of exceptions\n\n5. Response Generation:\n   - No explicit response is generated as this is a resource cleanup operation\n   - System should maintain internal state indicating resources have been properly released\n   - Any critical errors during closing should be logged for system administrators",
    "databaseEntities": [],
    "validationRules": [
      "ResultSet and Statement objects may be null",
      "ResultSet must be closed before its associated Statement",
      "Exceptions during closing operations must be suppressed to ensure all resources are attempted to be closed"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "ResultSet": {
        "type": "object",
        "description": "Database result set containing query results"
      },
      "Statement": {
        "type": "object",
        "description": "Database statement used for executing SQL queries"
      }
    }
  },
  {
    "featureName": "CloseResultSet",
    "description": "Safely closes a ResultSet object to release database resources.",
    "inputValues": [
      "resultSet-object-DatabaseResource"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the ResultSet object to be closed\n   - Determine if the ResultSet is required or optional\n   - Check if associated Statement object is also to be closed\n\n2. Data Validation:\n   - Check if the provided ResultSet object is null\n     * IF ResultSet is null, THEN skip closing operation\n     * IF ResultSet is not null, THEN proceed with closing\n   - Verify the ResultSet object state\n     * Check if ResultSet is already closed\n     * Determine if ResultSet is still in use by other operations\n\n3. Business Rule Processing:\n   - Determine the proper sequence for resource cleanup\n     * IF both ResultSet and Statement are provided, THEN close ResultSet first\n     * Ensure proper resource management according to database connection lifecycle\n   - Handle any dependencies between resources\n     * Verify no active operations are using the ResultSet\n     * Check for any pending data fetches\n\n4. Core Operation Execution:\n   - Attempt to close the ResultSet\n     * Execute the close operation on the ResultSet object\n     * Capture any exceptions that occur during closing\n     * Suppress exceptions to prevent operation interruption\n   - Handle any cleanup of related resources\n     * IF Statement object is provided, THEN:\n       * Clear any warnings from the Statement\n       * Close the Statement object\n       * Suppress any exceptions from Statement closing\n   - Verify resources are properly released\n     * Ensure database cursors are released\n     * Confirm memory resources are freed\n\n5. Response Generation:\n   - Determine operation success status\n     * IF closing operations completed without errors, THEN mark as success\n     * IF exceptions were caught but suppressed, THEN log information\n   - Return appropriate response\n     * No explicit return value needed as operation is void\n     * Ensure calling process can continue regardless of close operation result",
    "databaseEntities": [],
    "validationRules": [
      "ResultSet object may be null, which should be handled gracefully",
      "Statement object may be null, which should be handled gracefully",
      "Exceptions during closing operations should be caught and suppressed"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "DatabaseResource": {
        "type": "object",
        "properties": {
          "resultSet": {
            "type": "object",
            "description": "Database result set object that needs to be closed"
          },
          "statement": {
            "type": "object",
            "description": "Optional associated statement object that may also need closing"
          }
        }
      }
    }
  },
  {
    "featureName": "CloseStatement",
    "description": "Safely closes a Statement object and clears warnings to release database resources.",
    "inputValues": [
      "statement-object-Statement"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the Statement object to be closed\n   - Statement object is mandatory\n   - No default values are applicable\n\n2. Data Validation:\n   - Validate Statement object existence\n     - IF Statement object is null THEN\n       - Skip processing and return without action\n     - ELSE\n       - Continue with resource release process\n\n3. Business Rule Processing:\n   - Verify Statement object state\n     - Check if Statement object is in a state that can be closed\n     - No additional dependencies need verification\n     - No resource availability checks required\n     - No business constraints to validate\n\n4. Core Operation Execution:\n   - Clear Statement warnings\n     - Attempt to clear any accumulated warnings from the Statement\n     - IF warning clearance fails THEN\n       - Suppress the exception\n       - Continue with close operation\n     - ELSE\n       - Proceed to close operation\n   - Close Statement object\n     - Attempt to close the Statement object to release resources\n     - IF close operation fails THEN\n       - Suppress the exception\n       - Consider the operation complete despite failure\n     - ELSE\n       - Statement is successfully closed\n       - Resources are released back to the system\n\n5. Response Generation:\n   - No explicit response is generated\n   - Operation completes silently\n   - No error responses are returned even if exceptions occur\n   - Operation is designed to be fail-safe with all exceptions suppressed",
    "databaseEntities": [],
    "validationRules": [
      "Statement object must be checked for null before attempting operations",
      "Exceptions during warning clearance must be suppressed",
      "Exceptions during close operation must be suppressed"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Statement": {
        "type": "object",
        "description": "Database statement object that represents a SQL statement to be executed",
        "properties": {
          "clearWarnings": {
            "type": "function",
            "description": "Clears any warnings reported for this Statement object"
          },
          "close": {
            "type": "function",
            "description": "Releases this Statement object's database and resources immediately"
          }
        }
      }
    }
  },
  {
    "featureName": "FileChangeNotification",
    "description": "Notifies listeners when a file has been changed by providing the filename.",
    "inputValues": [
      "filename-string-File"
    ],
    "businessLogic": "1. Input Collection\n   - Collect the filename (string) that has changed\n   - The filename is mandatory and system-provided\n   - No default values are applicable\n\n2. Data Validation\n   - Validate filename input:\n     a. Check if filename is not null or empty\n        IF filename is null or empty THEN\n          Generate error: \"Filename cannot be empty\"\n        END IF\n     b. Check if filename string is properly formatted\n        IF filename format is invalid THEN\n          Generate error: \"Invalid filename format\"\n        END IF\n\n3. Business Rule Processing\n   - Verify system state for notification processing\n     a. Check if notification system is active\n        IF notification system is inactive THEN\n          Log warning and exit process\n        END IF\n     b. Verify listener registration status\n        IF no listeners are registered THEN\n          Log information about lack of listeners\n          Exit process without notifications\n        END IF\n\n4. Core Operation Execution\n   - Process file change notification\n     a. Prepare notification data package with filename\n     b. For each registered listener:\n        i. Deliver notification with filename to the listener\n        ii. IF delivery fails THEN\n             Log delivery failure\n             Continue to next listener\n           END IF\n     c. Record notification delivery status\n        IF any delivery failed THEN\n          Log summary of failed notifications\n        END IF\n\n5. Response Generation\n   - Generate notification completion response\n     a. IF all notifications were successful THEN\n          Return success status with notification count\n        ELSE\n          Return partial success with details of failed notifications\n        END IF\n     b. Include timestamp of notification processing\n     c. Include summary of notification recipients",
    "databaseEntities": [],
    "validationRules": [
      "Filename must not be null or empty",
      "Filename must be properly formatted",
      "Notification system must be active",
      "At least one listener must be registered to receive notifications"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "FileChangeEvent": {
        "filename": "string",
        "timestamp": "date",
        "notificationStatus": "string"
      }
    }
  },
  {
    "featureName": "MonitorFileChanges",
    "description": "Monitors files for changes and notifies listeners when modifications are detected.",
    "inputValues": [
      "listener-object-FileChangeListener",
      "filename-string-File",
      "period-number-Interval"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the following inputs:\n     a. listener (mandatory): The object that will be notified when file changes occur\n     b. filename (mandatory): The path to the file that needs to be monitored\n     c. period (mandatory): The time interval in milliseconds between file checks\n\n2. Data Validation:\n   - Validate the listener input:\n     a. Verify the listener is not null\n     b. Confirm the listener implements the required notification method\n     c. IF listener is invalid, THEN display an error message and abort operation\n   - Validate the filename input:\n     a. Verify the filename is not empty or null\n     b. Check if the filename represents a valid file path\n     c. IF filename is invalid, THEN display an error message and abort operation\n   - Validate the period input:\n     a. Verify the period is a positive number\n     b. Ensure the period is not too small to cause system performance issues\n     c. IF period is invalid, THEN display an error message and abort operation\n\n3. Business Rule Processing:\n   - Check if the file exists:\n     a. Attempt to access the file at the specified path\n     b. IF file does not exist, THEN log a warning but continue setup\n   - Check if the file is already being monitored:\n     a. Look up the filename in the current monitoring registry\n     b. IF file is already monitored, THEN remove the existing monitor\n   - Verify system resources:\n     a. Ensure the system has sufficient resources to add another file monitor\n     b. IF resources are insufficient, THEN log an error and abort operation\n\n4. Core Operation Execution:\n   - Create a monitoring task:\n     a. Initialize a new task with the listener and filename\n     b. Store the initial last modified timestamp of the file\n     c. Add the task to the monitoring registry with the filename as key\n   - Schedule the monitoring task:\n     a. Configure the task to run at the specified period intervals\n     b. Start the monitoring process\n     c. Log the successful addition of the file monitor\n   - Implement the file checking mechanism:\n     a. At each scheduled interval, check the current last modified timestamp\n     b. Compare it with the previously stored timestamp\n     c. IF timestamps differ, THEN update the stored timestamp\n     d. AND notify the listener about the file change\n\n5. Response Generation:\n   - For successful monitor setup:\n     a. Return confirmation that the file is now being monitored\n     b. Include details about the monitoring frequency\n     c. Provide information on how to stop the monitoring\n   - For monitor removal:\n     a. Return confirmation that the file is no longer being monitored\n     b. Include information about when the monitoring was stopped\n   - For monitoring events:\n     a. When a file change is detected, notify the listener with file details\n     b. Include the filename that changed\n     c. Optionally provide the timestamp of the change",
    "databaseEntities": [],
    "validationRules": [
      "Listener object must not be null",
      "Filename must not be empty",
      "Monitoring period must be a positive number",
      "File path should be valid and accessible",
      "System must have sufficient resources for monitoring"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "FileChangeListener": {
        "type": "object",
        "properties": {
          "fileChanged": {
            "type": "function",
            "description": "Method called when a file change is detected"
          }
        },
        "required": [
          "fileChanged"
        ]
      }
    }
  },
  {
    "featureName": "AddFileChangeListener",
    "description": "Registers a listener to be notified when a specified file changes.",
    "inputValues": [
      "listener-object-FileChangeListener",
      "filename-string-File",
      "period-number-Time"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the file change listener object (mandatory)\n   - Collect the filename to monitor (mandatory)\n   - Collect the monitoring period in milliseconds (mandatory)\n   - System will use these inputs to set up file monitoring\n\n2. Data Validation:\n   - Validate that the listener object is not null\n     * IF listener is null THEN return error message indicating invalid listener\n   - Validate that the filename is not empty\n     * IF filename is empty or null THEN return error message indicating invalid filename\n   - Validate that the filename points to an existing file\n     * IF file does not exist THEN log a warning but continue processing\n   - Validate that the period is a positive number\n     * IF period is negative or zero THEN return error message indicating invalid monitoring period\n\n3. Business Rule Processing:\n   - Check if the file is already being monitored\n     * IF file is already monitored THEN remove existing monitoring task\n   - Verify system resources are available for monitoring\n     * IF system cannot allocate resources for monitoring THEN return resource limitation error\n   - Log the monitoring operation with filename information\n\n4. Core Operation Execution:\n   - Create a new monitoring task for the specified file\n     * Initialize task with the listener, filename, and current file state\n     * Store the file's current last modified timestamp\n   - Register the task in the monitoring system\n     * Add task to the collection of monitored files\n     * Schedule the task to run at specified intervals (period)\n   - Set up the monitoring mechanism\n     * Configure the task to check file modification time periodically\n     * Define the notification process when changes are detected\n\n5. Response Generation:\n   - Return confirmation that monitoring has been established\n   - Include details about:\n     * The file being monitored\n     * The monitoring frequency\n     * How to cancel the monitoring later if needed\n   - Provide any warning messages if the file doesn't exist but monitoring was still set up",
    "databaseEntities": [],
    "validationRules": [
      "Listener object must not be null",
      "Filename must not be empty",
      "Monitoring period must be a positive number",
      "System must have available resources for monitoring"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "FileChangeListener": {
        "type": "object",
        "description": "Interface for objects that want to be notified of file changes",
        "properties": {
          "fileChanged": {
            "type": "method",
            "description": "Method called when a monitored file changes",
            "parameters": [
              {
                "name": "filename",
                "type": "string",
                "description": "Path of the file that changed"
              }
            ]
          }
        },
        "required": [
          "fileChanged"
        ]
      }
    }
  },
  {
    "featureName": "RemoveFileChangeListener",
    "description": "Stops monitoring a specific file by removing its change listener.",
    "inputValues": [
      "filename-string-FileMonitor"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the filename (string) to stop monitoring\n   - Verify the filename is not null or empty\n\n2. Data Validation:\n   - Validate that the filename is a valid string\n   - Check if the filename is currently being monitored\n     - IF filename is not in the list of monitored files THEN\n       - Generate appropriate notification that the file is not being monitored\n       - Exit the process\n\n3. Business Rule Processing:\n   - Verify system has appropriate permissions to modify monitoring settings\n   - Check if any dependent processes require this file monitoring to continue\n     - IF dependent processes exist THEN\n       - Generate warning about potential impacts\n       - Request confirmation to proceed\n\n4. Core Operation Execution:\n   - Retrieve the monitoring task associated with the filename from the storage\n   - Cancel the scheduled monitoring task\n     - Stop any active monitoring processes for this file\n     - Release resources associated with this monitoring task\n   - Remove the file entry from the monitored files list\n     - Update internal tracking to reflect the change\n\n5. Response Generation:\n   - Generate success confirmation that the file is no longer being monitored\n   - Include details about when monitoring was stopped\n   - Provide information about how to restart monitoring if needed",
    "databaseEntities": [],
    "validationRules": [
      "Filename must not be null or empty",
      "Filename must reference a previously monitored file",
      "System must have appropriate permissions to modify monitoring settings"
    ],
    "dbSeedingOperations": [],
    "schema": {}
  },
  {
    "featureName": "CompareForum",
    "description": "Compares forums based on their order and name for sorting purposes.",
    "inputValues": [
      "forum1-object-Forum",
      "forum2-object-Forum"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect two forum objects for comparison:\n     1.1. forum1 (mandatory): The first forum to compare\n     1.2. forum2 (mandatory): The second forum to compare against\n   - Each forum must contain:\n     * order: A numeric value representing the forum's display order\n     * name: A string value representing the forum's display name\n\n2. Data Validation:\n   - Validate forum objects:\n     2.1. Check if forum1 is not null\n        IF forum1 is null THEN\n          Return error indicating first forum object is required\n     2.2. Check if forum2 is not null\n        IF forum2 is null THEN\n          Return error indicating second forum object is required\n     2.3. Verify both forum objects have order property\n        IF either forum is missing order property THEN\n          Return error indicating order property is required\n     2.4. Verify both forum objects have name property\n        IF either forum is missing name property THEN\n          Return error indicating name property is required\n\n3. Business Rule Processing:\n   - No additional business rules to process\n\n4. Core Operation Execution:\n   4.1. Compare forum order values\n      IF forum1.order > forum2.order THEN\n        Return positive value (1) indicating forum1 comes after forum2\n      ELSE IF forum1.order < forum2.order THEN\n        Return negative value (-1) indicating forum1 comes before forum2\n      ELSE\n        4.2. When order values are equal, compare forum names\n          Return result of string comparison between forum1.name and forum2.name\n          * Positive value if forum1.name comes after forum2.name alphabetically\n          * Negative value if forum1.name comes before forum2.name alphabetically\n          * Zero if names are identical\n\n5. Response Generation:\n   5.1. Return comparison result\n      - Return value will be one of:\n        * Positive integer (1): Indicating forum1 should be placed after forum2\n        * Negative integer (-1): Indicating forum1 should be placed before forum2\n        * Zero (0): Indicating forums are equivalent for sorting purposes",
    "databaseEntities": [
      "jforum_forums"
    ],
    "validationRules": [
      "Forum objects must not be null",
      "Forum objects must have order property",
      "Forum objects must have name property"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Forum": {
        "type": "object",
        "properties": {
          "order": {
            "type": "number",
            "description": "The display order of the forum"
          },
          "name": {
            "type": "string",
            "description": "The display name of the forum"
          }
        },
        "required": [
          "order",
          "name"
        ]
      }
    }
  },
  {
    "featureName": "ManageFormFieldSelection",
    "description": "Manages form field selection state with name, ID, and selection status for UI components.",
    "inputValues": [
      "name-string-FormField",
      "id-string-FormField",
      "selected-boolean-FormField"
    ],
    "businessLogic": "1. Input Collection:\n   1.1. Collect the following required inputs:\n       - name (string): The descriptive text label for the form field\n       - id (string): The unique identifier associated with the form field\n       - selected (boolean): The selection state of the form field\n   1.2. All fields are mandatory for proper field selection management\n\n2. Data Validation:\n   2.1. Validate the name field:\n       - IF name is null or empty THEN\n         - Generate error message: \"Field name cannot be empty\"\n       - IF name exceeds maximum allowed length THEN\n         - Generate error message: \"Field name exceeds maximum allowed length\"\n   2.2. Validate the id field:\n       - IF id is null or empty THEN\n         - Generate error message: \"Field ID cannot be empty\"\n       - IF id is not unique within the current form context THEN\n         - Generate error message: \"Field ID must be unique\"\n   2.3. Validate the selected field:\n       - Ensure the selected value is a valid boolean (true or false)\n       - IF selected is not a valid boolean THEN\n         - Default to false\n\n3. Business Rule Processing:\n   3.1. Check for field visibility rules:\n       - IF the field has dependencies on other field selections THEN\n         - Verify those dependencies are satisfied\n       - IF dependencies are not satisfied THEN\n         - Log warning about potential inconsistent state\n   3.2. Check for mutually exclusive selections:\n       - IF this field belongs to a mutually exclusive group AND selected is true THEN\n         - Ensure other fields in the same group are set to not selected\n   3.3. Check for required group selections:\n       - IF this field belongs to a group where at least one selection is required THEN\n         - Verify at least one field in the group will be selected\n\n4. Core Operation Execution:\n   4.1. Create or update the form field selection data:\n       - Store the name value for display purposes\n       - Store the id value for field identification\n       - Store the selected state for rendering the field\n   4.2. Update related field states if necessary:\n       - IF this field controls the visibility of other fields THEN\n         - Update the visibility state of dependent fields\n       - IF this field is part of a mutually exclusive group AND selected is true THEN\n         - Update other fields in the group to not selected\n   4.3. Prepare the field data for UI rendering:\n       - Format the field data for appropriate display in the user interface\n       - Include any additional rendering hints based on the field state\n\n5. Response Generation:\n   5.1. For successful field selection management:\n       - Return the complete field data object with name, id, and selected state\n       - Include any additional rendering information for the UI\n   5.2. For validation failures:\n       - Return appropriate error messages for each validation failure\n       - Maintain the current field state without changes\n   5.3. For business rule violations:\n       - Return warnings about potential inconsistent states\n       - Provide guidance on resolving the inconsistencies",
    "databaseEntities": [],
    "validationRules": [
      "Field name must not be empty",
      "Field ID must not be empty",
      "Field ID must be unique within form context",
      "Selected value must be a valid boolean"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "FormField": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "description": "The descriptive text label for the form field"
          },
          "id": {
            "type": "string",
            "description": "The unique identifier associated with the form field"
          },
          "selected": {
            "type": "boolean",
            "description": "The selection state of the form field"
          }
        },
        "required": [
          "name",
          "id",
          "selected"
        ]
      }
    }
  },
  {
    "featureName": "ManageGroupHierarchy",
    "description": "Manages hierarchical group structures with parent-child relationships and nested subgroups.",
    "inputValues": [
      "groupId-number-Group",
      "groupName-string-Group",
      "parentGroupId-number-Group",
      "subgroups-object-GroupNode"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect group information:\n     1.1. Group ID (mandatory, system-generated unique identifier)\n     1.2. Group name (mandatory, user-provided string)\n     1.3. Parent group ID (optional, references existing group)\n     1.4. Subgroups (optional, collection of group nodes)\n\n2. Data Validation:\n   2.1. Validate Group ID:\n      - IF creating new group, THEN ensure ID is not provided (system will generate)\n      - IF updating existing group, THEN verify ID exists in the system\n      - IF ID is invalid, THEN return error message \"Invalid group ID\"\n   2.2. Validate Group Name:\n      - Verify name is not empty\n      - Verify name length is between 3 and 50 characters\n      - IF name validation fails, THEN return error message \"Group name must be between 3 and 50 characters\"\n   2.3. Validate Parent Group ID:\n      - IF parent group ID is provided, THEN verify it exists in the system\n      - Verify no circular references (group cannot be its own ancestor)\n      - IF parent validation fails, THEN return error message \"Invalid parent group\"\n   2.4. Validate Subgroups:\n      - IF subgroups are provided, THEN verify each subgroup has valid data\n      - Verify no duplicate subgroup IDs\n      - IF subgroup validation fails, THEN return error message \"Invalid subgroup data\"\n\n3. Business Rule Processing:\n   3.1. Check Hierarchy Constraints:\n      - Verify maximum nesting depth is not exceeded (limit to 5 levels)\n      - Verify user has permission to modify the group hierarchy\n      - IF hierarchy constraints violated, THEN return error message \"Hierarchy constraints violated\"\n   3.2. Check Group Relationships:\n      - Verify no conflicting group relationships\n      - Ensure group membership integrity is maintained\n      - IF relationship constraints violated, THEN return error message \"Invalid group relationship\"\n   3.3. Check System Constraints:\n      - Verify system groups cannot be modified if protected\n      - Ensure required system groups remain in the hierarchy\n      - IF system constraints violated, THEN return error message \"System group constraints violated\"\n\n4. Core Operation Execution:\n   4.1. Process Group Creation/Update:\n      - IF new group, THEN create group record with provided name\n      - IF existing group, THEN update group information\n      - Set parent-child relationship if parent ID is provided\n      - IF operation fails, THEN rollback all changes and return error\n   4.2. Process Subgroup Management:\n      - FOR each subgroup in the collection:\n        - IF subgroup exists, THEN update subgroup information\n        - IF subgroup is new, THEN create new subgroup\n        - Set parent-child relationship with current group\n      - Remove any existing subgroups not in the provided collection if applicable\n      - IF subgroup operations fail, THEN rollback changes and return error\n   4.3. Update Group Hierarchy:\n      - Recalculate and update the complete group hierarchy structure\n      - Update all affected group relationships\n      - IF hierarchy update fails, THEN rollback changes and return error\n\n5. Response Generation:\n   5.1. Prepare Success Response:\n      - Include updated group information\n      - Include complete hierarchy information with all subgroups\n      - Include operation status and timestamp\n   5.2. Handle Error Scenarios:\n      - Provide detailed error information if any operation failed\n      - Include guidance on resolving the error\n      - Log error details for system administrators",
    "databaseEntities": [
      "jforum_groups",
      "jforum_user_groups"
    ],
    "validationRules": [
      "Group name must not be empty",
      "Group name must be between 3 and 50 characters",
      "Group hierarchy cannot exceed 5 levels of nesting",
      "Group cannot be its own ancestor (no circular references)",
      "System protected groups cannot be modified",
      "Each group must have a unique ID",
      "Parent group must exist in the system"
    ],
    "dbSeedingOperations": [
      "Create default system groups if not present",
      "Establish initial group hierarchy structure"
    ],
    "schema": {
      "GroupNode": {
        "type": "object",
        "properties": {
          "id": {
            "type": "number",
            "description": "Unique identifier for the group"
          },
          "name": {
            "type": "string",
            "description": "Name of the group"
          },
          "extraNodes": {
            "type": "array",
            "items": {
              "$ref": "#/GroupNode"
            },
            "description": "Collection of subgroups"
          }
        },
        "required": [
          "id",
          "name"
        ]
      }
    }
  },
  {
    "featureName": "AddGroupNode",
    "description": "Adds a new node to the group hierarchy structure.",
    "inputValues": [
      "name-string-GroupNode",
      "id-number-GroupNode",
      "parentNode-object-GroupNode"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the following inputs:\n     a. name (string, mandatory): The name of the new group node\n     b. id (number, mandatory): The unique identifier for the new group node\n     c. parentNode (object, mandatory): The parent group node to which this node will be added\n\n2. Data Validation:\n   - Validate the name input:\n     a. IF name is empty or null THEN\n        i. Generate error: \"Group node name cannot be empty\"\n     b. IF name contains invalid characters THEN\n        i. Generate error: \"Group node name contains invalid characters\"\n   - Validate the id input:\n     a. IF id is less than or equal to 0 THEN\n        i. Generate error: \"Group node ID must be a positive number\"\n     b. IF id already exists in the hierarchy THEN\n        i. Generate error: \"Group node ID already exists\"\n   - Validate the parentNode input:\n     a. IF parentNode is null THEN\n        i. Generate error: \"Parent node cannot be null\"\n\n3. Business Rule Processing:\n   - Check hierarchy constraints:\n     a. IF adding this node would create a circular reference THEN\n        i. Generate error: \"Cannot add node as it would create a circular reference\"\n     b. IF maximum depth of hierarchy would be exceeded THEN\n        i. Generate error: \"Maximum hierarchy depth would be exceeded\"\n   - Check node limit constraints:\n     a. IF parent node has reached maximum allowed child nodes THEN\n        i. Generate error: \"Parent node cannot accept more child nodes\"\n\n4. Core Operation Execution:\n   - Create a new GroupNode instance:\n     a. Initialize the node with empty subgroups collection\n     b. Set the node name to the provided name\n     c. Set the node id to the provided id\n   - Add the new node to the parent node:\n     a. Call the addNode method on the parent node\n     b. Pass the newly created node as parameter\n   - Update the hierarchy structure:\n     a. Recalculate any hierarchy-dependent properties\n     b. Update any indexes or caches that track the hierarchy\n\n5. Response Generation:\n   - On success:\n     a. Return confirmation that the node was added successfully\n     b. Include the updated parent node with the new child node\n     c. Include the total count of nodes in the parent\n   - On failure:\n     a. Return appropriate error message\n     b. Include information about which validation or business rule failed\n     c. Provide guidance on how to correct the issue",
    "databaseEntities": [
      "jforum_groups"
    ],
    "validationRules": [
      "Group node name must not be empty",
      "Group node ID must be a positive number",
      "Parent node must exist",
      "Group node ID must be unique within the hierarchy",
      "Adding a node must not create a circular reference",
      "Hierarchy depth limits must not be exceeded"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "GroupNode": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "description": "The name of the group node"
          },
          "id": {
            "type": "number",
            "description": "The unique identifier for the group node"
          },
          "extraNodes": {
            "type": "array",
            "items": {
              "$ref": "#/GroupNode"
            },
            "description": "Collection of child nodes under this group node"
          }
        },
        "required": [
          "name",
          "id"
        ]
      }
    }
  },
  {
    "featureName": "RetrieveGroupNode",
    "description": "Retrieves a specific node from the group hierarchy by position.",
    "inputValues": [
      "position-number-GroupNode"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the position number to identify which node to retrieve from the group hierarchy\n   - Position must be a non-negative integer value\n   - The group hierarchy structure must already exist in the system\n\n2. Data Validation:\n   - Validate that the position parameter is provided\n   - Validate that the position is a valid number\n   - Validate that the position is non-negative\n   - IF position is not provided THEN\n     - Generate error message: \"Position parameter is required\"\n   - IF position is not a valid number THEN\n     - Generate error message: \"Position must be a valid number\"\n   - IF position is negative THEN\n     - Generate error message: \"Position cannot be negative\"\n\n3. Business Rule Processing:\n   - Verify that the group hierarchy structure exists\n   - Verify that the requested position exists within the hierarchy\n   - IF group hierarchy structure does not exist THEN\n     - Generate error message: \"Group hierarchy not initialized\"\n   - IF position is greater than or equal to the size of the node collection THEN\n     - Generate error message: \"Position out of bounds. Maximum allowed position is [size-1]\"\n\n4. Core Operation Execution:\n   - Access the group hierarchy structure\n   - Locate the node at the specified position in the collection\n   - Retrieve the complete node information including:\n     - Node ID\n     - Node name\n     - Any child nodes (if present)\n   - Prepare the node data for return\n\n5. Response Generation:\n   - IF operation is successful THEN\n     - Return the retrieved GroupNode with all its properties\n     - Include node ID, name, and number of child nodes\n   - IF operation fails THEN\n     - Return appropriate error message based on the failure reason\n     - Include guidance on valid position ranges if applicable",
    "databaseEntities": [
      "jforum_groups"
    ],
    "validationRules": [
      "Position parameter must be provided",
      "Position must be a valid number",
      "Position must be non-negative",
      "Position must be less than the size of the node collection",
      "Group hierarchy structure must exist"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "GroupNode": {
        "id": "number",
        "name": "string",
        "childNodes": "array"
      }
    }
  },
  {
    "featureName": "LoadInternationalizationResources",
    "description": "Loads internationalization resource files for language support.",
    "inputValues": [
      "localeName-string-Locale",
      "mergeWith-string-Locale",
      "force-boolean-LoadOption"
    ],
    "businessLogic": "1. Input Collection\n   - Collect the following inputs:\n     a. localeName (string): The name of the locale to load (mandatory)\n     b. mergeWith (string): The name of another locale to merge with (optional)\n     c. force (boolean): Whether to force reload even if already loaded (optional, default: false)\n   - System will use application configuration for:\n     a. Base directory path for locale files\n     b. Default locale name\n     c. File monitoring delay settings\n\n2. Data Validation\n   - Validate localeName:\n     a. IF localeName is null or empty, THEN\n        i. Return without loading anything\n     b. IF force is false AND localeName is already loaded, THEN\n        i. Return without reloading\n   - Validate locale existence:\n     a. IF locale names registry is empty, THEN\n        i. Load locale names registry first\n     b. Check if requested locale exists in registry\n        i. IF not found, use default locale instead\n\n3. Business Rule Processing\n   - Process merge requirements:\n     a. IF mergeWith parameter is provided, THEN\n        i. Check if mergeWith locale is already loaded\n           - IF not loaded, load mergeWith locale first\n        ii. Create new properties collection with merged locale as base\n   - Handle file access:\n     a. Determine correct file path using locale name\n     b. Verify file existence\n        i. IF file doesn't exist, use default locale file instead\n     c. Prepare for file reading operation\n\n4. Core Operation Execution\n   - Load locale file:\n     a. Open file input stream for the locale file\n     b. Load properties from the file\n     c. Close file input stream properly\n   - Store loaded resources:\n     a. Add loaded properties to the messages map with localeName as key\n   - Set up change monitoring:\n     a. IF locale is not already being monitored, THEN\n        i. Add locale to monitoring list\n        ii. IF file change monitoring is enabled (delay > 0), THEN\n            - Register file change listener for automatic reload\n\n5. Response Generation\n   - Success response:\n     a. Locale resources are now available in the system\n     b. Messages can be retrieved using the locale name\n   - Error handling:\n     a. IF file access errors occur, THEN\n        i. Throw appropriate exception with error details\n     b. IF file format is invalid, THEN\n        i. Throw appropriate exception with format error details",
    "databaseEntities": [],
    "validationRules": [
      "Locale name must not be null or empty for loading",
      "Locale file must exist or system must fall back to default locale",
      "Base directory for locale files must be properly configured",
      "Locale names registry must be available or loadable"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Locale": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "description": "Identifier for the locale"
          },
          "properties": {
            "type": "object",
            "description": "Collection of message keys and their translated values"
          }
        }
      },
      "LoadOption": {
        "type": "object",
        "properties": {
          "force": {
            "type": "boolean",
            "description": "Whether to force reload of already loaded resources"
          }
        }
      }
    }
  },
  {
    "featureName": "GetLocalizedMessage",
    "description": "Retrieves internationalized messages with optional parameter formatting.",
    "inputValues": [
      "messageName-string-Message",
      "localeName-string-Locale",
      "parameters-object-Parameters"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the following inputs:\n     a. messageName (mandatory): The key identifier for the message to retrieve\n     b. localeName (optional): The language/locale identifier\n     c. parameters (optional): Values to be inserted into message placeholders\n   - If localeName is not provided, determine the current user's language preference\n   - If parameters are not provided, use the message as-is without formatting\n\n2. Data Validation:\n   - Validate messageName:\n     a. Check if messageName is not null or empty\n     b. Verify messageName exists in the message repository\n     c. If invalid, prepare appropriate error message\n   - Validate localeName (if provided):\n     a. Check if localeName is registered in the system\n     b. Verify if localization files exist for the specified locale\n     c. If invalid, fall back to the default language\n   - Validate parameters (if provided):\n     a. Ensure parameters match the expected format for the message template\n     b. Verify parameter count matches placeholder count in the message\n     c. If parameters are invalid, prepare appropriate error message\n\n3. Business Rule Processing:\n   - Determine the appropriate locale to use:\n     a. IF localeName is provided and valid, use it\n     b. ELSE IF current user has a language preference set, use that\n     c. ELSE use the system default language\n   - Check if the determined locale is already loaded:\n     a. IF not loaded, load the locale resource files\n     b. IF loading fails, fall back to default locale\n   - Handle locale inheritance:\n     a. IF the locale has a parent locale defined, ensure parent messages are available\n     b. Prepare for message fallback to parent locale if needed\n\n4. Core Operation Execution:\n   - Retrieve the raw message template:\n     a. Look up the message by messageName in the appropriate locale resource bundle\n     b. IF message not found in specified locale, check parent locale\n     c. IF still not found, check system default locale\n     d. IF still not found, return an error indicator or the message key itself\n   - Process the message template:\n     a. IF parameters are provided:\n        i. Format the message by replacing placeholders with parameter values\n        ii. Handle any special formatting requirements (dates, numbers, etc.)\n     b. ELSE return the raw message template\n   - Handle any encoding or character set requirements\n\n5. Response Generation:\n   - Prepare the final localized message:\n     a. Ensure proper encoding of special characters\n     b. Apply any text direction requirements (left-to-right or right-to-left)\n   - Return the formatted message to the caller\n   - IF any errors occurred during processing:\n     a. Log appropriate error information\n     b. Return a fallback message or error indicator\n     c. Include information about the failure reason",
    "databaseEntities": [],
    "validationRules": [
      "Message name must not be empty",
      "Locale name must be registered in the system if provided",
      "Parameters must match the expected format for the message template",
      "Message must exist in at least the default locale"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Parameters": {
        "type": "array",
        "items": {
          "type": "object",
          "properties": {
            "value": {
              "type": "string",
              "description": "The value to insert into the message template"
            },
            "type": {
              "type": "string",
              "description": "Optional type information for formatting (date, number, etc.)"
            }
          },
          "required": [
            "value"
          ]
        }
      }
    }
  },
  {
    "featureName": "ChangeBoardDefaultLanguage",
    "description": "Updates the default language used throughout the forum.",
    "inputValues": [
      "newDefaultLanguage-string-Language"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the following required inputs:\n     a. newDefaultLanguage (string): The language code for the new default language\n     - This is a mandatory field with no default value\n     - The value must correspond to an available language in the system\n\n2. Data Validation:\n   - Validate the newDefaultLanguage input:\n     a. Check if the newDefaultLanguage is not null or empty\n        IF newDefaultLanguage is null or empty THEN\n          Generate error message: \"Default language cannot be empty\"\n          Exit process\n        END IF\n     b. Check if the newDefaultLanguage exists in the system\n        IF newDefaultLanguage does not exist in available languages THEN\n          Generate error message: \"The specified language is not available in the system\"\n          Exit process\n        END IF\n\n3. Business Rule Processing:\n   - Check system state for language change:\n     a. Verify if the requested language is different from current default\n        IF newDefaultLanguage is same as current default language THEN\n          Generate notification: \"The requested language is already set as default\"\n          Exit process without making changes\n        END IF\n     b. Verify if language resources are accessible\n        IF language resource files cannot be accessed THEN\n          Generate error message: \"Cannot access language resources\"\n          Exit process\n        END IF\n\n4. Core Operation Execution:\n   - Change the default language:\n     a. Load the new language resources\n        - Access language resource files for the new language\n        - If merging with admin language is required, perform merge\n     b. Set the new language as system default\n        - Update system configuration to use new language\n        - Store the new default language setting\n     c. IF any errors occur during language change THEN\n          Revert to previous default language\n          Generate error message: \"Failed to change default language\"\n          Exit process\n        END IF\n\n5. Response Generation:\n   - Generate success response:\n     a. Create confirmation message that language was changed successfully\n     b. Include the name of the new default language in the response\n     c. Provide information about system-wide effect of the change\n     d. IF users need to refresh or restart sessions THEN\n          Include this information in the response\n        END IF",
    "databaseEntities": [
      "jforum_users"
    ],
    "validationRules": [
      "New default language must not be null or empty",
      "New default language must exist in the system's available languages",
      "Language resource files must be accessible"
    ],
    "dbSeedingOperations": [],
    "schema": {}
  },
  {
    "featureName": "CheckLanguageAvailability",
    "description": "Verifies if a specific language is loaded or exists in the system.",
    "inputValues": [
      "language-string-Language"
    ],
    "businessLogic": "1. Input Collection:\n   1.1. Collect the language identifier string.\n       1.1.1. The language identifier is a mandatory input.\n       1.1.2. No default value is provided.\n\n2. Data Validation:\n   2.1. Validate the language identifier format.\n       2.1.1. Ensure the language identifier is not null.\n       2.1.2. Ensure the language identifier is not an empty string.\n       2.1.3. IF validation fails, THEN return an error message indicating invalid language format.\n\n3. Business Rule Processing:\n   3.1. Check system state for language availability.\n       3.1.1. Verify if the language resources are initialized.\n       3.1.2. IF language resources are not initialized, THEN initialize the language system.\n   3.2. Determine the type of verification needed.\n       3.2.1. Decide whether to check if language is loaded in memory or if it exists as a valid option.\n\n4. Core Operation Execution:\n   4.1. Check if the language is currently loaded in the system.\n       4.1.1. Search the loaded languages collection for the specified language identifier.\n       4.1.2. IF the language is found in the loaded collection, THEN mark as \"loaded\".\n       4.1.3. IF the language is not found, THEN mark as \"not loaded\".\n   4.2. Check if the language exists as a valid option.\n       4.2.1. Search the available language definitions for the specified language identifier.\n       4.2.2. IF the language is found in the definitions, THEN mark as \"exists\".\n       4.2.3. IF the language is not found, THEN mark as \"does not exist\".\n\n5. Response Generation:\n   5.1. Prepare the verification result.\n       5.1.1. Include the language identifier in the response.\n       5.1.2. Include the \"loaded\" status in the response.\n       5.1.3. Include the \"exists\" status in the response.\n   5.2. Return the verification result.\n       5.2.1. IF both checks were successful, THEN return success response with availability details.\n       5.2.2. IF any check failed, THEN return appropriate status indicating which aspect of availability failed.",
    "databaseEntities": [],
    "validationRules": [
      "Language identifier must not be null",
      "Language identifier must not be an empty string"
    ],
    "dbSeedingOperations": [],
    "schema": {}
  },
  {
    "featureName": "GetUserLanguagePreference",
    "description": "Determines the appropriate language based on user session settings.",
    "inputValues": [
      "userSession-object-UserSession"
    ],
    "businessLogic": "1. Input Collection:\n   - Retrieve UserSession object which may contain language preference\n   - System will need access to default language configuration\n   1.1. Identify if UserSession is available\n   1.2. Check if language preference is set in UserSession\n   1.3. Access system default language configuration if needed\n\n2. Data Validation:\n   - Validate UserSession data\n   2.1. Check if UserSession object exists\n   2.2. IF UserSession is null THEN mark as invalid\n   2.3. IF UserSession exists, check if language attribute exists\n   2.4. IF language attribute exists, check if it contains a value\n   2.5. IF language value exists, check if it's not an empty string\n\n3. Business Rule Processing:\n   - Apply language selection logic\n   3.1. IF UserSession is valid AND has non-empty language setting THEN\n       3.1.1. Select the user's preferred language\n   3.2. ELSE\n       3.2.1. Select the system default language\n   3.3. Verify the selected language exists in the system\n       3.3.1. IF selected language is not registered in the system THEN\n           3.3.1.1. Fall back to system default language\n\n4. Core Operation Execution:\n   - Determine final language selection\n   4.1. Based on validation and business rules, select appropriate language\n       4.1.1. IF user has valid language preference THEN use that language\n       4.1.2. ELSE use system default language\n   4.2. Return the selected language identifier\n       4.2.1. Ensure language identifier is properly formatted\n       4.2.2. Verify language resources are available\n\n5. Response Generation:\n   - Provide the determined language preference\n   5.1. Return language identifier string\n   5.2. IF operation successful, provide language code\n   5.3. IF operation encounters issues, provide default language and log issue",
    "databaseEntities": [
      "jforum_users",
      "jforum_sessions"
    ],
    "validationRules": [
      "UserSession must be checked for null before accessing properties",
      "Language preference must be non-null and non-empty to be considered valid",
      "Selected language must exist in the system's registered languages",
      "Default language must be available as fallback"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "UserSession": {
        "type": "object",
        "properties": {
          "lang": {
            "type": "string",
            "description": "User's language preference code"
          }
        }
      }
    }
  },
  {
    "featureName": "MonitorLanguageFileChanges",
    "description": "Watches for changes in language files and reloads them automatically when modifications are detected.",
    "inputValues": [
      "localeName-string-Language",
      "fileChangeDelay-number-SystemConfiguration"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect localeName (string): The identifier for the language file to monitor\n   - Retrieve fileChangesDelay (number): Time interval in milliseconds between file checks\n     - This value is system-generated from configuration settings\n     - Default value is determined by system configuration\n\n2. Data Validation:\n   - Validate localeName:\n     - Check if localeName is not null or empty\n     - Verify localeName exists in the available locales list\n     - IF localeName is invalid THEN generate appropriate error message\n   - Validate fileChangesDelay:\n     - Verify fileChangesDelay is a positive number\n     - IF fileChangesDelay is zero or negative THEN monitoring will be disabled\n\n3. Business Rule Processing:\n   - Check if the language file is already being monitored\n     - IF language file is already being monitored THEN skip adding duplicate monitor\n   - Determine the full file path for the language file\n     - Combine base directory with locale-specific filename\n     - Verify file exists at the specified location\n     - IF file does not exist THEN generate appropriate error message\n\n4. Core Operation Execution:\n   - Add localeName to the list of monitored languages\n   - IF fileChangesDelay is greater than zero THEN:\n     - Register a file change listener for the language file\n     - Configure the listener with:\n       - The full path to the language file\n       - The specified monitoring interval (fileChangesDelay)\n       - A callback action to execute when changes are detected\n   - When file changes are detected:\n     - Record monitoring activity in system logs\n     - Reload the language file with updated content\n     - Merge with default language if necessary\n     - Update the language cache with new translations\n\n5. Response Generation:\n   - Success response:\n     - Confirmation that monitoring has been established\n     - Details of the monitored file path\n     - The configured monitoring interval\n   - Error response:\n     - Specific error message describing the failure\n     - Suggestions for resolving the issue",
    "databaseEntities": [],
    "validationRules": [
      "LocaleName must not be null or empty",
      "LocaleName must exist in the available locales list",
      "FileChangesDelay must be a number",
      "Language file must exist at the specified path"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Language": {
        "localeName": "string",
        "filePath": "string",
        "isMonitored": "boolean"
      },
      "SystemConfiguration": {
        "fileChangesDelay": "number"
      }
    }
  },
  {
    "featureName": "EncryptStringWithMD5",
    "description": "Encrypts a string using MD5 hashing algorithm and returns the hexadecimal representation.",
    "inputValues": [
      "inputString-string-StringToEncrypt"
    ],
    "businessLogic": "1. Input Collection\n   1.1. Collect the input string to be encrypted\n       1.1.1. Receive the string value from the user or system\n       1.1.2. This input is mandatory and must be provided\n       1.1.3. No default value is provided\n\n2. Data Validation\n   2.1. Validate the input string\n       2.1.1. Check if the input string is null\n          IF input string is null THEN\n             Generate an error message indicating string cannot be null\n             Terminate the process\n       2.1.2. Check if the input string is empty\n          IF input string length is zero THEN\n             Generate an error message indicating string cannot be empty\n             Terminate the process\n\n3. Business Rule Processing\n   3.1. Prepare for encryption\n       3.1.1. Initialize a buffer to store the hexadecimal result\n       3.1.2. Verify system capability to perform MD5 hashing\n          IF MD5 algorithm is not available THEN\n             Generate an error message indicating encryption cannot be performed\n             Terminate the process\n\n4. Core Operation Execution\n   4.1. Perform MD5 hashing\n       4.1.1. Convert the input string to bytes\n       4.1.2. Apply the MD5 algorithm to the byte array\n       4.1.3. Obtain the resulting hash as a byte array\n   4.2. Convert hash to hexadecimal representation\n       4.2.1. Iterate through each byte in the hash\n          FOR each byte in the hash\n             4.2.1.1. Convert the byte to an integer value (0-255)\n             4.2.1.2. Convert the integer to a hexadecimal string\n             4.2.1.3. IF the hexadecimal value is a single digit (less than 16)\n                         Prepend a '0' to the hexadecimal value\n             4.2.1.4. Append the hexadecimal value to the result buffer\n\n5. Response Generation\n   5.1. Return the encrypted string\n       5.1.1. Provide the hexadecimal string representation of the MD5 hash\n       5.1.2. In case of success, return the complete 32-character hexadecimal string\n       5.1.3. In case of failure, provide appropriate error information",
    "databaseEntities": [],
    "validationRules": [
      "Input string must not be null",
      "Input string must not be empty",
      "System must support MD5 hashing algorithm"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "StringToEncrypt": {
        "type": "object",
        "properties": {
          "value": {
            "type": "string",
            "description": "The string value to be encrypted"
          }
        },
        "required": [
          "value"
        ]
      }
    }
  },
  {
    "featureName": "MakeSafeHtml",
    "description": "Sanitizes HTML content by removing unsafe tags and attributes to prevent XSS attacks.",
    "inputValues": [
      "htmlContent-string-Content",
      "sanitizationMode-string-Mode"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the HTML content to be sanitized (htmlContent-string-Content)\n   - Determine the sanitization mode (sanitizationMode-string-Mode)\n     - Valid modes: \"full\" (complete sanitization) or \"attributesOnly\" (only check attributes)\n     - Default mode is \"full\" if not specified\n   - System loads configuration for allowed HTML tags, attributes, and protocols\n\n2. Data Validation:\n   - Validate HTML content:\n     - Check if content is null or empty\n       - IF content is null or empty THEN return the content as-is without processing\n     - Check if content contains HTML tags\n       - IF no HTML tags are detected THEN return content as-is\n   - Validate sanitization mode:\n     - IF mode is not \"full\" or \"attributesOnly\" THEN default to \"full\"\n\n3. Business Rule Processing:\n   - Load system configuration settings:\n     - Retrieve list of allowed HTML tags from system configuration\n     - Retrieve list of allowed HTML attributes from system configuration\n     - Retrieve list of allowed URL protocols from system configuration\n   - Determine processing approach based on sanitization mode:\n     - IF mode is \"attributesOnly\" THEN prepare for attribute-only sanitization\n     - IF mode is \"full\" THEN prepare for complete HTML sanitization\n\n4. Core Operation Execution:\n   - Parse the HTML content into a structured format\n   - IF sanitization mode is \"full\":\n     - For each HTML node in the content:\n       - IF node is a text node:\n         - Escape any HTML-like characters (< and >)\n       - IF node is an HTML tag:\n         - Check if the tag is in the allowed tags list\n           - IF tag is allowed:\n             - Validate and sanitize all attributes of the tag\n             - Keep the tag with sanitized attributes\n           - IF tag is not allowed:\n             - Convert tag to escaped text to prevent execution\n     - Reconstruct the sanitized HTML content\n   - IF sanitization mode is \"attributesOnly\":\n     - For each HTML tag in the content:\n       - Validate all attributes against security rules:\n         - Remove event handler attributes (starting with \"on\")\n         - Remove attributes with newlines, carriage returns, or null characters\n         - Validate href and src attributes to ensure they use allowed protocols\n         - Check style attributes for potentially dangerous constructs\n       - Keep the tag with sanitized attributes\n     - Reconstruct the HTML content with sanitized attributes\n\n5. Response Generation:\n   - Return the sanitized HTML content\n   - IF any parsing errors occurred during processing:\n     - Log the error details\n     - Return an appropriate error message\n   - Include information about what was sanitized (optional for debugging)",
    "databaseEntities": [],
    "validationRules": [
      "HTML content must be properly formatted for parsing",
      "Sanitization mode must be either 'full' or 'attributesOnly'",
      "HTML tags must be in the allowed tags list to be preserved",
      "HTML attributes must be in the allowed attributes list to be preserved",
      "URL protocols in href and src attributes must be in the allowed protocols list",
      "Attributes with event handlers (starting with 'on') are not allowed",
      "Attributes containing newlines, carriage returns, or null characters are not allowed",
      "Style attributes must not contain parentheses to prevent JavaScript execution"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Content": {
        "type": "object",
        "properties": {
          "htmlContent": {
            "type": "string",
            "description": "The HTML content to be sanitized"
          }
        }
      },
      "Mode": {
        "type": "object",
        "properties": {
          "sanitizationMode": {
            "type": "string",
            "enum": [
              "full",
              "attributesOnly"
            ],
            "description": "The mode of sanitization to apply"
          }
        }
      }
    }
  },
  {
    "featureName": "EnsureAllAttributesAreSafe",
    "description": "Validates and sanitizes HTML tag attributes to ensure they don't contain malicious code.",
    "inputValues": [
      "htmlContent-string-Content"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the HTML content (htmlContent-string-Content) to be sanitized\n   - This content is mandatory and must be provided as a string\n   - No default values are provided\n\n2. Data Validation:\n   - Validate that the input HTML content is not null\n   - Validate that the input HTML content is not empty\n   - IF the content is null OR empty THEN\n     - Return the content as-is without processing\n   - ENDIF\n\n3. Business Rule Processing:\n   - Verify that the HTML parsing system is available\n   - Prepare the output buffer to store the sanitized content\n   - Prepare the HTML lexer/parser to process the content\n   - Verify that the configuration for allowed tags and attributes is loaded\n\n4. Core Operation Execution:\n   - Initialize a buffer to store the sanitized output\n   - Parse the HTML content into individual nodes\n   - FOR each node in the HTML content:\n     - IF the node is an HTML tag THEN\n       - Extract all attributes from the tag\n       - FOR each attribute in the tag:\n         - IF attribute name is null THEN\n           - Keep the attribute as-is\n         - ELSE\n           - Convert attribute name to uppercase for case-insensitive comparison\n           - IF attribute value is null THEN\n             - Keep the attribute as-is\n           - ELSE\n             - Convert attribute value to lowercase for case-insensitive comparison\n             - Check if the attribute is potentially dangerous:\n               - IF attribute name starts with \"ON\" (event handlers) THEN\n                 - Remove the attribute\n               - ELSE IF attribute value contains newlines, carriage returns, or null characters THEN\n                 - Remove the attribute\n               - ELSE IF attribute is \"HREF\" or \"SRC\" THEN\n                 - Validate the URL protocol against allowed protocols list\n                 - IF protocol is not allowed THEN\n                   - Remove the attribute\n                 - ENDIF\n               - ELSE IF attribute is \"STYLE\" THEN\n                 - Check for potentially dangerous constructs like functions\n                 - IF style contains parentheses THEN\n                   - Remove the attribute\n                 - ENDIF\n               - ENDIF\n             - IF attribute value contains HTML entity codes (&#) THEN\n               - Replace them with safe equivalents (&amp;#)\n             - ENDIF\n             - Keep the sanitized attribute\n           - ENDIF\n         - ENDIF\n       - ENDFOR\n       - Update the tag with only the sanitized attributes\n       - Add the sanitized tag to the output buffer\n     - ELSE\n       - Add the node as-is to the output buffer\n     - ENDIF\n   - ENDFOR\n   - IF any parsing error occurs THEN\n     - Generate appropriate error information\n     - Handle the exception according to system policy\n   - ENDIF\n\n5. Response Generation:\n   - Return the sanitized HTML content as a string\n   - IF any errors occurred during processing THEN\n     - Include error information in the response\n   - ENDIF",
    "databaseEntities": [],
    "validationRules": [
      "HTML content must not be null",
      "Attribute names starting with 'ON' are not allowed (event handlers)",
      "Attribute values must not contain newlines, carriage returns, or null characters",
      "HREF and SRC attributes must use allowed protocols only",
      "STYLE attributes must not contain function calls (parentheses)",
      "HTML entity codes in attribute values must be properly escaped"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Content": {
        "type": "object",
        "properties": {
          "htmlContent": {
            "type": "string",
            "description": "HTML content to be sanitized"
          }
        },
        "required": [
          "htmlContent"
        ]
      }
    }
  },
  {
    "featureName": "ValidateHrefLinks",
    "description": "Checks if URLs in href attributes use allowed protocols to prevent JavaScript injection.",
    "inputValues": [
      "content-string-HtmlContent",
      "allowedProtocols-object-ProtocolList"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the HTML content to be validated (content-string-HtmlContent)\n   - Collect the list of allowed protocols (allowedProtocols-object-ProtocolList)\n   - System will use configuration settings if no protocols are explicitly provided\n\n2. Data Validation:\n   - Verify that the HTML content is not empty\n     * IF content is null or empty THEN\n       - Return empty string\n     * END IF\n   - Verify that the allowed protocols list is available\n     * IF allowedProtocols is not provided THEN\n       - Load default allowed protocols from system configuration\n     * END IF\n\n3. Business Rule Processing:\n   - Prepare validation environment\n     * Initialize HTML parsing mechanism\n     * Prepare storage for processed content\n   - Determine validation mode\n     * Check if relative URLs are allowed based on system configuration\n     * Verify welcome tags and attributes are properly loaded\n\n4. Core Operation Execution:\n   - Parse the HTML content into manageable nodes\n     * FOR each node in the HTML content DO\n       - IF node is a tag with href attribute THEN\n         * Extract the href value\n         * Check if href value starts with any allowed protocol\n           - IF href starts with allowed protocol THEN\n             > Mark as valid\n           - ELSE IF relative URLs are allowed AND href starts with '/' THEN\n             > Mark as valid\n           - ELSE\n             > Mark as invalid\n           - END IF\n         * IF href is invalid THEN\n           > Remove or sanitize the attribute\n         * END IF\n       - END IF\n     * END FOR\n   - Reconstruct the HTML with validated href attributes\n\n5. Response Generation:\n   - Compile the processed HTML content with all validated links\n   - Return the sanitized HTML content\n   - IF any links were sanitized or removed THEN\n     * Include information about modified content\n   - END IF",
    "databaseEntities": [],
    "validationRules": [
      "HTML content must not be null or empty",
      "Href attributes must start with an allowed protocol",
      "Relative URLs must start with '/' if allowed by configuration",
      "Protocols in href attributes must match case-insensitively with allowed protocols",
      "Href values must not contain newlines, carriage returns, or null characters"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "ProtocolList": {
        "type": "array",
        "items": {
          "type": "string",
          "description": "Valid protocol prefix (e.g., 'http://', 'https://', 'ftp://')"
        }
      }
    }
  },
  {
    "featureName": "GetGroupHierarchy",
    "description": "Retrieves the complete hierarchical structure of groups with parent-child relationships.",
    "inputValues": [
      "parentGroupId-number-Group"
    ],
    "businessLogic": "1. Input Collection\n   - Collect the following inputs:\n     1.1. parentGroupId (number, optional): The ID of the parent group to start hierarchy from\n         - If not provided, default to 0 (root level)\n\n2. Data Validation\n   - Validate the input parameters:\n     2.1. IF parentGroupId is provided THEN\n         2.1.1. Verify parentGroupId is a valid number\n         2.1.2. Verify parentGroupId exists in the group database\n         2.1.3. IF validation fails THEN\n             - Generate appropriate error message\n             - Return error response\n\n3. Business Rule Processing\n   - Verify system state and access permissions:\n     3.1. Check if the current user has permission to view group hierarchy\n     3.2. Verify the group system is properly configured\n     3.3. IF any verification fails THEN\n         - Generate appropriate error message\n         - Return error response\n\n4. Core Operation Execution\n   - Retrieve and build the group hierarchy:\n     4.1. Initialize an empty list to store the group hierarchy nodes\n     4.2. Retrieve all root groups (groups with the specified parentGroupId or 0 if not specified)\n     4.3. FOR EACH root group retrieved:\n         4.3.1. Create a group node object with the group's information\n         4.3.2. Process child groups recursively:\n             a. Retrieve all child groups where parent ID equals current group ID\n             b. FOR EACH child group:\n                 i. Create a child group node\n                 ii. Process its children recursively (repeat from step a)\n                 iii. Add the child node to the current group's children list\n         4.3.3. Add the complete group node (with all its children) to the result list\n     4.4. IF any error occurs during processing THEN\n         - Log the error details\n         - Generate appropriate error message\n         - Return error response\n\n5. Response Generation\n   - Prepare and return the group hierarchy:\n     5.1. Format the hierarchical structure of groups\n     5.2. Include the following information for each group:\n         - Group ID\n         - Group name\n         - Parent group ID\n         - List of child groups (if any)\n         - Depth level in the hierarchy\n     5.3. Return the complete hierarchy structure\n     5.4. IF the operation was successful THEN\n         - Include success status in the response\n     5.5. ELSE\n         - Include error details and suggestions for resolution",
    "databaseEntities": [
      "jforum_groups",
      "jforum_user_groups"
    ],
    "validationRules": [
      "Parent group ID must be a valid number if provided",
      "Parent group must exist in the database if ID is provided",
      "User must have permission to view group hierarchy",
      "Group system must be properly configured"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "GroupNode": {
        "id": "number",
        "name": "string",
        "parentId": "number",
        "children": "array",
        "depth": "number"
      }
    }
  },
  {
    "featureName": "ProcessSubgroups",
    "description": "Recursively processes group hierarchies by finding and attaching child groups to their parents.",
    "inputValues": [
      "rootGroups-object-GroupNodeList",
      "groupId-number-GroupNode"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the list of root groups (rootGroups) with parent ID of 0\n   - For each operation on a specific group, collect the group ID (groupId)\n   - System will use these inputs to build the complete hierarchical structure\n\n2. Data Validation:\n   - Validate that rootGroups is a properly structured list\n     * IF rootGroups is null or empty THEN return empty result list\n     * ENSURE each group node contains at minimum an ID and name\n   - Validate groupId when processing a specific group\n     * ENSURE groupId is a positive integer\n     * VERIFY the group exists in the system\n\n3. Business Rule Processing:\n   - Verify access permissions to group hierarchy\n     * CHECK if current user has permission to view group structure\n     * IF permission denied THEN return appropriate error message\n   - Check system state for group processing\n     * ENSURE group system is initialized and available\n     * VERIFY no concurrent group structure modifications are in progress\n\n4. Core Operation Execution:\n   - Initialize empty result list to store processed group hierarchy\n   - FOR each root group in the rootGroups list:\n     * Create a new group node object with root group data\n     * Process child groups recursively:\n       > Retrieve all direct child groups where parent ID matches current group ID\n       > FOR each child group found:\n         # Process any children of this child group recursively\n         # Attach the fully processed child group to its parent\n     * Add the complete root group with all descendants to result list\n   - Handle circular references:\n     * WHILE processing child groups, maintain a list of already processed group IDs\n     * IF a group ID is encountered that's already in the processed list THEN\n       > Skip processing to prevent infinite recursion\n       > Log warning about circular reference\n\n5. Response Generation:\n   - Return the complete hierarchical structure of groups\n   - For each group node in the result, include:\n     * Group identification information (ID, name)\n     * List of all child groups (if any)\n     * Depth level in the hierarchy\n   - IF any errors occurred during processing:\n     * Return appropriate error information\n     * Include details about which part of the hierarchy failed to process",
    "databaseEntities": [
      "jforum_groups"
    ],
    "validationRules": [
      "Group IDs must be positive integers",
      "Root groups must have parent ID of 0",
      "Child groups must have a valid parent ID that exists in the system",
      "Group hierarchy must not contain circular references",
      "Each group must have a unique ID",
      "Each group must have a non-empty name"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "GroupNode": {
        "id": "number",
        "name": "string",
        "parentId": "number",
        "childNodes": "array<GroupNode>"
      },
      "GroupNodeList": {
        "type": "array",
        "items": {
          "$ref": "#/GroupNode"
        }
      }
    }
  },
  {
    "featureName": "NormalizeUrl",
    "description": "Normalizes URLs by replacing spaces with underscores and removing special characters.",
    "inputValues": [
      "url-string-UrlInput",
      "limit-number-UrlLimit",
      "friendlyTruncate-boolean-TruncateOption"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the URL string to be normalized (mandatory)\n   - Collect the character limit for truncation (optional, default: 30)\n   - Collect the friendly truncation flag (optional, default: true)\n\n2. Data Validation:\n   - Validate URL string:\n     a. Check if URL string is not null\n     b. Check if URL string is not empty\n     c. If validation fails, return appropriate error message\n   - Validate character limit:\n     a. Check if limit is a positive integer\n     b. If validation fails, use default limit value (30)\n   - Validate friendly truncation flag:\n     a. Check if friendlyTruncate is a boolean value\n     b. If validation fails, use default value (true)\n\n3. Business Rule Processing:\n   - Determine the maximum length for processing:\n     a. IF friendly truncation is enabled, processing may exceed the limit to avoid cutting words\n     b. IF friendly truncation is disabled, strictly enforce the character limit\n   - Prepare character replacement rules:\n     a. Space characters should be replaced with underscores\n     b. Hyphen characters should be replaced with underscores\n     c. Only letters and digits should be retained\n     d. Multiple consecutive spaces/hyphens should be replaced with a single underscore\n\n4. Core Operation Execution:\n   - Convert the input URL to a character array for processing\n   - Initialize an empty result buffer to store the normalized URL\n   - Process each character in the input URL:\n     a. IF current position is within limit OR (friendly truncation is enabled AND processing beyond limit but last character is not underscore):\n       i. IF character is a space or hyphen:\n          - IF friendly truncation is enabled AND beyond limit, exit the loop\n          - IF previous character is not underscore, append underscore to result\n       ii. IF character is a letter or digit:\n          - Append character to result\n       iii. ELSE IF friendly truncation is enabled AND beyond limit:\n          - Exit the loop\n   - Convert the final result to lowercase\n\n5. Response Generation:\n   - Return the normalized URL string\n   - IF an error occurred during processing, return appropriate error message\n   - Include information about any truncation that occurred",
    "databaseEntities": [],
    "validationRules": [
      "URL string must not be null or empty",
      "Character limit must be a positive integer",
      "Friendly truncation flag must be a boolean value",
      "Spaces and hyphens must be replaced with underscores",
      "Only letters, digits, and underscores are allowed in the normalized URL",
      "The normalized URL must be converted to lowercase",
      "Multiple consecutive spaces or hyphens must be replaced with a single underscore"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "UrlInput": {
        "type": "string",
        "description": "The URL string to be normalized"
      },
      "UrlLimit": {
        "type": "number",
        "description": "Maximum number of characters to process",
        "default": 30
      },
      "TruncateOption": {
        "type": "boolean",
        "description": "Flag indicating whether to use friendly truncation",
        "default": true
      }
    }
  },
  {
    "featureName": "NormalizeUrlWithLimits",
    "description": "Normalizes URLs with customizable character limits and truncation options.",
    "inputValues": [
      "url-string-UrlInput",
      "limit-number-CharacterLimit",
      "friendlyTruncate-boolean-TruncationOption"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the URL string to be normalized (mandatory)\n   - Collect character limit for truncation (optional, default: 30)\n   - Collect friendly truncation flag (optional, default: true)\n\n2. Data Validation:\n   - Validate URL input:\n     a. Check if URL is not null or empty\n     b. If URL is null or empty, return an error message\n   - Validate character limit:\n     a. Ensure limit is a positive integer\n     b. If limit is negative or zero, use the default limit value\n   - Validate friendly truncation flag:\n     a. Ensure the value is a boolean\n     b. If invalid, use the default value (true)\n\n3. Business Rule Processing:\n   - Determine the effective character limit to use:\n     a. IF custom limit is provided and valid, use it\n     b. ELSE use the default limit (30 characters)\n   - Determine the truncation behavior:\n     a. IF friendly truncation is enabled, prepare to avoid cutting words\n     b. ELSE prepare for strict character limit enforcement\n\n4. Core Operation Execution:\n   - Initialize an empty result container for the normalized URL\n   - Process the input URL character by character:\n     a. FOR each character in the input URL:\n        i. IF within character limit OR (friendly truncation is enabled AND processing beyond limit but last character added wasn't a separator):\n           - IF character is a space or hyphen:\n             * IF friendly truncation is enabled AND beyond limit, stop processing\n             * IF previous character in result isn't already a separator, add an underscore\n           - ELSE IF character is a letter or digit:\n             * Add the character to the result\n           - ELSE IF friendly truncation is enabled AND beyond limit:\n             * Stop processing\n   - Convert the final result to lowercase\n\n5. Response Generation:\n   - Return the normalized URL string\n   - IF the URL was truncated, indicate this in the response\n   - IF any errors occurred during processing, return appropriate error information",
    "databaseEntities": [],
    "validationRules": [
      "URL input must not be null or empty",
      "Character limit must be a positive integer",
      "Friendly truncation flag must be a boolean value"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "UrlInput": {
        "type": "string",
        "description": "The URL string to be normalized"
      },
      "CharacterLimit": {
        "type": "number",
        "description": "Maximum number of characters to process",
        "default": 30
      },
      "TruncationOption": {
        "type": "boolean",
        "description": "Whether to use friendly truncation that avoids cutting words",
        "default": true
      }
    }
  },
  {
    "featureName": "CreateBBCode",
    "description": "Creates a BBCode tag with specified name, regex pattern, and replacement text.",
    "inputValues": [
      "tagName-string-BBCode",
      "regex-string-BBCode",
      "replace-string-BBCode",
      "removeQuotes-boolean-BBCode",
      "alwaysProcess-boolean-BBCode"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the following inputs:\n     a. tagName (string, mandatory): The name of the BBCode tag to be created\n     b. regex (string, mandatory): Regular expression pattern for matching the tag\n     c. replace (string, mandatory): Replacement text/pattern for the tag\n     d. removeQuotes (boolean, optional): Flag indicating whether quotes should be removed\n     e. alwaysProcess (boolean, optional): Flag indicating whether the tag should always be processed\n\n2. Data Validation:\n   a. Validate tagName:\n      - Check if tagName is not empty\n      - Verify tagName follows allowed format (alphanumeric characters)\n      - IF validation fails, THEN generate appropriate error message\n   b. Validate regex:\n      - Check if regex is not empty\n      - Verify regex is a valid regular expression pattern\n      - IF validation fails, THEN generate appropriate error message\n   c. Validate replace:\n      - Check if replace is not empty\n      - IF validation fails, THEN generate appropriate error message\n   d. Validate boolean flags:\n      - Ensure removeQuotes and alwaysProcess are valid boolean values\n      - Set default values if not provided (false for both)\n\n3. Business Rule Processing:\n   a. Check for tag name conflicts:\n      - Verify the tagName doesn't conflict with existing BBCode tags\n      - IF conflict exists, THEN generate error message about duplicate tag name\n   b. Verify regex pattern compatibility:\n      - Ensure the regex pattern is compatible with the system\n      - Check for potential security issues in the regex pattern\n      - IF issues found, THEN generate appropriate warning or error\n\n4. Core Operation Execution:\n   a. Create new BBCode instance:\n      - Initialize a new BBCode object\n      - Set the tagName property to the provided value\n      - Set the regex property to the provided pattern\n      - Set the replace property to the provided replacement text\n   b. Configure additional properties:\n      - IF removeQuotes is true, THEN enable quote removal for this BBCode\n      - IF alwaysProcess is true, THEN enable always process flag for this BBCode\n   c. Register the BBCode:\n      - Add the new BBCode to the system's collection of available BBCodes\n      - Ensure the BBCode is properly indexed for efficient lookup\n   d. Update any related caches:\n      - Clear or update any caches that might contain BBCode information\n\n5. Response Generation:\n   a. Success response:\n      - Generate confirmation that BBCode was successfully created\n      - Include the created BBCode details (tagName, regex pattern summary)\n      - Provide information on how to use the newly created BBCode\n   b. Error response:\n      - IF any step failed, THEN provide detailed error information\n      - Include specific validation errors or business rule violations\n      - Suggest possible solutions or alternatives",
    "databaseEntities": [],
    "validationRules": [
      "Tag name must not be empty",
      "Regular expression pattern must not be empty",
      "Replacement text must not be empty",
      "Tag name must be unique",
      "Regular expression must be valid"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "BBCode": {
        "type": "object",
        "properties": {
          "tagName": {
            "type": "string",
            "description": "The name of the BBCode tag"
          },
          "regex": {
            "type": "string",
            "description": "Regular expression pattern for matching the tag"
          },
          "replace": {
            "type": "string",
            "description": "Replacement text/pattern for the tag"
          },
          "removeQuotes": {
            "type": "boolean",
            "description": "Flag indicating whether quotes should be removed"
          },
          "alwaysProcess": {
            "type": "boolean",
            "description": "Flag indicating whether the tag should always be processed"
          }
        },
        "required": [
          "tagName",
          "regex",
          "replace"
        ]
      }
    }
  },
  {
    "featureName": "ConfigureBBCodeProcessing",
    "description": "Configures BBCode processing options including quote removal and always-process settings.",
    "inputValues": [
      "tagName-string-BBCode",
      "regex-string-BBCode",
      "replace-string-BBCode",
      "removeQuotes-boolean-BBCode",
      "alwaysProcess-boolean-BBCode"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the following inputs:\n     1.1. tagName (string, mandatory): The name of the BBCode tag to be configured\n     1.2. regex (string, mandatory): The regular expression pattern for matching the BBCode\n     1.3. replace (string, mandatory): The replacement string for the BBCode\n     1.4. removeQuotes (boolean, optional): Flag indicating whether quotes should be removed\n     1.5. alwaysProcess (boolean, optional): Flag indicating whether the BBCode should always be processed\n\n2. Data Validation:\n   2.1. Validate tagName:\n      - Check if tagName is not empty\n      - Verify tagName follows the proper format for BBCode tags\n      - IF tagName is empty or invalid THEN\n        - Generate error message: \"Tag name cannot be empty and must follow proper BBCode format\"\n      - END IF\n   2.2. Validate regex:\n      - Check if regex is not empty\n      - Verify regex is a valid regular expression pattern\n      - IF regex is empty or invalid THEN\n        - Generate error message: \"Regular expression pattern cannot be empty and must be valid\"\n      - END IF\n   2.3. Validate replace:\n      - Check if replace is not null (can be empty string)\n      - IF replace is null THEN\n        - Generate error message: \"Replacement string cannot be null\"\n      - END IF\n   2.4. Validate removeQuotes:\n      - Ensure removeQuotes is a boolean value if provided\n      - IF removeQuotes is provided but not a boolean THEN\n        - Generate error message: \"Remove quotes flag must be a boolean value\"\n      - END IF\n   2.5. Validate alwaysProcess:\n      - Ensure alwaysProcess is a boolean value if provided\n      - IF alwaysProcess is provided but not a boolean THEN\n        - Generate error message: \"Always process flag must be a boolean value\"\n      - END IF\n\n3. Business Rule Processing:\n   3.1. Check for existing BBCode with the same tagName:\n      - Search for existing BBCode with the provided tagName\n      - IF existing BBCode found THEN\n        - Determine if this is an update operation\n        - Verify user has permission to update existing BBCode\n      - END IF\n   3.2. Verify system state allows BBCode configuration:\n      - Check if BBCode processing is enabled in the system\n      - IF BBCode processing is disabled THEN\n        - Generate warning: \"BBCode processing is currently disabled in the system\"\n      - END IF\n   3.3. Validate compatibility of settings:\n      - IF both removeQuotes and alwaysProcess are true THEN\n        - Verify this combination is allowed by business rules\n        - Generate warning if needed: \"Using both remove quotes and always process may cause unexpected behavior\"\n      - END IF\n\n4. Core Operation Execution:\n   4.1. Create or update BBCode configuration:\n      - IF updating existing BBCode THEN\n        - Retrieve the existing BBCode object\n      - ELSE\n        - Create a new BBCode object\n      - END IF\n      - Set the tagName property to the provided tagName\n      - Set the regex property to the provided regex\n      - Set the replace property to the provided replace\n      - IF removeQuotes is true THEN\n        - Enable quote removal for this BBCode\n      - END IF\n      - IF alwaysProcess is true THEN\n        - Enable always process for this BBCode\n      - END IF\n   4.2. Save the BBCode configuration:\n      - Store the BBCode configuration in the system\n      - IF save operation fails THEN\n        - Revert any changes made\n        - Generate error message: \"Failed to save BBCode configuration\"\n      - END IF\n   4.3. Update related caches:\n      - Clear any caches related to BBCode processing\n      - Rebuild BBCode processing rules if necessary\n\n5. Response Generation:\n   5.1. Generate success response:\n      - Include confirmation message: \"BBCode configuration for [tagName] has been successfully saved\"\n      - Include summary of configured settings\n      - Provide information about how the BBCode will be processed\n   5.2. Handle error responses:\n      - For validation errors, include specific field errors\n      - For business rule violations, include explanation\n      - For system errors, include appropriate error codes\n   5.3. Include next steps:\n      - Suggest testing the BBCode in a preview environment\n      - Provide link to BBCode management interface\n      - Offer option to configure additional BBCodes",
    "databaseEntities": [],
    "validationRules": [
      "Tag name must not be empty",
      "Regular expression pattern must be valid",
      "Replacement string must not be null",
      "Remove quotes flag must be a boolean value",
      "Always process flag must be a boolean value"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "BBCode": {
        "type": "object",
        "properties": {
          "tagName": {
            "type": "string",
            "description": "The name of the BBCode tag"
          },
          "regex": {
            "type": "string",
            "description": "Regular expression pattern for matching the BBCode"
          },
          "replace": {
            "type": "string",
            "description": "Replacement string for the BBCode"
          },
          "removeQuotes": {
            "type": "boolean",
            "description": "Flag indicating whether quotes should be removed"
          },
          "alwaysProcess": {
            "type": "boolean",
            "description": "Flag indicating whether the BBCode should always be processed"
          }
        },
        "required": [
          "tagName",
          "regex",
          "replace"
        ]
      }
    }
  },
  {
    "featureName": "ParseBBCodeConfiguration",
    "description": "Parses BB code configuration from XML file to create BBCode handlers.",
    "inputValues": [
      "configPath-string-Configuration",
      "bbCodeConfig-object-BBCodeConfig"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect configPath (string): Path to the BB code configuration file\n   - Collect bbCodeConfig (object): Configuration object containing BB code settings\n     - configDir (string): Directory containing configuration files\n     - Optional: parserOptions (object): Additional parsing options\n\n2. Data Validation:\n   - Validate configPath:\n     - Check if configPath is not empty or null\n     - Verify the path format is valid\n     - IF configPath is invalid THEN generate appropriate error message\n   - Validate bbCodeConfig:\n     - Check if bbCodeConfig is not null\n     - Verify configDir exists within bbCodeConfig\n     - IF bbCodeConfig is invalid THEN generate appropriate error message\n\n3. Business Rule Processing:\n   - Determine configuration file location:\n     - Construct full path to BB code configuration file using configDir and filename\n     - Check if configuration file exists\n     - IF file does not exist THEN check if resource exists in system path\n     - IF neither file nor resource exists THEN generate error message\n   - Initialize data structures:\n     - Create collection for regular BB codes\n     - Create collection for \"always process\" BB codes\n     - Prepare parsing environment\n\n4. Core Operation Execution:\n   - Parse XML configuration file:\n     - Initialize XML parser\n     - Read configuration file content\n     - FOR each BB code tag in configuration:\n       - Extract tag attributes (name, removeQuotes, alwaysProcess)\n       - Extract regex pattern for matching\n       - Extract replacement pattern\n       - Create BB code object with extracted information\n       - IF alwaysProcess attribute is true THEN add to always process collection\n       - ELSE add to regular BB codes collection\n     - Handle any parsing exceptions\n   - Process parsed BB codes:\n     - Validate all BB code entries for required fields\n     - Check for duplicate tag names\n     - Verify regex patterns are valid\n\n5. Response Generation:\n   - Create BB code handler result object:\n     - Include collection of regular BB codes\n     - Include collection of \"always process\" BB codes\n     - Include lookup methods for finding BB codes by name\n   - Generate success response:\n     - Include counts of loaded BB codes\n     - Include status information\n   - IF any errors occurred during parsing:\n     - Generate error response with details\n     - Include information about problematic entries",
    "databaseEntities": [],
    "validationRules": [
      "Configuration path must not be empty",
      "Configuration directory must exist",
      "BB code configuration file must be accessible",
      "BB code tags must have a name attribute",
      "BB code tags must have valid regex patterns",
      "BB code tags must have replacement patterns"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "BBCodeConfig": {
        "type": "object",
        "properties": {
          "configDir": {
            "type": "string",
            "description": "Directory containing configuration files"
          },
          "parserOptions": {
            "type": "object",
            "description": "Additional parsing options",
            "properties": {
              "removeQuotes": {
                "type": "boolean",
                "description": "Whether to remove quotes from BB code tags"
              },
              "alwaysProcess": {
                "type": "boolean",
                "description": "Whether to always process certain BB code tags"
              }
            }
          }
        },
        "required": [
          "configDir"
        ]
      }
    }
  },
  {
    "featureName": "ManageBBCodeTags",
    "description": "Manages BB code tags with their regex patterns and replacement templates.",
    "inputValues": [
      "tagName-string-BBCode",
      "regex-string-BBCode",
      "replacement-string-BBCode",
      "removeQuotes-boolean-BBCode",
      "alwaysProcess-boolean-BBCode",
      "bbCodeConfig-object-BBCodeConfig"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the following inputs:\n     a. tagName (string, mandatory): The name of the BB code tag\n     b. regex (string, mandatory): The regular expression pattern to match the tag\n     c. replacement (string, mandatory): The template to replace the matched pattern\n     d. removeQuotes (boolean, optional): Flag indicating whether to remove quotes, defaults to false\n     e. alwaysProcess (boolean, optional): Flag indicating whether to always process this tag, defaults to false\n     f. bbCodeConfig (object, optional): Configuration file path, defaults to system configuration\n\n2. Data Validation:\n   - Validate tagName:\n     a. IF tagName is empty or null THEN\n        i. Generate error message: \"Tag name cannot be empty\"\n     b. IF tagName contains invalid characters THEN\n        i. Generate error message: \"Tag name contains invalid characters\"\n   - Validate regex:\n     a. IF regex is empty or null THEN\n        i. Generate error message: \"Regular expression pattern cannot be empty\"\n     b. IF regex is not a valid pattern THEN\n        i. Generate error message: \"Invalid regular expression pattern\"\n   - Validate replacement:\n     a. IF replacement is empty or null THEN\n        i. Generate error message: \"Replacement template cannot be empty\"\n\n3. Business Rule Processing:\n   - Check for tag name uniqueness:\n     a. IF a BB code with the same tagName already exists THEN\n        i. Generate warning message: \"A BB code with this tag name already exists and will be overwritten\"\n   - Verify configuration accessibility:\n     a. IF bbCodeConfig is provided THEN\n        i. Verify the configuration file exists\n        ii. IF configuration file does not exist THEN\n           1. Generate error message: \"Configuration file not found\"\n     b. ELSE\n        i. Use default system configuration path\n        ii. Verify the default configuration file exists\n        iii. IF default configuration file does not exist THEN\n           1. Generate error message: \"Default configuration file not found\"\n\n4. Core Operation Execution:\n   - Create a new BBCode object:\n     a. Set the tagName property\n     b. Set the regex pattern property\n     c. Set the replacement template property\n     d. IF removeQuotes is true THEN\n        i. Enable the remove quotes feature\n     e. IF alwaysProcess is true THEN\n        i. Enable the always process feature\n   - Add the BBCode to the appropriate collection:\n     a. IF alwaysProcess is true THEN\n        i. Add to the alwaysProcessMap collection\n     b. ELSE\n        i. Add to the bbMap collection\n   - Update the configuration:\n     a. IF adding a new BB code THEN\n        i. Add the new BB code to the configuration\n     b. IF updating an existing BB code THEN\n        i. Update the existing BB code in the configuration\n     c. Save the updated configuration\n\n5. Response Generation:\n   - For successful operation:\n     a. Generate success message: \"BB code tag successfully managed\"\n     b. Return the created/updated BBCode object\n     c. Include the total count of BB codes in the system\n   - For failed operation:\n     a. Generate appropriate error message based on the failure reason\n     b. Include suggestions for resolving the issue\n     c. Provide information about the current BB code configuration",
    "databaseEntities": [],
    "validationRules": [
      "Tag name must not be empty",
      "Regular expression pattern must not be empty",
      "Replacement template must not be empty",
      "Tag name must be unique within the system",
      "Configuration file must exist and be accessible",
      "Regular expression pattern must be valid"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "BBCodeConfig": {
        "type": "object",
        "properties": {
          "configPath": {
            "type": "string",
            "description": "Path to the BB code configuration file"
          },
          "defaultTags": {
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "name": {
                  "type": "string",
                  "description": "Name of the default BB code tag"
                },
                "regex": {
                  "type": "string",
                  "description": "Default regular expression pattern"
                },
                "replacement": {
                  "type": "string",
                  "description": "Default replacement template"
                },
                "removeQuotes": {
                  "type": "boolean",
                  "description": "Whether to remove quotes for this tag"
                },
                "alwaysProcess": {
                  "type": "boolean",
                  "description": "Whether to always process this tag"
                }
              }
            }
          }
        }
      }
    }
  },
  {
    "featureName": "ExecuteAsyncTask",
    "description": "Executes tasks asynchronously using a thread pool with configurable parameters.",
    "inputValues": [
      "task-object-AsyncTask"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the task to be executed asynchronously\n     1.1. Receive the task object that implements the required interface\n     1.2. Verify the task object is not null\n     1.3. Ensure the task contains all necessary execution parameters\n\n2. Data Validation:\n   - Validate the task before submission\n     2.1. Check if the task object is properly initialized\n     2.2. Verify that the task contains valid execution parameters\n     2.3. IF task is invalid THEN\n          2.3.1. Generate appropriate validation error\n          2.3.2. Abort the execution process\n     2.4. IF task is valid THEN\n          2.4.1. Proceed to the next step\n\n3. Business Rule Processing:\n   - Apply thread pool management rules\n     3.1. Check current thread pool status\n     3.2. Verify if the thread pool has capacity for new tasks\n     3.3. IF thread pool is at maximum capacity THEN\n          3.3.1. Apply queuing strategy based on configuration\n          3.3.2. IF queue is full THEN\n                 3.3.2.1. Apply rejection policy (wait, discard, or throw exception)\n     3.4. Check task priority settings if applicable\n     3.5. Apply any task-specific execution rules\n\n4. Core Operation Execution:\n   - Submit task to the thread pool\n     4.1. Prepare the task for asynchronous execution\n     4.2. Submit the task to the thread pool executor\n     4.3. Record task submission in the system log\n     4.4. IF submission fails THEN\n          4.4.1. Log the failure reason\n          4.4.2. Apply error handling strategy\n          4.4.3. Notify monitoring systems if configured\n     4.5. IF submission succeeds THEN\n          4.5.1. Generate task tracking identifier if needed\n          4.5.2. Update task status to \"submitted\"\n\n5. Response Generation:\n   - Generate appropriate response\n     5.1. IF task was successfully submitted THEN\n          5.1.1. Return success indicator\n          5.1.2. Include task tracking information if available\n     5.2. IF task submission failed THEN\n          5.2.1. Return failure indicator\n          5.2.2. Include detailed error information\n          5.2.3. Provide troubleshooting guidance if applicable",
    "databaseEntities": [],
    "validationRules": [
      "Task object must not be null",
      "Task must be properly initialized",
      "Thread pool must have capacity or queue space available"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "AsyncTask": {
        "type": "object",
        "properties": {
          "taskType": {
            "type": "string",
            "description": "The type of task to be executed"
          },
          "parameters": {
            "type": "object",
            "description": "Parameters required for task execution"
          },
          "priority": {
            "type": "integer",
            "description": "Optional priority level for the task"
          },
          "timeout": {
            "type": "integer",
            "description": "Optional timeout in milliseconds"
          }
        },
        "required": [
          "taskType",
          "parameters"
        ]
      }
    }
  },
  {
    "featureName": "ResizeImage",
    "description": "Resizes an image to specified dimensions while maintaining aspect ratio.",
    "inputValues": [
      "imagePath-string-Image",
      "imageType-number-ImageType",
      "maxWidth-number-Dimension",
      "maxHeight-number-Dimension"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the following required inputs:\n     a. imagePath: Path to the image file (mandatory)\n     b. imageType: Type of image (mandatory) - can be JPEG, PNG, or GIF\n     c. maxWidth: Maximum width for the resized image (mandatory)\n     d. maxHeight: Maximum height for the resized image (mandatory)\n   - System will use these inputs to resize the image while maintaining its aspect ratio\n\n2. Data Validation:\n   - Validate image path:\n     a. Check if the path is not empty\n     b. Verify the path points to an existing file\n     c. If validation fails, generate appropriate error message\n   - Validate image type:\n     a. Ensure image type is one of the supported types (JPEG, PNG, GIF)\n     b. If validation fails, generate appropriate error message\n   - Validate dimensions:\n     a. Ensure maxWidth is a positive integer\n     b. Ensure maxHeight is a positive integer\n     c. If validation fails, generate appropriate error message\n\n3. Business Rule Processing:\n   - Check system resources:\n     a. Verify sufficient memory is available for image processing\n     b. Ensure the system has appropriate permissions to read the source image\n     c. IF any resource check fails, THEN abort operation and return appropriate error\n   - Determine if resizing is necessary:\n     a. IF original image dimensions are already smaller than maxWidth and maxHeight, THEN\n        no resizing is needed\n     b. ELSE calculate new dimensions while preserving aspect ratio\n\n4. Core Operation Execution:\n   - Load the source image:\n     a. Open the image file from the provided path\n     b. IF loading fails, THEN generate appropriate error\n   - Calculate new dimensions:\n     a. Get original image width and height\n     b. Calculate aspect ratio (width/height)\n     c. IF width > maxWidth OR height > maxHeight, THEN\n        i. IF maxWidth/maxHeight > aspect ratio, THEN\n           - Set new width = maxHeight * aspect ratio\n           - Set new height = maxHeight\n        ii. ELSE\n           - Set new width = maxWidth\n           - Set new height = maxWidth / aspect ratio\n     d. ELSE keep original dimensions\n   - Perform image resizing:\n     a. Create a new image with calculated dimensions\n     b. Apply smooth scaling algorithm to maintain image quality\n     c. Transfer pixel data from source to resized image\n   - Handle transparency:\n     a. IF original image has transparency AND output type supports it, THEN\n        preserve transparency in resized image\n\n5. Response Generation:\n   - Success response:\n     a. Return the resized image object\n     b. Include information about new dimensions\n     c. Include original and new file sizes\n   - Error response:\n     a. Provide specific error message based on failure point\n     b. Include suggestions for resolving common issues\n     c. Log detailed error information for troubleshooting",
    "databaseEntities": [],
    "validationRules": [
      "Image path must not be empty",
      "Image file must exist at the specified path",
      "Image type must be one of the supported types (JPEG, PNG, GIF)",
      "Maximum width must be a positive integer",
      "Maximum height must be a positive integer",
      "System must have sufficient memory for image processing",
      "System must have read permissions for the source image"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Image": {
        "type": "object",
        "properties": {
          "path": {
            "type": "string",
            "description": "Path to the image file"
          },
          "width": {
            "type": "number",
            "description": "Width of the image in pixels"
          },
          "height": {
            "type": "number",
            "description": "Height of the image in pixels"
          }
        }
      },
      "ImageType": {
        "type": "number",
        "enum": [
          -1,
          0,
          1,
          2
        ],
        "description": "Type of image: -1 (UNKNOWN), 0 (JPEG), 1 (PNG), 2 (GIF)"
      },
      "Dimension": {
        "type": "number",
        "description": "Size dimension in pixels"
      }
    }
  },
  {
    "featureName": "SaveImage",
    "description": "Saves an image to disk in specified format (JPEG or PNG).",
    "inputValues": [
      "image-object-BufferedImage",
      "toFileName-string-FilePath",
      "type-number-ImageType"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the following inputs:\n     a. image (BufferedImage): The image data to be saved\n     b. toFileName (String): The complete file path where the image will be saved\n     c. type (Integer): The image format type (0 for JPEG, 1 for PNG)\n   - All fields are mandatory\n\n2. Data Validation:\n   - Validate image input:\n     a. Check if image is not null\n     b. IF image is null THEN\n        i. Generate error message: \"Image data cannot be null\"\n        ii. Terminate process\n   - Validate toFileName input:\n     a. Check if toFileName is not null or empty\n     b. IF toFileName is null or empty THEN\n        i. Generate error message: \"File path cannot be empty\"\n        ii. Terminate process\n     c. Check if the file path is valid and accessible\n     d. IF file path is invalid or inaccessible THEN\n        i. Generate error message: \"Invalid or inaccessible file path\"\n        ii. Terminate process\n   - Validate type input:\n     a. Check if type is a valid image format (0 for JPEG, 1 for PNG)\n     b. IF type is not 0 or 1 THEN\n        i. Generate error message: \"Unsupported image format. Use 0 for JPEG or 1 for PNG\"\n        ii. Terminate process\n\n3. Business Rule Processing:\n   - Determine the appropriate file format string based on type:\n     a. IF type equals 0 THEN\n        i. Set format string to \"jpg\"\n     b. ELSE IF type equals 1 THEN\n        i. Set format string to \"png\"\n   - Check if the destination directory exists:\n     a. Extract directory path from toFileName\n     b. IF directory does not exist THEN\n        i. Create directory structure\n        ii. IF directory creation fails THEN\n           1. Generate error message: \"Unable to create directory structure\"\n           2. Terminate process\n   - Check if a file already exists at the destination:\n     a. IF file exists at toFileName THEN\n        i. Determine if the file should be overwritten based on system settings\n        ii. IF overwrite is not allowed THEN\n           1. Generate error message: \"File already exists and overwrite is not permitted\"\n           2. Terminate process\n\n4. Core Operation Execution:\n   - Prepare the file output destination:\n     a. Create a new File object using toFileName\n   - Write the image data to the file:\n     a. Use the determined format string (\"jpg\" or \"png\")\n     b. Write the image data to the file\n     c. IF writing operation fails THEN\n        i. Generate error message: \"Failed to write image data to file\"\n        ii. Terminate process\n   - Verify the file was created successfully:\n     a. Check if the file exists at the specified location\n     b. IF file does not exist THEN\n        i. Generate error message: \"File creation verification failed\"\n        ii. Terminate process\n\n5. Response Generation:\n   - IF image saving process completes successfully THEN\n     a. Generate success response with:\n        i. Status: Success\n        ii. Message: \"Image successfully saved to [toFileName]\"\n        iii. File path: The complete path where the image was saved\n        iv. Format: The format the image was saved in (JPEG or PNG)\n   - ELSE\n     a. Generate error response with:\n        i. Status: Error\n        ii. Error message: Specific error encountered during the process\n        iii. Suggestion: Recommended action to resolve the issue",
    "databaseEntities": [],
    "validationRules": [
      "Image data must not be null",
      "File path must not be empty",
      "File path must be valid and accessible",
      "Image type must be either 0 (JPEG) or 1 (PNG)",
      "Destination directory must exist or be creatable",
      "File must not already exist if overwrite is not permitted"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "BufferedImage": {
        "type": "object",
        "description": "Represents image data in memory",
        "properties": {
          "width": {
            "type": "number",
            "description": "Width of the image in pixels"
          },
          "height": {
            "type": "number",
            "description": "Height of the image in pixels"
          },
          "type": {
            "type": "number",
            "description": "Internal representation type of the image"
          }
        }
      }
    }
  },
  {
    "featureName": "SaveCompressedImage",
    "description": "Compresses and saves JPEG images with specified quality settings.",
    "inputValues": [
      "image-object-BufferedImage",
      "toFileName-string-FilePath",
      "type-number-ImageType"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the following inputs:\n     a. image (BufferedImage): The image to be compressed and saved\n     b. toFileName (String): The complete file path where the image will be saved\n     c. type (Integer): The image type identifier (JPEG or PNG)\n   - All inputs are mandatory for this operation\n\n2. Data Validation:\n   - Validate image input:\n     a. Check if the image object is not null\n     b. IF image is null THEN\n        i. Generate an error indicating invalid image input\n     c. Verify image has valid dimensions and content\n   - Validate toFileName input:\n     a. Check if the file path is not empty\n     b. Verify the file path is valid and accessible\n     c. Ensure the directory exists or can be created\n     d. Check if the user has write permissions to the specified location\n   - Validate type input:\n     a. Verify type is a valid image format identifier\n     b. IF type is not supported THEN\n        i. Generate an error indicating unsupported image format\n\n3. Business Rule Processing:\n   - Check image format compatibility:\n     a. IF type is PNG THEN\n        i. Verify PNG compression is supported\n        ii. IF PNG compression is not supported THEN\n            1. Generate an unsupported operation error\n     b. IF type is JPEG THEN\n        i. Proceed with JPEG compression\n     c. IF type is neither JPEG nor PNG THEN\n        i. Generate an unsupported format error\n   - Determine appropriate compression settings:\n     a. For JPEG images, set compression quality to 0.7 (70%)\n     b. For other formats, use default settings if applicable\n\n4. Core Operation Execution:\n   - Prepare image writer based on format:\n     a. Obtain appropriate image writer for the specified format\n     b. IF no suitable writer is found THEN\n        i. Generate an error indicating missing writer support\n     c. Create output stream for the destination file\n     d. Configure the writer with the output stream\n   - Configure compression parameters:\n     a. Create appropriate parameter object for the image format\n     b. Set compression mode to explicit\n     c. Set compression quality value\n   - Execute image compression and saving:\n     a. Write the image data to the output stream using configured parameters\n     b. Flush the output stream to ensure all data is written\n     c. Release resources by disposing the writer\n     d. Close the output stream\n   - Handle potential errors:\n     a. IF any I/O errors occur during saving THEN\n        i. Clean up any partially written files\n        ii. Generate appropriate error with details\n\n5. Response Generation:\n   - For successful operation:\n     a. Return confirmation that the image was successfully compressed and saved\n     b. Include the file path where the image was saved\n     c. Include the compression quality that was applied\n   - For failed operation:\n     a. Return detailed error information\n     b. Include suggestions for resolving the issue\n     c. Provide information about supported formats and compression options",
    "databaseEntities": [],
    "validationRules": [
      "Image input must not be null",
      "File path must be valid and accessible",
      "Image type must be supported (currently only JPEG compression is fully supported)",
      "Write permissions must exist for the target file location",
      "PNG compression is not supported and will throw an exception"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "BufferedImage": {
        "type": "object",
        "properties": {
          "width": {
            "type": "number",
            "description": "Width of the image in pixels"
          },
          "height": {
            "type": "number",
            "description": "Height of the image in pixels"
          },
          "type": {
            "type": "number",
            "description": "Type of the buffered image (RGB, ARGB, etc.)"
          }
        }
      },
      "FilePath": {
        "type": "string",
        "description": "String representing the complete file path where the image will be saved"
      },
      "ImageType": {
        "type": "number",
        "description": "Integer constant representing image format (0 for JPEG, 1 for PNG)",
        "enum": [
          0,
          1
        ]
      }
    }
  },
  {
    "featureName": "CreateHeadlessBufferedImage",
    "description": "Creates a BufferedImage using nearest neighbor approximation for headless systems.",
    "inputValues": [
      "sourceImage-object-BufferedImage",
      "imageType-number-ImageType",
      "targetWidth-number-Dimension",
      "targetHeight-number-Dimension"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the source image (BufferedImage object)\n   - Collect the image type (integer constant)\n   - Collect the target width (integer)\n   - Collect the target height (integer)\n   - All inputs are mandatory\n\n2. Data Validation:\n   - Validate source image is not null\n     * IF source image is null THEN return error message \"Source image cannot be null\"\n   - Validate target dimensions are positive numbers\n     * IF width <= 0 THEN return error message \"Target width must be a positive number\"\n     * IF height <= 0 THEN return error message \"Target height must be a positive number\"\n   - Validate image type is supported\n     * IF image type is not one of the supported types THEN return error message \"Unsupported image type\"\n\n3. Business Rule Processing:\n   - Determine the appropriate BufferedImage type based on input image type\n     * IF image type is PNG and source image has alpha channel\n       THEN use ARGB color model\n     * ELSE use RGB color model\n   - Check if system is headless\n     * IF system is not headless THEN log warning that headless method is being used unnecessarily\n\n4. Core Operation Execution:\n   - Create a new BufferedImage with the target width, height, and determined color model\n   - For each pixel position (x,y) in the target image:\n     * Calculate the corresponding source pixel position\n     * Sample the color from the source image at calculated position\n     * Apply the color to the target image at current position (x,y)\n   - Apply nearest neighbor approximation to maintain efficiency\n     * For each target pixel, find the closest source pixel without interpolation\n     * Map source pixel RGB values directly to target pixel\n\n5. Response Generation:\n   - Return the newly created BufferedImage\n   - Include metadata about the transformation:\n     * Original dimensions\n     * New dimensions\n     * Color model used\n     * Approximation method used (nearest neighbor)\n   - IF any errors occurred during processing\n     THEN return appropriate error message and log the failure",
    "databaseEntities": [],
    "validationRules": [
      "Source image must not be null",
      "Target width must be a positive number",
      "Target height must be a positive number",
      "Image type must be a supported format"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "BufferedImage": {
        "type": "object",
        "properties": {
          "width": {
            "type": "number",
            "description": "Width of the image in pixels"
          },
          "height": {
            "type": "number",
            "description": "Height of the image in pixels"
          },
          "type": {
            "type": "number",
            "description": "Type of the buffered image (color model)"
          }
        }
      },
      "ImageType": {
        "type": "number",
        "enum": [
          -1,
          0,
          1,
          2
        ],
        "description": "Constant representing image type (UNKNOWN=-1, JPEG=0, PNG=1, GIF=2)"
      },
      "Dimension": {
        "type": "number",
        "description": "Size value in pixels",
        "minimum": 1
      }
    }
  },
  {
    "featureName": "CreateHeadlessSmoothBufferedImage",
    "description": "Creates a smoothly scaled BufferedImage using bilinear filtering for headless systems.",
    "inputValues": [
      "sourceImage-object-BufferedImage",
      "imageType-number-ImageType",
      "targetWidth-number-Dimension",
      "targetHeight-number-Dimension"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the source image (mandatory)\n   - Collect the image type (mandatory)\n   - Collect the target width (mandatory)\n   - Collect the target height (mandatory)\n   - System will determine the appropriate color model based on image type\n\n2. Data Validation:\n   - Validate source image is not null\n     * IF source image is null THEN return error message \"Source image cannot be null\"\n   - Validate target dimensions are positive numbers\n     * IF width <= 0 THEN return error message \"Target width must be positive\"\n     * IF height <= 0 THEN return error message \"Target height must be positive\"\n   - Validate image type is supported\n     * IF image type is not one of the supported types THEN return error message \"Unsupported image type\"\n\n3. Business Rule Processing:\n   - Determine the appropriate color model for the target image\n     * IF image type is PNG and source image has transparency\n       THEN use color model with alpha channel support\n     * ELSE use standard RGB color model without transparency\n   - Calculate scaling factors\n     * Calculate horizontal scaling factor = target width / source width\n     * Calculate vertical scaling factor = target height / source height\n\n4. Core Operation Execution:\n   - Create a new empty destination image with the specified dimensions and color model\n   - For each pixel position (x,y) in the destination image:\n     * Calculate the corresponding source position\n     * Calculate interpolation factors for x and y dimensions\n     * Get the four surrounding pixels from the source image\n     * Apply bilinear interpolation to calculate the new pixel color:\n       - Interpolate horizontally between top two pixels\n       - Interpolate horizontally between bottom two pixels\n       - Interpolate vertically between the two horizontal interpolation results\n     * Set the calculated color to the current pixel in the destination image\n\n5. Response Generation:\n   - Return the newly created image with smooth scaling applied\n   - IF any error occurs during processing\n     THEN return appropriate error message with details of the failure",
    "databaseEntities": [],
    "validationRules": [
      "Source image must not be null",
      "Target width must be a positive number",
      "Target height must be a positive number",
      "Image type must be supported"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "BufferedImage": {
        "type": "object",
        "properties": {
          "width": {
            "type": "number",
            "description": "Width of the image in pixels"
          },
          "height": {
            "type": "number",
            "description": "Height of the image in pixels"
          },
          "colorModel": {
            "type": "object",
            "description": "Color model of the image"
          }
        }
      },
      "ImageType": {
        "type": "number",
        "description": "Constant representing image format (JPEG, PNG, GIF, etc.)"
      },
      "Dimension": {
        "type": "number",
        "description": "Size value in pixels"
      }
    }
  },
  {
    "featureName": "DetectImageTransparency",
    "description": "Determines if an image contains transparent pixels.",
    "inputValues": [
      "image-object-Image"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the image object to be analyzed\n   - The image must be a valid image object\n   - No additional parameters are required\n\n2. Data Validation:\n   - Validate that the provided image is not null\n     - IF image is null THEN\n       - Return an error indicating invalid input\n     - END IF\n   - Verify that the image is in a supported format\n     - IF image format is not supported THEN\n       - Return an error indicating unsupported image format\n     - END IF\n\n3. Business Rule Processing:\n   - Prepare to analyze the image's color model\n   - Ensure the system can access the image data\n     - IF image data cannot be accessed THEN\n       - Return an error indicating inability to process image\n     - END IF\n\n4. Core Operation Execution:\n   - Extract a sample of the image's pixel data\n     - Use a minimal sample (such as a single pixel) for efficiency\n   - Retrieve the color model from the pixel data\n     - IF pixel data extraction fails THEN\n       - Handle the interruption gracefully\n       - Return false (assume no transparency)\n     - END IF\n   - Analyze the color model to determine if it supports alpha channel\n     - Check if the color model has an alpha component\n\n5. Response Generation:\n   - Return the transparency detection result\n     - IF color model has alpha channel THEN\n       - Return true (image has transparency)\n     - ELSE\n       - Return false (image has no transparency)\n     - END IF\n   - In case of any processing errors or interruptions:\n     - Return false as the default fallback value\n     - Log the error for troubleshooting purposes",
    "databaseEntities": [],
    "validationRules": [
      "Input image must not be null",
      "Image must be in a supported format",
      "Image data must be accessible for analysis"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Image": {
        "type": "object",
        "description": "Represents an image to be analyzed for transparency",
        "properties": {
          "data": {
            "type": "binary",
            "description": "The binary data of the image"
          },
          "format": {
            "type": "string",
            "description": "The format of the image (e.g., JPEG, PNG, GIF)"
          }
        },
        "required": [
          "data"
        ]
      }
    }
  },
  {
    "featureName": "FilterClickstreamRequests",
    "description": "Processes HTTP requests to track clickstream data and identify bot traffic.",
    "inputValues": [
      "request-object-HttpRequest",
      "response-object-HttpResponse",
      "chain-object-FilterChain"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the incoming HTTP request object\n   - Collect the HTTP response object\n   - Collect the filter chain object for request processing\n   - All inputs are mandatory and system-provided\n\n2. Data Validation:\n   - Validate that the request object is not null\n     * IF request is null THEN generate error\n     * Error message: \"Request object cannot be null\"\n   - Validate that the response object is not null\n     * IF response is null THEN generate error\n     * Error message: \"Response object cannot be null\"\n   - Validate that the filter chain object is not null\n     * IF filter chain is null THEN generate error\n     * Error message: \"Filter chain object cannot be null\"\n\n3. Business Rule Processing:\n   - Check if the filter has already been applied to this request\n     * Examine request attributes for the filter application marker\n     * IF filter marker exists THEN skip processing and proceed to next filter\n     * IF filter marker does not exist THEN mark the request as processed\n       - Set a filter application attribute on the request object\n   - Determine if the request is coming from a bot\n     * Extract user agent information from the request\n     * Compare user agent against known bot patterns\n     * IF user agent matches bot pattern THEN\n       - Identify the specific bot type\n       - Log the bot detection if debug logging is enabled\n       - Set a bot identification attribute on the request\n     * IF user agent does not match bot pattern THEN\n       - Set a non-bot identification attribute on the request\n\n4. Core Operation Execution:\n   - Apply the filter to the request\n     * Mark the request with the filter application attribute\n     * Perform bot detection on the request\n     * Set appropriate bot/non-bot attributes on the request\n   - Continue the filter chain processing\n     * Pass the modified request to the next filter in the chain\n     * Allow the response to flow back through the filter chain\n   - Handle any exceptions during processing\n     * IF exception occurs during processing THEN\n       - Log the exception details\n       - Propagate the exception to the caller\n\n5. Response Generation:\n   - No direct response modification is performed\n   - The request proceeds through the filter chain with added attributes:\n     * Filter application marker\n     * Bot identification status\n   - Any errors during processing are propagated as exceptions",
    "databaseEntities": [],
    "validationRules": [
      "Request object must not be null",
      "Response object must not be null",
      "Filter chain object must not be null",
      "Filter should only be applied once per request"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "HttpRequest": {
        "type": "object",
        "properties": {
          "attributes": {
            "type": "object",
            "description": "Collection of request attributes"
          },
          "userAgent": {
            "type": "string",
            "description": "User agent string from the request headers"
          }
        }
      },
      "HttpResponse": {
        "type": "object",
        "properties": {
          "status": {
            "type": "number",
            "description": "HTTP status code"
          },
          "headers": {
            "type": "object",
            "description": "Collection of response headers"
          }
        }
      },
      "FilterChain": {
        "type": "object",
        "properties": {
          "filters": {
            "type": "array",
            "description": "Collection of filters to be applied"
          }
        }
      }
    }
  },
  {
    "featureName": "ManageBotAgents",
    "description": "Manages the list of bot agents for clickstream tracking and filtering.",
    "inputValues": [
      "botAgent-string-ClickstreamConfig",
      "botHost-string-ClickstreamConfig"
    ],
    "businessLogic": "1. Input Collection\n   1.1. Collect bot agent information\n       1.1.1. Obtain bot agent identifier string\n       1.1.2. Check if the bot agent identifier is provided\n       1.1.3. Determine if this is an add or remove operation\n   1.2. Collect bot host information\n       1.2.1. Obtain bot host identifier string\n       1.2.2. Check if the bot host identifier is provided\n       1.2.3. Determine if this is an add or remove operation\n\n2. Data Validation\n   2.1. Validate bot agent information\n       2.1.1. IF bot agent identifier is provided THEN\n           2.1.1.1. Verify the bot agent identifier is not empty\n           2.1.1.2. Verify the bot agent identifier is a valid string format\n           2.1.1.3. Check if the bot agent already exists in the system\n       2.1.2. ELSE skip bot agent validation\n   2.2. Validate bot host information\n       2.2.1. IF bot host identifier is provided THEN\n           2.2.1.1. Verify the bot host identifier is not empty\n           2.2.1.2. Verify the bot host identifier is a valid hostname format\n           2.2.1.3. Check if the bot host already exists in the system\n       2.2.2. ELSE skip bot host validation\n\n3. Business Rule Processing\n   3.1. Verify system state for bot management\n       3.1.1. Check if the clickstream tracking system is active\n       3.1.2. Verify user has permission to manage bot configurations\n   3.2. Process bot agent rules\n       3.2.1. IF adding a bot agent THEN\n           3.2.1.1. Check if maximum number of bot agents has been reached\n           3.2.1.2. Verify the bot agent pattern is valid for filtering\n       3.2.2. IF removing a bot agent THEN\n           3.2.2.1. Verify the bot agent exists in the current configuration\n   3.3. Process bot host rules\n       3.3.1. IF adding a bot host THEN\n           3.3.1.1. Check if maximum number of bot hosts has been reached\n           3.3.1.2. Verify the bot host pattern is valid for filtering\n       3.3.2. IF removing a bot host THEN\n           3.3.2.1. Verify the bot host exists in the current configuration\n\n4. Core Operation Execution\n   4.1. Manage bot agent list\n       4.1.1. IF adding a bot agent THEN\n           4.1.1.1. Add the bot agent to the configuration\n           4.1.1.2. Update the bot agent list in memory\n           4.1.1.3. Log the addition of the new bot agent\n       4.1.2. IF removing a bot agent THEN\n           4.1.2.1. Remove the bot agent from the configuration\n           4.1.2.2. Update the bot agent list in memory\n           4.1.2.3. Log the removal of the bot agent\n   4.2. Manage bot host list\n       4.2.1. IF adding a bot host THEN\n           4.2.1.1. Add the bot host to the configuration\n           4.2.1.2. Update the bot host list in memory\n           4.2.1.3. Log the addition of the new bot host\n       4.2.2. IF removing a bot host THEN\n           4.2.2.1. Remove the bot host from the configuration\n           4.2.2.2. Update the bot host list in memory\n           4.2.2.3. Log the removal of the bot host\n   4.3. Save configuration changes\n       4.3.1. Persist the updated configuration\n       4.3.2. Apply changes to the active clickstream tracking system\n\n5. Response Generation\n   5.1. Generate success response\n       5.1.1. Provide confirmation of the completed operation\n       5.1.2. Include summary of changes made to bot agent list\n       5.1.3. Include summary of changes made to bot host list\n       5.1.4. Return the current complete list of bot agents and hosts\n   5.2. Generate error response\n       5.2.1. Provide detailed error message if operation failed\n       5.2.2. Include suggestions for resolving the issue\n       5.2.3. Provide option to retry the operation",
    "databaseEntities": [],
    "validationRules": [
      "Bot agent identifier must not be empty",
      "Bot host identifier must not be empty",
      "Bot agent must not already exist in the system when adding",
      "Bot host must not already exist in the system when adding",
      "Bot agent must exist in the system when removing",
      "Bot host must exist in the system when removing",
      "Bot host must be in valid hostname format",
      "User must have permission to manage bot configurations"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "ClickstreamConfig": {
        "type": "object",
        "properties": {
          "botAgents": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "List of bot agent identifiers"
          },
          "botHosts": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "List of bot host identifiers"
          }
        }
      }
    }
  },
  {
    "featureName": "ManageBotHosts",
    "description": "Manages the list of bot hosts for clickstream tracking and filtering.",
    "inputValues": [
      "botHost-string-ClickstreamConfig"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the following inputs:\n     - botHost (string, mandatory): The host identifier to be added or managed\n     - operation (string, mandatory): The type of operation to perform (add, remove, view)\n   - System will use the existing ClickstreamConfig instance to manage the bot hosts list\n\n2. Data Validation:\n   - Validate botHost input:\n     - IF botHost is provided and operation is 'add' or 'remove'\n       - THEN verify botHost is not empty\n       - THEN verify botHost is a valid string format (no special characters except periods, hyphens)\n       - THEN verify botHost length is between 3 and 255 characters\n     - IF validation fails\n       - THEN generate appropriate error message specifying the validation issue\n   - Validate operation input:\n     - Verify operation is one of the allowed values: 'add', 'remove', or 'view'\n     - IF validation fails\n       - THEN generate error message indicating valid operation types\n\n3. Business Rule Processing:\n   - Check system state:\n     - Verify ClickstreamConfig instance is properly initialized\n     - Verify access permissions for managing bot hosts\n   - Process according to operation type:\n     - IF operation is 'add':\n       - Check if botHost already exists in the list\n       - IF botHost exists\n         - THEN generate notification that host is already in the list\n     - IF operation is 'remove':\n       - Check if botHost exists in the list\n       - IF botHost does not exist\n         - THEN generate notification that host is not in the list\n\n4. Core Operation Execution:\n   - Execute the requested operation:\n     - IF operation is 'add':\n       - Add the botHost to the bot hosts list\n       - Update the ClickstreamConfig with the new list\n     - IF operation is 'remove':\n       - Remove the botHost from the bot hosts list\n       - Update the ClickstreamConfig with the modified list\n     - IF operation is 'view':\n       - Retrieve the current list of bot hosts from ClickstreamConfig\n   - Handle any exceptions during execution:\n     - IF exception occurs\n       - THEN log the error details\n       - THEN prepare appropriate error message for user\n\n5. Response Generation:\n   - Generate appropriate response based on operation outcome:\n     - IF operation completed successfully:\n       - For 'add': Confirm botHost was added successfully\n       - For 'remove': Confirm botHost was removed successfully\n       - For 'view': Return the complete list of bot hosts\n     - Include the current count of bot hosts in the system\n     - IF operation failed:\n       - Include specific error details\n       - Provide guidance on how to correct the issue",
    "databaseEntities": [],
    "validationRules": [
      "Bot host must not be empty",
      "Bot host must be a valid string format",
      "Bot host length must be between 3 and 255 characters",
      "Operation must be one of: add, remove, or view"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "ClickstreamConfig": {
        "type": "object",
        "properties": {
          "botAgents": {
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "botHosts": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      }
    }
  },
  {
    "featureName": "LoadClickstreamConfig",
    "description": "Loads and parses clickstream configuration from XML file to identify bot hosts and agents.",
    "inputValues": [
      "configPath-string-ConfigPath"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect configPath (string): Path to the clickstream configuration XML file\n     - This can be provided directly or retrieved from system globals\n     - If not explicitly provided, the system will use a default configuration path\n\n2. Data Validation:\n   - Validate configuration path:\n     - IF configPath is null or empty THEN\n       - Log warning message about missing configuration path\n       - Use default configuration path if available\n       - IF no default path available THEN\n         - Return empty configuration object\n     - Check if the configuration file exists:\n       - IF file does not exist at the specified path THEN\n         - Attempt to load as a resource stream\n         - IF resource stream cannot be found THEN\n           - Log error about missing configuration file\n           - Return empty configuration object\n\n3. Business Rule Processing:\n   - Check if configuration is already loaded:\n     - IF configuration is already loaded and caching is enabled THEN\n       - Return the cached configuration\n     - ELSE\n       - Proceed with loading new configuration\n   - Prepare XML parser:\n     - Initialize SAX parser factory\n     - Create new SAX parser instance\n     - Set up configuration handler for parsing\n\n4. Core Operation Execution:\n   - Create new clickstream configuration object\n   - Parse XML configuration file:\n     - FOR each 'bot-host' element in XML:\n       - Extract host name attribute\n       - Add host name to bot hosts list in configuration\n     - FOR each 'bot-agent' element in XML:\n       - Extract agent name attribute\n       - Add agent name to bot agents list in configuration\n   - Handle parsing exceptions:\n     - IF SAX exception occurs THEN\n       - Log error about XML parsing failure\n       - Return empty configuration or throw runtime exception\n     - IF IO exception occurs THEN\n       - Log error about file reading failure\n       - Return empty configuration or throw runtime exception\n     - IF parser configuration exception occurs THEN\n       - Log fatal error about parser initialization\n       - Return empty configuration or throw runtime exception\n\n5. Response Generation:\n   - Return the populated clickstream configuration object:\n     - Configuration object contains:\n       - List of bot host patterns\n       - List of bot agent patterns\n   - Cache the configuration for future use if caching is enabled\n   - Log successful loading of configuration",
    "databaseEntities": [],
    "validationRules": [
      "Configuration path must be accessible",
      "XML file must be well-formed",
      "Bot host entries must have a 'name' attribute",
      "Bot agent entries must have a 'name' attribute"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "ClickstreamConfig": {
        "type": "object",
        "properties": {
          "botHosts": {
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "botAgents": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      }
    }
  },
  {
    "featureName": "DetectMultipartContent",
    "description": "Determines if a request contains multipart content based on content type headers.",
    "inputValues": [
      "request-object-RequestContext",
      "contentType-string-RequestContext"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the request object containing HTTP request information\n   - Extract the content type header from the request\n   - Determine the HTTP method (if applicable to the request type)\n\n2. Data Validation:\n   - Validate that the request object is not null\n      * IF request is null THEN return an error indicating invalid request\n   - Validate that the content type can be retrieved\n      * IF content type cannot be accessed THEN proceed with null content type value\n\n3. Business Rule Processing:\n   - Check if the request method is relevant for multipart content\n      * IF request type supports method checking AND method is not POST\n         THEN return false as multipart content requires POST method\n   - Check if the content type header exists\n      * IF content type is null THEN return false as multipart content requires a content type\n   - Check if the content type starts with \"multipart/\"\n      * Convert content type to lowercase for case-insensitive comparison\n      * IF content type starts with \"multipart/\" THEN mark as multipart content\n      * ELSE mark as non-multipart content\n\n4. Core Operation Execution:\n   - No data modifications are performed in this feature\n   - The determination is made solely based on the request properties\n   - No state changes occur in the system\n\n5. Response Generation:\n   - Return a boolean result:\n      * TRUE if the request contains multipart content\n      * FALSE if the request does not contain multipart content\n   - No additional information needs to be returned",
    "databaseEntities": [],
    "validationRules": [
      "Request object must not be null",
      "Multipart content requires a content type header",
      "Content type must start with 'multipart/' to be considered multipart content",
      "For HTTP requests, only POST method supports multipart content"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "RequestContext": {
        "type": "object",
        "properties": {
          "contentType": {
            "type": "string",
            "description": "The Content-Type header value from the request"
          },
          "method": {
            "type": "string",
            "description": "The HTTP method used for the request (GET, POST, etc.)"
          }
        }
      }
    }
  },
  {
    "featureName": "ParseMultipartRequest",
    "description": "Processes RFC 1867 compliant multipart/form-data streams into FileItem instances.",
    "inputValues": [
      "requestContext-object-RequestContext",
      "contentType-string-RequestHeader",
      "contentLength-number-RequestHeader",
      "inputStream-object-InputStream",
      "fileItemFactory-object-FileItemFactory"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect HttpServletRequest object containing the multipart request information\n     - HttpServletRequest must contain content type header\n     - HttpServletRequest must contain content length information\n     - HttpServletRequest must provide access to the input stream\n   - System configuration parameters:\n     - Maximum allowed file size (sizeMax)\n     - Header encoding preference\n     - FileItemFactory implementation for creating FileItem instances\n     - FileItemFactory must be configured before parsing\n\n2. Data Validation:\n   - Validate Request\n     - Check if HttpServletRequest is not null\n     - IF HttpServletRequest is null THEN\n       - Generate error: \"Request cannot be null\"\n     - END IF\n   - Validate Request Method\n     - Check if request method is POST\n     - IF request method is not POST THEN\n       - Generate error: \"Request method must be POST for multipart requests\"\n     - END IF\n   - Validate Content Type\n     - Extract content type from request headers\n     - IF content type is null THEN\n       - Generate error: \"Missing content type header\"\n     - END IF\n     - IF content type does not start with \"multipart/\" THEN\n       - Generate error: \"Invalid content type: not a multipart request\"\n     - END IF\n   - Validate Content Length\n     - Extract content length from request headers\n     - IF content length is -1 (unknown) THEN\n       - Generate error: \"Request rejected: unknown size\"\n     - END IF\n     - IF maximum size is configured (sizeMax >= 0) AND content length exceeds maximum size THEN\n       - Generate error: \"Request rejected: size exceeds allowed limit\"\n     - END IF\n   - Validate FileItemFactory\n     - Check if FileItemFactory has been configured\n     - IF FileItemFactory is null THEN\n       - Generate error: \"FileItemFactory must be configured before parsing\"\n     - END IF\n\n3. Business Rule Processing:\n   - Extract Multipart Boundary\n     - Parse content type header to extract boundary marker\n     - IF boundary cannot be determined THEN\n       - Generate error: \"Request rejected: no multipart boundary found\"\n     - END IF\n   - Prepare Processing Environment\n     - Create collection to store parsed file items\n     - Configure multipart stream processor with:\n       - Boundary information\n       - Header encoding settings\n       - Size limitations\n     - Create ServletRequestContext wrapper around HttpServletRequest\n     - Obtain input stream from request context\n\n4. Core Operation Execution:\n   - Initialize Multipart Stream\n     - Create multipart stream with input stream and boundary\n     - Apply header encoding if specified\n   - Process Multipart Parts\n     - WHILE more parts are available in the stream DO\n       - Read part headers\n       - Determine if current part is a form field or file upload\n       - IF part is a form field THEN\n         - Extract field name and value\n         - Create form field item using configured FileItemFactory\n       - ELSE (part is a file)\n         - Extract file name, content type, and field name\n         - Create file item using configured FileItemFactory\n         - Stream file content to storage location determined by factory\n       - END IF\n       - Add created item to collection\n     - END WHILE\n   - Handle Processing Exceptions\n     - IF I/O error occurs during processing THEN\n       - Clean up temporary resources\n       - Generate appropriate error message\n     - END IF\n\n5. Response Generation:\n   - Success Response\n     - Return List of FileItem objects containing:\n       - Form fields with their values\n       - File uploads with their content and metadata\n     - Items are ordered as they appeared in the original request\n   - Error Response\n     - Return appropriate exception with detailed message:\n       - InvalidContentTypeException for content type problems\n       - SizeLimitExceededException for size violations\n       - UnknownSizeException for unknown content length\n       - FileUploadException for general processing errors",
    "databaseEntities": [],
    "validationRules": [
      "Request must not be null",
      "Request method must be POST for multipart requests",
      "Content type header must be present",
      "Content type must start with 'multipart/'",
      "Content length must be known (not -1)",
      "Request size must not exceed maximum allowed size if specified",
      "Multipart boundary must be present in content type header",
      "FileItemFactory must be configured before parsing"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "RequestContext": {
        "type": "object",
        "properties": {
          "contentType": {
            "type": "string",
            "description": "The content type header of the request"
          },
          "contentLength": {
            "type": "number",
            "description": "The content length of the request in bytes"
          },
          "inputStream": {
            "type": "object",
            "description": "The input stream containing the request data"
          }
        },
        "required": [
          "contentType",
          "contentLength",
          "inputStream"
        ]
      },
      "FileItem": {
        "type": "object",
        "properties": {
          "fieldName": {
            "type": "string",
            "description": "The name of the form field"
          },
          "contentType": {
            "type": "string",
            "description": "The content type of the file"
          },
          "isFormField": {
            "type": "boolean",
            "description": "Whether the item is a regular form field or a file upload"
          },
          "fileName": {
            "type": "string",
            "description": "The original filename in the client's filesystem"
          },
          "size": {
            "type": "number",
            "description": "The size of the file in bytes"
          },
          "content": {
            "type": "object",
            "description": "The contents of the file or form field"
          }
        },
        "required": [
          "fieldName",
          "isFormField"
        ]
      },
      "FileItemFactory": {
        "type": "object",
        "description": "Factory for creating FileItem instances",
        "properties": {
          "sizeThreshold": {
            "type": "number",
            "description": "The threshold beyond which files are written to disk"
          },
          "repository": {
            "type": "object",
            "description": "The directory in which temporary files will be created"
          }
        }
      },
      "ServletRequestContext": {
        "type": "object",
        "description": "Wrapper for HttpServletRequest providing access to request parameters",
        "properties": {
          "request": {
            "type": "object",
            "description": "The wrapped HttpServletRequest"
          }
        },
        "required": [
          "request"
        ]
      }
    }
  },
  {
    "featureName": "ConfigureUploadSizeLimit",
    "description": "Sets and retrieves maximum allowed upload size for file uploads.",
    "inputValues": [
      "sizeMax-number-UploadConfiguration",
      "headerEncoding-string-UploadConfiguration"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the following inputs:\n     - sizeMax (number): The maximum allowed size for file uploads in bytes\n     - headerEncoding (string): The character encoding for reading part headers\n   - sizeMax is optional with a default value of -1 (no maximum)\n   - headerEncoding is optional with a default value of system default encoding\n\n2. Data Validation:\n   - Validate sizeMax input:\n     - IF sizeMax is provided and is not a number, THEN\n       - Return error message: \"Size maximum must be a numeric value\"\n     - IF sizeMax is provided and is less than -1, THEN\n       - Return error message: \"Size maximum must be -1 (unlimited) or a positive number\"\n   - Validate headerEncoding input:\n     - IF headerEncoding is provided and is not a valid character encoding, THEN\n       - Return error message: \"Invalid character encoding specified\"\n\n3. Business Rule Processing:\n   - Check system state for upload configuration:\n     - Verify the upload configuration system is initialized\n     - IF system is not in a state to accept configuration changes, THEN\n       - Return error message: \"Upload system is not ready for configuration\"\n   - Process size limit rules:\n     - IF sizeMax is set to -1, THEN\n       - Mark upload size as unlimited\n     - IF sizeMax is set to 0, THEN\n       - Return error message: \"Upload size cannot be set to zero\"\n     - IF sizeMax is positive, THEN\n       - Ensure the value doesn't exceed system capabilities\n       - IF sizeMax exceeds maximum possible system value, THEN\n         - Return error message: \"Requested size limit exceeds system capabilities\"\n\n4. Core Operation Execution:\n   - Apply the upload size configuration:\n     - Store the sizeMax value in the configuration system\n     - IF sizeMax is provided, THEN\n       - Update the maximum upload size setting\n     - IF headerEncoding is provided, THEN\n       - Update the header encoding setting\n     - Record configuration change in system logs\n     - Update any dependent components that need to be aware of the new limits\n   - Handle configuration persistence:\n     - Save configuration changes to ensure they persist across system restarts\n     - IF persistence fails, THEN\n       - Revert to previous configuration\n       - Return error message: \"Failed to save configuration changes\"\n\n5. Response Generation:\n   - Generate success response:\n     - Include confirmation that upload size limit has been configured\n     - Include the current values for sizeMax and headerEncoding\n     - Provide information about how the new limits will affect uploads\n   - IF any errors occurred during configuration, THEN\n     - Generate appropriate error response with details\n     - Include guidance on resolving the issue",
    "databaseEntities": [],
    "validationRules": [
      "Upload size limit must be -1 (unlimited) or a positive number",
      "Header encoding must be a valid character encoding",
      "Upload configuration system must be initialized before changes",
      "Upload size cannot be set to zero"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "UploadConfiguration": {
        "sizeMax": {
          "type": "number",
          "description": "Maximum allowed size for uploads in bytes. -1 indicates no maximum."
        },
        "headerEncoding": {
          "type": "string",
          "description": "Character encoding used when reading part headers. Null uses platform default."
        }
      }
    }
  },
  {
    "featureName": "ConfigureHeaderEncoding",
    "description": "Sets and retrieves character encoding used when reading part headers.",
    "inputValues": [
      "encoding-string-EncodingConfiguration"
    ],
    "businessLogic": "1. Input Collection\n   - Collect the following input:\n     - encoding (string): The character encoding to be used when reading headers\n     - This field is optional; when not provided, the system will use platform default encoding\n\n2. Data Validation\n   - Validate the encoding input:\n     - IF encoding is provided:\n       - Check if the encoding is a valid character encoding name\n       - Verify the encoding is supported by the system\n       - IF encoding is invalid:\n         - Generate appropriate error message indicating invalid encoding format\n         - Abort the operation\n     - IF encoding is not provided (null):\n       - System will use platform default encoding\n       - No validation needed\n\n3. Business Rule Processing\n   - Check system state:\n     - Verify that the file upload component is properly initialized\n     - Ensure the component is in a state where encoding configuration is applicable\n   - Determine encoding application scope:\n     - The encoding will be applied to all subsequent file upload operations\n     - The encoding will only affect header parsing, not the content of uploaded files\n\n4. Core Operation Execution\n   - Store the encoding configuration:\n     - IF encoding is provided:\n       - Save the specified encoding value in the system configuration\n       - Update all relevant components to use the new encoding\n     - IF encoding is null:\n       - Reset to use platform default encoding\n       - Update all relevant components accordingly\n   - Apply the encoding setting to the multipart stream processor\n   - Ensure the encoding setting persists for the duration of the current session\n\n5. Response Generation\n   - Generate success response:\n     - Confirm the encoding has been successfully set or reset to default\n     - Include the current active encoding in the response\n     - Provide information about how this setting will affect file uploads\n   - IF any errors occurred:\n     - Generate appropriate error response\n     - Include specific details about why the encoding could not be set\n     - Provide guidance on valid encoding options",
    "databaseEntities": [],
    "validationRules": [
      "Encoding must be a valid character encoding supported by the system",
      "Null encoding value is acceptable and will result in using platform default encoding"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "EncodingConfiguration": {
        "type": "object",
        "properties": {
          "encoding": {
            "type": "string",
            "description": "Character encoding name to be used for reading part headers"
          }
        }
      }
    }
  },
  {
    "featureName": "ProcessMultipartFormData",
    "description": "Processes multipart form data requests, extracting file items and form fields.",
    "inputValues": [
      "contentType-string-Request",
      "requestSize-number-Request",
      "sizeMax-number-Configuration",
      "headerEncoding-string-Configuration",
      "inputStream-object-InputStream"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the following inputs:\n     a. contentType (mandatory): The content type header value from the request\n     b. requestSize (mandatory): The size of the request in bytes\n     c. sizeMax (mandatory): The maximum allowed request size in bytes\n     d. headerEncoding (optional): Character encoding for headers\n     e. inputStream (mandatory): The input stream containing the multipart data\n\n2. Data Validation:\n   - Validate request size:\n     a. IF requestSize is -1 (unknown)\n        THEN generate error: \"Request was rejected because its size is unknown\"\n     b. IF sizeMax is greater than or equal to 0 AND requestSize exceeds sizeMax\n        THEN generate error: \"Request was rejected because its size exceeds allowed range\"\n   - Validate content type:\n     a. Extract boundary from contentType\n     b. IF boundary is not found\n        THEN generate error: \"Request was rejected because no multipart boundary was found\"\n\n3. Business Rule Processing:\n   - Prepare for multipart processing:\n     a. Create an empty collection to store processed items\n     b. Set up multipart stream with input stream and boundary\n     c. IF headerEncoding is provided\n        THEN apply the encoding to the multipart stream\n\n4. Core Operation Execution:\n   - Process multipart data:\n     a. Skip preamble to reach first part\n     b. WHILE more parts exist:\n        i. Read and parse headers for current part\n        ii. Extract field name from headers\n        iii. IF field name exists:\n             1. Check if content type indicates nested multipart (multipart/mixed):\n                a. IF nested multipart:\n                   i. Extract sub-boundary\n                   ii. Process each sub-part:\n                       - Read sub-part headers\n                       - IF file name exists in headers:\n                         * Create file item\n                         * Read body data into item\n                         * Add item to collection\n                       - ELSE:\n                         * Discard body data (non-file items in multipart/mixed are ignored)\n                b. ELSE (regular part):\n                   i. Determine if part is a form field or file based on presence of filename\n                   ii. Create appropriate item\n                   iii. Read body data into item\n                   iv. Add item to collection\n        iv. ELSE (no field name):\n             1. Skip this part by discarding body data\n        v. Check for next boundary\n   - Handle processing errors:\n     a. IF any I/O errors occur during processing\n        THEN generate appropriate error message with details\n\n5. Response Generation:\n   - Return the collection of processed items:\n     a. Each item contains:\n        i. Field name\n        ii. Content type (for file items)\n        iii. Whether it's a form field or file\n        iv. File name (for file items)\n        v. The actual data content\n   - For error conditions:\n     a. Return appropriate error information including:\n        i. Error type (size limit, unknown size, invalid format, etc.)\n        ii. Detailed message explaining the issue",
    "databaseEntities": [
      "jforum_attachments"
    ],
    "validationRules": [
      "Request size must be known (not -1)",
      "Request size must not exceed maximum allowed size if specified",
      "Content type must contain a valid multipart boundary",
      "Headers in multipart data must be properly formatted",
      "Field names must be extracted from Content-disposition headers",
      "File names must be extracted from Content-disposition headers when present"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "InputStream": {
        "type": "object",
        "properties": {
          "data": {
            "type": "binary",
            "description": "The binary content of the input stream"
          }
        }
      }
    }
  },
  {
    "featureName": "ParseMultipartBoundaries",
    "description": "Extracts and processes boundary markers from multipart content types.",
    "inputValues": [
      "contentType-string-RequestHeader",
      "headers-object-HeaderCollection",
      "headerPart-string-HeaderData"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect contentType (string): The content type header value from the request\n   - Collect headers (object): Map containing HTTP request headers\n   - Collect headerPart (string): Raw header part data from the multipart request\n   - System will use these inputs to extract boundary information and parse headers\n\n2. Data Validation:\n   - Validate contentType:\n      * Check if contentType is not null\n      * Verify contentType contains multipart format information\n      * Ensure boundary parameter exists within contentType\n      * Generate appropriate error if validation fails\n   - Validate headers:\n      * Verify headers collection is properly structured\n      * Check for required headers like Content-Disposition\n      * Ensure headers follow expected format with name-value pairs\n   - Validate headerPart:\n      * Check if headerPart is not null\n      * Verify headerPart does not exceed maximum allowed size\n      * Ensure headerPart contains valid header format\n\n3. Business Rule Processing:\n   - Check request size constraints:\n      * IF request size is unknown (-1), THEN reject with appropriate message\n      * IF maximum size is defined AND request exceeds it, THEN reject with size limit message\n   - Process content type information:\n      * Extract boundary parameter from content type\n      * IF boundary is null, THEN reject the request with appropriate message\n      * Convert boundary string to byte array using appropriate character encoding\n   - Verify multipart structure integrity:\n      * Check for proper multipart format compliance\n      * Verify boundary markers are correctly positioned\n      * Ensure nested multipart sections (if any) have valid sub-boundaries\n\n4. Core Operation Execution:\n   - Parse boundary information:\n      * Extract boundary string from content type using parameter parser\n      * Convert boundary string to byte array using ISO-8859-1 encoding\n      * Fall back to default encoding if ISO-8859-1 is unsupported\n   - Process header information:\n      * Parse raw header part into structured header map\n      * Extract field names from Content-Disposition headers\n      * Extract file names from Content-Disposition headers when present\n      * Handle special cases like empty filenames\n   - Parse multipart headers:\n      * Read header lines until empty line is encountered\n      * Split each header at the colon character\n      * Extract header name (converting to lowercase) and value\n      * Handle multiple headers with the same name by combining values\n      * Skip malformed headers that don't contain a colon\n\n5. Response Generation:\n   - For boundary extraction:\n      * Return extracted boundary as byte array\n      * Return null if boundary parameter is not found\n   - For field name extraction:\n      * Return field name string if found\n      * Return null if Content-Disposition header is missing or malformed\n   - For file name extraction:\n      * Return file name string if found\n      * Return empty string if filename parameter exists but has no value\n      * Return null if no filename parameter exists\n   - For header parsing:\n      * Return map of header names to header values\n      * Combine multiple headers with same name using comma separation",
    "databaseEntities": [
      "jforum_attachments"
    ],
    "validationRules": [
      "Content type must contain a boundary parameter",
      "Request size must not exceed the maximum allowed size",
      "Request size must be known (not -1)",
      "Headers must be properly formatted with name-value pairs",
      "Header part must not exceed maximum header size",
      "Content-Disposition header must be present for field name extraction",
      "Boundary string must be convertible to byte array"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "HeaderCollection": {
        "type": "object",
        "properties": {
          "contentDisposition": {
            "type": "string",
            "description": "Content disposition header value"
          },
          "contentType": {
            "type": "string",
            "description": "Content type header value"
          }
        }
      }
    }
  },
  {
    "featureName": "ExtractFileAttachments",
    "description": "Extracts file attachments from multipart requests with proper header parsing.",
    "inputValues": [
      "contentType-string-Request",
      "requestSize-number-Request",
      "inputStream-object-InputStream",
      "headerEncoding-string-Request",
      "sizeMax-number-Configuration"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect contentType (string) from the request headers\n   - Collect requestSize (number) representing the total size of the request\n   - Collect inputStream (object) containing the raw request data\n   - Collect headerEncoding (string) for parsing headers\n   - Collect sizeMax (number) representing the maximum allowed request size\n\n2. Data Validation:\n   - Validate request size:\n     a. IF requestSize is -1 (unknown)\n        THEN reject the request with \"unknown size\" error message\n     b. IF sizeMax is defined (not negative) AND requestSize exceeds sizeMax\n        THEN reject the request with \"size exceeds allowed range\" error message\n   - Validate content type:\n     a. Extract boundary parameter from contentType\n     b. IF boundary is not found\n        THEN reject the request with \"no multipart boundary found\" error message\n\n3. Business Rule Processing:\n   - Prepare for multipart processing:\n     a. Create a collection to store extracted file items\n     b. Convert boundary string to appropriate byte representation\n     c. Initialize multipart stream processor with input stream and boundary\n     d. Set header encoding for proper character interpretation\n\n4. Core Operation Execution:\n   - Process multipart content:\n     a. Skip preamble section of the multipart content\n     b. WHILE more parts exist in the multipart content:\n        i. Read and parse headers for the current part\n        ii. Extract field name from headers\n        iii. IF field name exists:\n             1. Determine content type of the part\n             2. IF content type indicates nested multipart content (multipart/mixed):\n                a. Extract sub-boundary from content type\n                b. Process nested multipart content:\n                   - WHILE more sub-parts exist:\n                     * Parse sub-part headers\n                     * IF file name exists in headers:\n                       - Create file item with appropriate attributes\n                       - Read body data into file item\n                       - Add file item to collection\n                     * ELSE:\n                       - Discard body data (non-file content)\n                c. Reset boundary to original boundary\n             3. ELSE (regular part):\n                a. Create appropriate file item based on headers\n                b. Read body data into file item\n                c. Add file item to collection\n        iv. ELSE (no field name):\n             1. Skip this part by discarding body data\n        v. Check for next boundary\n   - Handle any I/O errors during processing:\n     a. IF I/O error occurs:\n        i. Convert to appropriate exception with descriptive message\n\n5. Response Generation:\n   - Return collection of extracted file items\n   - Each file item contains:\n     a. Field name from the request\n     b. File name (if applicable)\n     c. Content type\n     d. Indicator whether it's a form field or file\n     e. The actual file data",
    "databaseEntities": [
      "jforum_attachments"
    ],
    "validationRules": [
      "Request size must be known (not -1)",
      "Request size must not exceed maximum allowed size if defined",
      "Content type must contain a valid multipart boundary",
      "Headers must be properly formatted with name-value pairs",
      "File attachments must have valid content disposition",
      "Maximum header size must not be exceeded"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "InputStream": {
        "type": "object",
        "properties": {
          "data": {
            "type": "binary",
            "description": "Raw binary data stream"
          }
        }
      },
      "FileItem": {
        "type": "object",
        "properties": {
          "fieldName": {
            "type": "string",
            "description": "Name of the form field"
          },
          "fileName": {
            "type": "string",
            "description": "Original name of the uploaded file"
          },
          "contentType": {
            "type": "string",
            "description": "MIME type of the content"
          },
          "isFormField": {
            "type": "boolean",
            "description": "Whether this item is a regular form field or a file"
          },
          "content": {
            "type": "binary",
            "description": "The file content data"
          }
        }
      }
    }
  },
  {
    "featureName": "ParseContentHeaders",
    "description": "Parses HTTP headers from multipart content sections into key-value pairs.",
    "inputValues": [
      "headerPart-string-HeaderContent",
      "contentType-string-ContentType",
      "headers-object-HeaderCollection"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect headerPart (string): The raw header content to be parsed\n   - Collect contentType (string): The Content-Type header value containing boundary information\n   - Collect headers (object): Optional existing header collection for appending values\n\n2. Data Validation:\n   - Validate headerPart:\n     2.1. Check if headerPart is not null\n     2.2. Check if headerPart contains valid content\n     2.3. Return empty map if headerPart is invalid\n   - Validate contentType (when applicable):\n     2.4. Check if contentType contains boundary parameter\n     2.5. Generate appropriate error message if boundary is missing\n\n3. Business Rule Processing:\n   - Process header format rules:\n     3.1. Determine maximum header size allowed\n     3.2. Check if header size exceeds maximum allowed size\n     3.3. Verify header format follows standard specifications\n   - Process multi-value header rules:\n     3.4. Identify rules for handling multiple headers with same name\n     3.5. Determine delimiter for combining multiple header values\n\n4. Core Operation Execution:\n   - Initialize header collection:\n     4.1. Create empty map to store header key-value pairs\n     4.2. Initialize parsing variables and buffers\n   - Parse individual headers:\n     4.3. Read header content line by line\n     4.4. For each line:\n        4.4.1. Check if line is empty (indicating end of headers)\n        4.4.2. Verify line contains colon separator\n        4.4.3. Skip malformed lines (no colon)\n        4.4.4. Extract header name (before colon, trimmed, converted to lowercase)\n        4.4.5. Extract header value (after colon, trimmed)\n   - Handle duplicate headers:\n     4.5. Check if header name already exists in collection\n     4.6. IF header exists:\n        4.6.1. Append new value to existing value with comma separator\n     4.7. ELSE:\n        4.7.1. Add new header name and value to collection\n   - Handle special headers:\n     4.8. Process Content-Disposition header to extract field names and filenames\n     4.9. Process Content-Type header to extract boundary information\n\n5. Response Generation:\n   - Prepare header collection response:\n     5.1. Finalize the map of parsed headers\n     5.2. Handle any parsing exceptions gracefully\n     5.3. Return the complete header collection\n   - Include metadata:\n     5.4. Add information about any skipped or malformed headers\n     5.5. Include count of successfully parsed headers",
    "databaseEntities": [],
    "validationRules": [
      "Header part must not be null or empty",
      "Header lines must contain a colon separator",
      "Header names must be trimmed and converted to lowercase",
      "Header values must be trimmed",
      "Multiple headers with the same name must be combined with comma separators",
      "Maximum header size must not exceed system-defined limit"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "HeaderCollection": {
        "type": "object",
        "properties": {
          "headerName": {
            "type": "string",
            "description": "The lowercase name of the header"
          },
          "headerValue": {
            "type": "string",
            "description": "The value of the header, or comma-separated values for multiple headers with the same name"
          }
        }
      }
    }
  },
  {
    "featureName": "CreateFileItems",
    "description": "Creates file item objects from parsed multipart content with metadata.",
    "inputValues": [
      "contentType-string-Request",
      "requestSize-number-Request",
      "sizeMax-number-Configuration",
      "headerEncoding-string-Configuration",
      "multipartContent-object-MultipartContent"
    ],
    "businessLogic": "1. Input Collection:\n   1.1. Collect the multipart content from the request\n   1.2. Obtain the content type header value\n   1.3. Get the request size in bytes\n   1.4. Retrieve the maximum allowed size configuration\n   1.5. Get the header encoding configuration\n\n2. Data Validation:\n   2.1. Validate request size\n      2.1.1. IF request size is unknown (-1)\n         THEN generate an error indicating unknown size\n      2.1.2. IF maximum size is configured (sizeMax >= 0) AND request size exceeds maximum\n         THEN generate an error indicating size limit exceeded\n   2.2. Validate multipart boundary\n      2.2.1. Extract boundary from content type header\n      2.2.2. IF boundary is not found\n         THEN generate an error indicating missing multipart boundary\n\n3. Business Rule Processing:\n   3.1. Prepare for multipart content processing\n      3.1.1. Set up multipart stream with input and boundary\n      3.1.2. Configure header encoding for the multipart stream\n   3.2. Check for multipart content structure\n      3.2.1. Skip preamble to position at first part\n      3.2.2. Verify multipart format is valid\n\n4. Core Operation Execution:\n   4.1. Process multipart parts\n      4.1.1. WHILE more parts exist\n         4.1.1.1. Parse headers from current part\n         4.1.1.2. Extract field name from headers\n         4.1.1.3. IF field name exists\n            4.1.1.3.1. Get content type of the part\n            4.1.1.3.2. IF content type indicates nested multipart (multipart/mixed)\n               4.1.1.3.2.1. Extract sub-boundary from content type\n               4.1.1.3.2.2. Process nested multipart content\n               4.1.1.3.2.3. WHILE more sub-parts exist\n                  4.1.1.3.2.3.1. Parse sub-part headers\n                  4.1.1.3.2.3.2. IF file name exists in headers\n                     4.1.1.3.2.3.2.1. Create file item with headers (not form field)\n                     4.1.1.3.2.3.2.2. Read body data into file item\n                     4.1.1.3.2.3.2.3. Add file item to collection\n                  4.1.1.3.2.3.3. ELSE\n                     4.1.1.3.2.3.3.1. Discard body data (non-file content)\n                  4.1.1.3.2.3.4. Move to next sub-part\n               4.1.1.3.2.4. Reset boundary to original boundary\n            4.1.1.3.3. ELSE (regular part)\n               4.1.1.3.3.1. Determine if part is form field based on file name presence\n               4.1.1.3.3.2. Create appropriate file item\n               4.1.1.3.3.3. Read body data into file item\n               4.1.1.3.3.4. Add file item to collection\n         4.1.1.4. ELSE (no field name)\n            4.1.1.4.1. Skip this part by discarding body data\n         4.1.1.5. Move to next part\n\n5. Response Generation:\n   5.1. Return collection of file items\n      5.1.1. Each file item contains:\n         5.1.1.1. Field name\n         5.1.1.2. Content type\n         5.1.1.3. File name (if applicable)\n         5.1.1.4. Content data\n         5.1.1.5. Form field status flag\n   5.2. IF any errors occurred during processing\n      5.2.1. Generate appropriate error response with details",
    "databaseEntities": [
      "jforum_attachments"
    ],
    "validationRules": [
      "Request size must be known (not -1)",
      "Request size must not exceed configured maximum size (if maximum is set)",
      "Content type must contain a valid multipart boundary",
      "Multipart content must follow proper format",
      "Headers in multipart content must be properly formatted",
      "Header size must not exceed maximum allowed size"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "MultipartContent": {
        "type": "object",
        "properties": {
          "inputStream": {
            "type": "object",
            "description": "Input stream containing the multipart data"
          },
          "headers": {
            "type": "object",
            "description": "Map of header names to values"
          }
        }
      },
      "FileItem": {
        "type": "object",
        "properties": {
          "fieldName": {
            "type": "string",
            "description": "Name of the form field"
          },
          "contentType": {
            "type": "string",
            "description": "MIME type of the content"
          },
          "isFormField": {
            "type": "boolean",
            "description": "Whether this item is a form field or file"
          },
          "fileName": {
            "type": "string",
            "description": "Name of the file if this is a file upload"
          },
          "content": {
            "type": "object",
            "description": "Content data of the file or form field"
          }
        }
      }
    }
  },
  {
    "featureName": "GetHeaderFromMap",
    "description": "Retrieves HTTP header value from a map using case-insensitive lookup.",
    "inputValues": [
      "headers-object-HeaderMap",
      "name-string-HeaderName"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the following inputs:\n     a. headers (mandatory): Map containing HTTP request headers\n     b. name (mandatory): String representing the header name to retrieve\n\n2. Data Validation:\n   - Validate headers input:\n     a. IF headers is null THEN\n        i. Return null or appropriate error indicator\n     b. IF headers is not a valid map structure THEN\n        i. Return null or appropriate error indicator\n   - Validate name input:\n     a. IF name is null or empty THEN\n        i. Return null or appropriate error indicator\n     b. IF name contains invalid characters THEN\n        i. Return null or appropriate error indicator\n\n3. Business Rule Processing:\n   - Process header name for case-insensitive lookup:\n     a. Convert the provided header name to lowercase\n     b. Prepare for map lookup operation\n\n4. Core Operation Execution:\n   - Perform case-insensitive header lookup:\n     a. Use the lowercase header name as the key for map lookup\n     b. Retrieve the corresponding value from the headers map\n     c. IF multiple header values exist with the same name THEN\n        i. Combine values into a comma-separated list\n\n5. Response Generation:\n   - Return the retrieved header value:\n     a. IF header was found THEN\n        i. Return the string value of the header\n     b. IF header was not found THEN\n        i. Return null or empty string based on system requirements\n     c. IF multiple values were found and combined THEN\n        i. Return the comma-separated list of values",
    "databaseEntities": [],
    "validationRules": [
      "Headers map must not be null",
      "Header name must not be null or empty",
      "Header name must contain valid characters"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "HeaderMap": {
        "type": "object",
        "properties": {
          "headerKeys": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Collection of HTTP header names"
          },
          "headerValues": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Collection of HTTP header values"
          }
        }
      },
      "HeaderName": {
        "type": "string",
        "description": "Name of the HTTP header to retrieve"
      }
    }
  },
  {
    "featureName": "GetFileItemFactory",
    "description": "Retrieves the factory class used for creating file items in the file upload system.",
    "inputValues": [],
    "businessLogic": "1. Input Collection:\n   - No user inputs required for this operation\n   - System will use internal state of the FileUpload object\n\n2. Data Validation:\n   - Check if the FileUpload object is properly initialized\n   - IF the FileUpload object is null THEN\n     - Return appropriate error indicating invalid object state\n   - No other validations required as this is a simple getter operation\n\n3. Business Rule Processing:\n   - Verify that the FileUpload system is in a valid state\n   - No additional business rules to process for this feature\n\n4. Core Operation Execution:\n   - Access the internal fileItemFactory property of the FileUpload object\n   - Retrieve the current FileItemFactory instance\n   - No modifications to the factory are performed during this operation\n   - No database operations are required\n\n5. Response Generation:\n   - Return the FileItemFactory object to the caller\n   - IF no factory has been set (null value) THEN\n     - Return null, indicating no factory is currently configured\n   - No transformation of the factory object is needed",
    "databaseEntities": [],
    "validationRules": [
      "FileUpload object must be properly initialized"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "FileItemFactory": {
        "type": "object",
        "description": "Factory interface for creating file items"
      }
    }
  },
  {
    "featureName": "SetFileItemFactory",
    "description": "Sets the factory class to use when creating file items for file uploads.",
    "inputValues": [
      "factory-object-FileItemFactory"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the FileItemFactory object to be set\n     - factory: The factory class for creating new file items\n     - This input is mandatory and must be provided by the caller\n\n2. Data Validation:\n   - Validate the factory input\n     - Check if the factory object is not null\n     - IF factory is null THEN\n       - Generate an error indicating that a valid factory must be provided\n       - Abort the operation and return appropriate error message\n     - END IF\n     - Verify that the factory object is of the correct type\n     - IF factory is not of the correct type THEN\n       - Generate a type mismatch error\n       - Abort the operation and return appropriate error message\n     - END IF\n\n3. Business Rule Processing:\n   - Check system state for factory assignment\n     - Determine if a factory is already set\n     - IF a factory is already set THEN\n       - Prepare for replacement of the existing factory\n     - ELSE\n       - Prepare for initial assignment of the factory\n     - END IF\n     - Verify that the system is in a state where changing the factory is allowed\n     - IF system state does not allow factory change THEN\n       - Generate an error indicating that factory cannot be changed in the current state\n       - Abort the operation and return appropriate error message\n     - END IF\n\n4. Core Operation Execution:\n   - Assign the provided factory to the file upload system\n     - Store the factory reference in the appropriate system variable\n     - Update any dependent components that need to be aware of the factory change\n     - IF any errors occur during assignment THEN\n       - Revert to the previous factory if one existed\n       - Generate an error indicating the failure reason\n       - Abort the operation and return appropriate error message\n     - END IF\n\n5. Response Generation:\n   - Generate success response\n     - Indicate that the factory was successfully set\n     - Include confirmation that the system is now using the new factory\n     - Return success status to the caller\n   - IF operation was not successful THEN\n     - Include detailed error information in the response\n     - Provide guidance on how to resolve the issue\n     - Return error status to the caller\n   - END IF",
    "databaseEntities": [],
    "validationRules": [
      "Factory object must not be null",
      "Factory object must be of the correct type",
      "System must be in a state where changing the factory is allowed"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "FileItemFactory": {
        "type": "object",
        "description": "Factory interface for creating file items",
        "properties": {
          "factoryType": {
            "type": "string",
            "description": "Type of factory implementation"
          },
          "configuration": {
            "type": "object",
            "description": "Configuration settings for the factory"
          }
        }
      }
    }
  },
  {
    "featureName": "HandleFileUploadErrors",
    "description": "Provides exception handling for errors encountered during file upload processing.",
    "inputValues": [
      "errorMessage-string-FileUpload"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect error message (optional)\n   - System will generate default error context if no message is provided\n\n2. Data Validation:\n   - Validate error message if provided\n     * IF error message is provided THEN\n       - Check that message is not excessively long (within system limits)\n       - Ensure message contains only valid characters\n     * ELSE\n       - Proceed with default error context\n\n3. Business Rule Processing:\n   - Determine error severity level\n     * Analyze error context to categorize severity (critical, warning, informational)\n     * Check if error is recoverable or non-recoverable\n   - Determine appropriate error handling strategy\n     * IF error is critical THEN\n       - Prepare for immediate operation termination\n     * ELSE IF error is warning THEN\n       - Prepare for potential retry or alternative processing\n     * ELSE\n       - Prepare for notification only\n\n4. Core Operation Execution:\n   - Create error context object\n     * Include timestamp of error occurrence\n     * Include error message (custom or default)\n     * Include error type classification\n   - Log error details\n     * Record error context to appropriate logging system\n     * Include relevant session information\n   - Prepare recovery options\n     * IF error is recoverable THEN\n       - Set up retry mechanisms\n       - Prepare alternative processing paths\n     * ELSE\n       - Prepare for graceful termination\n\n5. Response Generation:\n   - Format user-friendly error message\n     * Translate technical details to user-appropriate language\n     * Include guidance on next steps if applicable\n   - Provide error reference code\n     * Generate unique identifier for this error instance\n     * Include in response for support reference\n   - Include recovery options in response\n     * IF retry is possible THEN\n       - Include retry instructions\n     * IF alternative actions are available THEN\n       - Include alternative action instructions\n     * ELSE\n       - Include contact support information",
    "databaseEntities": [
      "jforum_attachments"
    ],
    "validationRules": [
      "Error message must not exceed system-defined character limit",
      "Error context must include timestamp of occurrence",
      "Critical errors must trigger immediate operation termination",
      "All errors must be logged with appropriate context information"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "ErrorContext": {
        "type": "object",
        "properties": {
          "message": {
            "type": "string",
            "description": "Detailed error message"
          },
          "timestamp": {
            "type": "date",
            "description": "When the error occurred"
          },
          "severity": {
            "type": "string",
            "description": "Error severity level (critical, warning, info)"
          },
          "referenceCode": {
            "type": "string",
            "description": "Unique identifier for this error instance"
          },
          "isRecoverable": {
            "type": "boolean",
            "description": "Whether the error allows for recovery"
          }
        }
      }
    }
  },
  {
    "featureName": "ReadMultipartStream",
    "description": "Reads and processes multipart stream data with boundary detection for file uploads.",
    "inputValues": [
      "inputStream-object-InputStream",
      "boundary-object-ByteArray",
      "bufferSize-number-Integer",
      "headerEncoding-string-String"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the input stream containing multipart data\n   - Collect the boundary token used for dividing the stream into encapsulations\n   - Collect the buffer size (optional, default is 4096 bytes)\n   - Collect the header encoding (optional, uses platform default if not specified)\n\n2. Data Validation:\n   - Validate that the input stream is not null\n     * IF input stream is null THEN return error \"Input stream cannot be null\"\n   - Validate that the boundary token is not null and not empty\n     * IF boundary is null or empty THEN return error \"Boundary token cannot be null or empty\"\n   - Validate that the buffer size is sufficient\n     * IF buffer size is less than (boundary length + 6) THEN set buffer size to default value\n     * Buffer must be large enough to contain boundary string, plus CR/LF and double dash, plus at least one byte of data\n\n3. Business Rule Processing:\n   - Initialize the multipart stream reader\n     * Create a new buffer with the specified size\n     * Prepare the boundary token by prepending CR/LF/DASH/DASH to the provided boundary\n     * Set the boundary length and keep region values\n     * Initialize head and tail pointers to 0\n   - Set the header encoding if provided\n     * IF header encoding is provided THEN set the encoding for reading part headers\n     * ELSE use the platform default encoding\n\n4. Core Operation Execution:\n   - Read data from the input stream\n     * Fill the buffer with data from the input stream when needed\n     * Track the position within the buffer using head and tail pointers\n     * When buffer is depleted, refill it from the input stream\n   - Process boundaries in the multipart stream\n     * Detect boundary markers that separate different parts of the multipart data\n     * Determine if a boundary indicates another encapsulation follows or if it's the end of the stream\n     * Handle special cases like IE5 Mac bug with input type=image\n   - Handle nested multipart streams\n     * Allow changing the boundary token for processing nested streams\n     * Ensure new boundary tokens have the same length as the original\n\n5. Response Generation:\n   - Provide methods to access the parsed content\n     * Return individual bytes from the stream\n     * Indicate whether more encapsulations are available in the stream\n     * Provide access to the header encoding information\n   - Handle error conditions\n     * Generate appropriate exceptions for malformed streams\n     * Generate appropriate exceptions for unexpected end of stream\n     * Generate appropriate exceptions for invalid boundary changes",
    "databaseEntities": [],
    "validationRules": [
      "Input stream must not be null",
      "Boundary token must not be null or empty",
      "Buffer size must be large enough to contain the boundary string plus necessary characters",
      "Nested stream boundaries must be the same length as the parent boundary",
      "Stream must follow proper multipart format with valid boundary markers"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "InputStream": {
        "type": "object",
        "description": "A data source providing bytes of data"
      },
      "ByteArray": {
        "type": "object",
        "description": "An array of bytes representing the boundary token"
      },
      "Integer": {
        "type": "number",
        "description": "A numeric value specifying the buffer size"
      },
      "String": {
        "type": "string",
        "description": "Character encoding used when reading headers"
      }
    }
  },
  {
    "featureName": "ReadBoundary",
    "description": "Detects boundary tokens in multipart streams to separate content encapsulations.",
    "inputValues": [
      "input-object-InputStream",
      "boundary-object-ByteArray",
      "bufSize-number-Integer"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the input stream (InputStream) containing multipart data\n   - Collect the boundary token (byte array) that separates content parts\n   - Collect buffer size (integer) for processing the request\n   - System will use default buffer size if not provided\n\n2. Data Validation:\n   - Validate input stream is not null\n     * IF input stream is null THEN return error message\n   - Validate boundary token is not null and not empty\n     * IF boundary token is null or empty THEN return error message\n   - Validate buffer size is sufficient\n     * IF buffer size is smaller than boundary length plus overhead THEN return error message\n     * Buffer must be large enough to contain boundary string, plus 4 characters for CR/LF and double dash, plus at least one byte of data\n\n3. Business Rule Processing:\n   - Initialize buffer for processing the request\n     * Create new byte array with specified buffer size\n   - Prepare boundary token for detection\n     * Prepend CR/LF/DASH/DASH to the boundary to properly identify boundaries\n     * Calculate boundary length including the prepended characters\n     * Calculate keep region (amount of data that must be kept in buffer)\n   - Initialize buffer position trackers\n     * Set head index to 0 (first valid character in buffer)\n     * Set tail index to 0 (last valid character in buffer + 1)\n\n4. Core Operation Execution:\n   - Read data from input stream into buffer\n     * IF buffer is depleted (head equals tail) THEN refill buffer\n     * IF no more data available THEN indicate end of stream\n   - Scan buffer for boundary token\n     * Move head position past boundary length\n     * Read next two bytes after boundary\n     * IF bytes match stream terminator (--) THEN mark as final boundary\n     * IF bytes match field separator (CRLF) THEN mark as intermediate boundary\n     * IF bytes don't match either pattern THEN report malformed stream\n   - Handle special cases\n     * Work around browser bugs (e.g., IE5 Mac bug with input type=image)\n     * Handle unexpected stream endings\n\n5. Response Generation:\n   - Return boundary detection result\n     * IF stream terminator detected THEN indicate no more encapsulations\n     * IF field separator detected THEN indicate more encapsulations available\n     * IF malformed boundary detected THEN return appropriate error\n   - Provide position information for content extraction\n     * Return current buffer position for content processing",
    "databaseEntities": [],
    "validationRules": [
      "Input stream must not be null",
      "Boundary token must not be null or empty",
      "Buffer size must be sufficient to contain boundary plus overhead",
      "Characters following boundary must be valid terminators or separators",
      "Stream must not end unexpectedly during boundary detection"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "InputStream": {
        "type": "object",
        "description": "Input stream containing multipart data"
      },
      "ByteArray": {
        "type": "object",
        "description": "Byte array representing boundary token"
      },
      "Integer": {
        "type": "number",
        "description": "Size of buffer for processing request"
      }
    }
  },
  {
    "featureName": "SetBoundary",
    "description": "Changes boundary tokens for nested multipart stream processing.",
    "inputValues": [
      "boundary-object-Boundary"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the boundary token (byte array) to be set for the multipart stream\n   - The boundary token is required and must be provided as a byte array\n   - No default values are provided for the boundary token\n\n2. Data Validation:\n   - Validate that the boundary token is not null\n     * IF boundary token is null THEN generate error message indicating boundary cannot be null\n   - Validate the boundary token length\n     * Compare the length of the provided boundary token with the current boundary length minus 4\n     * IF lengths do not match THEN generate an IllegalBoundaryException with message \"The length of a boundary token can not be changed\"\n     * The validation ensures nested multipart streams maintain consistent boundary token lengths\n\n3. Business Rule Processing:\n   - Verify that the multipart stream is properly initialized\n     * Ensure the internal boundary array has been created\n     * Ensure the boundaryLength property has been set\n     * IF the stream is not initialized THEN generate an error indicating the stream must be initialized first\n   - Check if the stream is in a state where boundary can be changed\n     * Ensure the stream is not in the middle of processing an encapsulation\n     * IF the stream is in an invalid state THEN generate an error indicating boundary cannot be changed in current state\n\n4. Core Operation Execution:\n   - Prepare to update the boundary token in the multipart stream\n     * The boundary array stores the token with a prefix of CR, LF, DASH, DASH (4 bytes)\n     * Only update the portion after this prefix\n   - Copy the provided boundary token into the internal boundary array\n     * Use System.arraycopy to copy the provided boundary token into the internal boundary array starting at position 4\n     * The first 4 positions in the array (0-3) remain unchanged as they contain CR, LF, DASH, DASH\n   - Update is complete without modifying other stream properties\n     * The boundaryLength and keepRegion properties remain unchanged as the new boundary has the same length\n\n5. Response Generation:\n   - For successful boundary update:\n     * No specific response is generated as the operation is void\n     * The multipart stream now uses the new boundary for parsing nested streams\n   - For validation failures:\n     * Return an IllegalBoundaryException with a descriptive message\n     * Include details about why the boundary token was rejected",
    "databaseEntities": [],
    "validationRules": [
      "Boundary token must not be null",
      "New boundary token length must match the current boundary length minus 4",
      "Multipart stream must be properly initialized before changing boundary",
      "Stream must not be in the middle of processing an encapsulation when changing boundary"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Boundary": {
        "type": "object",
        "properties": {
          "value": {
            "type": "array",
            "description": "Byte array representing the boundary token"
          },
          "length": {
            "type": "integer",
            "description": "Length of the boundary token"
          }
        },
        "required": [
          "value"
        ]
      }
    }
  },
  {
    "featureName": "ReadHeadersFromMultipartStream",
    "description": "Reads header part of a multipart encapsulation and returns it as a string.",
    "inputValues": [
      "multipartStream-object-MultipartStream"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the multipart stream object that contains the encapsulated data\n   - Prepare a byte array output stream to store header data\n   - Set maximum header size limit\n\n2. Data Validation:\n   - Validate that the multipart stream is properly initialized\n   - Verify that the stream is positioned at the beginning of a header section\n   - Ensure the header size limit is appropriate to prevent abuse\n\n3. Business Rule Processing:\n   - Check if header encoding is specified\n   - Verify that the stream has not reached its end\n   - Ensure the system has enough memory to process the header\n\n4. Core Operation Execution:\n   - Initialize counter variables and buffers\n   - Read bytes from the stream one by one\n     - IF byte matches the current position in the header separator pattern\n       - Increment the pattern match counter\n     - ELSE\n       - Reset the pattern match counter to zero\n     - Add the byte to the output buffer if within size limits\n     - Increment the size counter\n     - IF size exceeds maximum allowed size\n       - Continue reading but stop storing bytes\n   - Continue until the complete header separator pattern is found\n   - Convert the collected bytes to a string\n     - IF header encoding is specified\n       - TRY to use the specified encoding\n       - IF encoding is not supported\n         - Fall back to platform default encoding\n     - ELSE\n       - Use platform default encoding\n\n5. Response Generation:\n   - Return the complete header string including the trailing separator\n   - IF stream ended unexpectedly\n     - Generate appropriate error message\n   - IF header size exceeded maximum\n     - Include warning information",
    "databaseEntities": [],
    "validationRules": [
      "Stream must not end unexpectedly during header reading",
      "Header size must not exceed maximum allowed size",
      "Header encoding must be supported if specified"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "MultipartStream": {
        "type": "object",
        "properties": {
          "buffer": {
            "type": "array",
            "description": "Buffer to store stream data"
          },
          "head": {
            "type": "integer",
            "description": "Current position in the buffer"
          },
          "tail": {
            "type": "integer",
            "description": "End position of data in the buffer"
          },
          "boundary": {
            "type": "array",
            "description": "Boundary separator pattern"
          },
          "headerEncoding": {
            "type": "string",
            "description": "Character encoding for headers"
          }
        }
      }
    }
  },
  {
    "featureName": "ReadBodyDataFromMultipartStream",
    "description": "Reads body data from current encapsulation and writes contents to output stream.",
    "inputValues": [
      "outputStream-object-OutputStream",
      "buffer-object-ByteArray",
      "head-number-Integer",
      "tail-number-Integer",
      "keepRegion-number-Integer",
      "boundary-object-ByteArray",
      "boundaryLength-number-Integer",
      "input-object-InputStream"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the output stream where data will be written\n   - Access the internal buffer containing data\n   - Use current head and tail positions in the buffer\n   - Access boundary information for detecting end of data\n   - All inputs are required for operation\n\n2. Data Validation:\n   - Validate that output stream is not null\n     * IF output stream is null THEN abort operation\n   - Validate that buffer is properly initialized\n     * IF buffer is null or empty THEN abort operation\n   - Validate that head and tail positions are valid\n     * IF head is negative THEN abort operation\n     * IF tail is less than head THEN abort operation\n     * IF tail exceeds buffer length THEN abort operation\n\n3. Business Rule Processing:\n   - Initialize tracking variables:\n     * Set 'done' flag to false\n     * Set 'total' bytes counter to zero\n   - Verify boundary information is valid\n     * IF boundary is null or empty THEN abort operation\n     * IF boundaryLength is invalid THEN abort operation\n\n4. Core Operation Execution:\n   - WHILE not done:\n     * Search for boundary separator in current buffer\n     * IF separator found THEN:\n       - Calculate remaining data before boundary\n       - Write remaining data to output stream\n       - Update total bytes counter\n       - Update head position to separator position\n       - Set done flag to true\n     * ELSE (no separator found):\n       - Determine padding amount to keep in buffer\n       - Write data from head to (tail - padding) to output stream\n       - Update total bytes counter\n       - Move remaining padding data to beginning of buffer\n       - Refill buffer with new data from input stream\n       - IF end of input stream reached unexpectedly THEN:\n         + Write remaining padding data to output stream\n         + Update total bytes counter\n         + Throw malformed stream exception\n   - Flush output stream to ensure all data is written\n\n5. Response Generation:\n   - Return total number of bytes written to output stream\n   - IF any errors occurred during processing THEN:\n     * Throw appropriate exception with descriptive message\n     * For unexpected end of stream, throw MalformedStreamException\n     * For I/O errors, propagate IOException",
    "databaseEntities": [],
    "validationRules": [
      "Output stream must not be null",
      "Buffer must be properly initialized",
      "Head position must be non-negative",
      "Tail position must be greater than or equal to head position",
      "Tail position must not exceed buffer length",
      "Boundary information must be valid"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "OutputStream": {
        "type": "object",
        "description": "Stream where data will be written",
        "methods": [
          "write",
          "flush"
        ]
      },
      "ByteArray": {
        "type": "array",
        "items": {
          "type": "integer",
          "minimum": 0,
          "maximum": 255
        },
        "description": "Array of bytes"
      },
      "InputStream": {
        "type": "object",
        "description": "Stream from which data is read",
        "methods": [
          "read"
        ]
      }
    }
  },
  {
    "featureName": "DiscardBodyData",
    "description": "Skips unwanted encapsulation data by reading and discarding body content.",
    "inputValues": [
      "inputStream-object-InputStream",
      "buffer-object-ByteArray",
      "boundary-object-ByteArray",
      "keepRegion-number-Integer"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect input stream containing multipart data\n   - Access buffer for temporary data storage\n   - Use boundary information for detecting section separators\n   - Utilize keepRegion parameter for buffer management\n\n2. Data Validation:\n   - Verify input stream is not null\n   - Ensure buffer has sufficient capacity for processing\n   - Validate boundary information is properly formatted\n   - Confirm keepRegion value is positive and within reasonable limits\n   - Generate appropriate error messages for any validation failures\n\n3. Business Rule Processing:\n   - Check if current position is at a valid data section\n   - Verify system has sufficient resources to process the stream\n   - Ensure the stream follows expected multipart format standards\n\n4. Core Operation Execution:\n   - INITIALIZE tracking variables for processing:\n     - Set done flag to false\n     - Set total bytes discarded counter to 0\n   - WHILE not done:\n     - Search for boundary separator in current buffer\n     - IF separator found:\n       - Calculate bytes to discard before boundary\n       - Update total bytes discarded counter\n       - Update head position to separator location\n       - Set done flag to true\n     - ELSE:\n       - Determine optimal buffer retention size (pad)\n       - Update total bytes discarded counter\n       - Move remaining buffer data to beginning\n       - Refill buffer with new data from input stream\n       - IF end of stream reached unexpectedly:\n         - Update total bytes discarded counter\n         - Throw malformed stream exception\n\n5. Response Generation:\n   - Return total number of bytes discarded\n   - Provide appropriate error information if exceptions occurred\n   - Ensure stream position is correctly set at boundary for next operation",
    "databaseEntities": [],
    "validationRules": [
      "Input stream must not be null",
      "Buffer must have sufficient capacity",
      "Boundary information must be properly formatted",
      "KeepRegion value must be positive",
      "Stream must follow expected multipart format"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "InputStream": {
        "type": "object",
        "properties": {
          "read": {
            "type": "function",
            "description": "Reads bytes from the input stream"
          }
        }
      },
      "ByteArray": {
        "type": "array",
        "items": {
          "type": "integer",
          "minimum": 0,
          "maximum": 255
        },
        "description": "Array of bytes for data processing"
      }
    }
  },
  {
    "featureName": "SkipPreamble",
    "description": "Finds the beginning of the first encapsulation in a multipart stream.",
    "inputValues": [
      "stream-object-InputStream",
      "boundary-object-ByteArray",
      "boundaryLength-number-Integer"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the input stream containing multipart data\n   - Obtain the boundary marker that separates encapsulations\n   - Determine the boundary length for processing\n\n2. Data Validation:\n   - Verify the input stream is not null\n   - Validate that the boundary marker is properly formatted\n   - Ensure the boundary length is a positive value\n   - Check that the stream is accessible and readable\n   - IF any validation fails, THEN return appropriate error message\n\n3. Business Rule Processing:\n   - Prepare the boundary for preamble skipping:\n     - Copy the boundary bytes, excluding the first two bytes (CR and LF)\n     - Adjust the boundary length accordingly\n   - Verify the stream has sufficient data for processing\n   - Ensure the buffer has enough capacity to hold the boundary\n\n4. Core Operation Execution:\n   - Discard all data in the stream up to the first boundary delimiter\n     - Read data from the stream into the buffer\n     - Search for boundary marker in the buffer\n     - IF boundary not found in current buffer segment, THEN:\n       - Retain a portion of the buffer for potential partial matches\n       - Read more data into the buffer\n       - Continue searching\n     - ELSE:\n       - Position the stream at the found boundary\n   - Attempt to read the boundary:\n     - Read the boundary marker from the current position\n     - Verify it matches the expected boundary pattern\n     - IF successful, THEN an encapsulation was found\n\n5. Response Generation:\n   - Restore the original boundary configuration:\n     - Copy the boundary bytes back to their original positions\n     - Reset the boundary length to its original value\n     - Restore the CR and LF bytes at the beginning\n   - Return a boolean result:\n     - TRUE if an encapsulation was successfully found\n     - FALSE if no encapsulation was found or an error occurred\n   - Ensure all resources are properly managed regardless of outcome",
    "databaseEntities": [],
    "validationRules": [
      "Input stream must not be null",
      "Boundary marker must be properly formatted",
      "Boundary length must be a positive value",
      "Stream must be accessible and readable"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "InputStream": {
        "type": "object",
        "properties": {
          "read": {
            "type": "function",
            "description": "Reads bytes from the stream into a buffer"
          }
        }
      },
      "ByteArray": {
        "type": "array",
        "items": {
          "type": "integer",
          "minimum": 0,
          "maximum": 255
        },
        "description": "Array of byte values representing the boundary marker"
      }
    }
  },
  {
    "featureName": "FindSeparator",
    "description": "Searches for boundary separator in the buffer to identify encapsulation boundaries.",
    "inputValues": [
      "buffer-object-ByteBuffer",
      "boundary-object-ByteArray",
      "head-number-Position",
      "tail-number-Position",
      "boundaryLength-number-Length"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the buffer data structure containing the content to search through\n   - Collect the boundary pattern to search for\n   - Collect the head position indicating the start of the search area\n   - Collect the tail position indicating the end of the search area\n   - Collect the boundary length for comparison purposes\n   - All inputs are mandatory for the search operation\n\n2. Data Validation:\n   - Validate that the buffer is not null\n     * IF buffer is null THEN return error indicating invalid buffer\n   - Validate that the boundary pattern is not null and has length greater than 0\n     * IF boundary is null or empty THEN return error indicating invalid boundary pattern\n   - Validate that head position is within valid range (0 <= head < buffer length)\n     * IF head is out of range THEN return error indicating invalid head position\n   - Validate that tail position is within valid range (head <= tail <= buffer length)\n     * IF tail is out of range THEN return error indicating invalid tail position\n   - Validate that boundaryLength is equal to the actual boundary length\n     * IF boundaryLength is incorrect THEN return error indicating boundary length mismatch\n\n3. Business Rule Processing:\n   - Calculate the maximum position where a boundary could start\n     * maxpos = tail - boundaryLength\n   - IF maxpos < head THEN\n     * Return -1 as there's not enough space for the boundary to exist\n   - Prepare variables for the search process:\n     * first = head (starting position for the search)\n     * match = 0 (counter for matched bytes)\n\n4. Core Operation Execution:\n   - WHILE first <= maxpos AND match != boundaryLength:\n     * Find the first occurrence of the first byte of the boundary pattern\n       - Search from position 'first' to 'tail' for boundary[0]\n       - IF not found OR found position > maxpos THEN return -1\n       - Update 'first' to the found position\n     * Compare subsequent bytes with the boundary pattern\n       - FOR match = 1 to boundaryLength-1:\n         * IF buffer[first + match] != boundary[match] THEN break the loop\n       - IF match reached boundaryLength THEN all bytes matched\n   - IF match equals boundaryLength THEN:\n     * Return (first - 1) as the position where the boundary starts\n   - ELSE:\n     * Return -1 indicating boundary not found\n\n5. Response Generation:\n   - Return the position of the boundary in the buffer (counting from the beginning)\n     * Success: Position value (0 or positive integer) indicating where boundary was found\n     * Not found: -1 indicating the boundary pattern does not exist in the specified region\n   - The returned position can be used by calling functions to process data before the boundary",
    "databaseEntities": [],
    "validationRules": [
      "Buffer must not be null",
      "Boundary pattern must not be null or empty",
      "Head position must be within valid range (0 <= head < buffer length)",
      "Tail position must be within valid range (head <= tail <= buffer length)",
      "Boundary length must match the actual length of the boundary array"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "ByteBuffer": {
        "type": "object",
        "properties": {
          "data": {
            "type": "array",
            "items": {
              "type": "integer"
            }
          },
          "length": {
            "type": "integer"
          }
        }
      },
      "ByteArray": {
        "type": "array",
        "items": {
          "type": "integer"
        }
      }
    }
  },
  {
    "featureName": "ParseParameterString",
    "description": "Extracts name/value pairs from a string using specified separator character.",
    "inputValues": [
      "inputString-string-ParameterString",
      "separator-string-Separator",
      "lowerCaseNames-boolean-NameCaseOption"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect inputString (string): The string containing name/value pairs to parse\n   - Collect separator (string): Single character that separates name/value pairs\n   - Collect lowerCaseNames (boolean): Flag indicating whether parameter names should be converted to lowercase\n   - System will prepare an empty result collection to store parsed parameters\n\n2. Data Validation:\n   - Validate inputString:\n     - IF inputString is null or empty THEN\n       - Return empty result collection\n     - END IF\n   - Validate separator:\n     - IF separator is not provided THEN\n       - Use default separator (typically semicolon or comma)\n     - END IF\n     - IF separator is more than one character THEN\n       - Use only the first character\n     - END IF\n   - Validate lowerCaseNames:\n     - IF lowerCaseNames is not provided THEN\n       - Set lowerCaseNames to false (default)\n     - END IF\n\n3. Business Rule Processing:\n   - Initialize parsing position to the beginning of the string\n   - Initialize maximum position to the length of the string\n   - WHILE there are characters left to parse DO\n     - Extract parameter name:\n       - Skip any leading whitespace\n       - Read characters until encountering '=' or separator\n       - Trim trailing whitespace from parameter name\n     - Extract parameter value (if present):\n       - IF next character is '=' THEN\n         - Skip the '=' character\n         - Parse parameter value considering quotation marks:\n           - IF value starts with a quote THEN\n             - Read until matching end quote, handling escaped quotes\n             - Remove surrounding quotes from final value\n           - ELSE\n             - Read until separator\n             - Trim whitespace from value\n           - END IF\n       - ELSE\n         - Set parameter value to null (parameter without value)\n       - END IF\n     - IF next character is separator THEN\n       - Skip the separator character\n     - END IF\n     - Process the parameter:\n       - IF parameter name is not empty THEN\n         - IF lowerCaseNames is true THEN\n           - Convert parameter name to lowercase\n         - END IF\n         - Add parameter name and value to result collection\n       - END IF\n   - END WHILE\n\n4. Core Operation Execution:\n   - Ensure all parameters have been extracted according to the parsing rules\n   - Handle special cases:\n     - Parameters without values are stored with null values\n     - Empty parameter names are ignored\n     - Duplicate parameter names will overwrite previous values\n   - Maintain the order of parameters as they appear in the input string\n\n5. Response Generation:\n   - Return the collection of parameter name/value pairs\n   - Ensure the collection maintains the expected structure (typically a Map or Dictionary)\n   - IF no valid parameters were found THEN\n     - Return empty collection\n   - END IF",
    "databaseEntities": [],
    "validationRules": [
      "Input string may be null or empty, which should return an empty result",
      "Parameter names must be unique in the result collection",
      "Parameter names can be optionally converted to lowercase",
      "Parameter values are optional and can be null",
      "Parameter values enclosed in quotes must have matching start and end quotes",
      "Escaped quotes within parameter values must be handled correctly",
      "Empty parameter names should be ignored"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "ParameterString": {
        "type": "object",
        "properties": {
          "content": {
            "type": "string",
            "description": "String containing name/value pairs to be parsed"
          }
        }
      },
      "Separator": {
        "type": "object",
        "properties": {
          "character": {
            "type": "string",
            "description": "Character that separates name/value pairs in the input string"
          }
        }
      },
      "NameCaseOption": {
        "type": "object",
        "properties": {
          "toLowerCase": {
            "type": "boolean",
            "description": "Flag indicating whether parameter names should be converted to lowercase"
          }
        }
      }
    }
  },
  {
    "featureName": "ParseParameterCharArray",
    "description": "Extracts name/value pairs from a character array using specified separator character.",
    "inputValues": [
      "chars-object-CharArray",
      "offset-number-Integer",
      "length-number-Integer",
      "separator-string-Character"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the character array to be parsed\n   - Collect the offset position to start parsing from\n   - Collect the length of the array segment to parse\n   - Collect the separator character that divides name/value pairs\n   - Determine if parameter names should be converted to lowercase (configuration setting)\n\n2. Data Validation:\n   - Verify the character array is not null\n     * IF character array is null THEN\n       * Return empty collection of parameters\n       * End processing\n   - Verify the offset is within array bounds\n     * IF offset is negative or greater than array length THEN\n       * Return error for invalid offset\n   - Verify the length is valid\n     * IF length is negative or offset+length exceeds array size THEN\n       * Return error for invalid length\n   - Verify the separator character is valid\n     * IF separator is not a valid character THEN\n       * Return error for invalid separator\n\n3. Business Rule Processing:\n   - Initialize result collection for storing name/value pairs\n   - Set up parsing position at the specified offset\n   - Set maximum position as offset + length\n   - WHILE there are characters remaining to process:\n     * Extract parameter name by parsing until '=' or separator is encountered\n       * Skip leading whitespace characters\n       * Collect characters until delimiter is found\n       * Trim trailing whitespace characters\n     * IF '=' character is found after parameter name THEN\n       * Move past the '=' character\n       * Extract parameter value by parsing until separator is encountered\n         * Handle quoted values (enclosed in double quotes)\n         * Handle escaped characters within quotes\n         * Remove surrounding quotes if present\n     * ELSE\n       * Set parameter value to null (parameter without value)\n     * IF separator character is found THEN\n       * Move past the separator character\n     * IF parameter name is not empty THEN\n       * IF lowercase setting is enabled THEN\n         * Convert parameter name to lowercase\n       * Store parameter name and value in result collection\n\n4. Core Operation Execution:\n   - Process each name/value pair sequentially\n   - Handle special cases:\n     * Quoted values that may contain separator characters\n     * Escaped quote characters within quoted values\n     * Parameters with no values\n   - Maintain uniqueness of parameter names in result collection\n     * If duplicate names are found, later values override earlier ones\n\n5. Response Generation:\n   - Return the complete collection of parsed name/value pairs\n   - Ensure parameter names are unique in the result\n   - Preserve the original character case of values\n   - Apply lowercase conversion to names if configured",
    "databaseEntities": [],
    "validationRules": [
      "Character array must not be null",
      "Offset must be within array bounds",
      "Length must be valid for the array",
      "Parameter names must be unique in result collection",
      "Quoted values must handle escaped characters properly",
      "Parameter names should be converted to lowercase if configured"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "CharArray": {
        "type": "object",
        "properties": {
          "data": {
            "type": "array",
            "items": {
              "type": "string",
              "minLength": 1,
              "maxLength": 1
            },
            "description": "Array of characters to be parsed"
          }
        },
        "required": [
          "data"
        ]
      }
    }
  },
  {
    "featureName": "ConfigureCaseConversion",
    "description": "Controls whether parameter names are converted to lowercase during parsing.",
    "inputValues": [
      "lowerCaseFlag-boolean-ParameterParser"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the boolean flag 'lowerCaseFlag' that determines case conversion behavior\n   - This flag is mandatory for this feature\n   - Default value is false (parameter names are not converted to lowercase)\n\n2. Data Validation:\n   - Validate that the input is a valid boolean value\n   - IF input is not a boolean type THEN\n     - Generate an error message indicating invalid input type\n     - Request a valid boolean value\n   - ENDIF\n\n3. Business Rule Processing:\n   - Verify that the parameter parser system is properly initialized\n   - Check if changing the case conversion setting would affect any ongoing parsing operations\n   - IF a parsing operation is in progress THEN\n     - Determine if changing the setting mid-operation is allowed\n     - IF not allowed THEN\n       - Generate a warning about potential inconsistent behavior\n     - ENDIF\n   - ENDIF\n\n4. Core Operation Execution:\n   - Store the provided boolean flag in the system configuration\n   - Update the internal state of the parameter parser to reflect the new setting\n   - Apply the case conversion setting to all subsequent parameter parsing operations\n   - IF lowerCaseFlag is TRUE THEN\n     - Configure the system to convert all parameter names to lowercase during parsing\n   - ELSE\n     - Configure the system to preserve the original case of parameter names during parsing\n   - ENDIF\n\n5. Response Generation:\n   - Confirm the successful update of the case conversion setting\n   - Return the current state of the case conversion setting after the update\n   - Provide information about how this setting will affect parameter parsing behavior\n   - Include any relevant warnings about the effects of this configuration change",
    "databaseEntities": [],
    "validationRules": [
      "The lowerCaseFlag must be a valid boolean value",
      "The parameter parser must be properly initialized before configuring case conversion"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "ParameterParser": {
        "type": "object",
        "properties": {
          "lowerCaseNames": {
            "type": "boolean",
            "description": "Flag indicating whether parameter names should be converted to lowercase"
          }
        },
        "required": [
          "lowerCaseNames"
        ]
      }
    }
  },
  {
    "featureName": "GetFileInputStream",
    "description": "Retrieves file contents as an input stream from memory or disk storage.",
    "inputValues": [
      "fileItem-object-FileItem"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the FileItem object that contains the file data\n   - System determines if the file is stored in memory or on disk\n   - No additional user inputs are required\n\n2. Data Validation:\n   - Verify the FileItem object is not null\n     * IF FileItem is null THEN return appropriate error\n   - Verify the file data exists and is accessible\n     * IF file data cannot be accessed THEN return appropriate error\n\n3. Business Rule Processing:\n   - Check the storage location of the file content\n     * Determine if the file is stored in memory or on disk based on internal thresholds\n     * Verify access permissions to the file storage location\n     * IF storage location is inaccessible THEN return appropriate error\n\n4. Core Operation Execution:\n   - IF file is stored on disk:\n     * Locate the physical file on the disk storage\n     * Create a file input stream from the disk file\n     * Return the file input stream\n   - ELSE IF file is stored in memory:\n     * Check if cached content exists\n       * IF cached content does not exist THEN retrieve data from deferred file output stream\n     * Create a byte array input stream from the cached content\n     * Return the byte array input stream\n   - Handle any I/O exceptions that may occur during stream creation\n     * IF exception occurs THEN log error details and return appropriate error\n\n5. Response Generation:\n   - Return the created input stream for success case\n   - For error cases, return appropriate error information:\n     * File not found error if file doesn't exist\n     * Access denied error if permissions are insufficient\n     * I/O error if stream cannot be created\n     * Include error details to assist with troubleshooting",
    "databaseEntities": [
      "jforum_attachments"
    ],
    "validationRules": [
      "FileItem object must not be null",
      "File data must be accessible either in memory or on disk",
      "File storage location must be accessible"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "FileItem": {
        "type": "object",
        "properties": {
          "fieldName": {
            "type": "string",
            "description": "The name of the form field"
          },
          "contentType": {
            "type": "string",
            "description": "The content type of the file"
          },
          "isFormField": {
            "type": "boolean",
            "description": "Whether this item is a simple form field"
          },
          "fileName": {
            "type": "string",
            "description": "The original filename in the user's filesystem"
          },
          "sizeThreshold": {
            "type": "integer",
            "description": "The threshold above which uploads will be stored on disk"
          },
          "repository": {
            "type": "object",
            "description": "The directory in which uploaded files will be stored"
          }
        }
      }
    }
  },
  {
    "featureName": "GetFileContentType",
    "description": "Retrieves the content type of the uploaded file.",
    "inputValues": [
      "fileItem-object-DiskFileItem"
    ],
    "businessLogic": "1. Input Collection:\n   - Receive a file item object containing file metadata and content\n   - Required inputs:\n     * fileItem: The DiskFileItem object containing file information\n   - No additional inputs required as all necessary data is contained in the file item\n\n2. Data Validation:\n   - Validate file item object\n     * Check if file item is not null\n     * IF file item is null THEN\n       - Return error indicating invalid file item\n     * END IF\n\n3. Business Rule Processing:\n   - Check if content type information is available\n     * IF content type is null THEN\n       - Determine if content type can be inferred from file properties\n       - IF content type cannot be determined THEN\n         - Prepare to return null or default content type\n       - END IF\n     * END IF\n   - Check if character set information is needed\n     * IF character set information is requested THEN\n       - Prepare to extract character set from content type\n     * END IF\n\n4. Core Operation Execution:\n   - Retrieve content type from file item\n     * Access the stored content type value from the file item\n     * IF content type contains character set information THEN\n       - Parse the content type string to separate MIME type and character set\n     * END IF\n   - Process content type information\n     * IF content type is null THEN\n       - Attempt to determine content type based on file name or content\n     * END IF\n\n5. Response Generation:\n   - Prepare content type response\n     * Format the content type string according to standard MIME format\n     * IF character set information is available and relevant THEN\n       - Include character set information in the response\n     * END IF\n   - Return the content type information\n     * Return the complete content type string\n     * IF an error occurred during processing THEN\n       - Return appropriate error information\n     * END IF",
    "databaseEntities": [
      "jforum_attachments"
    ],
    "validationRules": [
      "File item must not be null",
      "Content type may be null if not specified by the browser"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "DiskFileItem": {
        "type": "object",
        "properties": {
          "fieldName": {
            "type": "string",
            "description": "The name of the form field as provided by the browser"
          },
          "contentType": {
            "type": "string",
            "description": "The content type passed by the browser, or null if not defined"
          },
          "isFormField": {
            "type": "boolean",
            "description": "Whether or not this item is a simple form field"
          },
          "fileName": {
            "type": "string",
            "description": "The original filename in the user's filesystem"
          },
          "sizeThreshold": {
            "type": "number",
            "description": "The threshold above which uploads will be stored on disk"
          },
          "repository": {
            "type": "object",
            "description": "The directory in which uploaded files will be stored"
          }
        }
      }
    }
  },
  {
    "featureName": "GetFileCharSet",
    "description": "Extracts the charset parameter from the content type of the uploaded file.",
    "inputValues": [
      "contentType-string-FileItem"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the content type string from the file item\n   - System will use DEFAULT_CHARSET as fallback value if no charset is specified\n\n2. Data Validation:\n   - Check if the provided content type is null\n     - IF content type is null, THEN proceed with null input handling\n     - IF content type is not null, THEN proceed with parsing\n   - Validate that content type string follows expected format with potential charset parameter\n     - Content type should follow pattern: type/subtype; param1=value1; param2=value2\n     - No specific format validation required as parser will handle malformed inputs\n\n3. Business Rule Processing:\n   - Initialize parameter parser for content type string\n   - Configure parser to use case-insensitive parameter names\n     - Set parser to convert parameter names to lowercase\n   - Parse the content type string using semicolon as delimiter\n     - Split content type into main type and parameters\n     - Extract all parameter name-value pairs\n   - Look for the specific \"charset\" parameter in the parsed parameters\n\n4. Core Operation Execution:\n   - Retrieve the charset parameter value from parsed parameters\n     - IF charset parameter exists, THEN return its value\n     - IF charset parameter does not exist, THEN return null\n   - No modifications to the original content type or file item are made\n   - Operation is read-only and does not affect system state\n\n5. Response Generation:\n   - Return the extracted charset value as a string\n   - IF no charset parameter was found, THEN return null\n   - No additional information or error responses needed as this is a simple extraction operation",
    "databaseEntities": [],
    "validationRules": [
      "Content type string may be null",
      "Content type string should follow MIME type format when provided",
      "Charset parameter is optional in content type"
    ],
    "dbSeedingOperations": [],
    "schema": {}
  },
  {
    "featureName": "GetFileName",
    "description": "Retrieves the original filename from the client's filesystem.",
    "inputValues": [
      "fileItem-object-DiskFileItem"
    ],
    "businessLogic": "1. Input Collection:\n   - Obtain a reference to the DiskFileItem object\n   - No additional inputs are required as the filename is already stored within the object\n   - The filename is a system-stored value that was captured during file upload\n\n2. Data Validation:\n   - Verify that the DiskFileItem object is not null\n     * IF DiskFileItem is null THEN\n       - Return an appropriate error message indicating invalid input\n     * END IF\n   - No additional validation is required as this is a retrieval operation\n\n3. Business Rule Processing:\n   - Check if the file information is available\n     * IF file information was not properly captured during upload THEN\n       - Return an empty or default filename value\n     * END IF\n   - No additional business rules apply to this retrieval operation\n\n4. Core Operation Execution:\n   - Access the stored filename property from the DiskFileItem object\n   - Return the filename value as stored during the upload process\n   - No modifications are made to the filename during retrieval\n   - No database operations are performed during this operation\n\n5. Response Generation:\n   - Return the original filename as a string value\n   - IF retrieval is successful THEN\n     * Return the filename string\n   - ELSE\n     * Return an appropriate error message\n   - END IF",
    "databaseEntities": [
      "jforum_attachments"
    ],
    "validationRules": [
      "DiskFileItem object must not be null",
      "Filename may be null if not specified during upload"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "DiskFileItem": {
        "type": "object",
        "properties": {
          "fieldName": {
            "type": "string",
            "description": "The name of the form field as provided by the browser"
          },
          "contentType": {
            "type": "string",
            "description": "The content type passed by the browser, or null if not defined"
          },
          "isFormField": {
            "type": "boolean",
            "description": "Whether or not this item is a simple form field"
          },
          "fileName": {
            "type": "string",
            "description": "The original filename in the user's filesystem"
          },
          "sizeThreshold": {
            "type": "number",
            "description": "The threshold above which uploads will be stored on disk"
          },
          "repository": {
            "type": "object",
            "description": "The directory in which uploaded files will be stored"
          }
        },
        "required": [
          "fieldName",
          "isFormField"
        ]
      }
    }
  },
  {
    "featureName": "CheckFileInMemory",
    "description": "Determines if file contents are stored in memory or on disk.",
    "inputValues": [
      "fileItem-object-DiskFileItem"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the DiskFileItem object that contains file data\n   - The DiskFileItem must be properly initialized with:\n     * Field name\n     * Content type\n     * Form field flag\n     * File name\n     * Size threshold\n     * Repository location\n\n2. Data Validation:\n   - Validate that the DiskFileItem object is not null\n     * IF DiskFileItem is null THEN return an error indicating invalid input\n   - Validate that the DiskFileItem has been properly initialized\n     * IF the internal deferred file output stream is not initialized THEN return an error indicating the file item is in an invalid state\n\n3. Business Rule Processing:\n   - Check system configuration for memory threshold settings\n     * Verify the configured size threshold value is valid (must be a positive number)\n     * Determine if the current system has sufficient memory resources available\n   - Evaluate file storage policy based on file attributes\n     * Consider file size in relation to the configured threshold\n     * Consider file type and any special handling requirements\n\n4. Core Operation Execution:\n   - Check if the file data is currently stored in memory\n     * Access the deferred file output stream object\n     * Query the stream's internal state to determine storage location\n     * IF the deferred file output stream reports data is in memory THEN\n       > Set result flag to true indicating in-memory storage\n     * ELSE\n       > Set result flag to false indicating on-disk storage\n   - Record the storage state for reference\n     * Update any monitoring or tracking information as needed\n     * Log the storage decision if required by the system\n\n5. Response Generation:\n   - Return the memory storage status\n     * Provide boolean result indicating whether file is in memory (true) or on disk (false)\n     * Include any additional metadata about the file if requested\n     * IF an error occurred during processing THEN provide appropriate error details",
    "databaseEntities": [
      "jforum_attachments"
    ],
    "validationRules": [
      "DiskFileItem object must not be null",
      "DiskFileItem must be properly initialized with a deferred file output stream",
      "Size threshold must be a positive integer value",
      "Repository location must be a valid directory path if file is stored on disk"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "DiskFileItem": {
        "type": "object",
        "properties": {
          "fieldName": {
            "type": "string",
            "description": "The name of the form field as provided by the browser"
          },
          "contentType": {
            "type": "string",
            "description": "The content type passed by the browser"
          },
          "isFormField": {
            "type": "boolean",
            "description": "Whether or not this item is a simple form field"
          },
          "fileName": {
            "type": "string",
            "description": "The original filename in the user's filesystem"
          },
          "sizeThreshold": {
            "type": "integer",
            "description": "The threshold above which uploads will be stored on disk"
          },
          "repository": {
            "type": "object",
            "description": "The directory in which uploaded files will be stored, if stored on disk"
          }
        },
        "required": [
          "fieldName",
          "isFormField",
          "sizeThreshold"
        ]
      }
    }
  },
  {
    "featureName": "GetFileSize",
    "description": "Calculates the size of the uploaded file in bytes.",
    "inputValues": [
      "fileItem-object-FileItem"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the FileItem object\n   - Determine if the file content is already cached in memory\n   - Identify the file storage location (memory or disk)\n\n2. Data Validation:\n   - Verify the FileItem object is not null\n   - Check if the file exists and is accessible\n   - Ensure the file has been properly uploaded and stored\n\n3. Business Rule Processing:\n   - Determine the appropriate method to calculate file size based on storage location:\n     a. IF file content is cached in memory:\n        - Use the cached content length\n     b. ELSE IF file is stored in memory but not cached:\n        - Retrieve the data from memory storage\n        - Calculate the length of the data\n     c. ELSE (file is stored on disk):\n        - Access the file from the disk storage location\n        - Calculate the file length from the disk file\n\n4. Core Operation Execution:\n   - Calculate the file size based on the determined method:\n     a. IF cached content exists:\n        - Return the length of the cached content array\n     b. ELSE IF file is in memory:\n        - Get the data from memory storage\n        - Return the length of the data array\n     c. ELSE:\n        - Access the file from disk\n        - Return the file length in bytes\n   - Convert the size to appropriate numeric format (long integer)\n\n5. Response Generation:\n   - Return the calculated file size in bytes as a long integer value\n   - IF any errors occurred during size calculation:\n     - Return appropriate error information\n     - Include details about the nature of the failure",
    "databaseEntities": [
      "jforum_attachments"
    ],
    "validationRules": [
      "FileItem object must not be null",
      "File must be accessible for size calculation",
      "File size must be returned as a non-negative long integer value"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "FileItem": {
        "type": "object",
        "properties": {
          "fieldName": {
            "type": "string",
            "description": "The name of the form field"
          },
          "contentType": {
            "type": "string",
            "description": "The content type of the file"
          },
          "isFormField": {
            "type": "boolean",
            "description": "Whether this item is a simple form field"
          },
          "fileName": {
            "type": "string",
            "description": "The original filename in the user's filesystem"
          },
          "sizeThreshold": {
            "type": "integer",
            "description": "The threshold above which uploads will be stored on disk"
          },
          "repository": {
            "type": "object",
            "description": "The directory in which uploaded files will be stored"
          },
          "cachedContent": {
            "type": "array",
            "items": {
              "type": "integer"
            },
            "description": "Cached contents of the file"
          }
        }
      }
    }
  },
  {
    "featureName": "GetFileBytes",
    "description": "Retrieves the complete contents of the file as a byte array.",
    "inputValues": [
      "fileItem-object-DiskFileItem"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the DiskFileItem object that contains the file data\n   - No additional inputs required as the file information is encapsulated in the DiskFileItem\n\n2. Data Validation:\n   - Verify the DiskFileItem object is not null\n     * IF DiskFileItem is null THEN\n       - Return error indicating invalid file item\n   - Check if the file content is accessible\n     * IF file cannot be accessed THEN\n       - Return error indicating file access issue\n\n3. Business Rule Processing:\n   - Determine the storage location of the file content\n     * IF file content is stored in memory THEN\n       - Prepare to retrieve from memory cache\n     * ELSE\n       - Prepare to read from disk storage\n   - Verify file size is within acceptable limits\n     * IF file size exceeds system limits THEN\n       - Return error indicating file size constraint violation\n\n4. Core Operation Execution:\n   - Check if file content is already cached in memory\n     * IF content is cached in memory THEN\n       - Return the cached byte array directly\n     * ELSE IF content is in memory but not cached THEN\n       - Retrieve data from memory storage\n       - Cache the retrieved data for future use\n       - Return the byte array\n     * ELSE (content is stored on disk)\n       - Create a byte array sized to the file length\n       - Open a file input stream to the disk file\n       - Read the complete file content into the byte array\n       - Close the file input stream\n       - Return the populated byte array\n   - Handle any exceptions during file reading\n     * IF an error occurs during file reading THEN\n       - Ensure all resources are properly closed\n       - Return null or appropriate error indication\n\n5. Response Generation:\n   - Return the byte array containing the complete file contents\n   - IF operation was successful THEN\n     * Return the byte array with file content\n   - ELSE\n     * Return appropriate error information\n     * Include details about the nature of the failure (access error, file not found, etc.)",
    "databaseEntities": [
      "jforum_attachments"
    ],
    "validationRules": [
      "File item must not be null",
      "File must be accessible for reading",
      "File size must be within system limits"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "DiskFileItem": {
        "type": "object",
        "properties": {
          "fieldName": {
            "type": "string",
            "description": "The name of the form field as provided by the browser"
          },
          "contentType": {
            "type": "string",
            "description": "The content type passed by the browser, or null if not defined"
          },
          "isFormField": {
            "type": "boolean",
            "description": "Whether or not this item is a simple form field"
          },
          "fileName": {
            "type": "string",
            "description": "The original filename in the user's filesystem"
          },
          "sizeThreshold": {
            "type": "integer",
            "description": "The threshold above which uploads will be stored on disk"
          },
          "repository": {
            "type": "object",
            "description": "The directory in which uploaded files will be stored, if stored on disk"
          },
          "cachedContent": {
            "type": "array",
            "items": {
              "type": "integer"
            },
            "description": "Cached contents of the file as byte array"
          },
          "dfos": {
            "type": "object",
            "description": "Output stream for this item"
          }
        }
      }
    }
  },
  {
    "featureName": "GetFileContentAsString",
    "description": "Converts file contents to a string using specified or default character encoding.",
    "inputValues": [
      "file-object-FileItem",
      "charset-string-CharacterEncoding"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect file object (mandatory)\n   - Collect charset encoding (optional)\n   - System will use default charset if none provided\n\n2. Data Validation:\n   - Validate file object:\n     a. Check if file object is not null\n     b. Verify file is accessible and readable\n     c. Return error if file cannot be accessed\n   - Validate charset (if provided):\n     a. Check if the charset name is valid\n     b. Verify system supports the requested encoding\n     c. Return error if charset is invalid or unsupported\n\n3. Business Rule Processing:\n   - Determine appropriate charset:\n     a. IF charset parameter is provided THEN\n        i. Use the provided charset\n     b. ELSE\n        i. Check if file has embedded charset information\n        ii. IF embedded charset exists THEN use embedded charset\n        iii. ELSE use default charset (ISO-8859-1)\n   - Verify file size is within acceptable limits:\n     a. Check if file size exceeds maximum allowed size\n     b. Return error if file is too large\n\n4. Core Operation Execution:\n   - Retrieve file contents:\n     a. IF file is stored in memory THEN\n        i. Access cached content directly\n     b. ELSE\n        i. Read file content from disk storage\n        ii. Cache content in memory if appropriate\n   - Convert binary content to string:\n     a. Apply the determined charset encoding to binary data\n     b. Handle any conversion errors\n     c. IF conversion fails THEN\n        i. Attempt fallback to default encoding\n        ii. Log encoding failure\n\n5. Response Generation:\n   - For successful conversion:\n     a. Return the file content as string\n     b. Include information about the charset used\n   - For failed conversion:\n     a. Return appropriate error message\n     b. Include details about the failure reason\n     c. Provide suggestions for resolution",
    "databaseEntities": [
      "jforum_attachments"
    ],
    "validationRules": [
      "File object must not be null",
      "File must be accessible and readable",
      "Charset must be supported by the system if specified",
      "File size must be within acceptable limits"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "FileItem": {
        "type": "object",
        "properties": {
          "fieldName": {
            "type": "string",
            "description": "The name of the form field"
          },
          "contentType": {
            "type": "string",
            "description": "The content type of the file"
          },
          "isFormField": {
            "type": "boolean",
            "description": "Whether this item is a simple form field"
          },
          "fileName": {
            "type": "string",
            "description": "The original filename in the user's filesystem"
          },
          "size": {
            "type": "number",
            "description": "The size of the file in bytes"
          },
          "content": {
            "type": "binary",
            "description": "The binary content of the file"
          },
          "storeLocation": {
            "type": "string",
            "description": "The location where the file is stored on disk"
          },
          "inMemory": {
            "type": "boolean",
            "description": "Whether the file is stored in memory or on disk"
          }
        }
      },
      "CharacterEncoding": {
        "type": "string",
        "description": "Character encoding name (e.g., 'UTF-8', 'ISO-8859-1')"
      }
    }
  },
  {
    "featureName": "WriteUploadedFileToLocation",
    "description": "Writes an uploaded file item to a specified disk location.",
    "inputValues": [
      "fileItem-object-FileItem",
      "destinationFile-object-File"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the uploaded file item (mandatory)\n   - Collect the destination file location (mandatory)\n   - Determine if the file content is stored in memory or on disk (system-generated)\n\n2. Data Validation:\n   - Validate that the file item is not null\n     * IF file item is null THEN return error \"File item cannot be null\"\n   - Validate that the destination file location is not null\n     * IF destination file is null THEN return error \"Destination file cannot be null\"\n   - Validate that the destination directory exists and is writable\n     * IF destination directory does not exist THEN create directory or return error \"Destination directory does not exist\"\n     * IF destination directory is not writable THEN return error \"Destination directory is not writable\"\n   - Validate that there is sufficient disk space at the destination\n     * IF insufficient disk space THEN return error \"Insufficient disk space at destination\"\n\n3. Business Rule Processing:\n   - Check if the file content is stored in memory\n     * IF file content is in memory THEN prepare for direct write operation\n     * IF file content is on disk THEN prepare for file move or copy operation\n   - Check if the destination file already exists\n     * IF destination file exists THEN determine whether to overwrite based on system settings\n     * IF overwrite not allowed and file exists THEN return error \"Destination file already exists\"\n\n4. Core Operation Execution:\n   - IF file content is in memory:\n     * Create a file output stream to the destination file\n     * Write the file content from memory to the destination file\n     * Close the file output stream\n   - ELSE IF file content is on disk:\n     * Attempt to rename the temporary file to the destination file\n     * IF rename operation fails:\n       * Create input stream from temporary file\n       * Create output stream to destination file\n       * Copy data in chunks from input to output stream\n       * Close both streams\n   - Handle any exceptions during file operations\n     * IF exception occurs THEN clean up resources and return appropriate error\n\n5. Response Generation:\n   - IF operation successful:\n     * Return success status\n     * Include information about the written file (name, size, location)\n   - IF operation failed:\n     * Return failure status\n     * Include specific error message and reason for failure\n     * Provide guidance on how to resolve the issue",
    "databaseEntities": [
      "jforum_attachments"
    ],
    "validationRules": [
      "File item must not be null",
      "Destination file location must not be null",
      "Destination directory must exist or be creatable",
      "Destination directory must be writable",
      "Sufficient disk space must be available at destination",
      "If destination file exists, system must determine whether to overwrite"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "FileItem": {
        "type": "object",
        "properties": {
          "fieldName": {
            "type": "string",
            "description": "Name of the form field"
          },
          "formField": {
            "type": "boolean",
            "description": "Whether this item represents a simple form field"
          },
          "content": {
            "type": "binary",
            "description": "The content of the file"
          },
          "name": {
            "type": "string",
            "description": "Original name of the file"
          },
          "size": {
            "type": "number",
            "description": "Size of the file in bytes"
          },
          "storeLocation": {
            "type": "string",
            "description": "Temporary location where file is stored"
          },
          "inMemory": {
            "type": "boolean",
            "description": "Whether the file is stored in memory"
          }
        }
      },
      "File": {
        "type": "object",
        "properties": {
          "path": {
            "type": "string",
            "description": "Path to the file"
          },
          "name": {
            "type": "string",
            "description": "Name of the file"
          },
          "exists": {
            "type": "boolean",
            "description": "Whether the file exists"
          }
        }
      }
    }
  },
  {
    "featureName": "DeleteTemporaryStorage",
    "description": "Deletes the underlying storage for a file item including temporary disk files.",
    "inputValues": [
      "fileItem-object-FileItem"
    ],
    "businessLogic": "1. Input Collection\n   - Collect the FileItem object that needs its temporary storage deleted\n   - Determine if the FileItem has associated temporary storage\n   - Check if the FileItem is stored in memory or on disk\n\n2. Data Validation\n   - Verify the FileItem object is not null\n     * IF FileItem is null THEN\n       - Generate an error indicating invalid input\n       - Terminate the operation\n     * END IF\n   - Check if the FileItem has a valid store location\n     * IF store location cannot be determined THEN\n       - Log a warning about inability to locate temporary storage\n       - Skip to Response Generation\n     * END IF\n\n3. Business Rule Processing\n   - Determine if the file is currently in use\n     * IF file is locked or in use by another process THEN\n       - Generate appropriate warning\n       - Consider retry logic or delayed deletion\n     * END IF\n   - Check system permissions for file deletion\n     * IF current user lacks permission to delete the file THEN\n       - Generate appropriate error message\n       - Terminate the operation\n     * END IF\n\n4. Core Operation Execution\n   - Clear any cached content in memory\n     * Set any in-memory cached content references to null\n     * Release memory resources associated with the file content\n   - Retrieve the physical file location\n     * Get the reference to the temporary file on disk\n     * IF no file exists on disk THEN\n       - Skip to next step\n     * END IF\n   - Delete the physical file\n     * Check if the file exists\n     * IF file exists THEN\n       - Execute file deletion operation\n       - IF deletion fails THEN\n         - Log error details\n         - Generate appropriate error message\n       * END IF\n     * END IF\n   - Clean up any tracking resources\n     * Remove file from any cleanup tracking mechanisms\n     * Release any locks or handles on the file\n\n5. Response Generation\n   - Generate success response\n     * Indicate successful deletion of temporary storage\n     * Include details about freed resources if applicable\n   - Generate error response if needed\n     * Include specific error details if deletion failed\n     * Provide guidance on manual cleanup if automatic deletion failed",
    "databaseEntities": [],
    "validationRules": [
      "FileItem object must not be null",
      "System must have appropriate permissions to delete the file",
      "File must not be locked by another process during deletion attempt"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "FileItem": {
        "type": "object",
        "properties": {
          "fieldName": {
            "type": "string",
            "description": "Name of the form field"
          },
          "storeLocation": {
            "type": "object",
            "description": "File object representing the temporary storage location"
          },
          "isFormField": {
            "type": "boolean",
            "description": "Indicates if the item is a form field or file upload"
          },
          "cachedContent": {
            "type": "object",
            "description": "In-memory cached content of the file"
          },
          "size": {
            "type": "number",
            "description": "Size of the file in bytes"
          },
          "name": {
            "type": "string",
            "description": "Original name of the file"
          }
        }
      }
    }
  },
  {
    "featureName": "ManageFormFieldProperties",
    "description": "Gets and sets form field properties for file items.",
    "inputValues": [
      "fieldName-string-FileItem",
      "formFieldState-boolean-FileItem",
      "fileContent-object-FileContent"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the following inputs:\n     a. fieldName (string, mandatory): The name of the form field\n     b. formFieldState (boolean, mandatory): Whether the item is a simple form field\n     c. fileContent (object, optional): The content of the file if applicable\n   - System will determine if the file is stored in memory or on disk\n\n2. Data Validation:\n   - Validate fieldName:\n     a. Check if fieldName is not null or empty\n     b. IF fieldName is null or empty THEN\n        i. Return error message indicating field name is required\n     c. ENDIF\n   - Validate formFieldState:\n     a. Ensure formFieldState is a valid boolean value\n     b. IF formFieldState is invalid THEN\n        i. Return error message indicating invalid form field state\n     c. ENDIF\n   - Validate fileContent (when applicable):\n     a. IF fileContent is provided THEN\n        i. Verify content format is valid\n        ii. Check if content size is within acceptable limits\n        iii. IF validation fails THEN\n            1. Return appropriate error message\n        iv. ENDIF\n     b. ENDIF\n\n3. Business Rule Processing:\n   - Determine file storage location:\n     a. Check if file content is stored in memory or on disk\n     b. IF stored on disk THEN\n        i. Verify temporary file exists and is accessible\n        ii. IF file is not accessible THEN\n            1. Return error indicating file storage issue\n        iii. ENDIF\n     c. ENDIF\n   - Verify system permissions:\n     a. Check if current user has permission to manage this file item\n     b. IF permission check fails THEN\n        i. Return error message indicating insufficient permissions\n     c. ENDIF\n\n4. Core Operation Execution:\n   - Set field properties:\n     a. Set the field name property to the provided fieldName\n     b. Set the form field state property to the provided formFieldState\n     c. IF fileContent is provided THEN\n        i. Update the file content based on storage type\n        ii. IF in-memory storage THEN\n            1. Update cached content\n        iii. ELSE\n            1. Write to temporary file location\n        iv. ENDIF\n     d. ENDIF\n   - Update related properties:\n     a. Update any dependent properties based on changes\n     b. Ensure consistency across all related properties\n     c. IF any update fails THEN\n        i. Revert changes to maintain consistency\n        ii. Return error message indicating update failure\n     d. ENDIF\n\n5. Response Generation:\n   - Prepare success response:\n     a. Include updated field properties in response\n     b. Include file metadata (name, size, storage location)\n     c. Include form field status\n   - IF any errors occurred THEN\n     a. Generate error response with specific error details\n     b. Include guidance on how to resolve the issue\n   - ENDIF\n   - Return final response to caller",
    "databaseEntities": [
      "jforum_attachments"
    ],
    "validationRules": [
      "Field name must not be empty",
      "Form field state must be a valid boolean value",
      "File content must be in a valid format when provided",
      "File size must be within system limits",
      "User must have permission to manage file properties"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "FileContent": {
        "type": "object",
        "properties": {
          "content": {
            "type": "string",
            "description": "The content of the file as a string"
          },
          "encoding": {
            "type": "string",
            "description": "Character encoding of the file content"
          },
          "size": {
            "type": "number",
            "description": "Size of the file content in bytes"
          },
          "inMemory": {
            "type": "boolean",
            "description": "Whether the file is stored in memory or on disk"
          }
        }
      }
    }
  },
  {
    "featureName": "GetFileOutputStream",
    "description": "Provides output stream for storing file contents.",
    "inputValues": [
      "sizeThreshold-number-FileItem",
      "repository-object-File",
      "tempFile-object-File"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the following inputs:\n     * sizeThreshold (number): Maximum size in bytes before content is stored on disk\n     * repository (object): Directory where temporary files will be stored\n     * tempFile (object): Optional pre-defined temporary file location\n   - System will generate:\n     * Unique file identifier for temporary file naming\n\n2. Data Validation:\n   - Validate sizeThreshold:\n     * IF sizeThreshold is negative or zero THEN\n       - Set to default threshold value\n     * END IF\n   - Validate repository location:\n     * IF repository is null THEN\n       - Use system temporary directory as default repository\n     * ELSE\n       - Verify repository directory exists\n       - Verify repository directory is writable\n       - IF repository is not valid THEN\n         - Use system temporary directory as fallback\n       - END IF\n     * END IF\n\n3. Business Rule Processing:\n   - Check if output stream already exists:\n     * IF output stream has been previously created THEN\n       - Return existing output stream without creating a new one\n     * END IF\n   - Determine temporary file location:\n     * IF tempFile is provided THEN\n       - Use provided tempFile\n     * ELSE\n       - Generate unique temporary file name\n       - Create file reference in repository directory\n     * END IF\n   - Verify system resources:\n     * Check available disk space in repository location\n     * IF insufficient disk space THEN\n       - Prepare error response\n     * END IF\n\n4. Core Operation Execution:\n   - Create deferred file output stream:\n     * Initialize stream with provided size threshold\n     * Associate stream with temporary file location\n     * Configure stream to store content in memory until threshold is exceeded\n     * Register temporary file for automatic cleanup when no longer needed\n   - Set up stream monitoring:\n     * Track whether content is stored in memory or on disk\n     * Prepare for potential stream closure operations\n   - Initialize stream for writing:\n     * Open file handles if needed\n     * Prepare buffer management\n\n5. Response Generation:\n   - Return output stream object:\n     * Provide stream interface for writing file contents\n     * Include reference to underlying storage mechanism\n   - In case of errors:\n     * Generate appropriate error information\n     * Include details about the failure reason\n     * Provide guidance on possible resolution steps",
    "databaseEntities": [],
    "validationRules": [
      "Repository directory must exist and be writable",
      "Size threshold must be a positive number",
      "Temporary file name must be unique",
      "Sufficient disk space must be available in repository location"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "File": {
        "type": "object",
        "properties": {
          "path": {
            "type": "string",
            "description": "File system path"
          },
          "name": {
            "type": "string",
            "description": "File name"
          },
          "exists": {
            "type": "boolean",
            "description": "Whether file exists on disk"
          },
          "canWrite": {
            "type": "boolean",
            "description": "Whether file is writable"
          }
        }
      }
    }
  },
  {
    "featureName": "GetFileStoreLocation",
    "description": "Retrieves the File object for the temporary storage location.",
    "inputValues": [
      "fileItem-object-DiskFileItem"
    ],
    "businessLogic": "1. Input Collection\n   - Collect the DiskFileItem object instance\n     - This is the file item for which the storage location is needed\n     - No additional inputs are required as the method operates on the instance state\n\n2. Data Validation\n   - Validate the DiskFileItem instance\n     - Check if the DiskFileItem object is not null\n     - IF DiskFileItem is null THEN\n       - Return appropriate error indicating invalid input\n     - END IF\n   - Validate the internal state of the DiskFileItem\n     - Check if the DeferredFileOutputStream (dfos) has been initialized\n     - IF dfos is null THEN\n       - The file data may be in memory only with no disk representation\n       - Return null to indicate no disk storage location exists\n     - END IF\n\n3. Business Rule Processing\n   - Determine the storage state of the file\n     - Check if the file is stored in memory or on disk\n     - IF file is stored entirely in memory THEN\n       - No physical file location exists\n       - Return null to indicate no disk storage location\n     - END IF\n   - Verify file accessibility\n     - Check if the temporary file exists and is accessible\n     - IF temporary file cannot be accessed THEN\n       - Return null or appropriate error\n     - END IF\n\n4. Core Operation Execution\n   - Retrieve the file storage location\n     - Access the internal DeferredFileOutputStream object\n     - Request the File object from the DeferredFileOutputStream\n     - Capture the returned File object representing the temporary storage location\n   - Prepare the response\n     - Package the File object for return to the caller\n     - Ensure no file operations are performed that would alter the file state\n\n5. Response Generation\n   - Return the File object\n     - IF successful retrieval THEN\n       - Return the File object representing the temporary storage location\n     - ELSE\n       - Return null to indicate no file storage location exists\n     - END IF\n   - No additional metadata is returned with the File object",
    "databaseEntities": [],
    "validationRules": [
      "DiskFileItem object must not be null",
      "Internal DeferredFileOutputStream must be initialized to return a valid file location",
      "The temporary file must exist and be accessible"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "DiskFileItem": {
        "type": "object",
        "properties": {
          "dfos": {
            "type": "object",
            "description": "DeferredFileOutputStream that manages the file data"
          },
          "repository": {
            "type": "object",
            "description": "Directory where temporary files are stored"
          },
          "sizeThreshold": {
            "type": "number",
            "description": "Size threshold determining when data should be stored on disk"
          },
          "cachedContent": {
            "type": "array",
            "description": "Cached content when file is stored in memory"
          },
          "isFormField": {
            "type": "boolean",
            "description": "Flag indicating if this item is a form field rather than a file"
          },
          "fieldName": {
            "type": "string",
            "description": "Name of the form field"
          }
        }
      }
    }
  },
  {
    "featureName": "CreateTemporaryFile",
    "description": "Creates a uniquely named temporary file in the configured repository path.",
    "inputValues": [
      "repository-object-FileRepository",
      "filePrefix-string-FilePrefix",
      "fileSuffix-string-FileSuffix"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect repository path (mandatory) - the directory where temporary files will be stored\n   - Collect file prefix (optional) - prefix to be added to the filename, defaults to 'upload_'\n   - Collect file suffix (optional) - suffix/extension to be added to the filename, defaults to '.tmp'\n\n2. Data Validation:\n   - Validate repository path:\n     a. Check if repository path is provided\n     b. Verify the repository path exists\n     c. Verify the repository path is a directory\n     d. Verify the repository has write permissions\n     e. If repository path is not provided, use system's default temporary directory\n   - Validate file prefix:\n     a. Ensure prefix contains only valid filename characters\n     b. If prefix is not provided, use default prefix\n   - Validate file suffix:\n     a. Ensure suffix contains only valid filename characters\n     b. If suffix is not provided, use default suffix\n\n3. Business Rule Processing:\n   - Check if the system has enough disk space in the repository location\n   - Verify maximum allowed temporary files limit is not exceeded\n   - Check if file creation is allowed based on system configuration\n\n4. Core Operation Execution:\n   - Generate a unique identifier for the file:\n     a. Create a counter-based unique ID\n     b. Format the ID to ensure consistent length\n   - Construct the complete filename using prefix, unique ID, and suffix\n   - Create the temporary file in the repository location:\n     a. Attempt to create a new file with the generated name\n     b. IF file already exists, regenerate unique ID and try again\n     c. Set appropriate file permissions\n   - Register the file for automatic cleanup:\n     a. Track the file for deletion when no longer needed\n     b. Associate file with the creating process/session\n\n5. Response Generation:\n   - Return success response with:\n     a. Full path to the created temporary file\n     b. File name\n     c. Creation timestamp\n     d. Expected cleanup time (if applicable)\n   - In case of failure, return error response with:\n     a. Error code\n     b. Error description\n     c. Suggested resolution steps",
    "databaseEntities": [],
    "validationRules": [
      "Repository path must exist and be writable",
      "File prefix must contain only valid filename characters",
      "File suffix must contain only valid filename characters",
      "System must have sufficient disk space available",
      "Generated filename must be unique within the repository",
      "Maximum number of temporary files per session must not be exceeded"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "FileRepository": {
        "type": "object",
        "properties": {
          "path": {
            "type": "string",
            "description": "Directory path where temporary files will be stored"
          },
          "maxSize": {
            "type": "number",
            "description": "Maximum allowed size for the repository in bytes"
          },
          "cleanupInterval": {
            "type": "number",
            "description": "Interval in milliseconds for automatic cleanup of temporary files"
          }
        },
        "required": [
          "path"
        ]
      },
      "FilePrefix": {
        "type": "string",
        "description": "Prefix to be added to the temporary filename"
      },
      "FileSuffix": {
        "type": "string",
        "description": "Suffix/extension to be added to the temporary filename"
      }
    }
  },
  {
    "featureName": "CreateFileItem",
    "description": "Creates disk or memory-based file items for handling uploaded files based on configurable size threshold.",
    "inputValues": [
      "fieldName-string-FileItem",
      "contentType-string-FileItem",
      "isFormField-boolean-FileItem",
      "fileName-string-FileItem",
      "sizeThreshold-number-FileItemFactory",
      "repository-object-Repository"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the following inputs:\n     a. fieldName (string, mandatory): The name of the form field\n     b. contentType (string, mandatory): The content type of the form field\n     c. isFormField (boolean, mandatory): Indicates if this is a plain form field\n     d. fileName (string, mandatory): The name of the uploaded file as supplied by the client\n     e. sizeThreshold (number, optional): The threshold in bytes above which files are stored on disk\n     f. repository (object, optional): The directory where temporary files will be stored\n\n2. Data Validation:\n   - Validate fieldName:\n     a. IF fieldName is null or empty THEN\n        i. Generate error message: \"Field name cannot be empty\"\n     b. ENDIF\n   - Validate contentType:\n     a. IF contentType is null THEN\n        i. Set contentType to default value \"application/octet-stream\"\n     b. ENDIF\n   - Validate sizeThreshold:\n     a. IF sizeThreshold is not provided THEN\n        i. Use default size threshold (10240 bytes)\n     b. ELSE IF sizeThreshold is less than 0 THEN\n        i. Generate error message: \"Size threshold cannot be negative\"\n     c. ENDIF\n   - Validate repository:\n     a. IF repository is not provided THEN\n        i. Use system default temporary directory\n     b. ELSE\n        i. Verify repository directory exists\n        ii. IF repository does not exist THEN\n            1. Attempt to create the directory\n            2. IF directory creation fails THEN\n               a. Generate error message: \"Unable to create repository directory\"\n            3. ENDIF\n        iii. ENDIF\n        iv. Verify repository is writable\n        v. IF repository is not writable THEN\n           1. Generate error message: \"Repository directory is not writable\"\n        vi. ENDIF\n     c. ENDIF\n\n3. Business Rule Processing:\n   - Check system resources:\n     a. Verify sufficient disk space is available in repository location\n     b. IF disk space is insufficient THEN\n        i. Generate error message: \"Insufficient disk space in repository location\"\n     c. ENDIF\n   - Check file handling permissions:\n     a. Verify system has permission to create temporary files\n     b. IF permission is denied THEN\n        i. Generate error message: \"System lacks permission to create temporary files\"\n     c. ENDIF\n\n4. Core Operation Execution:\n   - Create file item based on parameters and configuration:\n     a. Initialize a new file item with the provided parameters\n     b. Configure the file item with the size threshold\n     c. Associate the file item with the repository location\n     d. Set up the file item's behavior based on isFormField flag:\n        i. IF isFormField is true THEN\n           1. Configure item to store form field data\n        ii. ELSE\n           1. Configure item to handle file upload data\n        iii. ENDIF\n     e. Prepare the file item for content storage:\n        i. Set up initial memory buffer for content\n        ii. Configure disk storage mechanism for overflow\n        iii. Initialize tracking for content size\n     f. IF any operation fails during creation THEN\n        i. Clean up any partially created resources\n        ii. Generate error message: \"Failed to create file item\"\n     g. ENDIF\n\n5. Response Generation:\n   - On successful creation:\n     a. Return the created file item object with:\n        i. All configured properties (fieldName, contentType, isFormField, fileName)\n        ii. Storage mechanism ready (memory or disk based on threshold)\n        iii. Repository location set (if disk-based storage will be used)\n   - On failure:\n     a. Return error details including:\n        i. Error code\n        ii. Error message describing the failure\n        iii. Suggested resolution steps if applicable",
    "databaseEntities": [
      "jforum_attachments"
    ],
    "validationRules": [
      "Field name must not be empty",
      "Size threshold must be a non-negative number",
      "Repository directory must exist and be writable if specified",
      "System must have sufficient disk space in repository location",
      "System must have permission to create temporary files"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Repository": {
        "type": "object",
        "properties": {
          "path": {
            "type": "string",
            "description": "Path to the directory where files will be stored"
          },
          "exists": {
            "type": "boolean",
            "description": "Indicates if the directory exists"
          },
          "writable": {
            "type": "boolean",
            "description": "Indicates if the directory is writable"
          }
        },
        "required": [
          "path"
        ]
      }
    }
  },
  {
    "featureName": "ConfigureFileStorage",
    "description": "Manages configuration for temporary file storage location and size thresholds for uploaded content.",
    "inputValues": [
      "repository-object-FileRepository",
      "sizeThreshold-number-SizeThreshold"
    ],
    "businessLogic": "1. Input Collection\n   - Collect the following inputs:\n     a. repository (optional): The directory where files will be stored\n     b. sizeThreshold (optional): The size threshold in bytes\n   - System will use default values if inputs are not provided:\n     a. Default repository: System temporary directory\n     b. Default size threshold: 10240 bytes (10KB)\n\n2. Data Validation\n   - Validate repository input:\n     a. IF repository is provided THEN\n        i. Check if repository path is valid\n        ii. Verify if repository directory exists\n        iii. Verify if repository directory is writable\n        iv. IF any validation fails THEN\n            - Generate appropriate error message\n            - Request valid repository path\n     b. IF repository is not provided THEN\n        i. Use system default temporary directory\n\n   - Validate size threshold input:\n     a. IF size threshold is provided THEN\n        i. Verify size threshold is a positive number\n        ii. Verify size threshold is within acceptable range\n        iii. IF validation fails THEN\n             - Generate appropriate error message\n             - Request valid size threshold\n     b. IF size threshold is not provided THEN\n        i. Use default size threshold (10240 bytes)\n\n3. Business Rule Processing\n   - Check system constraints:\n     a. Verify system has sufficient disk space in repository location\n     b. Verify system has appropriate permissions to create files in repository\n     c. IF repository is system default AND not accessible THEN\n        i. Notify user of permission issues\n        ii. Suggest alternative repository location\n   - Validate configuration compatibility:\n     a. Check if size threshold is appropriate for expected file uploads\n     b. Warn if size threshold is set too low for typical usage\n     c. Check if repository has sufficient space for expected usage\n\n4. Core Operation Execution\n   - Apply configuration settings:\n     a. Set the repository location for file storage\n        i. IF custom repository provided THEN use provided location\n        ii. ELSE use system default temporary directory\n     b. Set the size threshold for memory vs. disk storage\n        i. IF custom threshold provided THEN use provided value\n        ii. ELSE use default threshold (10240 bytes)\n     c. Update the file storage configuration with new settings\n     d. Initialize the storage system with updated configuration\n     e. Verify configuration was applied successfully\n\n5. Response Generation\n   - Generate success response:\n     a. Confirmation message that configuration was updated\n     b. Summary of applied configuration settings:\n        i. Repository location (path)\n        ii. Size threshold (in bytes)\n     c. Provide recommendations if configuration may cause issues:\n        i. Warning if threshold is unusually high or low\n        ii. Warning if repository space is limited\n   - IF configuration failed THEN:\n     a. Generate detailed error message\n     b. Provide troubleshooting steps\n     c. Suggest alternative configuration options",
    "databaseEntities": [
      "jforum_attachments"
    ],
    "validationRules": [
      "Repository path must be a valid directory path",
      "Repository directory must exist and be accessible",
      "Repository directory must have write permissions",
      "Size threshold must be a positive integer",
      "Size threshold must be appropriate for expected file sizes"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "FileRepository": {
        "type": "object",
        "properties": {
          "path": {
            "type": "string",
            "description": "Directory path where files will be stored"
          },
          "isWritable": {
            "type": "boolean",
            "description": "Indicates if the directory has write permissions"
          }
        }
      },
      "SizeThreshold": {
        "type": "object",
        "properties": {
          "value": {
            "type": "number",
            "description": "Size threshold in bytes"
          },
          "unit": {
            "type": "string",
            "description": "Unit of measurement (bytes, KB, MB)",
            "enum": [
              "bytes",
              "KB",
              "MB"
            ]
          }
        }
      }
    }
  },
  {
    "featureName": "CreateFileUpload",
    "description": "Creates a file upload processor with optional FileItemFactory configuration.",
    "inputValues": [
      "fileItemFactory-object-FileItemFactory",
      "request-object-HttpServletRequest"
    ],
    "businessLogic": "1. Input Collection:\n   1.1. Collect the following inputs:\n       - request (mandatory): The HTTP request containing multipart form data\n       - fileItemFactory (optional): Factory for creating file items\n   1.2. If fileItemFactory is not provided, system will use default implementation\n\n2. Data Validation:\n   2.1. Validate request object:\n       - IF request is null THEN\n           - Generate error: \"Request cannot be null\"\n       - END IF\n   2.2. Validate request content type:\n       - IF request method is not \"POST\" THEN\n           - Return false for multipart content check\n       - END IF\n       - IF content type does not contain \"multipart/form-data\" THEN\n           - Return false for multipart content check\n       - END IF\n   2.3. Validate fileItemFactory if provided:\n       - IF fileItemFactory is provided and not properly initialized THEN\n           - Generate error: \"Invalid FileItemFactory configuration\"\n       - END IF\n\n3. Business Rule Processing:\n   3.1. Check system resources:\n       - Verify system has sufficient disk space for temporary file storage\n       - Verify memory allocation is sufficient for processing\n   3.2. Check upload constraints:\n       - Determine maximum allowed file size\n       - Determine allowed file types if restrictions apply\n       - IF any constraints cannot be satisfied THEN\n           - Generate appropriate error message\n       - END IF\n\n4. Core Operation Execution:\n   4.1. Initialize file upload processor:\n       - IF fileItemFactory was provided THEN\n           - Create file upload processor with provided factory\n       - ELSE\n           - Create file upload processor with default factory\n       - END IF\n   4.2. Configure upload parameters:\n       - Set maximum file size if applicable\n       - Set maximum request size if applicable\n       - Set memory threshold if applicable\n   4.3. Process the multipart request:\n       - Parse the request content\n       - Extract all file items from the request\n       - FOR each file item in the request:\n           - Process the item according to its type (form field or uploaded file)\n           - Store file data using the configured FileItemFactory\n       - END FOR\n   4.4. Handle processing errors:\n       - IF any errors occur during processing THEN\n           - Clean up any temporary resources\n           - Generate appropriate error message\n       - END IF\n\n5. Response Generation:\n   5.1. Prepare response data:\n       - Create list of processed file items\n       - Include metadata for each file item (name, size, content type)\n   5.2. Generate success response:\n       - Return the list of file items in the order they were transmitted\n   5.3. In case of errors:\n       - Return appropriate error information\n       - Include guidance on resolving the issue",
    "databaseEntities": [
      "jforum_attachments"
    ],
    "validationRules": [
      "Request must not be null",
      "Request method must be POST for multipart content",
      "Content type must contain multipart/form-data",
      "FileItemFactory must be properly initialized if provided"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "FileItemFactory": {
        "type": "object",
        "properties": {
          "sizeThreshold": {
            "type": "number",
            "description": "The threshold above which files will be stored on disk"
          },
          "repository": {
            "type": "object",
            "description": "The location where files will be stored"
          }
        }
      },
      "HttpServletRequest": {
        "type": "object",
        "properties": {
          "method": {
            "type": "string",
            "description": "HTTP method of the request"
          },
          "contentType": {
            "type": "string",
            "description": "Content type of the request"
          },
          "content": {
            "type": "object",
            "description": "The multipart form data content"
          }
        }
      }
    }
  },
  {
    "featureName": "GetRequestContentType",
    "description": "Retrieves the content type of an HTTP servlet request.",
    "inputValues": [
      "request-object-HttpServletRequest"
    ],
    "businessLogic": "1. Input Collection:\n   1.1. Receive the HTTP servlet request object.\n      1.1.1. The request object must be a valid HttpServletRequest instance.\n      1.1.2. The request object is mandatory and cannot be null.\n\n2. Data Validation:\n   2.1. Validate the request object.\n      2.1.1. IF request is null THEN\n         2.1.1.1. Generate an error indicating invalid request object.\n         2.1.1.2. Terminate the operation.\n      2.1.2. ELSE continue to the next step.\n\n3. Business Rule Processing:\n   3.1. Check if the request context is accessible.\n      3.1.1. IF the request context cannot be accessed THEN\n         3.1.1.1. Generate an error indicating inaccessible request context.\n         3.1.1.2. Terminate the operation.\n      3.1.2. ELSE continue to the next step.\n\n4. Core Operation Execution:\n   4.1. Extract the content type from the request.\n      4.1.1. Access the content type information from the request object.\n      4.1.2. IF content type information is available THEN\n         4.1.2.1. Retrieve the content type string.\n      4.1.3. ELSE\n         4.1.3.1. Set content type as null or an appropriate default value.\n\n5. Response Generation:\n   5.1. Return the content type information.\n      5.1.1. Format the content type as a string.\n      5.1.2. Return the content type string to the caller.\n      5.1.3. IF an error occurred during the process THEN\n         5.1.3.1. Return an appropriate error message.\n         5.1.3.2. Provide information about the nature of the error.",
    "databaseEntities": [],
    "validationRules": [
      "The HTTP servlet request object must not be null",
      "The request context must be accessible"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "HttpServletRequest": {
        "type": "object",
        "properties": {
          "contentType": {
            "type": "string",
            "description": "The MIME type of the request content"
          }
        }
      }
    }
  },
  {
    "featureName": "GetRequestContentLength",
    "description": "Retrieves the content length of an HTTP servlet request.",
    "inputValues": [
      "request-object-HttpServletRequest"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the HttpServletRequest object\n     - This is a mandatory input\n     - No default values are applicable\n\n2. Data Validation:\n   - Validate the HttpServletRequest object\n     - Check if the request object is not null\n     - IF request is null THEN\n       - Generate an error indicating invalid request\n       - Terminate the operation\n     - END IF\n\n3. Business Rule Processing:\n   - Verify the request can be processed\n     - Check if the request contains content length information\n     - No specific business constraints apply to this operation\n\n4. Core Operation Execution:\n   - Access the content length information\n     - Extract the content length value from the request\n     - The content length represents the size of the request body in bytes\n     - IF content length information is not available THEN\n       - Return a default value (typically -1) indicating unknown length\n     - END IF\n\n5. Response Generation:\n   - Return the content length value\n     - The value is returned as an integer\n     - A positive number indicates the actual content length in bytes\n     - Zero indicates empty content\n     - A negative value may indicate that the content length is unknown",
    "databaseEntities": [],
    "validationRules": [
      "The request object must not be null",
      "The request must be a valid HTTP servlet request"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "HttpServletRequest": {
        "type": "object",
        "description": "Represents an HTTP request received by a servlet",
        "properties": {
          "contentLength": {
            "type": "integer",
            "description": "The length, in bytes, of the request body"
          },
          "contentType": {
            "type": "string",
            "description": "The MIME type of the body of the request"
          }
        }
      }
    }
  },
  {
    "featureName": "GetRequestInputStream",
    "description": "Provides access to the input stream of an HTTP servlet request.",
    "inputValues": [
      "request-object-HttpServletRequest"
    ],
    "businessLogic": "1. Input Collection:\n   1.1. Receive the HttpServletRequest object\n      1.1.1. Verify the request object is not null\n      1.1.2. Store the request object for further processing\n\n2. Data Validation:\n   2.1. Validate the request object\n      2.1.1. IF request is null THEN\n         2.1.1.1. Generate an error indicating invalid request\n         2.1.1.2. Terminate the process\n      2.1.2. ELSE continue with processing\n\n3. Business Rule Processing:\n   3.1. Check request state\n      3.1.1. Verify the request has not been processed before\n      3.1.2. Ensure the request is in a readable state\n      3.1.3. IF request state is invalid THEN\n         3.1.3.1. Generate appropriate error message\n         3.1.3.2. Terminate the process\n\n4. Core Operation Execution:\n   4.1. Access request properties\n      4.1.1. Retrieve the content type from the request\n      4.1.2. Retrieve the content length from the request\n   4.2. Access request input stream\n      4.2.1. Request the input stream from the request object\n      4.2.2. IF input stream cannot be accessed THEN\n         4.2.2.1. Handle the exception appropriately\n         4.2.2.2. Generate error message about stream access failure\n         4.2.2.3. Terminate the process\n      4.2.3. ELSE continue with the input stream\n\n5. Response Generation:\n   5.1. Prepare response with request information\n      5.1.1. Include the input stream in the response\n      5.1.2. Include content type information if needed\n      5.1.3. Include content length information if needed\n   5.2. Return the response\n      5.2.1. Ensure all resources are properly managed\n      5.2.2. Return the input stream and/or related information to the caller",
    "databaseEntities": [],
    "validationRules": [
      "Request object must not be null",
      "Request must be in a readable state",
      "Input stream must be accessible"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "HttpServletRequest": {
        "type": "object",
        "properties": {
          "contentType": {
            "type": "string",
            "description": "The content type of the request"
          },
          "contentLength": {
            "type": "integer",
            "description": "The content length of the request in bytes"
          },
          "inputStream": {
            "type": "object",
            "description": "The input stream containing the request data"
          }
        }
      }
    }
  },
  {
    "featureName": "FormatRequestContext",
    "description": "Formats request context information showing content length and type.",
    "inputValues": [
      "request-object-HttpServletRequest"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect HttpServletRequest object\n     1.1. Verify the request object is not null\n     1.2. Ensure the request contains necessary headers\n\n2. Data Validation:\n   - Validate request object integrity\n     2.1. Check if the request object is properly initialized\n     2.2. Verify the request contains content type information\n     2.3. Verify the request contains content length information\n     2.4. IF any validation fails, THEN prepare appropriate error message\n\n3. Business Rule Processing:\n   - Process request context information\n     3.1. Extract content type from the request\n     3.2. Extract content length from the request\n     3.3. Verify extracted information is valid\n        3.3.1. IF content type is null, THEN use default type or empty string\n        3.3.2. IF content length is negative, THEN set to 0 or default value\n\n4. Core Operation Execution:\n   - Format the request context information\n     4.1. Create a formatted string representation\n        4.1.1. Add \"ContentLength=\" prefix followed by the content length value\n        4.1.2. Add \", ContentType=\" separator\n        4.1.3. Append the content type value\n     4.2. Ensure proper string encoding for special characters if needed\n\n5. Response Generation:\n   - Return the formatted context information\n     5.1. Return the formatted string containing content length and type\n     5.2. IF any errors occurred during processing, THEN include error information\n     5.3. Ensure the response is properly formatted for display or logging purposes",
    "databaseEntities": [],
    "validationRules": [
      "HttpServletRequest object must not be null",
      "Content type information must be accessible from the request",
      "Content length information must be accessible from the request"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "HttpServletRequest": {
        "type": "object",
        "properties": {
          "contentType": {
            "type": "string",
            "description": "The content type of the request"
          },
          "contentLength": {
            "type": "integer",
            "description": "The content length of the request in bytes"
          },
          "inputStream": {
            "type": "object",
            "description": "The input stream for the request data"
          }
        }
      }
    }
  },
  {
    "featureName": "SendActivationEmail",
    "description": "Sends account activation emails to users with activation key links and manual activation options.",
    "inputValues": [
      "user-object-User"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect user object (mandatory) containing:\n     * User ID\n     * Email address\n     * Username\n     * Activation key\n\n2. Data Validation:\n   - Validate user object:\n     * Check if user object is not null\n     * Verify user ID is valid\n     * Ensure email address is properly formatted\n     * Confirm activation key exists\n   - IF any validation fails THEN:\n     * Generate appropriate error message\n     * Terminate the process\n\n3. Business Rule Processing:\n   - Check system configuration:\n     * Verify email functionality is enabled\n     * Confirm email templates exist\n     * Ensure forum URL configuration is available\n   - Generate activation URLs:\n     * Create direct activation URL using user's activation key and ID\n     * Create manual activation URL as fallback option\n   - Prepare email parameters:\n     * Add activation URL to email parameters\n     * Add manual activation URL to email parameters\n     * Add user details to email parameters\n\n4. Core Operation Execution:\n   - Retrieve email templates:\n     * Get activation email subject template\n     * Get activation email body template\n   - Process email templates:\n     * Replace placeholders with actual values\n     * Format email content appropriately\n   - Send activation email:\n     * Set recipient as user's email address\n     * Set email subject\n     * Set email body with activation instructions\n     * Send the email\n   - Handle sending failures:\n     * Log any errors encountered\n     * Store failed email attempts for retry if applicable\n\n5. Response Generation:\n   - On successful email sending:\n     * Generate success confirmation\n     * Include timestamp of email dispatch\n   - On failure:\n     * Generate detailed error information\n     * Provide troubleshooting suggestions\n     * Suggest alternative activation methods",
    "databaseEntities": [
      "jforum_users"
    ],
    "validationRules": [
      "User object must not be null",
      "User must have a valid ID",
      "User must have a valid email address",
      "User must have an activation key",
      "Email system must be properly configured"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "User": {
        "type": "object",
        "properties": {
          "id": {
            "type": "number",
            "description": "Unique identifier for the user"
          },
          "username": {
            "type": "string",
            "description": "User's login name"
          },
          "email": {
            "type": "string",
            "description": "User's email address"
          },
          "activationKey": {
            "type": "string",
            "description": "Key used to activate the user account"
          }
        },
        "required": [
          "id",
          "email",
          "activationKey"
        ]
      }
    }
  },
  {
    "featureName": "DispatchEmailMessages",
    "description": "Executes email sending process by triggering the spammer component to dispatch queued messages.",
    "inputValues": [
      "spammer-object-Spammer"
    ],
    "businessLogic": "1. Input Collection\n   - Collect the Spammer component instance\n     1.1. Verify the Spammer instance is properly initialized\n     1.2. Ensure the Spammer has access to the email queue\n     1.3. Check if the Spammer component is ready to process messages\n\n2. Data Validation\n   - Validate the Spammer component\n     2.1. Verify the Spammer component is not null\n     2.2. Check if the Spammer component is in a valid state for message dispatch\n     2.3. IF the Spammer component is invalid or not ready\n         2.3.1. Log validation failure\n         2.3.2. Terminate the dispatch process\n         2.3.3. Return appropriate error status\n\n3. Business Rule Processing\n   - Check system conditions for email dispatch\n     3.1. Verify the system is in an operational state for sending emails\n     3.2. Check if email sending is enabled in system configuration\n     3.3. Verify the email queue is accessible\n     3.4. IF any system condition fails\n         3.4.1. Log the specific condition failure\n         3.4.2. Terminate the dispatch process\n         3.4.3. Return appropriate error status\n\n4. Core Operation Execution\n   - Trigger the email dispatch process\n     4.1. Call the dispatchMessages method on the Spammer component\n     4.2. Monitor the dispatch process for completion\n     4.3. IF any errors occur during dispatch\n         4.3.1. Log the specific error details\n         4.3.2. Determine if retry is appropriate\n         4.3.3. IF retry is appropriate\n             4.3.3.1. Schedule a retry attempt\n         4.3.4. ELSE\n             4.3.4.1. Mark failed messages for manual review\n             4.3.4.2. Generate failure notification\n     4.4. Track the number of messages successfully sent\n     4.5. Update message status for dispatched messages\n\n5. Response Generation\n   - Generate operation summary\n     5.1. Compile statistics on the dispatch operation\n         5.1.1. Number of messages processed\n         5.1.2. Number of successful deliveries\n         5.1.3. Number of failed deliveries\n     5.2. IF operation completed successfully\n         5.2.1. Generate success status with operation statistics\n         5.2.2. Log successful completion of the dispatch task\n     5.3. ELSE\n         5.3.1. Generate failure status with error details\n         5.3.2. Log failure details for troubleshooting\n         5.3.3. Include recommendations for resolving the issue",
    "databaseEntities": [
      "jforum_users",
      "jforum_privmsgs",
      "jforum_privmsgs_text"
    ],
    "validationRules": [
      "Spammer component must be properly initialized",
      "Email queue must be accessible",
      "System must be in operational state for sending emails",
      "Email sending must be enabled in system configuration"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Spammer": {
        "type": "object",
        "properties": {
          "dispatchMessages": {
            "type": "function",
            "description": "Method to process and send queued email messages"
          },
          "emailQueue": {
            "type": "array",
            "description": "Collection of email messages waiting to be sent"
          }
        },
        "required": [
          "dispatchMessages",
          "emailQueue"
        ]
      }
    }
  },
  {
    "featureName": "SendNewTopicNotifications",
    "description": "Sends email notifications to subscribed users when a new forum topic is created.",
    "inputValues": [
      "forum-object-Forum",
      "topic-object-Topic",
      "post-object-Post",
      "subscribedUsers-object-UserList"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect Forum information (required)\n     * Forum ID\n     * Forum name\n   - Collect Topic information (required)\n     * Topic ID\n     * Topic title\n     * Last post ID\n   - Collect Post information (optional)\n     * Post text content\n     * Post author information\n   - Collect list of subscribed users (required)\n     * User email addresses\n     * User notification preferences\n\n2. Data Validation:\n   - Validate Forum data\n     * Verify Forum ID exists\n     * Verify Forum is active and visible\n   - Validate Topic data\n     * Verify Topic ID exists\n     * Verify Topic title is not empty\n     * Verify Topic belongs to the specified Forum\n   - Validate Post data (if provided)\n     * Verify Post content is not empty\n     * Verify Post belongs to the specified Topic\n   - Validate subscribed users list\n     * Verify list contains at least one user\n     * Verify each user has a valid email address\n     * Verify each user has opted in for topic notifications\n   - IF any validation fails, THEN\n     * Log validation error\n     * Exit notification process\n\n3. Business Rule Processing:\n   - Check system notification settings\n     * Verify email notifications are enabled system-wide\n     * Retrieve email template configurations\n   - Process notification content\n     * Generate topic link URL\n     * Generate forum unwatch link URL\n     * Format post content for email (if post is provided)\n     * Prepare email subject line with topic title\n   - Apply user notification preferences\n     * Filter out users who disabled forum notifications\n     * Check notification frequency settings for each user\n   - IF system notifications are disabled, THEN\n     * Log notification skipped message\n     * Exit notification process\n\n4. Core Operation Execution:\n   - Prepare notification parameters\n     * Set topic information in template\n     * Set forum information in template\n     * Set post content in template (if available)\n     * Set direct link to the topic\n     * Set unsubscribe link for the forum\n   - Generate email content\n     * Apply email template with parameters\n     * Format subject line with topic title\n   - Process email queue\n     * Group users by notification preferences\n     * Prepare batch email operation\n     * Set email metadata (subject, from address, reply-to)\n   - Send notifications\n     * Process each user in the queue\n     * Send personalized email to each recipient\n     * Track delivery status\n   - IF any sending errors occur, THEN\n     * Log failed delivery attempts\n     * Continue with remaining recipients\n\n5. Response Generation:\n   - Generate notification summary\n     * Count of successful notifications sent\n     * Count of failed notifications\n     * Timestamp of notification completion\n   - Update notification records\n     * Mark topic notifications as sent\n     * Record notification timestamp\n   - Return notification status\n     * Success or failure indicator\n     * Error details if applicable\n     * Notification statistics summary",
    "databaseEntities": [
      "jforum_users",
      "jforum_forums",
      "jforum_topics",
      "jforum_posts",
      "jforum_posts_text"
    ],
    "validationRules": [
      "Forum must exist and be active",
      "Topic must exist and belong to the specified forum",
      "Topic title must not be empty",
      "Subscribed users list must not be empty",
      "Each subscribed user must have a valid email address",
      "Each subscribed user must have opted in for notifications",
      "Email notifications must be enabled in system settings"
    ],
    "dbSeedingOperations": [
      "Ensure system email templates exist for new topic notifications",
      "Ensure system configuration contains valid email settings"
    ],
    "schema": {
      "Forum": {
        "id": "number",
        "name": "string"
      },
      "Topic": {
        "id": "number",
        "title": "string",
        "lastPostId": "number"
      },
      "Post": {
        "id": "number",
        "text": "string",
        "authorId": "number"
      },
      "UserList": {
        "type": "array",
        "items": {
          "id": "number",
          "email": "string",
          "notificationPreferences": "object"
        }
      }
    }
  },
  {
    "featureName": "GenerateTopicEmailContent",
    "description": "Creates formatted email content with topic details, links, and post content for notifications.",
    "inputValues": [
      "forum-object-Forum",
      "topic-object-Topic",
      "post-object-Post",
      "users-object-UserList"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the following inputs:\n     a. forum (mandatory): Forum object containing forum details\n     b. topic (mandatory): Topic object containing topic details\n     c. post (optional): Post object containing post content\n     d. users (mandatory): List of users to receive the notification\n\n2. Data Validation:\n   - Validate forum input:\n     a. IF forum is null THEN\n        i. Generate error: \"Forum information is required\"\n     b. IF forum identifier is invalid THEN\n        i. Generate error: \"Valid forum identifier is required\"\n   - Validate topic input:\n     a. IF topic is null THEN\n        i. Generate error: \"Topic information is required\"\n     b. IF topic identifier is invalid THEN\n        i. Generate error: \"Valid topic identifier is required\"\n     c. IF topic title is empty THEN\n        i. Generate error: \"Topic must have a title\"\n   - Validate users input:\n     a. IF users list is null or empty THEN\n        i. Generate error: \"At least one recipient user is required\"\n\n3. Business Rule Processing:\n   - Generate required links:\n     a. Generate forum link as base URL for all links\n     b. Generate post link using topic identifier and last post identifier\n     c. Generate unwatch link using forum identifier\n   - Prepare notification parameters:\n     a. Add topic information to parameters\n     b. Add generated links to parameters\n     c. IF post is not null THEN\n        i. Prepare post content for display\n        ii. Add post content to parameters\n\n4. Core Operation Execution:\n   - Set recipient users for the notification\n   - Set template parameters with all collected information\n   - Generate email subject using configured template and topic title\n   - Prepare email message using:\n     a. Formatted subject line with topic title\n     b. Email message template from system configuration\n\n5. Response Generation:\n   - Return prepared email content with:\n     a. Subject line containing topic title\n     b. Body content with:\n        i. Topic information\n        ii. Link to view the topic\n        iii. Post content (if available)\n        iv. Link to unwatch the forum\n   - IF any errors occurred during processing THEN\n     a. Return error details with specific validation failure information",
    "databaseEntities": [
      "jforum_users",
      "jforum_forums",
      "jforum_topics",
      "jforum_posts",
      "jforum_posts_text"
    ],
    "validationRules": [
      "Forum object must not be null",
      "Topic object must not be null",
      "Topic must have a valid identifier",
      "Topic must have a non-empty title",
      "Users list must contain at least one recipient"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Forum": {
        "id": "number",
        "name": "string"
      },
      "Topic": {
        "id": "number",
        "title": "string",
        "lastPostId": "number"
      },
      "Post": {
        "id": "number",
        "text": "string"
      },
      "UserList": {
        "type": "array",
        "items": {
          "id": "number",
          "email": "string",
          "username": "string"
        }
      }
    }
  },
  {
    "featureName": "CreateUnwatchForumLink",
    "description": "Generates unsubscribe links allowing users to stop watching specific forums.",
    "inputValues": [
      "forum-object-Forum",
      "forumLink-string-String"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the following inputs:\n     a. forum (mandatory): Forum object containing forum information\n     b. forumLink (mandatory): Base URL string for the forum system\n     c. userId (system-generated): Identifier for the user who will receive the unwatch link\n\n2. Data Validation:\n   - Validate forum input:\n     a. Check if forum object is not null\n     b. Verify forum ID exists and is a valid positive integer\n     c. IF forum is invalid THEN generate error message \"Invalid forum information provided\"\n   - Validate forumLink input:\n     a. Check if forumLink is not null or empty\n     b. Verify forumLink is a valid URL format\n     c. IF forumLink is invalid THEN generate error message \"Invalid forum base URL provided\"\n   - Validate user authorization:\n     a. Verify the user is currently watching the specified forum\n     b. IF user is not watching the forum THEN generate warning \"User is not currently watching this forum\"\n\n3. Business Rule Processing:\n   - Check system configuration:\n     a. Verify that forum watching functionality is enabled in system settings\n     b. IF watching is disabled THEN generate error message \"Forum watching functionality is currently disabled\"\n   - Check user permissions:\n     a. Verify user has permission to unwatch forums\n     b. IF user lacks permission THEN generate error message \"User does not have permission to unwatch forums\"\n   - Check forum status:\n     a. Verify forum is active and available for watching/unwatching\n     b. IF forum is inactive THEN generate error message \"Cannot unwatch an inactive forum\"\n\n4. Core Operation Execution:\n   - Generate the unwatch link:\n     a. Construct the base path using the provided forumLink\n     b. Append the unwatching endpoint path\n     c. Add the forum ID as a parameter\n     d. Add any required system extensions (e.g., .page, .html)\n     e. Add any required security tokens or user identifiers\n     f. Format the final URL according to system standards\n   - Validate the generated link:\n     a. Verify the link format is correct\n     b. Ensure all required parameters are included\n     c. IF link validation fails THEN regenerate with default parameters\n   - Store link information:\n     a. Associate the generated link with the user and forum in temporary storage\n     b. Set appropriate expiration for the link if required\n\n5. Response Generation:\n   - On success:\n     a. Return the complete unwatch link URL\n     b. Include any additional context information needed for display\n     c. Provide confirmation message \"Unwatch link successfully generated\"\n   - On failure:\n     a. Return appropriate error code and message\n     b. Include troubleshooting information if available\n     c. Suggest alternative actions for the user",
    "databaseEntities": [
      "jforum_users",
      "jforum_forums",
      "jforum_topics"
    ],
    "validationRules": [
      "Forum object must not be null",
      "Forum ID must be a valid positive integer",
      "Forum link base URL must not be empty",
      "Forum link must be a valid URL format",
      "User must be currently watching the forum",
      "Forum watching functionality must be enabled in system",
      "User must have permission to unwatch forums",
      "Forum must be active"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Forum": {
        "type": "object",
        "properties": {
          "id": {
            "type": "integer",
            "description": "Unique identifier for the forum"
          },
          "name": {
            "type": "string",
            "description": "Name of the forum"
          },
          "description": {
            "type": "string",
            "description": "Description of the forum"
          },
          "isActive": {
            "type": "boolean",
            "description": "Whether the forum is currently active"
          }
        },
        "required": [
          "id",
          "name"
        ]
      }
    }
  },
  {
    "featureName": "SetCustomMessageId",
    "description": "Sets a custom Message-ID header for email messages.",
    "inputValues": [
      "messageId-string-EmailMessage"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the following inputs:\n     a. messageId (string, mandatory): The custom Message-ID value to be set for the email\n\n2. Data Validation:\n   - Validate the messageId input:\n     a. Check if messageId is provided\n        IF messageId is null or empty THEN\n          Return error: \"Message ID cannot be empty\"\n     b. Check if messageId follows proper format\n        IF messageId does not match required format THEN\n          Return error: \"Invalid Message-ID format\"\n\n3. Business Rule Processing:\n   - Verify system state for message handling:\n     a. Check if the email message object exists\n        IF email message object is null THEN\n          Return error: \"Email message not initialized\"\n     b. Verify the message is in editable state\n        IF message is already finalized or sent THEN\n          Return error: \"Cannot modify headers of finalized message\"\n\n4. Core Operation Execution:\n   - Set the custom Message-ID:\n     a. Store the provided messageId in the message object\n     b. When message headers are updated:\n        IF custom messageId is set THEN\n          Add the custom Message-ID header to the email\n        ELSE\n          Use system-generated Message-ID\n     c. Ensure the Message-ID is properly formatted in email headers\n\n5. Response Generation:\n   - Generate appropriate response:\n     a. On success:\n        Return confirmation that Message-ID was successfully set\n     b. On failure:\n        Return specific error message indicating why the operation failed\n        Include guidance on proper Message-ID format if applicable",
    "databaseEntities": [],
    "validationRules": [
      "Message ID must not be empty",
      "Message ID must follow proper email header format",
      "Email message must be in editable state"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "EmailMessage": {
        "type": "object",
        "properties": {
          "messageId": {
            "type": "string",
            "description": "Custom Message-ID header value for the email"
          },
          "subject": {
            "type": "string",
            "description": "Email subject"
          },
          "content": {
            "type": "string",
            "description": "Email content"
          },
          "headers": {
            "type": "object",
            "description": "Collection of email headers"
          },
          "status": {
            "type": "string",
            "enum": [
              "draft",
              "ready",
              "sent"
            ],
            "description": "Current status of the email message"
          }
        }
      }
    }
  },
  {
    "featureName": "UpdateMessageID",
    "description": "Updates the Message-ID header using either a custom ID or the default implementation.",
    "inputValues": [
      "messageId-string-Message"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the following inputs:\n     - messageId (string, optional): Custom Message-ID to be used in the email header\n   - System will use the current email message context\n\n2. Data Validation:\n   - Validate messageId input if provided:\n     - IF messageId is provided but empty:\n       - Log a warning about empty Message-ID\n       - Proceed with default Message-ID generation\n     - IF messageId is provided and contains invalid characters:\n       - Check that messageId follows proper email header format\n       - IF invalid format detected:\n         - Log validation error\n         - Proceed with default Message-ID generation\n\n3. Business Rule Processing:\n   - Check system configuration for Message-ID handling:\n     - IF system is configured to always use default Message-ID generation:\n       - Ignore custom messageId even if provided\n       - Flag system to use default generation\n     - ELSE:\n       - Determine if custom or default Message-ID should be used:\n         - IF messageId is provided and valid:\n           - Flag system to use custom Message-ID\n         - ELSE:\n           - Flag system to use default Message-ID generation\n\n4. Core Operation Execution:\n   - Process the Message-ID update:\n     - IF using custom Message-ID:\n       - Store the provided messageId in the message object\n       - Prepare message header with custom ID\n     - ELSE:\n       - Set messageId to null in the message object\n       - System will generate default Message-ID during message processing\n   - Update the email message headers:\n     - IF custom Message-ID is being used:\n       - Add or replace the \"Message-ID\" header with the custom value\n     - ELSE:\n       - Allow system to generate and set the default Message-ID\n\n5. Response Generation:\n   - Return status of Message-ID update operation:\n     - IF operation completed successfully:\n       - Return success status\n       - Include information about which Message-ID type was used (custom or default)\n     - ELSE:\n       - Return error status\n       - Include error details and suggestions for resolution",
    "databaseEntities": [],
    "validationRules": [
      "Message-ID must follow proper email header format if provided",
      "System must fall back to default Message-ID generation if custom ID is invalid",
      "Message-ID header must be properly set in the email message"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Message": {
        "type": "object",
        "properties": {
          "messageId": {
            "type": "string",
            "description": "Custom Message-ID to be used in the email header"
          }
        }
      }
    }
  },
  {
    "featureName": "SendLostPasswordEmail",
    "description": "Sends a password recovery email to users with a unique activation link.",
    "inputValues": [
      "user-object-User",
      "mailTitle-string-EmailSubject"
    ],
    "businessLogic": "1. Input Collection:\n   1.1. Collect the User object containing:\n       - User ID (mandatory)\n       - Email address (mandatory)\n       - Username (mandatory)\n       - Activation key (mandatory, system-generated)\n   1.2. Collect email subject title (mandatory)\n   1.3. System retrieves forum link from system configuration (system-generated)\n\n2. Data Validation:\n   2.1. Validate User object:\n       - Verify user ID exists and is valid\n       - Verify email address is properly formatted\n       - Verify activation key is present and valid\n       - IF any user data is invalid, THEN abort process and log error\n   2.2. Validate email subject:\n       - Verify subject is not empty\n       - IF subject is empty, THEN use default subject from system configuration\n\n3. Business Rule Processing:\n   3.1. Verify system email functionality is enabled:\n       - Check system configuration for email service availability\n       - IF email service is disabled, THEN abort process and log error\n   3.2. Verify email template exists:\n       - Check for lost password email template in the system\n       - IF template not found, THEN abort process and log error\n   3.3. Verify user is eligible for password recovery:\n       - Check if user account is active\n       - Check if user has exceeded password recovery attempts\n       - IF user is not eligible, THEN abort process and log error\n\n4. Core Operation Execution:\n   4.1. Construct password recovery URL:\n       - Combine forum base URL with recovery path\n       - Append user's activation key to create unique recovery link\n       - Format URL according to system requirements\n   4.2. Prepare email content:\n       - Load email template for lost password\n       - Replace template variables with actual values:\n         * Insert user information (username, email)\n         * Insert the unique recovery URL\n         * Insert any additional system information\n   4.3. Send email to user:\n       - Set recipient to user's email address\n       - Set email subject from provided mail title\n       - Set email content from prepared template\n       - Process email sending through system mailer\n       - Handle any sending failures with appropriate logging\n\n5. Response Generation:\n   5.1. For successful email sending:\n       - Record the password recovery attempt in the system\n       - Update user's last password recovery request timestamp\n       - Return success status with timestamp\n   5.2. For failed email sending:\n       - Log detailed error information\n       - Return failure status with error description\n       - Provide alternative recovery instructions if applicable",
    "databaseEntities": [
      "jforum_users"
    ],
    "validationRules": [
      "User must exist in the system",
      "User email must be valid and properly formatted",
      "User activation key must be present and valid",
      "Email subject must not be empty",
      "System email functionality must be enabled",
      "Lost password email template must exist in the system",
      "User account must be active to receive password recovery email",
      "User must not have exceeded maximum password recovery attempts"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "User": {
        "type": "object",
        "properties": {
          "id": {
            "type": "number",
            "description": "Unique identifier for the user"
          },
          "username": {
            "type": "string",
            "description": "User's login name"
          },
          "email": {
            "type": "string",
            "description": "User's email address"
          },
          "activationKey": {
            "type": "string",
            "description": "Unique key for password recovery verification"
          },
          "active": {
            "type": "boolean",
            "description": "Indicates if the user account is active"
          }
        },
        "required": [
          "id",
          "username",
          "email",
          "activationKey"
        ]
      }
    }
  },
  {
    "featureName": "SendPrivateMessageNotification",
    "description": "Sends email notifications to users when they receive new private messages.",
    "inputValues": [
      "user-object-User",
      "messageLink-string-Link"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect user object (mandatory) containing recipient details\n   - Collect message link (mandatory) for accessing the private message\n   - System will use email templates (mandatory) for notification content\n   - User email address (mandatory from user object)\n\n2. Data Validation:\n   - Validate user object:\n      a. Check if user object is not null\n      b. Verify user has valid ID\n      c. IF user email is null or empty THEN\n         i. Exit process without sending notification\n         ii. Log skipped notification attempt\n      d. Validate email format for correctness\n   - Validate message link:\n      a. Ensure link is not empty\n      b. Verify link format is valid\n   - Validate system configuration:\n      a. Check if email notification feature is enabled\n      b. Verify email templates exist and are accessible\n\n3. Business Rule Processing:\n   - Check user notification preferences:\n      a. IF user has disabled private message notifications THEN\n         i. Skip notification process\n         ii. Log notification preference status\n      b. ELSE continue with notification process\n   - Check system notification limits:\n      a. Verify notification frequency limits are not exceeded\n      b. Check if user's daily notification limit is reached\n   - Prepare notification context:\n      a. Create parameter collection for template\n      b. Add user information to parameters\n      c. Add message access link to parameters\n      d. Add system information (site name, etc.) to parameters\n\n4. Core Operation Execution:\n   - Prepare email message:\n      a. Select appropriate email template\n      b. Apply template parameters to generate content\n      c. Set email subject line from configuration\n      d. Format email body with proper HTML/text content\n   - Send notification:\n      a. Add recipient email address\n      b. Set sender address from system configuration\n      c. Attempt to send email message\n      d. IF sending fails THEN\n         i. Log failure with reason\n         ii. Store notification for retry if applicable\n      e. ELSE mark notification as sent successfully\n   - Update notification records:\n      a. Record timestamp of notification\n      b. Update user's notification counter\n      c. Link notification record to private message\n\n5. Response Generation:\n   - For successful notification:\n      a. Return success status\n      b. Include notification ID if applicable\n      c. Include timestamp of notification\n   - For failed notification:\n      a. Return failure status\n      b. Include error reason\n      c. Include suggestion for retry if applicable\n   - For skipped notification (due to preferences):\n      a. Return skipped status\n      b. Include reason for skipping",
    "databaseEntities": [
      "User",
      "PrivateMessage",
      "NotificationPreference",
      "NotificationLog"
    ],
    "validationRules": [
      "User must have a valid email address",
      "Email notification must be enabled in system settings",
      "User must have private message notifications enabled in preferences",
      "Email templates must exist and be accessible",
      "Message link must be valid and accessible",
      "Notification frequency limits must not be exceeded"
    ],
    "dbSeedingOperations": [
      "Ensure default email templates exist for private message notifications",
      "Set default system configuration for notification settings"
    ],
    "schema": {
      "User": {
        "id": "number",
        "username": "string",
        "email": "string",
        "notificationPreferences": "object"
      }
    }
  },
  {
    "featureName": "SendCustomizedEmails",
    "description": "Sends customized email messages to multiple users with template-based content.",
    "inputValues": [
      "users-object-User",
      "subject-string-EmailSubject",
      "messageTemplate-string-TemplateFile",
      "templateParams-object-TemplateParameters",
      "messageId-string-EmailMessageId",
      "inReplyTo-string-ReplyReference"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the following inputs:\n     a. users (mandatory): List of User objects who will receive emails\n     b. subject (mandatory): Email subject line\n     c. messageTemplate (mandatory): Path to the email template file\n     d. templateParams (mandatory): Parameters to populate the email template\n     e. messageId (optional): Unique identifier for the email message\n     f. inReplyTo (optional): Reference to previous message if this is a reply\n\n2. Data Validation:\n   - Validate users list:\n     a. IF users list is empty THEN\n        i. Return error: \"No recipients specified\"\n     b. FOR EACH user in users list:\n        i. Validate email address format\n        ii. IF email address is invalid THEN\n            1. Log warning: \"Invalid email address for user\"\n            2. Remove user from recipients list\n   - Validate subject:\n     a. IF subject is empty THEN\n        i. Return error: \"Email subject cannot be empty\"\n   - Validate message template:\n     a. IF template file does not exist THEN\n        i. Return error: \"Email template not found\"\n     b. IF template file cannot be read THEN\n        i. Return error: \"Cannot read email template\"\n\n3. Business Rule Processing:\n   - Check email system configuration:\n     a. Retrieve SMTP server settings from system configuration\n     b. Verify authentication requirements\n     c. IF authentication required THEN\n        i. Verify username and password are provided\n        ii. IF credentials missing THEN\n            1. Return error: \"SMTP authentication credentials required\"\n   - Determine message format (HTML or plain text):\n     a. Read message format preference from system configuration\n     b. Set appropriate content type for email messages\n   - Check customization requirements:\n     a. Analyze users list to determine if customization is needed\n     b. FOR EACH user in users list:\n        i. Check if user has text notification preference\n        ii. IF any user requires text notification THEN\n            1. Set needCustomization flag to true\n            2. BREAK loop\n\n4. Core Operation Execution:\n   - Initialize email session:\n     a. Create mail session with appropriate properties\n     b. Set sender address from system configuration\n   - Prepare message template:\n     a. Load template file with appropriate character encoding\n     b. Add forum name to template parameters\n   - IF customization not needed THEN\n     a. Process template once to generate generic message\n     b. Set message content for all recipients\n   - Prepare for message dispatch:\n     a. Set message sent date to current time\n     b. Set message subject with appropriate character encoding\n     c. IF messageId is provided THEN\n        i. Create identifiable message with specified ID\n     d. IF inReplyTo is provided THEN\n        i. Add In-Reply-To header to message\n   - Send messages to recipients:\n     a. IF authentication required THEN\n        i. Connect to SMTP server with credentials\n        ii. FOR EACH user in users list:\n            1. IF customization needed THEN\n               a. Add user to template parameters\n               b. Process template for specific user\n               c. Set message content for this user\n            2. Create recipient address from user's email\n            3. Set recipient in message\n            4. Send message to recipient\n            5. IF send delay configured THEN\n               a. Pause for specified delay period\n        iii. Close SMTP connection\n     b. ELSE\n        i. FOR EACH user in users list:\n           1. IF customization needed THEN\n              a. Add user to template parameters\n              b. Process template for specific user\n              c. Set message content for this user\n           2. Create recipient address from user's email\n           3. Set recipient in message\n           4. Send message to recipient\n           5. IF send delay configured THEN\n              a. Pause for specified delay period\n\n5. Response Generation:\n   - Track email sending results:\n     a. Count successful deliveries\n     b. Collect any delivery failures\n   - Generate success response:\n     a. Return success status\n     b. Include count of messages sent\n     c. Include list of any failed deliveries\n   - IF any errors occurred during processing THEN\n     a. Return error status\n     b. Include detailed error information\n     c. Include any partial success information",
    "databaseEntities": [
      "jforum_users"
    ],
    "validationRules": [
      "Users list must not be empty",
      "Each user must have a valid email address",
      "Email subject must not be empty",
      "Email template file must exist and be readable",
      "SMTP server settings must be properly configured",
      "Authentication credentials must be provided if SMTP authentication is required"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "User": {
        "type": "object",
        "properties": {
          "email": {
            "type": "string",
            "description": "Email address of the user"
          },
          "username": {
            "type": "string",
            "description": "Username of the user"
          },
          "notifyText": {
            "type": "function",
            "description": "Function that returns whether the user prefers text notifications"
          }
        },
        "required": [
          "email"
        ]
      },
      "TemplateParameters": {
        "type": "object",
        "properties": {
          "forumName": {
            "type": "string",
            "description": "Name of the forum"
          },
          "user": {
            "type": "object",
            "description": "User object for customization"
          }
        }
      }
    }
  },
  {
    "featureName": "DispatchMessages",
    "description": "Delivers email messages to recipients with authentication and configurable sending delay.",
    "inputValues": [
      "users-object-User",
      "subject-string-MessageSubject",
      "messageFile-string-TemplateFile",
      "messageId-string-MessageIdentifier",
      "inReplyTo-string-ReplyReference",
      "templateParams-object-TemplateParameters"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect list of recipient users (mandatory)\n   - Get message subject (mandatory)\n   - Get message template file path (mandatory)\n   - Get message identifier (optional)\n   - Get in-reply-to reference (optional)\n   - Get template parameters (mandatory)\n   - System retrieves configuration values:\n     * SMTP host and port\n     * Authentication credentials\n     * Message format (HTML or text)\n     * Sending delay between messages\n     * SSL settings\n\n2. Data Validation:\n   - Validate recipient list:\n     * IF recipient list is empty THEN return error \"No recipients specified\"\n     * FOR EACH recipient, validate email format\n   - Validate message subject:\n     * IF subject is empty THEN return error \"Subject cannot be empty\"\n   - Validate message template file:\n     * IF template file does not exist THEN return error \"Template file not found\"\n     * IF template file cannot be read THEN return error \"Cannot read template file\"\n   - Validate SMTP configuration:\n     * IF SMTP host is not specified THEN return error \"SMTP host not configured\"\n     * IF authentication is enabled:\n       * IF username is empty THEN return error \"SMTP username not configured\"\n       * IF password is empty THEN return error \"SMTP password not configured\"\n\n3. Business Rule Processing:\n   - Determine message format (HTML or text) based on system configuration\n   - Determine if authentication is required based on system configuration\n   - Determine if SSL connection is required based on system configuration\n   - Check if message customization is needed:\n     * FOR EACH recipient, check notification preferences\n     * IF any recipient requires customized content THEN set customization flag\n   - Prepare email session with appropriate properties:\n     * Set SMTP host and port\n     * Set authentication settings\n     * Set character encoding\n     * Set local hostname if specified\n\n4. Core Operation Execution:\n   - Create email message with appropriate headers:\n     * Set sent date to current time\n     * Set sender address from system configuration\n     * Set subject with proper character encoding\n     * IF message ID is provided THEN set message ID\n     * IF in-reply-to reference is provided THEN add in-reply-to header\n   - Prepare message content:\n     * Load message template\n     * IF customization is not needed:\n       * Process template with provided parameters\n       * Set message content based on format (HTML or text)\n   - Send messages to recipients:\n     * IF authentication is required:\n       * Establish authenticated transport connection\n       * FOR EACH recipient:\n         * IF customization is needed THEN generate personalized content\n         * Send message to recipient\n         * IF sending delay is greater than zero THEN wait for specified delay\n       * Close transport connection\n     * ELSE:\n       * FOR EACH recipient:\n         * IF customization is needed THEN generate personalized content\n         * Send message to recipient\n         * IF sending delay is greater than zero THEN wait for specified delay\n\n5. Response Generation:\n   - IF all messages are sent successfully THEN:\n     * Return success status\n     * Log successful dispatch information\n   - IF any errors occur during sending THEN:\n     * Log detailed error information\n     * Return failure status with error details",
    "databaseEntities": [
      "jforum_users"
    ],
    "validationRules": [
      "Recipient list must not be empty",
      "Each recipient must have a valid email address",
      "Message subject must not be empty",
      "Message template file must exist and be readable",
      "SMTP host must be configured",
      "If authentication is enabled, username and password must be provided",
      "Message format must be either HTML or text"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "User": {
        "type": "object",
        "properties": {
          "email": {
            "type": "string",
            "description": "Email address of the user"
          },
          "notifyText": {
            "type": "function",
            "description": "Function that returns whether the user requires text notification"
          }
        },
        "required": [
          "email"
        ]
      },
      "TemplateParameters": {
        "type": "object",
        "properties": {
          "forumName": {
            "type": "string",
            "description": "Name of the forum"
          },
          "user": {
            "type": "object",
            "description": "User object for customization"
          }
        }
      }
    }
  },
  {
    "featureName": "PrepareEmailMessage",
    "description": "Creates email messages with subject, template-based content and proper headers.",
    "inputValues": [
      "subject-string-EmailMessage",
      "messageFile-string-EmailTemplate",
      "messageId-string-EmailMessage",
      "inReplyTo-string-EmailMessage",
      "users-object-UserList",
      "templateParams-object-TemplateParameters"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the following required inputs:\n     a. subject: String containing the email subject line\n     b. messageFile: String path to the email template file\n     c. templateParams: Object containing parameters to be used in the template\n   - Collect the following optional inputs:\n     a. messageId: String identifier for the email (optional)\n     b. inReplyTo: String reference to a previous email (optional)\n     c. users: List of user objects who will receive the email\n   - System will use the following configuration values:\n     a. Forum name\n     b. Mail sender address\n     c. Mail character set\n     d. Message format (HTML or text)\n\n2. Data Validation:\n   - Validate subject:\n     a. Check that subject is not empty\n     b. Ensure subject is properly encoded\n   - Validate messageFile:\n     a. Verify that the template file exists\n     b. Ensure the template file is accessible\n   - Validate templateParams:\n     a. Ensure required template parameters are present\n     b. Verify parameter types match expected template variables\n   - Validate users list (if provided):\n     a. Verify each user has a valid email address\n     b. Check that the users list is not empty\n\n3. Business Rule Processing:\n   - Determine message format:\n     a. IF configured format is HTML, prepare HTML message\n     b. ELSE prepare plain text message\n   - Check for customization requirements:\n     a. Examine all users in the recipient list\n     b. IF any user requires text customization, set needCustomization flag to true\n     c. ELSE set needCustomization flag to false\n   - Prepare email headers:\n     a. Set sent date to current time\n     b. Set sender address from system configuration\n     c. IF messageId is provided, use it for the email\n     d. IF inReplyTo is provided, add it as a header\n\n4. Core Operation Execution:\n   - Create email message object:\n     a. IF messageId is provided, create identifiable message with the ID\n     b. ELSE create standard message\n   - Load email template:\n     a. Get template encoding from system configuration\n     b. IF template encoding is specified, load template with encoding\n     c. ELSE load template with default encoding\n   - Add forum name to template parameters\n   - Process template content:\n     a. IF customization is not needed, process template once for all recipients\n     b. ELSE defer template processing until sending time\n   - Set message content:\n     a. IF format is HTML, replace newlines with HTML breaks\n     b. Set appropriate content type and character set\n     c. Apply the processed template content to the message\n\n5. Response Generation:\n   - Return prepared message object with:\n     a. Complete message headers\n     b. Processed template content (if not customized)\n     c. Template and parameters (if customization needed)\n     d. List of recipients\n   - Include success indicator\n   - Provide any warning messages about potential delivery issues",
    "databaseEntities": [
      "jforum_users"
    ],
    "validationRules": [
      "Email subject must not be empty",
      "Message template file must exist and be accessible",
      "Template parameters must contain all required variables",
      "Each recipient must have a valid email address",
      "Message format must be either HTML or text"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "UserList": {
        "type": "array",
        "items": {
          "type": "object",
          "properties": {
            "email": {
              "type": "string",
              "description": "Email address of the recipient"
            },
            "notifyText": {
              "type": "boolean",
              "description": "Flag indicating if user requires customized text"
            }
          },
          "required": [
            "email"
          ]
        }
      },
      "TemplateParameters": {
        "type": "object",
        "properties": {
          "forumName": {
            "type": "string",
            "description": "Name of the forum"
          },
          "user": {
            "type": "object",
            "description": "User object for customization"
          }
        }
      }
    }
  },
  {
    "featureName": "ProcessEmailTemplate",
    "description": "Processes email templates with user-specific parameters to generate personalized content.",
    "inputValues": [
      "subject-string-EmailSubject",
      "templateFile-string-TemplateFile",
      "recipients-object-RecipientList",
      "templateParameters-object-TemplateParameters",
      "messageId-string-MessageIdentifier",
      "inReplyTo-string-ReferenceIdentifier"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the email subject (mandatory)\n   - Collect the template file path (mandatory)\n   - Collect the list of recipients (mandatory)\n   - Collect template parameters for personalization (mandatory)\n   - Collect message identifier (optional)\n   - Collect in-reply-to reference (optional)\n   - System will use configuration values for sender address, mail server settings, and character encoding\n\n2. Data Validation:\n   - Validate email subject:\n     * Must not be empty\n     * Must be properly encoded using system character set\n   - Validate template file path:\n     * Must point to an existing template file\n     * File must be readable\n     * File must contain valid template syntax\n   - Validate recipients list:\n     * Must contain at least one recipient\n     * Each recipient must have a valid email address\n     * Each recipient must have notification preferences set\n   - Validate template parameters:\n     * Must contain all required placeholders for the template\n     * Values must be properly formatted for template processing\n   - Validate message identifier (if provided):\n     * Must follow standard message ID format\n   - Validate in-reply-to reference (if provided):\n     * Must reference a valid previous message ID\n\n3. Business Rule Processing:\n   - Check system mail configuration:\n     * Verify SMTP server settings are configured\n     * Determine if authentication is required\n     * Determine if SSL is enabled\n     * Verify sender email address is configured\n   - Determine message format (HTML or text) based on system configuration\n   - Determine if template customization is needed:\n     * Check if any recipient has specific notification preferences\n     * If customization is needed, prepare for per-user message generation\n   - Check for sending delay requirements between messages\n\n4. Core Operation Execution:\n   - Initialize mail session with appropriate properties:\n     * Set SMTP host and port\n     * Configure authentication if required\n     * Set character encoding\n     * Configure SSL if enabled\n   - Prepare email message template:\n     * Load template file with proper encoding\n     * Add system parameters to template context\n     * Add forum name and other global parameters\n   - Process template for non-customized scenario:\n     * If customization is not needed, process template once\n     * Store processed content for all recipients\n   - Establish connection to mail server if authentication required:\n     * Connect using configured credentials\n     * Verify connection is established\n   - For each recipient:\n     * If customization is needed:\n       - Add recipient-specific parameters to template context\n       - Process template with recipient context\n       - Format message as HTML or text based on configuration\n     * Set recipient as the TO address\n     * Set message headers (message ID, in-reply-to if provided)\n     * Send message to recipient\n     * Apply sending delay if configured\n     * Log successful sending\n   - Close mail server connection if established\n\n5. Response Generation:\n   - If all messages sent successfully:\n     * Return success status\n     * Include count of messages sent\n     * Include timestamp of operation completion\n   - If any failures occurred:\n     * Return error status\n     * Include details of which recipients could not be processed\n     * Include error messages for troubleshooting\n     * Provide information on partial success (which messages were sent)",
    "databaseEntities": [
      "jforum_users"
    ],
    "validationRules": [
      "Email subject must not be empty",
      "Template file must exist and be readable",
      "Recipients list must contain at least one valid recipient",
      "Each recipient must have a valid email address",
      "Template parameters must contain all required placeholders",
      "SMTP server settings must be properly configured",
      "Sender email address must be properly configured"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "RecipientList": {
        "type": "array",
        "items": {
          "type": "object",
          "properties": {
            "email": {
              "type": "string",
              "description": "Email address of the recipient"
            },
            "notifyText": {
              "type": "boolean",
              "description": "Whether the recipient prefers text notifications"
            }
          },
          "required": [
            "email",
            "notifyText"
          ]
        }
      },
      "TemplateParameters": {
        "type": "object",
        "properties": {
          "forumName": {
            "type": "string",
            "description": "Name of the forum"
          },
          "user": {
            "type": "object",
            "description": "User-specific information for personalization"
          }
        },
        "additionalProperties": true
      }
    }
  },
  {
    "featureName": "NotifyTopicReplies",
    "description": "Sends email notifications to users when new replies are posted to forum topics they follow.",
    "inputValues": [
      "topic-object-Topic",
      "post-object-Post",
      "users-object-UserList"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect Topic object containing topic details (required)\n     - Topic ID\n     - Topic title\n     - Forum ID\n     - First post ID\n     - Last post ID\n     - Total replies count\n   - Collect Post object containing the reply details (optional)\n     - Post ID\n     - Post text content\n     - Post author information\n   - Collect list of Users who follow the topic (required)\n     - Each user must have email address and notification preferences\n\n2. Data Validation:\n   - Validate Topic object\n     - Ensure Topic ID is valid and exists\n     - Verify Topic title is not empty\n     - Confirm Forum ID is valid\n   - Validate Post object (if provided)\n     - Ensure Post ID is valid\n     - Verify Post text is not empty\n   - Validate Users list\n     - Ensure list is not empty\n     - Verify each user has valid email address\n     - Check each user has opted in for notifications\n   - IF any validation fails, THEN\n     - Log validation errors\n     - Exit notification process\n\n3. Business Rule Processing:\n   - Check system notification settings\n     - Verify email notifications are enabled system-wide\n     - Confirm email template files exist\n   - Process topic pagination\n     - Calculate current page number based on total replies and posts per page setting\n     - IF total replies exceed posts per page, THEN\n       - Determine correct page number for the new reply\n     - ELSE\n       - Use default page (first page)\n   - Generate notification links\n     - Create direct link to the new reply post\n     - Create unsubscribe link for each recipient\n   - Prepare message context\n     - Format topic title for email subject\n     - Include forum context information\n     - IF Post object is provided, THEN\n       - Prepare post content for display in email\n       - Format post text according to display rules\n\n4. Core Operation Execution:\n   - Create email parameters\n     - Set email subject with topic title\n     - Set message template file path\n     - Add topic information to template parameters\n     - Add navigation links to template parameters\n     - Add formatted post content to template parameters (if available)\n   - Process message threading\n     - Generate unique message ID for the notification\n     - IF not the first post in topic, THEN\n       - Set In-Reply-To header to maintain email thread\n   - FOR EACH user in the notification list\n     - Prepare personalized email content\n     - Add user to recipient list\n   - Send notification emails\n     - Process email template with parameters\n     - Send emails to all recipients\n     - Track delivery status\n   - IF any sending errors occur, THEN\n     - Log error details\n     - Continue with remaining recipients\n\n5. Response Generation:\n   - Generate notification summary\n     - Count of successful notifications sent\n     - List of any failed notifications\n   - Update notification tracking\n     - Record timestamp of notification\n     - Update user notification history\n   - Return notification status\n     - Success or failure indication\n     - Error details if applicable",
    "databaseEntities": [
      "jforum_users",
      "jforum_topics",
      "jforum_posts",
      "jforum_posts_text",
      "jforum_forums"
    ],
    "validationRules": [
      "Topic must exist in the system",
      "Topic title must not be empty",
      "Users must have valid email addresses",
      "Users must have opted in to receive notifications",
      "Email notification templates must exist",
      "System must have email notification functionality enabled"
    ],
    "dbSeedingOperations": [
      "Ensure notification template files exist in the system",
      "Verify system configuration contains required email settings"
    ],
    "schema": {
      "Topic": {
        "id": "number",
        "title": "string",
        "forumId": "number",
        "firstPostId": "number",
        "lastPostId": "number",
        "totalReplies": "number"
      },
      "Post": {
        "id": "number",
        "text": "string",
        "authorId": "number",
        "topicId": "number",
        "forumId": "number"
      },
      "UserList": {
        "type": "array",
        "items": {
          "id": "number",
          "email": "string",
          "username": "string",
          "notificationPreferences": "object"
        }
      }
    }
  },
  {
    "featureName": "GenerateUnwatchLink",
    "description": "Creates personalized links allowing users to unsubscribe from topic notifications.",
    "inputValues": [
      "userId-number-User",
      "topicId-number-Topic",
      "forumLink-string-System"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect topicId (mandatory): The unique identifier for the topic\n   - Collect userId (mandatory): The unique identifier of the user to generate the link for\n   - Collect forumLink (mandatory): The base URL for the forum system\n   - System will generate a timestamp (system-generated): Used for link validation\n\n2. Data Validation:\n   - Validate topicId:\n     a. Must be a positive integer\n     b. Must reference an existing topic in the system\n     c. Return error if topic does not exist: \"Topic not found\"\n   - Validate userId:\n     a. Must be a positive integer\n     b. Must reference an existing user in the system\n     c. Return error if user does not exist: \"User not found\"\n   - Validate forumLink:\n     a. Must be a valid URL string\n     b. Must not be empty\n     c. Return error if invalid: \"Invalid forum URL\"\n   - Validate user subscription status:\n     a. Check if user is currently subscribed to the topic\n     b. Return error if not subscribed: \"User is not subscribed to this topic\"\n\n3. Business Rule Processing:\n   - Verify user permissions:\n     a. Check if user has permission to unsubscribe from notifications\n     b. Return error if no permission: \"User does not have permission to unsubscribe\"\n   - Verify topic status:\n     a. Check if topic is active and not locked or deleted\n     b. Return error if topic is inactive: \"Cannot unsubscribe from inactive topic\"\n   - Verify system notification settings:\n     a. Check if notification system is enabled\n     b. Return error if disabled: \"Notification system is currently disabled\"\n\n4. Core Operation Execution:\n   - Generate unique token:\n     a. Create a secure token combining userId, topicId, and timestamp\n     b. Apply encryption or hashing to secure the token\n     c. Store token in the system with expiration date\n   - Construct unwatch URL:\n     a. Combine forumLink with appropriate path components\n     b. Append the topic identifier\n     c. Add the generated security token\n     d. Format according to system URL standards\n   - Record link generation:\n     a. Log the generation of unwatch link for auditing\n     b. Store link-user association for tracking\n     c. Update user notification preferences if needed\n\n5. Response Generation:\n   - Success response:\n     a. Return the complete unwatch URL\n     b. Include expiration information for the link\n     c. Provide usage instructions if applicable\n   - Error response:\n     a. Return specific error message based on validation failures\n     b. Include support contact information\n     c. Provide alternative unsubscription methods if available",
    "databaseEntities": [
      "jforum_users",
      "jforum_topics",
      "jforum_forums",
      "jforum_user_groups"
    ],
    "validationRules": [
      "Topic ID must reference an existing topic",
      "User ID must reference an existing user",
      "User must be currently subscribed to the topic",
      "Forum link must be a valid URL string",
      "Topic must be active (not locked or deleted)",
      "User must have permission to unsubscribe from notifications"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "UnwatchLink": {
        "type": "object",
        "properties": {
          "url": {
            "type": "string",
            "description": "The complete URL for unsubscribing"
          },
          "userId": {
            "type": "number",
            "description": "ID of the user the link is generated for"
          },
          "topicId": {
            "type": "number",
            "description": "ID of the topic to unsubscribe from"
          },
          "expirationDate": {
            "type": "date",
            "description": "Date when the unwatch link expires"
          },
          "token": {
            "type": "string",
            "description": "Security token to validate the unwatch request"
          }
        },
        "required": [
          "url",
          "userId",
          "topicId",
          "expirationDate",
          "token"
        ]
      }
    }
  },
  {
    "featureName": "GenerateMessageLink",
    "description": "Creates direct links to specific posts within forum topics with proper pagination.",
    "inputValues": [
      "topic-object-Topic",
      "post-object-Post",
      "forumLink-string-String"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect Topic object (mandatory) containing topic details\n   - Collect Post object (optional) containing post details\n   - Collect forumLink string (mandatory) containing base URL of the forum\n   - System will use postsPerPage configuration value (mandatory)\n\n2. Data Validation:\n   - Validate Topic object:\n     a. Ensure topic ID is not null or zero\n     b. Ensure topic has valid total replies count\n     c. Return error if topic validation fails\n   - Validate forumLink:\n     a. Ensure forumLink is not empty\n     b. Ensure forumLink is properly formatted\n     c. Return error if forumLink validation fails\n   - Validate Post object (if provided):\n     a. Ensure post ID is not null or zero\n     b. Return error if post validation fails when provided\n\n3. Business Rule Processing:\n   - Determine pagination requirements:\n     a. IF total replies in topic >= postsPerPage THEN\n        i. Calculate page number based on total replies and postsPerPage\n        ii. Set page parameter to (totalReplies / postsPerPage) * postsPerPage\n     b. ELSE\n        i. No pagination required, use default page\n   - Determine message anchor:\n     a. IF post is provided THEN\n        i. Use post ID as anchor reference\n     b. ELSE\n        i. Use topic's lastPostId as anchor reference\n\n4. Core Operation Execution:\n   - Generate message link:\n     a. Start with base forumLink\n     b. Append \"posts/list/\" path\n     c. Append pagination information if required\n     d. Append topic ID\n     e. Append system extension value\n     f. Append anchor reference using '#' followed by post ID\n   - Format final URL ensuring all components are properly joined\n   - Validate generated URL structure\n\n5. Response Generation:\n   - Return the complete message link URL\n   - Include metadata about the link:\n     a. Topic information\n     b. Page information if pagination was applied\n     c. Post reference information\n   - If any errors occurred during generation:\n     a. Return error details\n     b. Include guidance on resolving the issue",
    "databaseEntities": [
      "jforum_topics",
      "jforum_posts",
      "jforum_forums"
    ],
    "validationRules": [
      "Topic ID must be valid and greater than zero",
      "Forum link must not be empty",
      "Post ID must be valid when post is provided",
      "Generated URL must contain all required components",
      "Pagination must be correctly calculated based on posts per page setting"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Topic": {
        "id": "number",
        "title": "string",
        "totalReplies": "number",
        "forumId": "number",
        "firstPostId": "number",
        "lastPostId": "number"
      },
      "Post": {
        "id": "number",
        "text": "string"
      }
    }
  },
  {
    "featureName": "ReloadQueriesFile",
    "description": "Reloads SQL queries configuration when the queries file changes.",
    "inputValues": [
      "filename-string-File"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the filename (string) of the changed queries file\n   - This input is mandatory and system-provided when a file change is detected\n\n2. Data Validation:\n   - Validate that the filename is not null or empty\n     * IF filename is null or empty THEN\n       - Log error message about invalid filename\n       - Terminate the operation\n     * END IF\n   - Verify that the file exists in the system\n     * IF file does not exist THEN\n       - Log error message about non-existent file\n       - Terminate the operation\n     * END IF\n\n3. Business Rule Processing:\n   - Check if the system is in a state where reloading queries is allowed\n     * IF system is in initialization phase THEN\n       - Defer reload until initialization completes\n     * END IF\n   - Determine if the changed file is the main queries file or a driver-specific file\n     * Store the file type information for later processing\n\n4. Core Operation Execution:\n   - Log information message that reload operation is starting for the specified filename\n   - Load the queries from the changed file into the system configuration\n     * Parse the file contents\n     * Extract query definitions\n     * Update the system's query repository\n   - Check if the changed file is the driver-specific queries file\n     * IF changed file is NOT the driver-specific queries file THEN\n       - Retrieve the driver-specific queries filename from system configuration\n       - Load the driver-specific queries to ensure consistency\n     * END IF\n   - IF any errors occur during reload THEN\n     - Log detailed error information\n     - Attempt to restore previous query definitions if possible\n     - Notify system administrators about the failure\n   - END IF\n\n5. Response Generation:\n   - Log successful completion of the reload operation\n   - Update system status indicators to reflect the new queries configuration\n   - No explicit user response as this is a system background operation",
    "databaseEntities": [],
    "validationRules": [
      "Filename must not be null or empty",
      "File must exist in the system",
      "File must contain valid SQL query definitions",
      "System must not be in a state that prevents configuration reloading"
    ],
    "dbSeedingOperations": [],
    "schema": {}
  },
  {
    "featureName": "LoadSystemConfiguration",
    "description": "Initializes and loads system configuration from default and installation-specific files.",
    "inputValues": [
      "appPath-string-SystemConfig",
      "mainConfigurationFile-string-SystemConfig"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the application path (appPath) which represents the base directory of the application\n   - Collect the main configuration file path (mainConfigurationFile) which contains system defaults\n   - Both inputs are mandatory for system initialization\n\n2. Data Validation:\n   - Validate that mainConfigurationFile is not null\n     * IF mainConfigurationFile is null THEN\n       - Generate an error indicating configuration file cannot be null\n       - Halt the initialization process\n   - Validate that appPath points to a valid directory\n     * IF appPath is invalid THEN\n       - Generate an error indicating invalid application path\n       - Halt the initialization process\n   - Validate that mainConfigurationFile exists and is readable\n     * IF file does not exist or cannot be read THEN\n       - Generate an error indicating configuration file cannot be accessed\n       - Halt the initialization process\n\n3. Business Rule Processing:\n   - Initialize the global configuration system\n     * Create a new instance of the configuration manager\n     * Store the application path as a system property\n     * Store the default configuration file path as a system property\n   - Determine the installation-specific configuration file path\n     * Retrieve the installation configuration path from default settings\n     * Verify if the installation configuration file exists\n   - Process any additional configuration files\n     * For each additional configuration file in the list:\n       - Check if the file exists\n       - IF file exists THEN load its properties\n       - IF file does not exist THEN log a warning and continue\n\n4. Core Operation Execution:\n   - Load default configuration properties\n     * Open and read the default configuration file\n     * Parse and store all key-value pairs from the file\n     * Close the file after reading\n   - Load installation-specific configuration properties\n     * IF installation configuration file exists THEN\n       - Open and read the installation configuration file\n       - Parse and store all key-value pairs from the file\n       - Close the file after reading\n     * ELSE\n       - Skip loading installation properties\n   - Initialize variable expansion system\n     * Set up the mechanism to expand variables in configuration values\n     * Clear any cached expansions\n   - Prepare the configuration system for use\n     * Ensure all required configuration properties are available\n     * Set up any derived properties based on loaded values\n\n5. Response Generation:\n   - Return the initialization status\n     * IF all configuration files loaded successfully THEN\n       - Indicate successful initialization\n       - Make configuration values available for retrieval\n     * ELSE\n       - Provide detailed error information about which files failed to load\n       - Include suggestions for resolving configuration issues",
    "databaseEntities": [],
    "validationRules": [
      "Main configuration file must not be null",
      "Application path must be a valid directory",
      "Configuration files must be readable",
      "Default configuration file must exist",
      "Installation configuration file path must be determined from defaults"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "SystemConfig": {
        "appPath": "string",
        "mainConfigurationFile": "string",
        "installationConfig": "string",
        "resourceDir": "string"
      }
    }
  },
  {
    "featureName": "ManageConfigurationValues",
    "description": "Sets, retrieves and manages configuration properties with support for different data types.",
    "inputValues": [
      "field-string-ConfigurationKey",
      "value-object-ConfigurationValue",
      "configFile-string-FilePath"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the following inputs:\n     a. field (mandatory): Configuration key name as string\n     b. value (mandatory): Configuration value which can be string, number, boolean, or object\n     c. configFile (optional): Path to configuration file\n     d. operation (mandatory): Type of operation (get, set, save, load, reset)\n\n2. Data Validation:\n   - Validate configuration key (field):\n     a. Check if field is not null or empty\n     b. Verify field follows naming convention\n     c. Return error if validation fails\n   - Validate configuration value:\n     a. For string values: Check for proper formatting\n     b. For numeric values: Verify it's a valid number\n     c. For boolean values: Ensure it's either \"true\" or \"false\"\n     d. For object values: Validate object structure\n   - Validate file path if provided:\n     a. Check if file exists\n     b. Verify read/write permissions\n     c. Return error if file is inaccessible\n\n3. Business Rule Processing:\n   - Check operation type and apply corresponding rules:\n     a. For GET operations:\n       i. Check if configuration exists in system\n       ii. Determine data type of requested configuration\n     b. For SET operations:\n       i. Verify if configuration is modifiable\n       ii. Check if value type matches expected type\n     c. For LOAD operations:\n       i. Verify file format is valid\n       ii. Check for duplicate configuration keys\n     d. For SAVE operations:\n       i. Ensure system has write permissions\n       ii. Check if there are changes to save\n     e. For RESET operations:\n       i. Confirm reset operation is allowed\n       ii. Identify which configurations to reset\n\n4. Core Operation Execution:\n   - Execute the requested operation:\n     a. For GET operations:\n       i. Retrieve value from configuration store\n       ii. Convert to appropriate data type (string, int, boolean, object)\n       iii. Apply variable expansion if needed\n     b. For SET operations:\n       i. Store value in appropriate configuration store (default, installation, or transient)\n       ii. Clear any cached values\n       iii. Update in-memory representation\n     c. For LOAD operations:\n       i. Open configuration file\n       ii. Parse file contents\n       iii. Load values into appropriate store\n       iv. Close file resources\n     d. For SAVE operations:\n       i. Sort configuration keys\n       ii. Create output stream to file\n       iii. Write configuration data\n       iv. Close file resources\n     e. For RESET operations:\n       i. Clear specified configuration stores\n       ii. Reload default values if needed\n\n5. Response Generation:\n   - Generate appropriate response based on operation:\n     a. For GET operations:\n       i. Return requested value with proper type\n       ii. Include metadata about the configuration if requested\n     b. For SET operations:\n       i. Confirm value was set successfully\n       ii. Return updated value for verification\n     c. For LOAD operations:\n       i. Return count of loaded configurations\n       ii. Include any warnings about overwritten values\n     d. For SAVE operations:\n       i. Confirm save was successful\n       ii. Include path where configuration was saved\n     e. For RESET operations:\n       i. Confirm reset was successful\n       ii. Include count of reset configurations",
    "databaseEntities": [],
    "validationRules": [
      "Configuration key must not be null or empty",
      "Configuration file path must be valid if provided",
      "Configuration value must match expected data type",
      "File must exist and be accessible for load operations",
      "System must have write permissions for save operations",
      "Variable references in configuration values must be resolvable"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "ConfigurationValue": {
        "type": "object",
        "properties": {
          "stringValue": {
            "type": "string",
            "description": "String representation of the configuration value"
          },
          "intValue": {
            "type": "integer",
            "description": "Integer representation of the configuration value"
          },
          "booleanValue": {
            "type": "boolean",
            "description": "Boolean representation of the configuration value"
          },
          "objectValue": {
            "type": "object",
            "description": "Object representation of the configuration value"
          },
          "valueType": {
            "type": "string",
            "enum": [
              "string",
              "integer",
              "boolean",
              "object"
            ],
            "description": "Type of the configuration value"
          }
        }
      }
    }
  },
  {
    "featureName": "SaveInstallationSettings",
    "description": "Persists installation-specific configuration values to a file.",
    "inputValues": [
      "installationConfig-string-ConfigFile",
      "configurationValues-object-ConfigurationProperties"
    ],
    "businessLogic": "1. Input Collection\n   - Collect the following inputs:\n     a. installationConfig (string, mandatory): Path to the installation configuration file\n     b. configurationValues (object, mandatory): Collection of key-value pairs representing configuration settings\n     c. System-generated timestamp (date, system-generated): Current date and time for tracking when settings were saved\n\n2. Data Validation\n   - Validate installation configuration file path:\n     a. Check if the path is not empty\n     b. Verify the path format is valid for the operating system\n     c. Ensure the directory exists and is writable\n     d. IF validation fails, THEN generate appropriate error message\n   - Validate configuration values:\n     a. Verify the configuration object is not null\n     b. Check that required configuration keys are present\n     c. Validate that values have appropriate data types for their respective settings\n     d. IF any validation fails, THEN generate detailed error message indicating which setting is invalid\n\n3. Business Rule Processing\n   - Check system state:\n     a. Verify the system is in a state that allows configuration changes\n     b. Ensure no other process is currently modifying the configuration file\n     c. IF the system is in an invalid state, THEN abort the operation and return appropriate error\n   - Verify user permissions:\n     a. Check if the current user has sufficient privileges to modify system settings\n     b. IF user lacks permissions, THEN generate an access denied error\n   - Validate configuration consistency:\n     a. Ensure the new configuration values don't conflict with each other\n     b. Verify the new settings won't cause system instability\n\n4. Core Operation Execution\n   - Prepare configuration data:\n     a. Create a sorted collection of all configuration properties\n     b. Format each property as a key-value pair\n     c. Add metadata including save timestamp and user information\n   - Create backup of existing configuration:\n     a. Check if the configuration file already exists\n     b. IF file exists, THEN create a backup copy with timestamp\n     c. Store backup in designated backup location\n   - Write configuration to file:\n     a. Create output stream to the configuration file\n     b. Write header information including timestamp and purpose\n     c. Write each configuration property in sorted order\n     d. Ensure proper formatting of the configuration file\n     e. Close the output stream properly\n     f. IF any error occurs during write, THEN restore from backup and report error\n   - Update runtime configuration:\n     a. Update the in-memory configuration with new values\n     b. Clear any cached values that depend on the changed settings\n\n5. Response Generation\n   - Success response:\n     a. Generate confirmation message that settings were saved successfully\n     b. Include timestamp of when the settings were saved\n     c. Provide summary of changes made (new settings vs. previous settings)\n   - Error response:\n     a. Detailed error message explaining what went wrong\n     b. Suggested remediation steps\n     c. Technical details for troubleshooting (for admin users)\n   - Notification:\n     a. Log the configuration change in system logs\n     b. Notify administrators about the configuration change if required",
    "databaseEntities": [],
    "validationRules": [
      "Installation configuration file path must not be empty",
      "Installation configuration file directory must exist and be writable",
      "Configuration values object must not be null",
      "Required configuration keys must be present",
      "Configuration values must have appropriate data types",
      "User must have sufficient privileges to modify system settings",
      "New configuration values must not conflict with each other"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "ConfigurationProperties": {
        "type": "object",
        "properties": {
          "properties": {
            "type": "object",
            "description": "Key-value pairs representing configuration settings",
            "additionalProperties": {
              "type": "string"
            }
          }
        },
        "required": [
          "properties"
        ]
      }
    }
  },
  {
    "featureName": "LoadSqlQueries",
    "description": "Loads SQL query definitions from external files for database operations.",
    "inputValues": [
      "queryFile-string-FilePath"
    ],
    "businessLogic": "1. Input Collection\n   - Collect the following inputs:\n     - queryFile (string, mandatory): Complete file path to the SQL queries file\n     - No default values are provided\n     - No system-generated fields are required\n\n2. Data Validation\n   - Validate the queryFile input:\n     - Check if queryFile is not null or empty\n       IF queryFile is null or empty THEN\n         Generate error message: \"Query file path cannot be empty\"\n     - Check if the file exists at the specified path\n       IF file does not exist THEN\n         Generate error message: \"SQL query file not found at the specified location\"\n     - Check if the file is readable\n       IF file is not readable THEN\n         Generate error message: \"SQL query file cannot be accessed or read\"\n     - Check if the file has the correct format (properties file format)\n       IF file format is invalid THEN\n         Generate error message: \"Invalid SQL query file format\"\n\n3. Business Rule Processing\n   - Check system state for query loading:\n     - Verify if the system is in a state where SQL queries can be loaded\n       IF system is not in proper initialization state THEN\n         Generate error message: \"System not ready to load SQL queries\"\n     - Check if queries storage is available and ready\n       IF queries storage is not available THEN\n         Generate error message: \"Query storage mechanism not available\"\n   - Check for potential conflicts:\n     - Determine if loading new queries would overwrite existing critical queries\n       IF critical queries would be overwritten without explicit permission THEN\n         Generate warning: \"Loading this file will overwrite existing queries\"\n\n4. Core Operation Execution\n   - Initialize file input stream:\n     - Create a file input stream for the query file\n     - Set the stream to null initially for proper resource management\n   - Load queries from file:\n     - Open the file input stream to the specified query file\n     - Load the SQL query definitions from the file into the queries storage\n     - Each query should be stored with its name as the key and SQL statement as the value\n   - Handle exceptions during loading:\n     - IF any I/O errors occur during file reading THEN\n       - Close any open resources\n       - Log the error details\n       - Generate error message: \"Failed to load SQL queries from file\"\n   - Resource cleanup:\n     - Ensure the file input stream is properly closed regardless of success or failure\n     - Release any locks or resources associated with the file\n\n5. Response Generation\n   - Success response:\n     - Indicate successful loading of SQL queries\n     - Include the number of SQL queries loaded\n     - Provide confirmation message: \"SQL queries successfully loaded from file\"\n   - Error response:\n     - Include detailed error information if the operation failed\n     - Provide guidance on resolving common issues\n     - Include system state information relevant to troubleshooting\n   - Additional information:\n     - List any queries that were updated or overwritten\n     - Provide information on how to access the loaded queries",
    "databaseEntities": [
      "jforum_users",
      "jforum_groups",
      "jforum_categories",
      "jforum_forums",
      "jforum_topics",
      "jforum_posts",
      "jforum_posts_text",
      "jforum_attachments",
      "jforum_privmsgs",
      "jforum_privmsgs_text",
      "jforum_moderator_groups",
      "jforum_user_groups",
      "jforum_sessions",
      "jforum_smilies",
      "jforum_words",
      "jforum_karma",
      "jforum_bookmarks",
      "jforum_quota_limit",
      "jforum_extension_groups"
    ],
    "validationRules": [
      "Query file path must not be empty",
      "SQL query file must exist at the specified location",
      "SQL query file must be readable",
      "SQL query file must be in valid properties format",
      "System must be in proper initialization state to load queries",
      "Query storage mechanism must be available"
    ],
    "dbSeedingOperations": [],
    "schema": {}
  },
  {
    "featureName": "ExpandConfigurationVariables",
    "description": "Processes configuration values containing variable references for dynamic configuration.",
    "inputValues": [
      "configValue-string-Configuration",
      "variableStore-object-VariableStore"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the configuration value string that may contain variable references\n   - Obtain reference to the variable store that contains actual values\n   - Identify the variable delimiter patterns (start and end markers)\n   - Determine if cache should be used for optimization\n\n2. Data Validation:\n   - Validate that the configuration value is not null\n     * IF configuration value is null THEN\n       - Return null as there is nothing to process\n     * END IF\n   - Validate that the variable store is accessible\n     * IF variable store is not accessible THEN\n       - Generate appropriate error message\n       - Abort the expansion process\n     * END IF\n   - Verify that the variable delimiters are properly defined\n     * IF start or end delimiters are not defined THEN\n       - Use system default delimiters\n     * END IF\n\n3. Business Rule Processing:\n   - Check if the configuration value contains any variable references\n     * IF no variable references are found THEN\n       - Return the original configuration value unchanged\n     * END IF\n   - Determine if any circular references exist in the variable definitions\n     * IF circular references are detected THEN\n       - Generate appropriate error message\n       - Break the circular reference by returning partially expanded value\n     * END IF\n   - Check if the expansion cache should be cleared\n     * IF cache invalidation is requested THEN\n       - Clear the existing variable expansion cache\n     * END IF\n\n4. Core Operation Execution:\n   - Parse the configuration value to identify variable references\n     * FOR each variable reference found in the configuration value\n       - Extract the variable name from between the delimiters\n       - Look up the variable value in the variable store\n       - IF variable exists in the store THEN\n         - Replace the variable reference with its actual value\n       - ELSE\n         - Leave the variable reference unchanged\n       - END IF\n     * END FOR\n   - Check if the expanded result contains further variable references\n     * WHILE expanded result contains variable references AND maximum recursion depth not reached\n       - Perform another round of variable expansion\n     * END WHILE\n   - Store the fully expanded result in cache if caching is enabled\n\n5. Response Generation:\n   - Return the fully expanded configuration value\n   - IF any variables could not be resolved THEN\n     - Log appropriate warnings about unresolved variables\n   - END IF\n   - IF maximum recursion depth was reached THEN\n     - Log warning about possible circular references\n   - END IF",
    "databaseEntities": [],
    "validationRules": [
      "Configuration value must be properly formatted with matching delimiters",
      "Variable references must use the correct syntax with start and end markers",
      "Variable store must be accessible during expansion",
      "Circular references in variable definitions must be detected and handled",
      "Maximum recursion depth must not be exceeded during expansion"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "VariableStore": {
        "type": "object",
        "properties": {
          "getVariableValue": {
            "type": "function",
            "description": "Returns the value of a variable from the store"
          }
        },
        "required": [
          "getVariableValue"
        ]
      }
    }
  },
  {
    "featureName": "ReloadSystemConfiguration",
    "description": "Reloads system configuration when configuration files change.",
    "inputValues": [
      "filename-string-ConfigFile"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the filename (string) of the changed configuration file\n   - System will automatically detect when a monitored file changes\n   - No user input required as this is a system-triggered process\n\n2. Data Validation:\n   - Validate the filename exists in the system\n     * IF filename is null or empty THEN\n       - Log an error message\n       - Abort the reload process\n     * IF file does not exist in the system THEN\n       - Log a warning message\n       - Abort the reload process\n   - Validate the file has proper read permissions\n     * IF file cannot be read THEN\n       - Log an error message about permission issues\n       - Abort the reload process\n\n3. Business Rule Processing:\n   - Check if system is in a state where configuration can be reloaded\n     * IF system is currently initializing THEN\n       - Queue the reload request for later processing\n       - Exit the current process\n     * IF another reload operation is in progress THEN\n       - Queue this request or skip based on system policy\n       - Log appropriate message\n   - Determine configuration type based on filename\n     * IF file is a core configuration file THEN\n       - Mark for complete system reload\n     * IF file is a module-specific configuration THEN\n       - Mark only affected modules for reload\n\n4. Core Operation Execution:\n   - Log the start of reload operation with filename information\n   - Initialize the configuration reload process\n     * Reset configuration cache for affected components\n     * Load new configuration values from the changed file\n     * Apply new configuration values to the system\n   - Update dependent components\n     * Notify all registered configuration listeners about changes\n     * Restart services that require restart after configuration changes\n   - Verify configuration integrity\n     * Check for missing required configuration values\n     * Validate configuration value formats and ranges\n     * IF validation fails THEN\n       - Log detailed error information\n       - Attempt to restore previous configuration\n       - Notify administrators about configuration issues\n\n5. Response Generation:\n   - Log the completion status of the reload operation\n     * IF reload was successful THEN\n       - Log success message with details of changes applied\n       - Update system status indicators\n     * IF reload failed THEN\n       - Log detailed error information\n       - Indicate which parts of the system may be affected\n       - Provide recovery suggestions\n   - Notify administrators about the configuration change\n     * Include timestamp, filename, and reload status\n     * Provide summary of significant configuration changes",
    "databaseEntities": [],
    "validationRules": [
      "Configuration filename must not be empty",
      "Configuration file must exist in the system",
      "Configuration file must have proper read permissions",
      "System must not be in initialization state during reload",
      "Configuration values must meet required format specifications"
    ],
    "dbSeedingOperations": [],
    "schema": {}
  },
  {
    "featureName": "ExpandVariables",
    "description": "Replaces variable placeholders in text with their actual values from a variable store.",
    "inputValues": [
      "source-string-Text",
      "variables-object-VariableStore",
      "pre-string-Prefix",
      "post-string-Suffix"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the following inputs:\n     a. source (string): The text containing variable placeholders to be expanded\n     b. variables (object): A variable store containing key-value pairs\n     c. pre (string): The prefix that marks the beginning of a variable placeholder\n     d. post (string): The suffix that marks the end of a variable placeholder\n   - System will use an internal cache to store previously processed texts\n\n2. Data Validation:\n   - Validate source text:\n     a. IF source is null THEN\n        i. Return null as there is nothing to process\n     b. Check if source exists in cache:\n        i. IF source exists in cache THEN\n           1. Return cached result immediately\n   - Validate variable markers:\n     a. Ensure pre and post are non-empty strings\n     b. Ensure variables store is properly initialized\n\n3. Business Rule Processing:\n   - Check for variable placeholders:\n     a. Search for the first occurrence of prefix in the source text\n     b. IF no prefix is found THEN\n        i. Return the original source text unchanged\n\n4. Core Operation Execution:\n   - Initialize a string buffer with the source text\n   - WHILE prefix is found in the text:\n     a. Find the position of the next suffix\n     b. Extract the variable name between prefix and suffix\n     c. IF prefix is at position 0 THEN\n        i. Handle special case for start of string\n        ii. Extract variable name accounting for position\n     d. ELSE\n        i. Extract variable name normally\n     e. Retrieve the variable value from the variable store\n     f. Replace the entire placeholder (prefix + name + suffix) with the variable value\n     g. Search for the next prefix occurrence\n   - Convert the modified buffer back to a string\n   - Store the result in the cache using the original source as key\n\n5. Response Generation:\n   - Return the processed text with all variables expanded\n   - IF any variable names are not found in the store THEN\n     a. The system should use whatever default behavior is defined in the variable store\n   - Ensure the cache is maintained for future lookups",
    "databaseEntities": [],
    "validationRules": [
      "Source text may be null, which returns null result",
      "If no variable placeholders exist, return original text unchanged",
      "Variable names must exist between prefix and suffix markers",
      "Variable store must contain values for all referenced variables"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "VariableStore": {
        "type": "object",
        "properties": {
          "getVariableValue": {
            "type": "function",
            "description": "Retrieves the value for a given variable name"
          }
        },
        "required": [
          "getVariableValue"
        ]
      }
    }
  },
  {
    "featureName": "ClearCache",
    "description": "Clears the internal cache of previously expanded variable strings.",
    "inputValues": [],
    "businessLogic": "1. Input Collection:\n   - No user inputs required for this operation\n   - This is a system-initiated operation\n\n2. Data Validation:\n   - No input validation required as there are no user inputs\n\n3. Business Rule Processing:\n   - Verify that the cache system is currently active\n   - IF cache system is not initialized THEN\n     - Log warning that cache clearing was attempted on inactive cache\n     - Skip operation\n   - END IF\n\n4. Core Operation Execution:\n   - Access the internal cache storage mechanism\n   - Remove all entries from the cache container\n   - Release any resources associated with cached items\n   - Reset cache statistics if applicable\n   - IF cache clearing operation fails THEN\n     - Log error details\n     - Attempt recovery of cache to stable state\n   - END IF\n\n5. Response Generation:\n   - Indicate successful cache clearing operation\n   - Return confirmation that cache has been emptied\n   - Include statistics about number of items cleared if available",
    "databaseEntities": [],
    "validationRules": [
      "Cache system must be initialized before clearing"
    ],
    "dbSeedingOperations": [],
    "schema": {}
  },
  {
    "featureName": "CreateRSS",
    "description": "Generates RSS feed content by processing a template with RSS data.",
    "inputValues": [
      "rssData-object-RSS"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect RSS data object containing feed information\n     - Channel information (title, description, link)\n     - Feed items (entries with title, description, link, publication date)\n     - Feed metadata (language, copyright, publication date)\n   - Template location for RSS rendering\n   - Character encoding for the output\n\n2. Data Validation:\n   - Validate RSS data object\n     - Verify RSS object is not null\n     - Ensure required channel properties are present (title, link, description)\n     - Validate that at least one feed item exists in the collection\n     - Check that each feed item has required properties (title, link)\n   - Validate template availability\n     - Ensure the RSS template file exists\n     - Verify the template has proper format for RSS generation\n   - Validate character encoding\n     - Ensure specified encoding is supported\n     - Default to system encoding if not specified\n\n3. Business Rule Processing:\n   - Apply content formatting rules\n     - Format dates according to RSS specification\n     - Ensure content descriptions follow allowed HTML guidelines\n     - Apply character limits if configured\n   - Apply system configuration settings\n     - Use system-defined template directory\n     - Apply configured encoding settings\n   - Prepare template processing context\n     - Create context with all required variables\n     - Add RSS object to template context\n     - Add encoding information to template context\n\n4. Core Operation Execution:\n   - Initialize template engine\n     - Load template configuration\n     - Locate the RSS template file\n   - Prepare output writer\n     - Create string writer for output collection\n   - Process template with RSS data\n     - Combine template with RSS data context\n     - Generate formatted XML output\n     - Capture complete output in string format\n   - Handle processing exceptions\n     - Catch any template processing errors\n     - Wrap technical exceptions in appropriate business exceptions\n     - Include error details for troubleshooting\n\n5. Response Generation:\n   - Format final RSS output\n     - Ensure proper XML formatting\n     - Validate against RSS specification requirements\n   - Return generated RSS content\n     - Provide complete XML string\n     - Include appropriate content type information\n   - Handle error scenarios\n     - Return appropriate error messages for validation failures\n     - Provide troubleshooting information for template processing errors",
    "databaseEntities": [
      "jforum_topics",
      "jforum_posts",
      "jforum_forums",
      "jforum_categories"
    ],
    "validationRules": [
      "RSS data object must not be null",
      "RSS channel must have a title",
      "RSS channel must have a description",
      "RSS channel must have a link",
      "RSS feed must contain at least one item",
      "Each RSS item must have a title and link",
      "Template file must exist and be accessible",
      "Character encoding must be supported by the system"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "RSS": {
        "type": "object",
        "properties": {
          "channel": {
            "type": "object",
            "properties": {
              "title": {
                "type": "string",
                "description": "The title of the RSS feed"
              },
              "link": {
                "type": "string",
                "description": "The URL to the website corresponding to the feed"
              },
              "description": {
                "type": "string",
                "description": "Description of the feed"
              },
              "language": {
                "type": "string",
                "description": "The language the feed is written in"
              },
              "pubDate": {
                "type": "string",
                "description": "Publication date of the feed"
              },
              "lastBuildDate": {
                "type": "string",
                "description": "The last time the content was updated"
              },
              "copyright": {
                "type": "string",
                "description": "Copyright notice for the feed content"
              }
            },
            "required": [
              "title",
              "link",
              "description"
            ]
          },
          "items": {
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "title": {
                  "type": "string",
                  "description": "The title of the item"
                },
                "link": {
                  "type": "string",
                  "description": "The URL to the item"
                },
                "description": {
                  "type": "string",
                  "description": "The item synopsis"
                },
                "author": {
                  "type": "string",
                  "description": "Email address of the author"
                },
                "pubDate": {
                  "type": "string",
                  "description": "Publication date of the item"
                },
                "guid": {
                  "type": "string",
                  "description": "Unique identifier for the item"
                }
              },
              "required": [
                "title",
                "link"
              ]
            }
          }
        },
        "required": [
          "channel",
          "items"
        ]
      }
    }
  },
  {
    "featureName": "CreateRssDocument",
    "description": "Creates a new RSS document with title, description, encoding and link information.",
    "inputValues": [
      "title-string-RSS",
      "description-string-RSS",
      "encoding-string-RSS",
      "link-string-RSS",
      "items-object-RSSItem"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the following required inputs:\n     1.1. title (string): The title of the RSS document\n     1.2. description (string): The description of the RSS document\n     1.3. encoding (string): The character encoding for the document\n     1.4. link (string): The main document link\n     1.5. items (optional): Collection of RSS items to be included\n\n2. Data Validation:\n   2.1. Validate title:\n      - Check if title is not empty\n      - IF title is empty THEN\n        - Generate error message: \"RSS document title cannot be empty\"\n      - END IF\n   2.2. Validate description:\n      - Check if description is not empty\n      - IF description is empty THEN\n        - Generate error message: \"RSS document description cannot be empty\"\n      - END IF\n   2.3. Validate encoding:\n      - Check if encoding is not empty\n      - IF encoding is empty THEN\n        - Generate error message: \"Character encoding must be specified\"\n      - END IF\n   2.4. Validate link:\n      - Check if link is not empty\n      - IF link is empty THEN\n        - Generate error message: \"Document link cannot be empty\"\n      - END IF\n      - Check if link is in valid URL format\n      - IF link format is invalid THEN\n        - Generate error message: \"Document link must be a valid URL\"\n      - END IF\n\n3. Business Rule Processing:\n   3.1. Check system state for RSS document creation:\n      - Verify if the system allows RSS document creation\n      - IF system does not allow RSS document creation THEN\n        - Generate error message: \"RSS document creation is currently disabled\"\n        - Terminate the process\n      - END IF\n   3.2. Check for duplicate RSS documents:\n      - IF an RSS document with identical title and link already exists THEN\n        - Generate warning: \"A similar RSS document already exists\"\n      - END IF\n\n4. Core Operation Execution:\n   4.1. Create new RSS document:\n      - Initialize a new RSS document with provided title, description, encoding, and link\n      - Initialize an empty collection for RSS items\n   4.2. Add items to RSS document (if provided):\n      - FOR EACH item in the provided items collection:\n        - Validate the item has required fields (title, description, link)\n        - IF item is valid THEN\n          - Add the item to the RSS document's items collection\n        - ELSE\n          - Skip invalid item and log warning\n        - END IF\n      - END FOR\n   4.3. Finalize RSS document:\n      - Set any default values for optional fields not provided\n      - Prepare the document for output or storage\n\n5. Response Generation:\n   5.1. Generate success response:\n      - Include the created RSS document with its properties:\n        - title\n        - description\n        - encoding\n        - link\n        - count of items added\n      - Provide confirmation message: \"RSS document successfully created\"\n   5.2. In case of failure:\n      - Include detailed error information\n      - Suggest possible solutions based on the error type\n      - Provide support information if needed",
    "databaseEntities": [],
    "validationRules": [
      "RSS document title must not be empty",
      "RSS document description must not be empty",
      "Character encoding must be specified",
      "Document link must not be empty",
      "Document link must be a valid URL",
      "Each RSS item must have a title, description, and link"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "RSSItem": {
        "type": "object",
        "properties": {
          "title": {
            "type": "string",
            "description": "The title of the RSS item"
          },
          "description": {
            "type": "string",
            "description": "The description of the RSS item"
          },
          "link": {
            "type": "string",
            "description": "The link to the full content of the RSS item"
          },
          "publicationDate": {
            "type": "string",
            "description": "The publication date of the RSS item"
          }
        },
        "required": [
          "title",
          "description",
          "link"
        ]
      }
    }
  },
  {
    "featureName": "AddRssItem",
    "description": "Adds a new item entry to an RSS document.",
    "inputValues": [
      "item-object-RSSItem"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the RSSItem object with the following properties:\n     * title: The title of the RSS item\n     * description: The description of the RSS item\n     * link: The link to the full content\n     * pubDate: The publication date of the item\n     * author: The author of the item (optional)\n     * categories: List of categories the item belongs to (optional)\n   - Verify the RSS document instance is properly initialized with:\n     * title: The document title\n     * description: The document description\n     * encoding: The character encoding\n     * link: The main document link\n\n2. Data Validation:\n   - Validate the RSSItem object:\n     * Verify title is not null or empty\n       IF title is null or empty THEN\n         Generate error: \"RSS item title cannot be empty\"\n       END IF\n     * Verify description is not null or empty\n       IF description is null or empty THEN\n         Generate error: \"RSS item description cannot be empty\"\n       END IF\n     * Verify link is not null and has valid URL format\n       IF link is null or invalid format THEN\n         Generate error: \"RSS item link must be a valid URL\"\n       END IF\n     * Verify pubDate is in valid date format\n       IF pubDate is provided and has invalid format THEN\n         Generate error: \"Publication date must be in valid format\"\n       END IF\n\n3. Business Rule Processing:\n   - Check if the RSS document has reached maximum allowed items (if applicable)\n     IF maximum item limit is defined AND current items count >= maximum limit THEN\n       Generate warning: \"Maximum RSS items limit reached\"\n       Determine if oldest items should be removed or new item rejected\n     END IF\n   - Check for duplicate items\n     FOR EACH existing item in RSS document\n       IF existing item has same link as new item THEN\n         Generate warning: \"Item with this link already exists\"\n         Determine if item should be updated or rejected\n       END IF\n     END FOR\n\n4. Core Operation Execution:\n   - Add the validated RSSItem to the RSS document's items collection\n     * Access the internal list of items in the RSS document\n     * Add the new RSSItem object to the list\n   - Update any internal indices or references if necessary\n   - Update the last modified timestamp of the RSS document if applicable\n\n5. Response Generation:\n   - On Success:\n     * Return confirmation that the item was added successfully\n     * Include the current count of items in the RSS document\n   - On Failure:\n     * Return appropriate error message based on validation failures\n     * Include guidance on how to correct the issue",
    "databaseEntities": [],
    "validationRules": [
      "RSS item title must not be empty",
      "RSS item description must not be empty",
      "RSS item link must be a valid URL",
      "Publication date must be in valid format if provided",
      "RSS document must be initialized before adding items"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "RSSItem": {
        "type": "object",
        "properties": {
          "title": {
            "type": "string",
            "description": "The title of the RSS item"
          },
          "description": {
            "type": "string",
            "description": "The description of the RSS item"
          },
          "link": {
            "type": "string",
            "description": "The link to the full content"
          },
          "pubDate": {
            "type": "string",
            "description": "The publication date of the item"
          },
          "author": {
            "type": "string",
            "description": "The author of the item"
          },
          "categories": {
            "type": "array",
            "description": "List of categories the item belongs to",
            "items": {
              "type": "string"
            }
          }
        },
        "required": [
          "title",
          "description",
          "link"
        ]
      }
    }
  },
  {
    "featureName": "RetrieveRssItems",
    "description": "Retrieves all item entries associated with an RSS document.",
    "inputValues": [
      "rssDocument-object-RSS"
    ],
    "businessLogic": "1. Input Collection\n   - Collect the RSS document object with the following properties:\n     * title: The document title\n     * description: The document description\n     * encoding: The character encoding\n     * link: The main document link\n     * items: The list of RSS items\n   - System will use the provided RSS document to retrieve its items\n\n2. Data Validation\n   - Validate the RSS document input:\n     * Check if the RSS document object is not null\n     * Verify that the RSS document has been properly initialized\n     * Ensure the items collection within the RSS document has been initialized\n   - IF any validation fails, THEN:\n     * Generate appropriate error message\n     * Terminate the retrieval process\n\n3. Business Rule Processing\n   - Verify access permissions to the RSS document\n   - Check if the RSS document is in a valid state for item retrieval\n   - IF the RSS document is not accessible or in an invalid state, THEN:\n     * Generate appropriate error message\n     * Terminate the retrieval process\n\n4. Core Operation Execution\n   - Access the internal items collection of the RSS document\n   - Prepare the collection for return to the caller\n   - IF the items collection is empty, THEN:\n     * Return an empty collection\n   - ELSE:\n     * Return the complete collection of RSS items\n\n5. Response Generation\n   - Format the response containing all RSS items\n   - Include the following information for each item in the collection:\n     * Item title\n     * Item description\n     * Item link\n     * Item publication date\n     * Any additional item metadata\n   - Return the complete collection to the caller",
    "databaseEntities": [],
    "validationRules": [
      "RSS document must not be null",
      "RSS document must be properly initialized",
      "Items collection must be initialized"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "RSS": {
        "title": "string",
        "description": "string",
        "encoding": "string",
        "link": "string",
        "items": "array"
      },
      "RSSItem": {
        "title": "string",
        "description": "string",
        "link": "string",
        "publicationDate": "date"
      }
    }
  },
  {
    "featureName": "GetRssDocumentProperties",
    "description": "Retrieves RSS document properties including title, description, encoding and link.",
    "inputValues": [
      "rssDocument-object-RSS"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the RSS document object with the following properties:\n     * title (mandatory): The title of the RSS document\n     * description (mandatory): The description of the RSS document\n     * encoding (mandatory): The character encoding of the document\n     * link (mandatory): The main link of the RSS document\n     * items (optional): List of RSS items associated with the document\n\n2. Data Validation:\n   - Validate RSS document object:\n     * Check if the RSS document object is not null\n     * IF RSS document is null THEN\n       - Return an error indicating invalid RSS document\n     * END IF\n\n3. Business Rule Processing:\n   - Verify RSS document integrity:\n     * Check if all required properties (title, description, encoding, link) are present\n     * IF any required property is missing THEN\n       - Return an error indicating which required property is missing\n     * END IF\n\n4. Core Operation Execution:\n   - Extract RSS document properties:\n     * Retrieve the title property from the RSS document\n     * Retrieve the description property from the RSS document\n     * Retrieve the encoding property from the RSS document\n     * Retrieve the link property from the RSS document\n     * Optionally retrieve the list of RSS items if needed\n\n5. Response Generation:\n   - Compile the RSS document properties:\n     * Create a response containing:\n       - title: The document title\n       - description: The document description\n       - encoding: The character encoding\n       - link: The main document link\n       - itemCount: The number of items in the RSS document (if items were retrieved)\n     * Return the compiled properties to the requester",
    "databaseEntities": [],
    "validationRules": [
      "RSS document object must not be null",
      "Title property must be present in the RSS document",
      "Description property must be present in the RSS document",
      "Encoding property must be present in the RSS document",
      "Link property must be present in the RSS document"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "RSS": {
        "type": "object",
        "properties": {
          "title": {
            "type": "string",
            "description": "The title of the RSS document"
          },
          "description": {
            "type": "string",
            "description": "The description of the RSS document"
          },
          "encoding": {
            "type": "string",
            "description": "The character encoding of the document"
          },
          "link": {
            "type": "string",
            "description": "The main link of the RSS document"
          },
          "items": {
            "type": "array",
            "description": "List of RSS items in the document",
            "items": {
              "type": "object",
              "description": "Individual RSS item"
            }
          }
        },
        "required": [
          "title",
          "description",
          "encoding",
          "link"
        ]
      }
    }
  },
  {
    "featureName": "ManageRssItemContent",
    "description": "Manages RSS item content with properties like author, title, description, and publication date.",
    "inputValues": [
      "author-string-RSSItem",
      "title-string-RSSItem",
      "description-string-RSSItem",
      "link-string-RSSItem",
      "contentType-string-RSSItem",
      "publishDate-string-RSSItem",
      "category-string-RSSItem"
    ],
    "businessLogic": "1. Input Collection:\n   1.1. Collect the following input fields:\n       - author (string, optional): Name of the content creator\n       - title (string, mandatory): Title of the RSS item\n       - description (string, mandatory): Content description of the RSS item\n       - link (string, mandatory): URL reference to the original content\n       - contentType (string, optional): Format of the description content (default: \"text/html\")\n       - publishDate (string, optional): Publication date and time of the content\n       - category (string, optional): Category classification for the content\n\n2. Data Validation:\n   2.1. Validate title field:\n       - IF title is empty or null THEN\n           - Generate error message: \"Title is required for RSS item\"\n       - IF title exceeds maximum allowed length (200 characters) THEN\n           - Generate error message: \"Title exceeds maximum allowed length\"\n   2.2. Validate description field:\n       - IF description is empty or null THEN\n           - Generate error message: \"Description is required for RSS item\"\n   2.3. Validate link field:\n       - IF link is empty or null THEN\n           - Generate error message: \"Link is required for RSS item\"\n       - IF link format is invalid (not a proper URL) THEN\n           - Generate error message: \"Link must be a valid URL\"\n   2.4. Validate contentType field (if provided):\n       - IF contentType is provided AND not one of the allowed values (\"text/html\", \"text/plain\") THEN\n           - Generate error message: \"Content type must be either text/html or text/plain\"\n       - IF contentType is not provided THEN\n           - Set contentType to default value \"text/html\"\n   2.5. Validate publishDate format (if provided):\n       - IF publishDate is provided AND format is invalid THEN\n           - Generate error message: \"Publish date must be in a valid date format\"\n\n3. Business Rule Processing:\n   3.1. Check system state for RSS functionality:\n       - IF RSS functionality is disabled in system settings THEN\n           - Generate error message: \"RSS functionality is currently disabled\"\n   3.2. Verify user permissions (if applicable):\n       - IF current user does not have permission to create/modify RSS content THEN\n           - Generate error message: \"Insufficient permissions to manage RSS content\"\n   3.3. Check content restrictions:\n       - IF description contains blocked content or exceeds size limits THEN\n           - Generate error message: \"Content contains restricted material or exceeds size limits\"\n\n4. Core Operation Execution:\n   4.1. Create or update RSS item object:\n       - Create new RSS item instance if not exists\n       - Set author property with provided author value\n       - Set title property with provided title value\n       - Set description property with provided description value\n       - Set link property with provided link value\n       - Set contentType property with provided or default contentType value\n       - Set publishDate property with provided publishDate value\n   4.2. Process categories:\n       - IF category is provided THEN\n           - Add category to the RSS item's categories collection\n       - IF multiple categories are provided THEN\n           - Add each category to the RSS item's categories collection\n   4.3. Finalize RSS item:\n       - Ensure all required properties are set\n       - Format content according to RSS specifications\n\n5. Response Generation:\n   5.1. For successful operation:\n       - Return success status\n       - Include the complete RSS item object with all properties\n       - Include any generated identifiers or timestamps\n   5.2. For failed operation:\n       - Return error status\n       - Include specific error messages for each validation or processing failure\n       - Provide guidance on how to correct the issues",
    "databaseEntities": [],
    "validationRules": [
      "Title must not be empty",
      "Description must not be empty",
      "Link must not be empty",
      "Link must be a valid URL",
      "Content type must be either text/html or text/plain if provided",
      "Publish date must be in a valid date format if provided"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "RSSItem": {
        "type": "object",
        "properties": {
          "author": {
            "type": "string",
            "description": "Name of the content creator"
          },
          "title": {
            "type": "string",
            "description": "Title of the RSS item"
          },
          "description": {
            "type": "string",
            "description": "Content description of the RSS item"
          },
          "link": {
            "type": "string",
            "description": "URL reference to the original content"
          },
          "contentType": {
            "type": "string",
            "description": "Format of the description content",
            "enum": [
              "text/html",
              "text/plain"
            ],
            "default": "text/html"
          },
          "publishDate": {
            "type": "string",
            "description": "Publication date and time of the content"
          },
          "categories": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "List of categories associated with the RSS item"
          }
        },
        "required": [
          "title",
          "description",
          "link"
        ]
      }
    }
  },
  {
    "featureName": "AddRssItemCategory",
    "description": "Associates categories with RSS items to enable content classification.",
    "inputValues": [
      "rssItem-object-RSSItem",
      "categoryName-string-Category"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the RSS item object (mandatory)\n   - Collect the category name (mandatory)\n   - System will validate if the RSS item object exists\n   - System will validate if the category name is provided\n\n2. Data Validation:\n   - Validate RSS item object:\n     * Check if the RSS item is not null\n     * Verify the RSS item has required properties (title, link)\n     * IF RSS item is invalid THEN return validation error\n   - Validate category name:\n     * Check if category name is not empty\n     * Check if category name is not null\n     * Check if category name length is within acceptable limits (1-50 characters)\n     * IF category name is invalid THEN return validation error\n\n3. Business Rule Processing:\n   - Check if the RSS item already has categories:\n     * IF categories collection is null THEN initialize a new categories collection\n   - Check for duplicate categories:\n     * FOR EACH existing category in the RSS item's categories collection\n       * IF current category name matches the provided category name THEN\n         * Return duplicate category error\n       * END IF\n     * END FOR\n\n4. Core Operation Execution:\n   - Add the category to the RSS item:\n     * Add the provided category name to the RSS item's categories collection\n     * Update the RSS item's metadata to reflect the new category association\n     * IF addition fails THEN\n       * Log the failure reason\n       * Revert any partial changes\n       * Return operation failure error\n     * END IF\n\n5. Response Generation:\n   - On Success:\n     * Return success status\n     * Include the updated RSS item with the new category in the response\n     * Include the total count of categories now associated with the RSS item\n   - On Error:\n     * Return appropriate error code and message\n     * Include guidance on how to resolve the issue\n     * Provide reference to support resources if needed",
    "databaseEntities": [
      "jforum_categories"
    ],
    "validationRules": [
      "RSS item must not be null",
      "Category name must not be empty",
      "Category name must be between 1 and 50 characters",
      "Category name must not already exist in the RSS item's categories"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "RSSItem": {
        "type": "object",
        "properties": {
          "author": {
            "type": "string",
            "description": "The author of the RSS item"
          },
          "link": {
            "type": "string",
            "description": "The URL link to the RSS item content"
          },
          "title": {
            "type": "string",
            "description": "The title of the RSS item"
          },
          "description": {
            "type": "string",
            "description": "The description of the RSS item"
          },
          "contentType": {
            "type": "string",
            "description": "The content type of the RSS item description"
          },
          "publishDate": {
            "type": "string",
            "description": "The publication date of the RSS item"
          },
          "categories": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "List of categories associated with the RSS item"
          }
        },
        "required": [
          "title",
          "link"
        ]
      },
      "Category": {
        "type": "string",
        "description": "The name of a category to be associated with an RSS item"
      }
    }
  },
  {
    "featureName": "FormatDateToRSS",
    "description": "Formats a date object to the expected RSS format using system configuration.",
    "inputValues": [
      "date-object-Date",
      "dateString-string-DateString"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect input date which can be either:\n     a. A Date object\n     b. A string representation of a date\n   - Determine the input type (Date object or string)\n   - Retrieve system configuration for date format settings\n\n2. Data Validation:\n   - IF input is a Date object:\n     a. Verify the Date object is not null\n     b. Proceed to formatting\n   - IF input is a string:\n     a. Verify the string is not null or empty\n     b. Verify the string follows the expected date format pattern from system configuration\n     c. IF validation fails, return the original string without modification\n\n3. Business Rule Processing:\n   - Retrieve the RSS date time format from system configuration\n   - Verify the format string is valid and available\n   - Set the locale to English for consistent international formatting\n   - Prepare the date formatter with the retrieved format and locale\n\n4. Core Operation Execution:\n   - IF input is a Date object:\n     a. Apply the RSS date formatter directly to the Date object\n     b. Generate the formatted date string\n   - IF input is a string:\n     a. Parse the input string using the system's standard date time format\n     b. Convert the parsed date to a Date object\n     c. Apply the RSS date formatter to the converted Date object\n     d. IF parsing fails, return the original input string\n\n5. Response Generation:\n   - Return the formatted date string in RSS-compatible format\n   - IF any errors occurred during string parsing, return the original input string\n   - Ensure the returned format matches the RSS specification requirements",
    "databaseEntities": [],
    "validationRules": [
      "Date object must not be null when using Date input method",
      "Date string must not be null or empty when using string input method",
      "Date string must conform to the system's configured date time format",
      "System configuration must contain valid RSS date time format"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Date": {
        "type": "object",
        "description": "Java Date object representing a specific point in time"
      },
      "DateString": {
        "type": "string",
        "description": "String representation of a date in the system's configured format"
      }
    }
  },
  {
    "featureName": "FormatStringDateToRSS",
    "description": "Converts a string date to RSS format, handling parsing exceptions gracefully.",
    "inputValues": [
      "dateString-string-Date"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the input string date (dateString-string-Date) that needs to be converted to RSS format\n   - The input date string is expected to be in the system's configured date-time format\n   - This is a mandatory field, no default value is provided\n\n2. Data Validation:\n   - Validate that the input date string is not null\n     * IF the input is null THEN return an error message indicating a date string is required\n   - Validate that the input date string is not empty\n     * IF the input is empty THEN return an error message indicating a valid date string is required\n   - No specific format validation is performed at this stage as the parsing will handle format issues\n\n3. Business Rule Processing:\n   - Determine the system's configured date-time format\n     * Retrieve the date-time format configuration from the system settings\n     * IF the format configuration is not available THEN use a default date-time format\n   - Determine the target RSS date-time format\n     * Retrieve the RSS date-time format configuration from the system settings\n     * IF the RSS format configuration is not available THEN use a default RSS date-time format (typically RFC 822)\n   - Verify that both source and target formats are valid date format patterns\n     * IF either format is invalid THEN return an error indicating invalid system configuration\n\n4. Core Operation Execution:\n   - Attempt to parse the input string date\n     * Create a date formatter using the system's configured date-time format\n     * Try to parse the input string into a Date object\n     * IF parsing fails THEN:\n       - Capture the parsing exception\n       - Return the original input string as fallback\n       - Log the parsing failure for system administrators\n     * IF parsing succeeds THEN:\n       - Create a date formatter using the RSS date-time format and English locale\n       - Format the parsed Date object into the RSS format string\n       - Return the formatted RSS date string\n   - Handle any unexpected exceptions during the conversion process\n     * IF any other exception occurs THEN:\n       - Return the original input string as fallback\n       - Log the exception for system administrators\n\n5. Response Generation:\n   - Success response:\n     * Return the date string formatted in RSS format\n     * Include the original input string for reference\n   - Error response:\n     * In case of parsing failure, return the original input string\n     * Include information about the failure reason\n     * Provide guidance on expected date format",
    "databaseEntities": [],
    "validationRules": [
      "Input date string must not be null",
      "Input date string must not be empty",
      "System date-time format configuration must be valid",
      "RSS date-time format configuration must be valid"
    ],
    "dbSeedingOperations": [],
    "schema": {}
  },
  {
    "featureName": "GenerateRecentTopicsRSS",
    "description": "Creates an RSS feed for recent forum topics with title, description, and links.",
    "inputValues": [
      "title-string-RSSFeed",
      "description-string-RSSFeed",
      "posts-object-ForumPosts"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the following required inputs:\n     a. title (string): The title for the RSS feed\n     b. description (string): The description for the RSS feed\n     c. posts (object): List of forum posts to include in the feed\n   - System-generated fields:\n     a. forumLink: Base URL for the forum\n     b. encoding: Character encoding for the feed\n     c. forumName: Name of the forum for title generation\n\n2. Data Validation:\n   a. Title Validation:\n      - Check if title is not empty\n      - Verify title length is within acceptable limits (1-100 characters)\n      - IF title is invalid THEN generate error message\n   b. Description Validation:\n      - Check if description is not empty\n      - Verify description length is within acceptable limits (1-500 characters)\n      - IF description is invalid THEN generate error message\n   c. Posts Collection Validation:\n      - Verify posts collection is not null\n      - Check if posts collection contains at least one item\n      - IF posts collection is invalid THEN generate error message\n   d. Authentication Validation:\n      - Check if user authentication is required for accessing the feed\n      - IF authentication is required and user is not authenticated THEN request authentication\n\n3. Business Rule Processing:\n   a. System Configuration Verification:\n      - Verify system encoding setting is available\n      - Check if forum base URL is properly configured\n      - Verify forum name is available for title generation\n      - Verify posts per page configuration is available\n      - IF any system configuration is missing THEN generate configuration error\n   b. Access Control Verification:\n      - Verify current user has permission to view the posts in the feed\n      - Check if topics are from accessible forums\n      - IF user lacks permission THEN exclude restricted posts from the feed\n   c. Content Filtering:\n      - Apply content filtering rules to remove inappropriate content\n      - Filter out posts from restricted forums if applicable\n      - Limit number of posts based on system configuration\n\n4. Core Operation Execution:\n   a. RSS Feed Initialization:\n      - Create new RSS feed object with provided title and description\n      - Set feed encoding using system configuration\n      - Set feed link using forum base URL + \"recentTopics/list\" + extension\n   b. Feed Items Generation:\n      - FOR EACH post in posts collection:\n         i. Create new feed item\n         ii. Set item title using post title\n         iii. Set item description using post content (possibly truncated)\n         iv. Set item link using forum URL + post URL\n         v. Set item publication date using post creation date\n         vi. Set item author using post author information\n         vii. Add item to feed\n   c. Feed Finalization:\n      - Apply any feed-wide settings (language, copyright, etc.)\n      - Prepare feed for output generation\n      - Increment view counters for topics if applicable\n\n5. Response Generation:\n   a. Success Response:\n      - Generate complete RSS XML document\n      - Set appropriate content type for RSS feed (text/xml)\n      - Include feed metadata (version, encoding)\n      - Return complete feed with all items\n   b. Error Response:\n      - IF any errors occurred during processing THEN:\n         i. Generate appropriate error message\n         ii. Log error details\n         iii. Return error response with explanation\n   c. Authentication Response:\n      - IF authentication is required THEN:\n         i. Request basic authentication\n         ii. Process authentication credentials if provided\n         iii. Redirect to appropriate page after authentication",
    "databaseEntities": [
      "jforum_topics",
      "jforum_posts",
      "jforum_posts_text",
      "jforum_users",
      "jforum_forums",
      "jforum_sessions"
    ],
    "validationRules": [
      "RSS feed title must not be empty",
      "RSS feed description must not be empty",
      "Posts collection must contain at least one item",
      "System encoding configuration must be available",
      "Forum base URL must be properly configured",
      "User must have permission to view the posts included in the feed",
      "Topics must be from accessible forums",
      "User authentication may be required for accessing certain forums"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "ForumPosts": {
        "type": "array",
        "items": {
          "type": "object",
          "properties": {
            "id": {
              "type": "integer",
              "description": "Unique identifier for the post"
            },
            "title": {
              "type": "string",
              "description": "Title of the forum post"
            },
            "content": {
              "type": "string",
              "description": "Content of the forum post"
            },
            "authorId": {
              "type": "integer",
              "description": "ID of the post author"
            },
            "authorName": {
              "type": "string",
              "description": "Name of the post author"
            },
            "creationDate": {
              "type": "string",
              "format": "date-time",
              "description": "Date and time when the post was created"
            },
            "forumId": {
              "type": "integer",
              "description": "ID of the forum containing this post"
            },
            "topicId": {
              "type": "integer",
              "description": "ID of the topic containing this post"
            }
          },
          "required": [
            "id",
            "title",
            "content",
            "authorId",
            "creationDate",
            "topicId"
          ]
        }
      }
    }
  },
  {
    "featureName": "GenerateTopicPostsRSS",
    "description": "Creates RSS feed for topic posts with formatted content, author information, and publication dates.",
    "inputValues": [
      "topicId-number-Topic",
      "forumId-number-Forum",
      "title-string-Topic",
      "description-string-Topic",
      "posts-object-PostList"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the following inputs:\n     a. topicId (mandatory): Numeric identifier for the topic\n     b. forumId (mandatory): Numeric identifier for the forum containing the topic\n     c. title (mandatory): String representing the RSS feed title\n     d. description (mandatory): String describing the RSS feed content\n     e. posts (mandatory): List of post objects containing post data\n   - System will generate:\n     a. forumLink: Base URL for the forum\n     b. currentTimestamp: Current system time for RSS feed generation\n\n2. Data Validation:\n   - Validate topicId:\n     a. Check if topicId is a positive integer\n     b. IF topicId is invalid THEN generate error message \"Invalid topic identifier\"\n     c. Check if topic exists in the system\n     d. IF topic does not exist THEN generate error message \"Topic not found\"\n   - Validate forumId:\n     a. Check if forumId is a positive integer\n     b. IF forumId is invalid THEN generate error message \"Invalid forum identifier\"\n     c. Check if forum exists in the system\n     d. IF forum does not exist THEN generate error message \"Forum not found\"\n   - Validate title:\n     a. Check if title is not empty\n     b. IF title is empty THEN generate error message \"RSS feed title cannot be empty\"\n   - Validate description:\n     a. Check if description is not empty\n     b. IF description is empty THEN generate error message \"RSS feed description cannot be empty\"\n   - Validate posts:\n     a. Check if posts collection is not null\n     b. Check if posts collection is not empty\n     c. IF posts collection is null or empty THEN generate error message \"No posts available for RSS generation\"\n\n3. Business Rule Processing:\n   - Verify user has access to the topic:\n     a. Check if the topic is in a restricted forum\n     b. IF topic is restricted AND user is not authenticated THEN request authentication\n     c. IF user does not have permission to view the topic THEN deny access\n   - Verify system encoding settings are available:\n     a. IF encoding settings are missing THEN use default encoding\n   - Verify forum link can be generated:\n     a. IF forum link generation fails THEN use default base URL\n   - Verify post processing capabilities:\n     a. Check if post formatting tools are available\n     b. IF formatting tools are unavailable THEN use plain text mode\n   - Update topic view count:\n     a. Increment the total views counter for the topic\n\n4. Core Operation Execution:\n   - Initialize RSS feed structure:\n     a. Create new RSS feed with provided title and description\n     b. Set encoding from system settings\n     c. Set feed link using forum base URL and topic identifier\n     d. Set publication date to current timestamp\n   - Process each post in the collection:\n     a. FOR EACH post in posts collection:\n        i. Disable BBCode formatting for the post\n        ii. Disable HTML formatting for the post\n        iii. Create new RSS item\n        iv. Set author to post username\n        v. Set content type to HTML\n        vi. Format post text for display\n        vii. Set formatted text as item description\n        viii. Format post timestamp as publication date\n        ix. Set post subject as item title\n        x. Generate and set link to the specific post\n        xi. Add item to RSS feed\n   - Finalize RSS feed:\n     a. Set all processed items in the feed structure\n     b. Prepare feed for output\n     c. Set content type to XML\n\n5. Response Generation:\n   - Success response:\n     a. Return complete RSS feed document with all items\n     b. Include proper XML formatting and headers\n     c. Set appropriate content type (text/xml)\n   - Error response:\n     a. IF any validation or processing errors occurred THEN return error message\n     b. Include specific error details and suggestions for resolution\n     c. IF authentication is required THEN prompt for basic authentication",
    "databaseEntities": [
      "jforum_topics",
      "jforum_posts",
      "jforum_posts_text",
      "jforum_users",
      "jforum_forums"
    ],
    "validationRules": [
      "Topic ID must be a positive integer",
      "Forum ID must be a positive integer",
      "Topic must exist in the system",
      "Forum must exist in the system",
      "User must have permission to access the topic",
      "RSS feed title must not be empty",
      "RSS feed description must not be empty",
      "Posts collection must not be empty",
      "Each post must have a valid username",
      "Each post must have a subject",
      "Each post must have content text",
      "Each post must have a valid timestamp"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "PostList": {
        "type": "array",
        "items": {
          "type": "object",
          "properties": {
            "id": {
              "type": "number",
              "description": "Unique identifier for the post"
            },
            "topicId": {
              "type": "number",
              "description": "Identifier of the topic this post belongs to"
            },
            "forumId": {
              "type": "number",
              "description": "Identifier of the forum this post belongs to"
            },
            "postUsername": {
              "type": "string",
              "description": "Username of the post author"
            },
            "subject": {
              "type": "string",
              "description": "Subject line of the post"
            },
            "text": {
              "type": "string",
              "description": "Content text of the post"
            },
            "time": {
              "type": "string",
              "format": "date-time",
              "description": "Timestamp when the post was created"
            },
            "bbCodeEnabled": {
              "type": "boolean",
              "description": "Flag indicating if BBCode is enabled for this post"
            },
            "htmlEnabled": {
              "type": "boolean",
              "description": "Flag indicating if HTML is enabled for this post"
            }
          },
          "required": [
            "id",
            "topicId",
            "forumId",
            "postUsername",
            "subject",
            "text",
            "time"
          ]
        }
      }
    }
  },
  {
    "featureName": "GenerateTopicRSS",
    "description": "Creates RSS feeds for forum topics with post content, author information, and publication dates.",
    "inputValues": [
      "title-string-Topic",
      "description-string-Topic",
      "forumId-number-Forum",
      "posts-object-PostList"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the following inputs:\n     a. title (mandatory): String representing the RSS feed title\n     b. description (mandatory): String describing the RSS feed content\n     c. forumId (mandatory): Numeric identifier for the forum\n     d. posts (mandatory): List of post objects to include in the feed\n\n2. Data Validation:\n   - Validate title:\n     a. Check if title is not empty\n     b. Verify title length is within acceptable limits\n     c. IF validation fails, THEN return error message\n   - Validate description:\n     a. Check if description is not empty\n     b. Verify description length is within acceptable limits\n     c. IF validation fails, THEN return error message\n   - Validate forumId:\n     a. Check if forumId is a positive integer\n     b. Verify forumId exists in the system\n     c. IF validation fails, THEN return error message\n   - Validate posts:\n     a. Check if posts list is not empty\n     b. Verify each post contains required fields (id, topicId, subject, text, postUsername, time)\n     c. IF validation fails, THEN return error message\n\n3. Business Rule Processing:\n   - Check system configuration:\n     a. Retrieve system encoding settings\n     b. Retrieve URL extension settings\n     c. IF any configuration is missing, THEN use default values\n   - Check user permissions:\n     a. Verify current user has access to the specified forum\n     b. Verify current user has permission to view the posts\n     c. IF permission check fails, THEN return access denied error\n\n4. Core Operation Execution:\n   - Initialize RSS feed:\n     a. Create new RSS feed with provided title and description\n     b. Set encoding based on system configuration\n     c. Set feed link to forum URL using forumId\n   - Process each post in the posts list:\n     a. Disable BBCode rendering for post content\n     b. Disable smilies rendering for post content\n     c. Create RSS item for each post with:\n        i. Author set to post username\n        ii. Publication date formatted from post timestamp\n        iii. Link pointing to the specific post\n        iv. Title set to post subject\n        v. Content type set to HTML\n        vi. Description set to formatted post text\n     d. Add item to RSS feed\n   - Finalize RSS feed:\n     a. Set content type headers\n     b. Format feed according to RSS specification\n\n5. Response Generation:\n   - Success response:\n     a. Return complete RSS feed in XML format\n     b. Include proper XML headers and content type\n     c. Include all generated RSS items\n   - Error response:\n     a. Return appropriate error message\n     b. Include error code and description\n     c. Log error details for troubleshooting",
    "databaseEntities": [
      "jforum_forums",
      "jforum_topics",
      "jforum_posts",
      "jforum_posts_text",
      "jforum_users"
    ],
    "validationRules": [
      "Title must not be empty",
      "Description must not be empty",
      "Forum ID must be a positive integer",
      "Forum ID must reference an existing forum",
      "Posts list must not be empty",
      "Each post must contain required fields (id, topicId, subject, text, postUsername, time)",
      "User must have permission to access the forum",
      "User must have permission to view the posts"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "PostList": {
        "type": "array",
        "items": {
          "type": "object",
          "properties": {
            "id": {
              "type": "number",
              "description": "Unique identifier for the post"
            },
            "topicId": {
              "type": "number",
              "description": "Identifier of the topic this post belongs to"
            },
            "subject": {
              "type": "string",
              "description": "Subject line of the post"
            },
            "text": {
              "type": "string",
              "description": "Content of the post"
            },
            "postUsername": {
              "type": "string",
              "description": "Username of the post author"
            },
            "time": {
              "type": "string",
              "format": "date-time",
              "description": "Timestamp when the post was created"
            }
          },
          "required": [
            "id",
            "topicId",
            "subject",
            "text",
            "postUsername",
            "time"
          ]
        }
      }
    }
  },
  {
    "featureName": "PrepareRSSContent",
    "description": "Formats forum posts into RSS items with links, titles, and HTML content.",
    "inputValues": [
      "title-string-RSS",
      "description-string-RSS",
      "forumId-number-Forum",
      "posts-object-PostList"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the following inputs:\n     a. title (mandatory): The title for the RSS feed\n     b. description (mandatory): The description for the RSS feed\n     c. forumId (mandatory): The identifier of the forum\n     d. posts (mandatory): List of post objects to be formatted as RSS items\n   - System will generate:\n     a. forumLink: The base URL for the forum\n\n2. Data Validation:\n   - Validate title:\n     a. Check if title is not empty\n     b. IF title is empty THEN\n        i. Generate error message \"RSS title cannot be empty\"\n     c. ENDIF\n   - Validate description:\n     a. Check if description is not empty\n     b. IF description is empty THEN\n        i. Generate error message \"RSS description cannot be empty\"\n     c. ENDIF\n   - Validate forumId:\n     a. Check if forumId is a positive integer\n     b. IF forumId is not a positive integer THEN\n        i. Generate error message \"Invalid forum ID\"\n     c. ENDIF\n   - Validate posts:\n     a. Check if posts list is not null\n     b. IF posts list is null THEN\n        i. Generate error message \"Post list cannot be null\"\n     c. ENDIF\n     d. Check if posts list is not empty\n     e. IF posts list is empty THEN\n        i. Generate warning message \"No posts available for RSS feed\"\n     f. ENDIF\n\n3. Business Rule Processing:\n   - Check system configuration:\n     a. Verify encoding setting is available\n     b. IF encoding setting is not available THEN\n        i. Use default encoding (UTF-8)\n     c. ENDIF\n     d. Verify servlet extension setting is available\n     e. IF servlet extension setting is not available THEN\n        i. Use default extension (.page)\n     f. ENDIF\n   - Prepare RSS feed container:\n     a. Create new RSS container with title and description\n     b. Set encoding from system configuration\n     c. Set link to forum using forumId and servlet extension\n\n4. Core Operation Execution:\n   - Process each post in the posts list:\n     a. FOR EACH post in posts list:\n        i. Disable BBCode for post content\n        ii. Disable smilies for post content\n        iii. Create new RSS item\n        iv. Set author to post username\n        v. Format and set publish date from post timestamp\n        vi. Generate and set link to the specific post\n        vii. Set title to post subject\n        viii. Set content type to HTML\n        ix. Prepare post text for display (convert to HTML)\n        x. Set description to prepared post text\n        xi. Add item to RSS container\n     b. END FOR\n   - Finalize RSS feed:\n     a. Set the prepared RSS container as the output\n\n5. Response Generation:\n   - Success response:\n     a. Return the complete RSS feed object containing all items\n     b. Include metadata about the feed (title, description, link)\n     c. Include count of items processed\n   - Error response:\n     a. Return specific error message for validation failures\n     b. Include information about which validation failed\n     c. Provide guidance on correct input format",
    "databaseEntities": [
      "jforum_posts",
      "jforum_forums",
      "jforum_topics"
    ],
    "validationRules": [
      "RSS title must not be empty",
      "RSS description must not be empty",
      "Forum ID must be a positive integer",
      "Post list must not be null",
      "Each post must have a valid subject",
      "Each post must have a valid timestamp",
      "Each post must have a valid username",
      "Each post must have valid content"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "PostList": {
        "type": "array",
        "items": {
          "type": "object",
          "properties": {
            "id": {
              "type": "number",
              "description": "Unique identifier for the post"
            },
            "topicId": {
              "type": "number",
              "description": "Identifier of the topic this post belongs to"
            },
            "subject": {
              "type": "string",
              "description": "Subject line of the post"
            },
            "text": {
              "type": "string",
              "description": "Content of the post"
            },
            "postUsername": {
              "type": "string",
              "description": "Username of the post author"
            },
            "time": {
              "type": "string",
              "format": "date-time",
              "description": "Timestamp when the post was created"
            }
          },
          "required": [
            "id",
            "topicId",
            "subject",
            "text",
            "postUsername",
            "time"
          ]
        }
      }
    }
  },
  {
    "featureName": "AdminLogin",
    "description": "Handles administrator login and authentication verification for admin access.",
    "inputValues": [
      "username-string-User",
      "password-string-User",
      "returnPath-string-System"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the following inputs:\n     a. username (string, mandatory): Administrator's username\n     b. password (string, mandatory): Administrator's password\n     c. returnPath (string, system-generated): Path to redirect after successful login\n\n2. Data Validation:\n   - Validate username:\n     a. Check if username is not empty\n     b. Check if username exists in the system\n     c. IF validation fails, THEN display appropriate error message\n   - Validate password:\n     a. Check if password is not empty\n     b. Check if password meets minimum length requirements\n     c. IF validation fails, THEN display appropriate error message\n\n3. Business Rule Processing:\n   - Check user authentication:\n     a. Verify if the provided credentials match a valid user account\n     b. IF credentials are invalid, THEN display authentication error message\n   - Check administrator permissions:\n     a. Retrieve user permissions from security repository\n     b. Verify if the user has administration access rights\n     c. IF user lacks administration permissions, THEN deny access and redirect to login page\n\n4. Core Operation Execution:\n   - Create user session:\n     a. Generate a new session for the administrator\n     b. Store administrator information in the session\n     c. Set administrator permissions in security repository\n   - Process login success:\n     a. Record login timestamp\n     b. Update last login information\n     c. IF any operation fails, THEN handle error and notify administrator\n\n5. Response Generation:\n   - Successful login response:\n     a. Redirect administrator to the admin dashboard\n     b. Display welcome message with administrator name\n     c. Show system status information\n   - Failed login response:\n     a. Redirect to login page\n     b. Display appropriate error message\n     c. Maintain entered username for convenience\n     d. Provide password recovery option",
    "databaseEntities": [
      "jforum_users",
      "jforum_groups",
      "jforum_user_groups",
      "jforum_sessions"
    ],
    "validationRules": [
      "Username must not be empty",
      "Password must not be empty",
      "User must exist in the system",
      "User must have administration permissions",
      "Session must be active and valid"
    ],
    "dbSeedingOperations": [
      "Ensure at least one administrator account exists in jforum_users",
      "Ensure administrator is assigned to admin group in jforum_user_groups",
      "Ensure admin group has proper permissions set"
    ],
    "schema": {
      "User": {
        "type": "object",
        "properties": {
          "id": {
            "type": "number"
          },
          "username": {
            "type": "string"
          },
          "password": {
            "type": "string"
          },
          "permissions": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        },
        "required": [
          "username",
          "password"
        ]
      },
      "System": {
        "type": "object",
        "properties": {
          "returnPath": {
            "type": "string"
          }
        }
      }
    }
  },
  {
    "featureName": "DisplayAdminMenu",
    "description": "Shows the administration menu for authenticated administrators.",
    "inputValues": [
      "userSession-object-UserSession"
    ],
    "businessLogic": "1. Input Collection\n   - Retrieve current user session information\n     - User ID from the session\n     - Authentication status\n     - User permissions\n\n2. Data Validation\n   - Validate user authentication status\n     - Check if the user is logged in\n     - IF user is not logged in, THEN prepare redirect to login page\n   - Validate administrative permissions\n     - Check if the user has administration access rights\n     - IF user does not have administration permissions, THEN prepare redirect to login page\n\n3. Business Rule Processing\n   - Verify administrative session validity\n     - Check if the security repository contains the user's permission control\n     - Verify the permission control allows administration access\n     - IF any validation fails, THEN prepare login redirect with appropriate return path\n\n4. Core Operation Execution\n   - Prepare administration menu display\n     - Load menu structure based on user's specific administrative permissions\n     - Organize menu items by category (users, forums, configuration, etc.)\n     - Filter menu items based on user's permission level\n   - Load system status information\n     - Current active sessions count\n     - System statistics if applicable\n\n5. Response Generation\n   - Generate administration menu view\n     - Display categorized menu items\n     - Include user information in the view context\n     - Include system status information if applicable\n   - IF any validation failed during processing\n     - Redirect to login page with return path set to administration area\n   - ELSE\n     - Display the administration menu interface",
    "databaseEntities": [
      "jforum_users",
      "jforum_groups",
      "jforum_sessions"
    ],
    "validationRules": [
      "User must be logged in to access administration menu",
      "User must have administration permission to access the menu",
      "Security repository must contain valid permission control for the user"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "UserSession": {
        "type": "object",
        "properties": {
          "userId": {
            "type": "number",
            "description": "The unique identifier of the user"
          },
          "isLogged": {
            "type": "boolean",
            "description": "Flag indicating if the user is logged in"
          },
          "permissions": {
            "type": "object",
            "description": "User's permission settings"
          }
        },
        "required": [
          "userId",
          "isLogged"
        ]
      }
    }
  },
  {
    "featureName": "DisplayAdminDashboard",
    "description": "Shows the main administration dashboard with forum statistics and system status.",
    "inputValues": [
      "userId-number-User",
      "userSession-object-UserSession",
      "boardStatus-object-BoardStatus"
    ],
    "businessLogic": "1. Input Collection\n   - Collect userId from the current user session\n   - Collect userSession object containing user authentication details\n   - System will generate boardStatus data\n   - System will determine if install module exists\n   - System will retrieve all active sessions\n\n2. Data Validation\n   - Validate user authentication status\n     * Check if user is logged in\n     * IF user is not logged in, THEN redirect to login page\n     * Set return path to admin login page\n   - Validate user permissions\n     * Check if user has administration access permissions\n     * IF user does not have admin permissions, THEN redirect to login page\n\n3. Business Rule Processing\n   - Check system installation status\n     * Verify if installation module still exists in the system\n     * IF installation module exists, THEN flag for admin notification\n   - Process board version information\n     * Retrieve latest version information from central repository\n     * Compare current version with latest available version\n     * Determine if system is up to date\n     * IF development version is detected, THEN mark accordingly\n     * IF newer version available, THEN prepare update notification\n\n4. Core Operation Execution\n   - Retrieve forum statistics\n     * Get total number of users\n     * Get total number of topics\n     * Get total number of posts\n     * Calculate posting activity metrics\n   - Gather system status information\n     * Collect all active user sessions\n     * Determine server load and performance metrics\n     * Check mail integration status\n   - Prepare version comparison data\n     * Format current version information\n     * Format latest version information\n     * Generate version difference notes if applicable\n\n5. Response Generation\n   - Prepare dashboard display data\n     * Compile forum statistics for display\n     * Format system status information\n     * Prepare version information and update notifications\n     * Include installation module warning if applicable\n   - Generate admin dashboard view\n     * Display forum statistics section\n     * Display system status section\n     * Display version information section\n     * Show administrative action options\n     * IF updates available, THEN display update notification\n     * IF installation module exists, THEN display security warning",
    "databaseEntities": [
      "jforum_users",
      "jforum_sessions",
      "jforum_forums",
      "jforum_topics",
      "jforum_posts"
    ],
    "validationRules": [
      "User must be logged in to access admin dashboard",
      "User must have administration permission to access dashboard",
      "Board statistics must be retrieved successfully",
      "Version check must complete with or without external connection"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "UserSession": {
        "type": "object",
        "properties": {
          "userId": {
            "type": "number",
            "description": "Unique identifier for the user"
          },
          "username": {
            "type": "string",
            "description": "Username of the logged in user"
          },
          "isLogged": {
            "type": "boolean",
            "description": "Flag indicating if user is logged in"
          }
        }
      },
      "BoardStatus": {
        "type": "object",
        "properties": {
          "totalUsers": {
            "type": "number",
            "description": "Total number of registered users"
          },
          "totalPosts": {
            "type": "number",
            "description": "Total number of posts in the forum"
          },
          "totalTopics": {
            "type": "number",
            "description": "Total number of topics in the forum"
          },
          "activeSessions": {
            "type": "number",
            "description": "Number of active user sessions"
          }
        }
      }
    }
  },
  {
    "featureName": "CheckBoardVersion",
    "description": "Verifies if the forum software is up-to-date by comparing the current version with the latest available version.",
    "inputValues": [
      "currentVersion-string-System",
      "latestVersion-string-RemoteServer"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect currentVersion (string) from the system configuration\n   - Collect latestVersion (string) from the remote version server\n   - Both inputs are system-generated and required\n   - Version format should be in semantic versioning (e.g., \"1.2.3\")\n\n2. Data Validation:\n   - Validate currentVersion:\n     * VERIFY that currentVersion is not empty\n     * VERIFY that currentVersion follows semantic versioning format (X.Y.Z)\n     * IF currentVersion is invalid THEN display error message \"Current version information is invalid\"\n   - Validate latestVersion:\n     * VERIFY that latestVersion was successfully retrieved from remote server\n     * VERIFY that latestVersion follows semantic versioning format (X.Y.Z)\n     * IF latestVersion is empty or invalid THEN set system as \"development version\" and exit process\n\n3. Business Rule Processing:\n   - Parse version components:\n     * Split currentVersion into major, minor, and revision components\n     * Split latestVersion into major, minor, and revision components\n     * IF currentVersion contains development suffix (e.g., \"-dev\") THEN remove suffix for comparison\n   - Check for development version:\n     * IF currentVersion contains \"-dev\" suffix THEN mark system as \"development version\"\n\n4. Core Operation Execution:\n   - Compare version components in order of importance (major, minor, revision):\n     * IF latestVersion major > currentVersion major THEN mark as \"not up to date\"\n     * ELSE IF latestVersion minor > currentVersion minor THEN mark as \"not up to date\"\n     * ELSE IF latestVersion revision > currentVersion revision THEN mark as \"not up to date\"\n     * ELSE mark as \"up to date\"\n   - Process version notes:\n     * Extract version notes from remote server response\n     * Format notes for display\n\n5. Response Generation:\n   - Prepare version comparison results:\n     * Include currentVersion value\n     * Include latestVersion value\n     * Include up-to-date status (boolean)\n     * Include development version status (boolean)\n     * Include version notes if available\n   - Display results to administrator:\n     * Show version comparison information\n     * IF not up to date THEN highlight available update\n     * IF development version THEN display appropriate notice",
    "databaseEntities": [],
    "validationRules": [
      "Current version must follow semantic versioning format (X.Y.Z)",
      "Latest version must be successfully retrieved from remote server",
      "Latest version must follow semantic versioning format (X.Y.Z)"
    ],
    "dbSeedingOperations": [],
    "schema": {}
  },
  {
    "featureName": "FetchMailManually",
    "description": "Triggers manual execution of the POP3 mail fetching process.",
    "inputValues": [
      "adminRequest-boolean-AdminAction"
    ],
    "businessLogic": "1. Input Collection\n   - Collect the admin request to manually fetch mail\n   - Verify the request is coming from an authenticated admin user\n   - No additional input parameters are required\n\n2. Data Validation\n   - Validate user authentication status\n     * Check if the user is logged in\n     * IF user is not logged in, THEN redirect to login page\n   - Validate user permissions\n     * Check if the user has administration privileges\n     * IF user does not have admin privileges, THEN deny access and redirect to login\n\n3. Business Rule Processing\n   - Verify system readiness for mail fetching\n     * Check if mail fetching service is properly configured\n     * Verify mail server settings are available\n   - Check if mail fetching is already in progress\n     * IF a mail fetching process is already running, THEN notify admin\n     * ELSE proceed with the operation\n\n4. Core Operation Execution\n   - Initialize mail fetching process\n     * Create a new thread for mail fetching operation\n     * Start the thread to run asynchronously\n     * Execute the POP3 mail listener process\n     * Fetch messages from the configured mail server\n     * Process received messages according to system rules\n     * Handle any exceptions that occur during mail fetching\n   - Update system status\n     * Record the time of last mail fetch operation\n     * Log the operation details for auditing purposes\n\n5. Response Generation\n   - Prepare admin dashboard view\n     * Include system statistics and status information\n     * Show confirmation message that mail fetching has been initiated\n     * Display any relevant system notifications\n   - Handle error scenarios\n     * IF mail fetching initialization fails, THEN show appropriate error message\n     * Include troubleshooting information if needed\n   - Return control to admin main page\n     * Display updated dashboard with current system status",
    "databaseEntities": [
      "jforum_users",
      "jforum_posts",
      "jforum_topics",
      "jforum_forums"
    ],
    "validationRules": [
      "User must be logged in to access this feature",
      "User must have administration privileges",
      "Mail fetching service must be properly configured",
      "Only one mail fetching process can run at a time"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "AdminAction": {
        "type": "object",
        "properties": {
          "userId": {
            "type": "number",
            "description": "ID of the admin user performing the action"
          },
          "hasAdminAccess": {
            "type": "boolean",
            "description": "Flag indicating if user has admin privileges"
          }
        }
      }
    }
  },
  {
    "featureName": "AdminAccessControl",
    "description": "Validates administrative access permissions before processing admin commands.",
    "inputValues": [
      "requestContext-object-RequestContext",
      "responseContext-object-ResponseContext",
      "templateContext-object-TemplateContext",
      "userSession-object-UserSession"
    ],
    "businessLogic": "1. Input Collection\n   1.1. Collect the request context containing user session information\n   1.2. Collect the response context for potential error responses\n   1.3. Collect the template context for rendering the appropriate view\n   1.4. Collect the current user session data\n      1.4.1. User identifier\n      1.4.2. User group memberships\n      1.4.3. Current session authentication status\n\n2. Data Validation\n   2.1. Validate user session exists\n      2.1.1. IF user session is null or invalid THEN\n         2.1.1.1. Generate authentication required error\n         2.1.1.2. Proceed to Response Generation with error\n      2.1.2. ELSE continue to next validation\n   2.2. Validate session authentication status\n      2.2.1. IF session is not authenticated THEN\n         2.2.1.1. Generate authentication required error\n         2.2.1.2. Proceed to Response Generation with error\n      2.2.2. ELSE continue to next validation\n\n3. Business Rule Processing\n   3.1. Check administrative permissions\n      3.1.1. Retrieve user's group memberships from session\n      3.1.2. Check if user belongs to administrator group\n         3.1.2.1. IF user is not in administrator group THEN\n            3.1.2.1.1. Generate access denied error\n            3.1.2.1.2. Log unauthorized access attempt\n            3.1.2.1.3. Proceed to Response Generation with error\n         3.1.2.2. ELSE continue to next step\n   3.2. Verify specific administrative permission for requested action\n      3.2.1. Extract requested administrative action from request context\n      3.2.2. Retrieve permission requirements for requested action\n      3.2.3. Check if user has required permissions for the action\n         3.2.3.1. IF user lacks specific permission for action THEN\n            3.2.3.1.1. Generate insufficient permissions error\n            3.2.3.1.2. Log permission violation attempt\n            3.2.3.1.3. Proceed to Response Generation with error\n         3.2.3.2. ELSE continue to next step\n\n4. Core Operation Execution\n   4.1. Mark request as administratively authorized\n      4.1.1. Set administrative access flag in request context\n      4.1.2. Log successful administrative access authorization\n   4.2. Prepare for command execution\n      4.2.1. Set up administrative context with elevated privileges\n      4.2.2. Prepare audit trail for administrative action\n   4.3. Allow command processing to continue\n      4.3.1. Pass control to the specific administrative command handler\n      4.3.2. Monitor execution for completion or errors\n\n5. Response Generation\n   5.1. For successful authorization\n      5.1.1. Allow normal command processing to generate response\n      5.1.2. Include administrative interface elements in template context\n      5.1.3. Return processed template for rendering\n   5.2. For authorization failures\n      5.2.1. Generate access denied template\n      5.2.2. Include error details in template context\n      5.2.3. Set appropriate HTTP status code in response context\n      5.2.4. Return error template for rendering",
    "databaseEntities": [
      "jforum_users",
      "jforum_groups",
      "jforum_user_groups"
    ],
    "validationRules": [
      "User must have an active session",
      "User must be authenticated",
      "User must belong to administrator group",
      "User must have specific permissions for the requested administrative action",
      "Administrative access attempts must be logged for audit purposes"
    ],
    "dbSeedingOperations": [
      "Ensure at least one user is assigned to the administrator group",
      "Ensure administrator group has all administrative permissions assigned"
    ],
    "schema": {
      "RequestContext": {
        "properties": {
          "sessionId": {
            "type": "string"
          },
          "requestedAction": {
            "type": "string"
          },
          "parameters": {
            "type": "object"
          }
        }
      },
      "ResponseContext": {
        "properties": {
          "statusCode": {
            "type": "number"
          },
          "headers": {
            "type": "object"
          }
        }
      },
      "TemplateContext": {
        "properties": {
          "variables": {
            "type": "object"
          },
          "templateName": {
            "type": "string"
          }
        }
      },
      "UserSession": {
        "properties": {
          "userId": {
            "type": "number"
          },
          "username": {
            "type": "string"
          },
          "authenticated": {
            "type": "boolean"
          },
          "groupMemberships": {
            "type": "array",
            "items": {
              "type": "number"
            }
          },
          "permissions": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      }
    }
  },
  {
    "featureName": "ConfigureAttachmentSettings",
    "description": "Displays and manages attachment configuration settings for the forum.",
    "inputValues": [
      "icon-string-AttachmentConfig",
      "createThumb-boolean-AttachmentConfig",
      "thumbHeight-number-AttachmentConfig",
      "thumbWidth-number-AttachmentConfig",
      "maxPostAttachments-number-AttachmentConfig",
      "thumbBorder-boolean-AttachmentConfig",
      "quotaDescription-string-QuotaLimit",
      "maxFileSize-number-QuotaLimit",
      "quotaType-number-QuotaLimit",
      "extensionGroupName-string-ExtensionGroup",
      "extensionGroupAllow-boolean-ExtensionGroup",
      "downloadMode-number-ExtensionGroup",
      "uploadIcon-string-ExtensionGroup",
      "extension-string-Extension",
      "extensionAllow-boolean-Extension",
      "extensionComment-string-Extension",
      "extensionGroupId-number-Extension",
      "groupQuotaMapping-object-GroupQuotaMapping"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect attachment configuration settings:\n     - Icon path (string, mandatory)\n     - Create thumbnail option (boolean, mandatory, default: false)\n     - Thumbnail height (number, mandatory if create thumbnail is true)\n     - Thumbnail width (number, mandatory if create thumbnail is true)\n     - Maximum attachments per post (number, mandatory)\n     - Show thumbnail border (boolean, mandatory, default: false)\n   - For quota limits:\n     - Quota description (string, mandatory)\n     - Maximum file size (number, mandatory)\n     - Quota type (number, mandatory)\n   - For extension groups:\n     - Group name (string, mandatory)\n     - Allow flag (boolean, mandatory, default: false)\n     - Download mode (number, mandatory)\n     - Upload icon (string, optional)\n   - For extensions:\n     - Extension name (string, mandatory)\n     - Allow flag (boolean, mandatory, default: false)\n     - Comment (string, optional)\n     - Extension group ID (number, mandatory)\n     - Upload icon (string, optional)\n   - For group quota mappings:\n     - Group ID (number, mandatory)\n     - Quota limit ID (number, mandatory)\n\n2. Data Validation:\n   - Validate attachment configuration settings:\n     - Icon path must not be empty\n     - If create thumbnail is true, thumbnail height and width must be positive numbers\n     - Maximum attachments per post must be a positive number\n   - Validate quota limits:\n     - Quota description must not be empty\n     - Maximum file size must be a positive number\n     - Quota type must be a valid type identifier\n   - Validate extension groups:\n     - Group name must not be empty\n     - Download mode must be a valid mode identifier\n   - Validate extensions:\n     - Extension name must not be empty\n     - If extension starts with a period (.), remove it\n     - Extension group ID must correspond to an existing extension group\n   - Validate group quota mappings:\n     - Group ID must correspond to an existing group\n     - Quota limit ID must correspond to an existing quota limit\n   - For each validation failure, prepare appropriate error message\n\n3. Business Rule Processing:\n   - Check system state for attachment functionality:\n     - Verify attachment feature is enabled in the system\n     - Ensure storage directory for attachments exists and is writable\n   - For quota limits:\n     - Verify quota type is compatible with system capabilities\n   - For extension groups:\n     - Ensure download mode is supported by the system\n   - For extensions:\n     - Check if extension is already registered in the system\n     - Verify extension is compatible with assigned group\n   - For group quota mappings:\n     - Ensure no duplicate mappings exist for the same group\n\n4. Core Operation Execution:\n   - For general configuration:\n     - Save attachment configuration settings to system preferences\n   - For quota limits:\n     - IF operation is create: Add new quota limit to the system\n     - IF operation is update: Update existing quota limits\n     - IF operation is delete: Remove selected quota limits\n   - For extension groups:\n     - IF operation is create: Add new extension group to the system\n     - IF operation is update: Update existing extension groups\n     - IF operation is delete: Remove selected extension groups\n   - For extensions:\n     - IF operation is create: Add new extension to the system\n     - IF operation is update: Update existing extensions\n     - IF operation is delete: Remove selected extensions\n   - For group quota mappings:\n     - Clear existing group quota mappings\n     - Create new mappings based on input\n   - IF any operation fails:\n     - Roll back changes where possible\n     - Log error details\n\n5. Response Generation:\n   - For configuration display:\n     - Retrieve current attachment settings\n     - Format settings for display in the user interface\n   - For quota limits display:\n     - Retrieve all quota limits\n     - Retrieve all user groups\n     - Retrieve existing group quota mappings\n     - Format data for display\n   - For extension groups display:\n     - Retrieve all extension groups\n     - Format data for display\n   - For extensions display:\n     - Retrieve all extensions\n     - Retrieve all extension groups\n     - Format data for display\n   - For any operation:\n     - IF operation successful: Display success message and updated data\n     - IF operation failed: Display error message with details\n     - Provide navigation options for different attachment configuration sections",
    "databaseEntities": [
      "jforum_quota_limit",
      "jforum_extension_groups",
      "jforum_attachments",
      "jforum_groups"
    ],
    "validationRules": [
      "Icon path must not be empty",
      "Thumbnail height and width must be positive numbers when thumbnails are enabled",
      "Maximum attachments per post must be a positive number",
      "Quota description must not be empty",
      "Maximum file size must be a positive number",
      "Quota type must be a valid type identifier",
      "Extension group name must not be empty",
      "Download mode must be a valid mode identifier",
      "Extension name must not be empty",
      "Extension group ID must correspond to an existing extension group",
      "Group ID must correspond to an existing group",
      "Quota limit ID must correspond to an existing quota limit"
    ],
    "dbSeedingOperations": [
      "Insert default quota limits if none exist",
      "Insert default extension groups if none exist",
      "Insert common file extensions with appropriate groups if none exist"
    ],
    "schema": {
      "GroupQuotaMapping": {
        "type": "object",
        "properties": {
          "groupId": {
            "type": "number",
            "description": "ID of the user group"
          },
          "quotaLimitId": {
            "type": "number",
            "description": "ID of the quota limit to apply to the group"
          }
        },
        "required": [
          "groupId",
          "quotaLimitId"
        ]
      }
    }
  },
  {
    "featureName": "SaveAttachmentConfigurations",
    "description": "Saves updated attachment configuration settings for the forum system.",
    "inputValues": [
      "icon-string-AttachmentConfig",
      "createThumb-boolean-AttachmentConfig",
      "thumbHeight-number-AttachmentConfig",
      "thumbWidth-number-AttachmentConfig",
      "maxPostAttachments-number-AttachmentConfig",
      "thumbBorder-boolean-AttachmentConfig"
    ],
    "businessLogic": "1. Input Collection\n   - Collect the following configuration settings from the user:\n     1.1. icon (string): Path or name of the attachment icon\n     1.2. createThumb (boolean): Whether to create thumbnails for image attachments\n     1.3. thumbHeight (number): Maximum height for thumbnails in pixels\n     1.4. thumbWidth (number): Maximum width for thumbnails in pixels\n     1.5. maxPostAttachments (number): Maximum number of attachments allowed per post\n     1.6. thumbBorder (boolean): Whether to show a border around thumbnails\n   - All fields are mandatory and must be provided by the user\n\n2. Data Validation\n   2.1. Validate icon path\n     - Check if icon path is not empty\n     - Verify the icon path format is valid\n     - IF icon path is invalid THEN generate error message \"Invalid attachment icon path\"\n   2.2. Validate thumbnail dimensions\n     - IF createThumb is TRUE THEN\n       - Verify thumbHeight is a positive number\n       - Verify thumbWidth is a positive number\n       - IF either dimension is invalid THEN generate error message \"Thumbnail dimensions must be positive numbers\"\n   2.3. Validate maximum attachments per post\n     - Verify maxPostAttachments is a positive integer\n     - IF maxPostAttachments is invalid THEN generate error message \"Maximum attachments per post must be a positive number\"\n   2.4. Validate all boolean values\n     - Ensure createThumb and thumbBorder are valid boolean values\n\n3. Business Rule Processing\n   3.1. Check system state\n     - Verify the system is in a state that allows configuration changes\n     - Ensure the user has administrative privileges to modify attachment settings\n     - IF user lacks permissions THEN generate error message \"Insufficient privileges to modify attachment settings\"\n   3.2. Check for configuration dependencies\n     - IF createThumb is TRUE THEN ensure thumbnail dimensions are specified\n     - IF thumbBorder is TRUE THEN ensure createThumb is also TRUE\n   3.3. Validate configuration consistency\n     - Ensure the combination of settings is valid and consistent\n     - Check that the settings don't conflict with other system configurations\n\n4. Core Operation Execution\n   4.1. Prepare configuration data\n     - Format all input values according to system requirements\n     - Convert boolean values to appropriate storage format\n   4.2. Update configuration settings\n     - Update attachment icon setting\n     - Update thumbnail creation setting\n     - Update thumbnail height setting\n     - Update thumbnail width setting\n     - Update maximum attachments per post setting\n     - Update thumbnail border setting\n   4.3. Save configuration to persistent storage\n     - Write all updated settings to the system configuration\n     - Ensure atomic update of all settings\n     - IF any setting fails to save THEN\n       - Roll back all changes\n       - Generate error message \"Failed to save attachment configuration\"\n\n5. Response Generation\n   5.1. Generate success response\n     - Create confirmation message \"Attachment configuration successfully updated\"\n     - Include summary of updated settings\n   5.2. Handle error scenarios\n     - IF any errors occurred during the process THEN\n       - Generate appropriate error message\n       - Provide guidance on how to correct the issue\n   5.3. Prepare UI update\n     - Refresh configuration display with new values\n     - Highlight changed settings for user awareness",
    "databaseEntities": [
      "jforum_quota_limit",
      "jforum_extension_groups"
    ],
    "validationRules": [
      "Attachment icon path must not be empty",
      "Thumbnail dimensions must be positive numbers when thumbnail creation is enabled",
      "Maximum attachments per post must be a positive integer",
      "Thumbnail border can only be enabled if thumbnail creation is enabled",
      "User must have administrative privileges to modify attachment settings"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "AttachmentConfig": {
        "type": "object",
        "properties": {
          "icon": {
            "type": "string",
            "description": "Path or name of the attachment icon"
          },
          "createThumb": {
            "type": "boolean",
            "description": "Whether to create thumbnails for image attachments"
          },
          "thumbHeight": {
            "type": "number",
            "description": "Maximum height for thumbnails in pixels"
          },
          "thumbWidth": {
            "type": "number",
            "description": "Maximum width for thumbnails in pixels"
          },
          "maxPostAttachments": {
            "type": "number",
            "description": "Maximum number of attachments allowed per post"
          },
          "thumbBorder": {
            "type": "boolean",
            "description": "Whether to show a border around thumbnails"
          }
        },
        "required": [
          "icon",
          "createThumb",
          "thumbHeight",
          "thumbWidth",
          "maxPostAttachments",
          "thumbBorder"
        ]
      }
    }
  },
  {
    "featureName": "CreateQuotaLimit",
    "description": "Creates a new quota limit for file attachments.",
    "inputValues": [
      "description-string-QuotaLimit",
      "size-number-QuotaLimit",
      "type-number-QuotaLimit"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the following required inputs:\n     a. Description (string): A descriptive name for the quota limit\n     b. Maximum File Size (number): The maximum allowed file size in bytes\n     c. Type (number): The type identifier for the quota limit\n   - All fields are mandatory\n   - No default values are provided\n\n2. Data Validation:\n   - Validate Description:\n     a. Check if description is not empty\n     b. Check if description is within acceptable length (1-255 characters)\n     c. Generate error message if validation fails\n   - Validate Maximum File Size:\n     a. Verify the value is a positive number\n     b. Verify the value is within acceptable range (greater than 0)\n     c. Generate error message if validation fails\n   - Validate Type:\n     a. Verify the type value is a valid integer\n     b. Verify the type value matches one of the predefined quota types\n     c. Generate error message if validation fails\n\n3. Business Rule Processing:\n   - Check system state:\n     a. Verify the system allows creation of new quota limits\n     b. Check if the user has appropriate permissions to create quota limits\n   - Verify resource constraints:\n     a. Check if the maximum number of quota limits has not been reached\n     b. IF maximum limit reached, THEN generate appropriate error message\n   - Check for duplicate quota descriptions:\n     a. Verify no existing quota limit has the same description\n     b. IF duplicate found, THEN generate appropriate error message\n\n4. Core Operation Execution:\n   - Create new Quota Limit record:\n     a. Generate a new unique identifier for the quota limit\n     b. Prepare the quota limit data with validated inputs\n     c. Store the quota limit record in the database\n     d. IF storage operation fails, THEN:\n        i. Log the failure details\n        ii. Revert any partial changes\n        iii. Generate appropriate error message\n\n5. Response Generation:\n   - On Success:\n     a. Generate success message indicating quota limit was created\n     b. Include the identifier of the newly created quota limit\n     c. Prepare the list of all quota limits for display\n     d. Include group information for quota assignment\n   - On Failure:\n     a. Generate detailed error message explaining the failure reason\n     b. Provide guidance on how to correct the issue\n     c. Preserve user input for correction",
    "databaseEntities": [
      "QuotaLimit",
      "AttachmentExtension",
      "AttachmentExtensionGroup"
    ],
    "validationRules": [
      "Quota description must not be empty",
      "Maximum file size must be a positive number",
      "Type must be a valid quota type identifier",
      "User must have administrative permissions to create quota limits",
      "Quota description must be unique"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "QuotaLimit": {
        "id": "number",
        "description": "string",
        "size": "number",
        "type": "number"
      }
    }
  },
  {
    "featureName": "UpdateQuotaLimits",
    "description": "Updates or deletes existing quota limits for attachments.",
    "inputValues": [
      "quotaLimits-object-QuotaLimit",
      "deleteQuotaIds-object-DeleteIds"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the following inputs:\n     1.1. quotaLimits (mandatory): Collection of quota limit records to update\n       - Each record contains: id, description, size, and type\n     1.2. deleteQuotaIds (optional): Collection of quota limit IDs to delete\n\n2. Data Validation:\n   2.1. Validate deleteQuotaIds (if provided):\n     - Verify each ID exists in the system\n     - Ensure IDs are positive integers\n     - Generate error message if any ID is invalid\n   2.2. Validate each quota limit record:\n     - Verify ID exists in the system (for updates)\n     - Ensure description is not empty\n     - Verify size is a positive integer\n     - Confirm type is a valid quota type value\n     - Generate appropriate error message for each validation failure\n\n3. Business Rule Processing:\n   3.1. Check system state:\n     - Verify the quota management system is active\n     - Ensure user has appropriate permissions to modify quotas\n   3.2. Check dependencies:\n     - Verify no quota limit being deleted is currently assigned to a group\n     - IF a quota is assigned to groups, THEN either reassign groups or prevent deletion\n   3.3. Check for duplicates:\n     - Ensure no duplicate quota descriptions exist after update\n\n4. Core Operation Execution:\n   4.1. Process deletions (if any):\n     - IF deleteQuotaIds is provided and not empty, THEN:\n       - Remove all specified quota limits from the system\n       - Track successful deletions\n   4.2. Process updates:\n     - FOR EACH quota limit record:\n       - Update the record with new values (description, size, type)\n       - Skip records that were marked for deletion\n       - Track successful updates\n   4.3. Handle failures:\n     - IF any operation fails, THEN:\n       - Record specific failure reason\n       - Continue with remaining operations\n       - Prepare comprehensive error report\n\n5. Response Generation:\n   5.1. Generate success response:\n     - Include count of successfully updated records\n     - Include count of successfully deleted records\n     - Provide updated list of all quota limits\n   5.2. Generate error response (if applicable):\n     - Include specific error messages for each failed operation\n     - Provide guidance on resolving issues\n   5.3. Return final status:\n     - Complete list of current quota limits\n     - Group quota assignments",
    "databaseEntities": [
      "QuotaLimit",
      "Group"
    ],
    "validationRules": [
      "Quota limit IDs must exist in the system for updates",
      "Quota limit description must not be empty",
      "Quota limit size must be a positive integer",
      "Quota limit type must be a valid value",
      "Quota limit descriptions must be unique",
      "User must have administrative permissions to modify quota limits"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "QuotaLimit": {
        "id": "number",
        "description": "string",
        "size": "number",
        "type": "number"
      },
      "DeleteIds": {
        "ids": "number[]"
      }
    }
  },
  {
    "featureName": "CreateExtensionGroup",
    "description": "Creates a new extension group for file attachments.",
    "inputValues": [
      "name-string-AttachmentExtensionGroup",
      "allow-boolean-AttachmentExtensionGroup",
      "downloadMode-number-AttachmentExtensionGroup",
      "uploadIcon-string-AttachmentExtensionGroup"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the following required inputs:\n     a. name (string): The name of the extension group\n     b. allow (boolean): Whether the extension group is allowed\n     c. downloadMode (number): The download mode for the extension group\n     d. uploadIcon (string): The icon to be displayed for this extension group\n\n2. Data Validation:\n   - Validate the name field:\n     a. IF name is empty or null THEN\n        i. Generate error message: \"Extension group name is required\"\n        ii. Return error response\n     b. IF name exceeds maximum allowed length THEN\n        i. Generate error message: \"Extension group name is too long\"\n        ii. Return error response\n   - Validate the downloadMode field:\n     a. IF downloadMode is not a valid option THEN\n        i. Generate error message: \"Invalid download mode selected\"\n        ii. Return error response\n   - Validate the uploadIcon field:\n     a. IF uploadIcon is provided and not in the list of available icons THEN\n        i. Generate error message: \"Selected upload icon is not valid\"\n        ii. Return error response\n\n3. Business Rule Processing:\n   - Check for duplicate extension group names:\n     a. Search existing extension groups for the same name\n     b. IF a group with the same name exists THEN\n        i. Generate error message: \"An extension group with this name already exists\"\n        ii. Return error response\n   - Verify system permissions:\n     a. Check if the current user has administrative privileges\n     b. IF user lacks required permissions THEN\n        i. Generate error message: \"Insufficient permissions to create extension groups\"\n        ii. Return error response\n\n4. Core Operation Execution:\n   - Create a new AttachmentExtensionGroup object with the following properties:\n     a. Set the name property to the provided name\n     b. Set the allow property to the provided allow value\n     c. Set the downloadMode property to the provided downloadMode value\n     d. Set the uploadIcon property to the provided uploadIcon value\n   - Save the new extension group to the database:\n     a. Generate a unique identifier for the new extension group\n     b. Insert the extension group record into the database\n     c. IF database operation fails THEN\n        i. Log the error details\n        ii. Generate error message: \"Failed to create extension group\"\n        iii. Return error response\n\n5. Response Generation:\n   - On successful creation:\n     a. Generate success message: \"Extension group created successfully\"\n     b. Include the newly created extension group details in the response\n     c. Return success response with the extension group ID\n   - On failure:\n     a. Include detailed error information\n     b. Provide guidance on how to resolve the issue\n     c. Return appropriate error status",
    "databaseEntities": [
      "jforum_extension_groups"
    ],
    "validationRules": [
      "Extension group name must not be empty",
      "Extension group name must be unique",
      "Download mode must be a valid option",
      "User must have administrative privileges to create extension groups"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "AttachmentExtensionGroup": {
        "id": "number",
        "name": "string",
        "allow": "boolean",
        "downloadMode": "number",
        "uploadIcon": "string"
      }
    }
  },
  {
    "featureName": "UpdateExtensionGroups",
    "description": "Updates or deletes existing attachment extension groups.",
    "inputValues": [
      "extensionGroups-object-ExtensionGroup",
      "deleteSelections-object-DeleteSelection"
    ],
    "businessLogic": "1. Input Collection:\n   1.1. Collect the following inputs:\n       - extensionGroups: List of extension group objects to update, each containing:\n           * id: Unique identifier for the extension group\n           * name: Name of the extension group\n           * allow: Boolean flag indicating if the group is allowed\n           * downloadMode: Integer representing the download mode\n           * uploadIcon: String path to the upload icon\n       - deleteSelections: List of extension group IDs to delete\n   1.2. System retrieves the total number of records to process\n\n2. Data Validation:\n   2.1. Validate extension group updates:\n       2.1.1. FOR each extension group in extensionGroups:\n           - Verify id is a valid positive integer\n           - Verify name is not empty\n           - Verify downloadMode is a valid option\n           - Verify uploadIcon path format is valid (if provided)\n       2.1.2. IF any validation fails:\n           - Generate appropriate error message\n           - Halt the update process\n   2.2. Validate deletion selections:\n       2.2.1. Verify all IDs in deleteSelections exist in the system\n       2.2.2. Check if any extension group marked for deletion is currently in use\n           - IF in use, generate warning message about potential impact\n\n3. Business Rule Processing:\n   3.1. Check system constraints:\n       3.1.1. Verify the user has administrative privileges\n       3.1.2. Ensure system is not in maintenance mode\n   3.2. Check for dependencies:\n       3.2.1. FOR each extension group ID in deleteSelections:\n           - Check if any file extensions are associated with this group\n           - IF associations exist:\n               * Generate warning about orphaned extensions\n               * Provide option to reassign or delete associated extensions\n\n4. Core Operation Execution:\n   4.1. Process deletions:\n       4.1.1. IF deleteSelections is not empty:\n           - Remove all selected extension groups from the system\n           - Log deletion activity\n   4.2. Process updates:\n       4.2.1. FOR each extension group in extensionGroups that is not in deleteSelections:\n           - Update the extension group record with new values\n           - Preserve any fields not explicitly changed\n           - Log update activity\n   4.3. Handle failures:\n       4.3.1. IF any operation fails:\n           - Roll back all changes made in this transaction\n           - Log the error details\n           - Prepare error message for user\n\n5. Response Generation:\n   5.1. Generate success response:\n       5.1.1. Create summary of changes made:\n           - Number of groups updated\n           - Number of groups deleted\n       5.1.2. Prepare updated list of all extension groups for display\n   5.2. Generate error response (if needed):\n       5.2.1. Include specific error messages for failed operations\n       5.2.2. Provide guidance on how to resolve issues\n   5.3. Return to extension groups management interface with appropriate message",
    "databaseEntities": [
      "jforum_extension_groups",
      "jforum_attachments"
    ],
    "validationRules": [
      "Extension group name must not be empty",
      "Extension group ID must be a positive integer",
      "Download mode must be a valid option",
      "Upload icon path must be in a valid format if provided",
      "Extension groups marked for deletion must exist in the system",
      "User must have administrative privileges to update extension groups"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "ExtensionGroup": {
        "id": "number",
        "name": "string",
        "allow": "boolean",
        "downloadMode": "number",
        "uploadIcon": "string"
      },
      "DeleteSelection": {
        "ids": [
          "number"
        ]
      }
    }
  },
  {
    "featureName": "CreateExtension",
    "description": "Creates a new file extension entry for attachments.",
    "inputValues": [
      "extension-string-AttachmentExtension",
      "comment-string-AttachmentExtension",
      "allow-boolean-AttachmentExtension",
      "uploadIcon-string-AttachmentExtension",
      "extensionGroup-number-AttachmentExtension"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the following required inputs:\n     1.1. extension (string): The file extension to be added\n     1.2. comment (string): Description or comment about the extension\n     1.3. allow (boolean): Whether the extension is allowed for upload\n     1.4. uploadIcon (string): Icon to represent this file extension\n     1.5. extensionGroup (number): ID of the extension group this extension belongs to\n\n2. Data Validation:\n   2.1. Validate extension field:\n       - Check if extension is not empty\n       - IF extension starts with a period (.), THEN remove the leading period\n       - Check if extension contains only valid characters (alphanumeric and limited special characters)\n       - Verify extension is not already in the system\n   2.2. Validate comment field:\n       - No specific validation required, can be empty\n   2.3. Validate allow field:\n       - Must be a boolean value (true/false)\n   2.4. Validate uploadIcon field:\n       - Check if the specified icon exists in the system (if provided)\n   2.5. Validate extensionGroup field:\n       - Must be a valid extension group ID that exists in the system\n       - Must be a positive integer\n\n3. Business Rule Processing:\n   3.1. Check system state:\n       - Verify the attachment system is enabled\n       - Verify the user has administrative privileges to add extensions\n   3.2. Check extension group validity:\n       - Verify the selected extension group exists\n       - Verify the selected extension group allows new extensions\n   3.3. Check for duplicate extensions:\n       - Verify the extension doesn't already exist in the system\n\n4. Core Operation Execution:\n   4.1. Prepare extension data:\n       - Format the extension properly (remove leading period if present)\n       - Set the allow status based on input\n       - Associate with the specified extension group\n   4.2. Create extension record:\n       - Create a new extension entry in the system\n       - Associate the extension with its group\n       - Set the upload icon for the extension\n       - Set the comment/description for the extension\n   4.3. Update related configurations:\n       - Update any caches or runtime configurations related to extensions\n\n5. Response Generation:\n   5.1. For successful creation:\n       - Generate success message indicating the extension was created\n       - Include the extension details in the response\n       - Provide navigation options to manage extensions\n   5.2. For validation failures:\n       - Return appropriate error messages for each validation failure\n       - Preserve user input for correction\n   5.3. For system errors:\n       - Generate appropriate error message\n       - Log the error details for administrators",
    "databaseEntities": [
      "jforum_extension_groups",
      "jforum_attachments"
    ],
    "validationRules": [
      "Extension must not be empty",
      "Extension group ID must be valid and exist in the system",
      "Extension must not already exist in the system",
      "Extension must contain only valid characters",
      "Upload icon must exist in the system if specified"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "AttachmentExtension": {
        "id": "number",
        "extension": "string",
        "comment": "string",
        "allow": "boolean",
        "uploadIcon": "string",
        "extensionGroupId": "number"
      }
    }
  },
  {
    "featureName": "UpdateExtensions",
    "description": "Updates or deletes existing file extension entries in the system.",
    "inputValues": [
      "extensionId-number-AttachmentExtension",
      "extension-string-AttachmentExtension",
      "allow-boolean-AttachmentExtension",
      "comment-string-AttachmentExtension",
      "uploadIcon-string-AttachmentExtension",
      "extensionGroupId-number-AttachmentExtension",
      "deleteIds-object-DeleteSelection"
    ],
    "businessLogic": "1. Input Collection:\n   1.1. Collect the following inputs:\n       - Total number of extension records to process\n       - For each extension record:\n           - Extension ID (system-generated, mandatory)\n           - Extension name (mandatory)\n           - Allow flag (optional, defaults to false)\n           - Comment (optional)\n           - Upload icon path (optional)\n           - Extension group ID (mandatory)\n       - List of extension IDs to delete (optional)\n\n2. Data Validation:\n   2.1. Validate total records count:\n       - IF total records count is less than 0 THEN\n           - Generate error message: \"Invalid record count\"\n       - END IF\n   2.2. For each extension record:\n       - IF extension name is empty THEN\n           - Generate error message: \"Extension name cannot be empty\"\n       - END IF\n       - IF extension name starts with a period (.) THEN\n           - Remove the leading period\n       - END IF\n       - IF extension group ID is not valid THEN\n           - Generate error message: \"Invalid extension group selected\"\n       - END IF\n   2.3. For delete selection:\n       - Verify each ID in delete list exists in the system\n       - IF any ID does not exist THEN\n           - Generate warning: \"One or more selected extensions do not exist\"\n       - END IF\n\n3. Business Rule Processing:\n   3.1. Check system state:\n       - Verify extension management is enabled in system\n       - IF not enabled THEN\n           - Generate error message: \"Extension management is disabled\"\n           - Abort operation\n       - END IF\n   3.2. Check for duplicate extensions:\n       - For each extension being updated:\n           - IF extension name already exists for another ID THEN\n               - Generate error message: \"Extension already exists\"\n           - END IF\n   3.3. Check extension group validity:\n       - For each extension record:\n           - Verify the extension group ID exists\n           - IF extension group does not exist THEN\n               - Generate error message: \"Selected extension group does not exist\"\n           - END IF\n\n4. Core Operation Execution:\n   4.1. Process deletion requests:\n       - IF delete list is not empty THEN\n           - Remove all extensions with IDs in the delete list\n           - Log deletion activity\n       - END IF\n   4.2. Process update requests:\n       - For each extension record not in delete list:\n           - Create extension object with provided values\n           - Update extension record in storage\n           - Log update activity\n       - END IF\n   4.3. Handle transaction integrity:\n       - IF any operation fails THEN\n           - Rollback all changes\n           - Generate error message: \"Failed to update extensions\"\n       - END IF\n\n5. Response Generation:\n   5.1. For successful operation:\n       - Generate success message: \"Extensions updated successfully\"\n       - Prepare updated list of all extensions\n       - Include list of extension groups for reference\n   5.2. For failed operation:\n       - Return appropriate error messages\n       - Maintain user input values for correction\n       - Provide guidance on resolving issues",
    "databaseEntities": [
      "jforum_extension_groups",
      "jforum_attachments"
    ],
    "validationRules": [
      "Extension name must not be empty",
      "Extension group ID must be valid",
      "Extension name must be unique in the system",
      "Extension group must exist in the system",
      "If extension name starts with a period, it will be removed"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "DeleteSelection": {
        "type": "object",
        "properties": {
          "ids": {
            "type": "array",
            "items": {
              "type": "number"
            },
            "description": "Array of extension IDs to be deleted"
          }
        }
      }
    }
  },
  {
    "featureName": "SaveGroupQuotas",
    "description": "Assigns quota limits to specific user groups for managing attachment size restrictions.",
    "inputValues": [
      "groupIds-number-Group",
      "quotaLimitIds-number-QuotaLimit"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the following inputs:\n     - Group IDs (mandatory): Identifiers for user groups to assign quotas to\n     - Quota Limit IDs (mandatory): Identifiers for quota limits to be assigned\n     - Total number of groups (system-generated): Count of groups to process\n\n2. Data Validation:\n   - Validate Group IDs:\n     - IF any Group ID is less than or equal to 0, THEN reject with error message \"Invalid group ID\"\n     - IF any Group ID does not exist in the system, THEN reject with error message \"Group not found\"\n   - Validate Quota Limit IDs:\n     - IF any Quota Limit ID is empty or null, THEN skip this entry (no quota assigned)\n     - IF any provided Quota Limit ID does not exist, THEN reject with error message \"Invalid quota limit\"\n\n3. Business Rule Processing:\n   - Check user permissions:\n     - IF current user does not have administrative privileges, THEN reject with error message \"Insufficient permissions\"\n   - Verify quota limit compatibility:\n     - FOR EACH quota limit being assigned:\n       - Verify the quota limit is active and available for assignment\n       - IF quota limit is disabled, THEN reject with error message \"Cannot assign inactive quota limit\"\n\n4. Core Operation Execution:\n   - Clean existing group quota assignments:\n     - Remove all current quota assignments for the specified groups\n     - Prepare system for new assignments\n   - Process group quota assignments:\n     - FOR EACH group in the input list:\n       - IF a quota limit is specified for this group:\n         - Create association between group and quota limit\n         - Record the assignment in the system\n       - ELSE:\n         - Skip this group (no quota will be assigned)\n   - Finalize quota assignments:\n     - Commit all changes to ensure data consistency\n     - Update any cached quota information\n\n5. Response Generation:\n   - Success response:\n     - Return confirmation message \"Group quota limits successfully saved\"\n     - Include summary of groups updated and their assigned quotas\n   - Error response:\n     - Return specific error message based on validation or processing failures\n     - Include guidance on how to correct the issue",
    "databaseEntities": [
      "jforum_groups",
      "jforum_quota_limit"
    ],
    "validationRules": [
      "Group IDs must be positive integers",
      "Group IDs must refer to existing groups",
      "Quota Limit IDs must refer to existing quota limits",
      "User must have administrative privileges to assign quotas",
      "Each group can have only one quota limit assigned"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Group": {
        "id": "number",
        "name": "string",
        "description": "string"
      },
      "QuotaLimit": {
        "id": "number",
        "description": "string",
        "size": "number",
        "type": "number"
      }
    }
  },
  {
    "featureName": "ListBanItems",
    "description": "Retrieves and displays all banned items including emails, users, and IPs.",
    "inputValues": [],
    "businessLogic": "1. Input Collection:\n   - No user inputs required for initial list display\n   - System will retrieve all banned items from the data store\n\n2. Data Validation:\n   - No input validation required for initial list display\n\n3. Business Rule Processing:\n   3.1. Verify user has administrative access\n      - IF user does not have admin privileges THEN\n         - Display access denied message\n         - Terminate process\n      - END IF\n\n4. Core Operation Execution:\n   4.1. Retrieve banned items\n      - Query data store for all banned items\n      - Organize items by type (email, user, IP)\n      - Sort items in appropriate order (alphabetical or chronological)\n   4.2. Process banned items for display\n      - For each banned item:\n         - Format the item details for display\n         - Include item type (email, user, IP)\n         - Include value of the banned item\n         - Include date when the ban was created\n         - Include ban reason if available\n         - Add item to display collection\n\n5. Response Generation:\n   5.1. Prepare display data\n      - Format the list of banned items for display\n      - Include column headers for item type, value, and other relevant information\n      - Include total count of banned items\n   5.2. Generate display view\n      - Display the list of banned items in tabular format\n      - Include action buttons for each item (delete, edit)\n      - Include option to add new banned items\n      - IF no banned items exist THEN\n         - Display message indicating no banned items found\n      - END IF",
    "databaseEntities": [
      "jforum_users"
    ],
    "validationRules": [
      "User must have administrative privileges to view banned items",
      "Banned items must be categorized by type (email, user, IP)"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "BanItem": {
        "id": "number",
        "type": "string",
        "value": "string",
        "creationDate": "date",
        "reason": "string"
      }
    }
  },
  {
    "featureName": "InsertBanItem",
    "description": "Displays and processes the form for adding a new ban entry to the system.",
    "inputValues": [
      "type-string-Banlist",
      "value-string-Banlist"
    ],
    "businessLogic": "1. Input Collection\n   - Collect the following required inputs:\n     1.1. Ban type (type): A string indicating the type of ban (email, user, or IP)\n     1.2. Ban value (value): A string containing the actual value to be banned\n   - Both fields are mandatory for the operation to proceed\n\n2. Data Validation\n   2.1. Validate ban type input\n      - Check if the ban type is not empty\n      - Verify the ban type is one of the allowed values: \"email\", \"user\", or \"ip\"\n      - IF ban type is invalid or empty THEN\n         - Prepare error message indicating invalid ban type\n         - Return to the input form with the error message\n      - END IF\n\n   2.2. Validate ban value input\n      - Check if the ban value is not empty\n      - IF ban value is empty THEN\n         - Prepare error message indicating missing ban value\n         - Return to the input form with the error message\n      - END IF\n      - Perform type-specific validation:\n         - IF ban type is \"email\" THEN\n            - Validate email format\n         - ELSE IF ban type is \"user\" THEN\n            - Validate that value can be converted to a valid user ID\n            - Verify the user ID exists in the system\n         - ELSE IF ban type is \"ip\" THEN\n            - Validate IP address format\n         - END IF\n\n3. Business Rule Processing\n   3.1. Check for duplicate entries\n      - Query existing ban entries to check if the same type and value already exist\n      - IF duplicate entry found THEN\n         - Prepare error message indicating duplicate ban entry\n         - Return to the input form with the error message\n      - END IF\n\n   3.2. Verify system permissions\n      - Verify the current user has administrative privileges to add ban entries\n      - IF user lacks required permissions THEN\n         - Prepare error message indicating insufficient permissions\n         - Redirect to appropriate error page\n      - END IF\n\n4. Core Operation Execution\n   4.1. Create new ban entry\n      - Initialize a new ban entry object\n      - Based on the ban type:\n         - IF type is \"email\" THEN\n            - Set the email field of the ban entry\n         - ELSE IF type is \"user\" THEN\n            - Convert value to integer user ID\n            - Set the user ID field of the ban entry\n         - ELSE IF type is \"ip\" THEN\n            - Set the IP field of the ban entry\n         - END IF\n\n   4.2. Save the ban entry\n      - Store the new ban entry in the database\n      - Update the system's ban list repository with the new entry\n      - IF save operation fails THEN\n         - Prepare error message indicating save failure\n         - Return to the input form with the error message\n      - END IF\n\n5. Response Generation\n   5.1. On successful ban entry creation\n      - Generate success message indicating the ban was successfully added\n      - Redirect to the ban list page showing all current bans including the new entry\n\n   5.2. On failure\n      - Generate appropriate error message based on the failure reason\n      - Return to the ban entry form with error details\n      - Preserve previously entered values to avoid re-entry",
    "databaseEntities": [
      "jforum_users",
      "jforum_sessions"
    ],
    "validationRules": [
      "Ban type must not be empty",
      "Ban type must be one of: email, user, or ip",
      "Ban value must not be empty",
      "If ban type is email, value must be a valid email format",
      "If ban type is user, value must be a valid user ID",
      "If ban type is ip, value must be a valid IP address format",
      "User must have administrative privileges to add ban entries"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Banlist": {
        "type": "object",
        "properties": {
          "id": {
            "type": "number",
            "description": "Unique identifier for the ban entry"
          },
          "type": {
            "type": "string",
            "enum": [
              "email",
              "user",
              "ip"
            ],
            "description": "Type of ban entry"
          },
          "value": {
            "type": "string",
            "description": "The actual value being banned (email address, user ID, or IP address)"
          }
        },
        "required": [
          "type",
          "value"
        ]
      }
    }
  },
  {
    "featureName": "SaveBanItem",
    "description": "Creates a new ban entry for email, user, or IP address in the system.",
    "inputValues": [
      "type-string-Banlist",
      "value-string-Banlist"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the ban type (mandatory string): email, user, or IP address\n   - Collect the ban value (mandatory string): the actual value to ban\n   - System will generate a unique identifier for the ban entry\n\n2. Data Validation:\n   - Validate ban type:\n     a. Check if type is not empty\n     b. Verify type is one of the allowed values: \"email\", \"user\", or \"ip\"\n     c. If validation fails, prepare error message indicating valid ban types\n   - Validate ban value:\n     a. Check if value is not empty\n     b. IF type is \"email\":\n        i. Verify value follows email format pattern\n     c. IF type is \"user\":\n        i. Verify value can be converted to a valid user identifier\n        ii. Verify user exists in the system\n     d. IF type is \"ip\":\n        i. Verify value follows valid IP address format\n     e. If validation fails, prepare appropriate error message based on type\n\n3. Business Rule Processing:\n   - Check for duplicate ban entries:\n     a. IF type is \"email\":\n        i. Verify the email is not already banned\n     b. IF type is \"user\":\n        i. Verify the user is not already banned\n     c. IF type is \"ip\":\n        i. Verify the IP address is not already banned\n   - Verify current user has permission to create ban entries\n   - If any business rule fails, prepare appropriate error message\n\n4. Core Operation Execution:\n   - Create new ban entry object\n   - Set the appropriate ban property based on type:\n     a. IF type is \"email\":\n        i. Set email property to the provided value\n     b. IF type is \"user\":\n        i. Convert value to integer user ID\n        ii. Set userId property to the converted value\n     c. IF type is \"ip\":\n        i. Set IP property to the provided value\n   - Save the ban entry to the persistent storage\n   - Update the ban list repository with the new entry\n   - IF any operation fails:\n     a. Roll back any partial changes\n     b. Prepare error message indicating failure reason\n\n5. Response Generation:\n   - IF operation successful:\n     a. Prepare success message indicating ban was created\n     b. Include ban entry details in response\n     c. Provide navigation options to view ban list\n   - IF operation failed:\n     a. Include detailed error message\n     b. Provide option to retry with corrected information\n     c. Include support information if needed",
    "databaseEntities": [
      "jforum_users",
      "jforum_banlist"
    ],
    "validationRules": [
      "Ban type must not be empty",
      "Ban type must be one of: email, user, or ip",
      "Ban value must not be empty",
      "Email ban value must follow valid email format",
      "User ban value must be a valid user identifier",
      "IP ban value must follow valid IP address format",
      "Ban entry must not be a duplicate of an existing entry"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Banlist": {
        "id": "number",
        "type": "string",
        "value": "string",
        "email": "string",
        "userId": "number",
        "ip": "string"
      }
    }
  },
  {
    "featureName": "DeleteBanItems",
    "description": "Removes selected ban entries from the system.",
    "inputValues": [
      "banlist_id-string-Banlist"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the following inputs:\n     a. banlist_id (mandatory): Array of identifiers for ban entries to be deleted\n\n2. Data Validation:\n   - Validate banlist_id input:\n     a. Check if banlist_id array is not null\n     b. Check if banlist_id array is not empty\n     c. IF validation fails, THEN:\n        i. Display error message indicating no items were selected for deletion\n        ii. Return to ban list view without performing deletion\n\n3. Business Rule Processing:\n   - Verify user permissions:\n     a. Check if current user has administrative privileges to delete ban entries\n     b. IF user lacks required permissions, THEN:\n        i. Display access denied message\n        ii. Log unauthorized deletion attempt\n        iii. Return to previous page\n   - Verify system state:\n     a. Check if ban list repository is available\n     b. IF repository is unavailable, THEN:\n        i. Display system error message\n        ii. Log the system error\n        iii. Return to previous page\n\n4. Core Operation Execution:\n   - Process each selected ban entry:\n     a. FOR EACH banlist_id in the input array:\n        i. Parse the string ID to numeric format\n        ii. Locate the ban entry in the system by ID\n        iii. IF entry exists, THEN:\n             1. Remove entry from persistent storage\n             2. Remove entry from system cache/repository\n        iv. IF entry does not exist, THEN:\n             1. Log warning about attempting to delete non-existent entry\n             2. Continue with next entry\n   - Handle operation results:\n     a. Track successful and failed deletions\n     b. IF any deletions failed, THEN:\n        i. Prepare partial success message with details\n     c. ELSE:\n        i. Prepare complete success message\n\n5. Response Generation:\n   - Generate appropriate response:\n     a. IF all selected entries were successfully deleted, THEN:\n        i. Display success message indicating number of entries removed\n     b. IF some entries failed to delete, THEN:\n        i. Display partial success message with details of failures\n     c. IF all entries failed to delete, THEN:\n        i. Display error message with failure reason\n   - Refresh ban list view:\n     a. Retrieve updated list of ban entries\n     b. Display updated ban list to user",
    "databaseEntities": [
      "jforum_banlist"
    ],
    "validationRules": [
      "At least one ban item must be selected for deletion",
      "User must have administrative privileges to delete ban entries",
      "Selected ban items must exist in the system"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Banlist": {
        "id": "number",
        "type": "string",
        "value": "string",
        "email": "string",
        "userId": "number",
        "ip": "string"
      }
    }
  },
  {
    "featureName": "ListBanners",
    "description": "Retrieves and displays all banners in the system.",
    "inputValues": [],
    "businessLogic": "1. Input Collection:\n   - No user inputs required for this feature\n   - System will automatically retrieve all banner records\n\n2. Data Validation:\n   - Verify user has appropriate access permissions to view banner listings\n   - IF user does not have required permissions THEN\n     - Display access denied message\n     - Terminate process\n   - END IF\n\n3. Business Rule Processing:\n   - Verify banner data source is available\n   - IF data source is unavailable THEN\n     - Log system error\n     - Display appropriate error message to user\n     - Terminate process\n   - END IF\n\n4. Core Operation Execution:\n   - Retrieve all banner records from the data store\n   - Sort banners according to system default ordering (if applicable)\n   - Prepare banner data for display\n     - Format banner attributes for presentation\n     - Calculate any derived values (such as status indicators)\n     - Prepare action links for each banner (edit, delete options)\n\n5. Response Generation:\n   - IF no banners exist in the system THEN\n     - Display empty state message\n     - Provide guidance on creating new banners\n   - ELSE\n     - Display banner listing with the following information for each banner:\n       - Banner name\n       - Description\n       - Active status\n       - Type\n       - Placement information\n       - Dimensions (width/height)\n       - Performance metrics (views/clicks)\n       - Action options (edit, delete)\n   - END IF\n   - Provide option to create new banner",
    "databaseEntities": [
      "Banner"
    ],
    "validationRules": [
      "User must have administrative access to view banners",
      "Banner listing must show all banners regardless of status",
      "Banner listing must include active status indicators",
      "Banner listing must provide edit and delete options for each banner"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Banner": {
        "id": "number",
        "name": "string",
        "description": "string",
        "comment": "string",
        "active": "boolean",
        "type": "number",
        "width": "number",
        "height": "number",
        "url": "string",
        "placement": "number",
        "weight": "number",
        "views": "number",
        "clicks": "number"
      }
    }
  },
  {
    "featureName": "InsertBanner",
    "description": "Displays form for creating a new banner and processes the form submission.",
    "inputValues": [
      "comment-string-Banner",
      "active-boolean-Banner",
      "type-number-Banner",
      "name-string-Banner",
      "description-string-Banner",
      "width-number-Banner",
      "height-number-Banner",
      "url-string-Banner",
      "placement-number-Banner",
      "weight-number-Banner",
      "views-number-Banner",
      "clicks-number-Banner"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the following banner information from the user:\n     a. Name (mandatory): Banner name identifier\n     b. Description (mandatory): Detailed description of the banner\n     c. Comment (optional): Additional notes about the banner\n     d. Active status (mandatory): Whether the banner is active (true/false)\n     e. Type (mandatory): Numeric code representing banner type\n     f. Width (mandatory): Width dimension in pixels\n     g. Height (mandatory): Height dimension in pixels\n     h. URL (mandatory): Target URL for the banner\n     i. Placement (mandatory): Numeric code for banner placement location\n     j. Weight (mandatory): Priority weight for display frequency\n     k. Views (optional): Initial view count, defaults to 0\n     l. Clicks (optional): Initial click count, defaults to 0\n\n2. Data Validation:\n   - Validate banner name:\n     a. Check if name is not empty\n     b. Verify name length is within acceptable limits\n     c. IF validation fails, display error message and retain form data\n   - Validate banner description:\n     a. Check if description is not empty\n     b. Verify description length is within acceptable limits\n     c. IF validation fails, display error message and retain form data\n   - Validate dimensions:\n     a. Ensure width is a positive integer\n     b. Ensure height is a positive integer\n     c. IF validation fails, display error message and retain form data\n   - Validate URL:\n     a. Check if URL is not empty\n     b. Verify URL format is valid\n     c. IF validation fails, display error message and retain form data\n   - Validate placement and type:\n     a. Ensure placement value is within valid range\n     b. Ensure type value is within valid range\n     c. IF validation fails, display error message and retain form data\n   - Validate weight:\n     a. Ensure weight is a non-negative integer\n     b. IF validation fails, display error message and retain form data\n\n3. Business Rule Processing:\n   - Check system constraints:\n     a. Verify system has sufficient storage capacity for new banner\n     b. Check if user has permission to create banners\n     c. IF any constraint fails, display appropriate error message\n   - Evaluate banner placement availability:\n     a. Check if the selected placement location can accommodate another banner\n     b. IF placement is unavailable, suggest alternative placement options\n   - Assess banner type compatibility:\n     a. Verify the selected type is compatible with the provided dimensions\n     b. IF incompatible, suggest appropriate dimensions for the selected type\n\n4. Core Operation Execution:\n   - Prepare banner data:\n     a. Format all input values according to system requirements\n     b. Set default values for any missing optional fields\n   - Create banner record:\n     a. Generate a unique identifier for the new banner\n     b. Store all banner information in the system\n     c. IF storage operation fails, display error message and allow retry\n   - Initialize banner metrics:\n     a. Set up tracking for banner views and clicks\n     b. Initialize any required monitoring systems\n     c. IF initialization fails, log warning but proceed\n\n5. Response Generation:\n   - For successful creation:\n     a. Display success message confirming banner creation\n     b. Show summary of created banner details\n     c. Provide options to view all banners or create another banner\n   - For failed creation:\n     a. Display detailed error message explaining the failure\n     b. Retain all entered form data for correction\n     c. Provide guidance on resolving the issue",
    "databaseEntities": [
      "Banner"
    ],
    "validationRules": [
      "Banner name must not be empty",
      "Banner description must not be empty",
      "Banner width must be a positive integer",
      "Banner height must be a positive integer",
      "Banner URL must be valid and not empty",
      "Banner placement must be within valid range",
      "Banner type must be within valid range",
      "Banner weight must be a non-negative integer"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Banner": {
        "id": "number",
        "name": "string",
        "description": "string",
        "comment": "string",
        "active": "boolean",
        "type": "number",
        "width": "number",
        "height": "number",
        "url": "string",
        "placement": "number",
        "weight": "number",
        "views": "number",
        "clicks": "number"
      }
    }
  },
  {
    "featureName": "SaveNewBanner",
    "description": "Creates and saves a new banner with specified attributes.",
    "inputValues": [
      "comment-string-Banner",
      "active-boolean-Banner",
      "type-number-Banner",
      "name-string-Banner",
      "description-string-Banner",
      "width-number-Banner",
      "height-number-Banner",
      "url-string-Banner",
      "placement-number-Banner",
      "weight-number-Banner",
      "views-number-Banner",
      "clicks-number-Banner"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the following banner information from the user:\n     1.1. name (mandatory): Banner name identifier\n     1.2. comment (optional): Additional notes about the banner\n     1.3. active (mandatory): Boolean flag indicating if banner is active\n     1.4. type (mandatory): Numeric value representing banner type\n     1.5. description (mandatory): Detailed description of the banner\n     1.6. width (mandatory): Numeric width of the banner in pixels\n     1.7. height (mandatory): Numeric height of the banner in pixels\n     1.8. url (mandatory): Web address the banner links to\n     1.9. placement (mandatory): Numeric value indicating display position\n     1.10. weight (mandatory): Numeric value for banner priority\n     1.11. views (mandatory): Initial view count, typically zero for new banners\n     1.12. clicks (mandatory): Initial click count, typically zero for new banners\n\n2. Data Validation:\n   2.1. Validate name field:\n      - IF name is empty or null THEN\n        - Generate error message: \"Banner name is required\"\n      - IF name exceeds maximum allowed length THEN\n        - Generate error message: \"Banner name cannot exceed [X] characters\"\n   2.2. Validate type field:\n      - IF type is not a valid banner type value THEN\n        - Generate error message: \"Invalid banner type selected\"\n   2.3. Validate dimensions:\n      - IF width is not a positive number THEN\n        - Generate error message: \"Width must be a positive number\"\n      - IF height is not a positive number THEN\n        - Generate error message: \"Height must be a positive number\"\n   2.4. Validate URL:\n      - IF url is empty or null THEN\n        - Generate error message: \"Banner URL is required\"\n      - IF url format is invalid THEN\n        - Generate error message: \"Please enter a valid URL\"\n   2.5. Validate placement:\n      - IF placement value is not within valid range THEN\n        - Generate error message: \"Invalid placement position selected\"\n   2.6. Validate weight:\n      - IF weight is negative THEN\n        - Generate error message: \"Weight cannot be negative\"\n   2.7. Validate counters:\n      - IF views is negative THEN\n        - Generate error message: \"View count cannot be negative\"\n      - IF clicks is negative THEN\n        - Generate error message: \"Click count cannot be negative\"\n\n3. Business Rule Processing:\n   3.1. Check system banner limits:\n      - IF maximum number of active banners would be exceeded THEN\n        - Generate warning: \"Adding this banner may affect system performance\"\n   3.2. Check banner name uniqueness:\n      - IF banner with same name already exists THEN\n        - Generate warning: \"A banner with this name already exists\"\n   3.3. Verify banner dimensions compatibility:\n      - IF banner dimensions exceed recommended sizes for selected placement THEN\n        - Generate warning: \"Banner dimensions may not be optimal for selected placement\"\n   3.4. Check URL accessibility:\n      - IF banner URL appears to be inaccessible THEN\n        - Generate warning: \"The specified URL may not be accessible\"\n\n4. Core Operation Execution:\n   4.1. Create new banner object:\n      - Initialize a new banner entity\n      - Populate all banner attributes from validated input\n   4.2. Save banner to storage:\n      - Add banner to persistent storage\n      - Generate unique identifier for the banner\n   4.3. Update banner index:\n      - Add banner to active banners list if active flag is true\n   4.4. Initialize banner statistics:\n      - Set creation timestamp\n      - Initialize tracking data for banner performance\n   4.5. Handle any storage failures:\n      - IF storage operation fails THEN\n        - Revert any partial changes\n        - Log detailed error information\n        - Prepare user-friendly error message\n\n5. Response Generation:\n   5.1. For successful creation:\n      - Generate success message: \"Banner '[name]' has been successfully created\"\n      - Include banner ID in response\n      - Provide link to view all banners\n   5.2. For validation failures:\n      - Return all validation error messages\n      - Preserve user input for correction\n   5.3. For system failures:\n      - Generate appropriate error message\n      - Provide guidance on next steps\n      - Include support reference if applicable",
    "databaseEntities": [
      "Banner"
    ],
    "validationRules": [
      "Banner name must not be empty",
      "Banner type must be a valid value",
      "Banner width and height must be positive numbers",
      "Banner URL must not be empty",
      "Banner URL must be in valid format",
      "Banner placement must be within valid range",
      "Banner weight must not be negative",
      "Banner view and click counts must not be negative"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Banner": {
        "id": "number",
        "comment": "string",
        "active": "boolean",
        "type": "number",
        "name": "string",
        "description": "string",
        "width": "number",
        "height": "number",
        "url": "string",
        "placement": "number",
        "weight": "number",
        "views": "number",
        "clicks": "number"
      }
    }
  },
  {
    "featureName": "EditBanner",
    "description": "Displays form for editing an existing banner and saves the updated information.",
    "inputValues": [
      "banner_id-number-Banner",
      "comment-string-Banner",
      "active-number-Banner",
      "type-number-Banner",
      "name-string-Banner",
      "description-string-Banner",
      "width-number-Banner",
      "height-number-Banner",
      "url-string-Banner",
      "placement-number-Banner",
      "weight-number-Banner",
      "views-number-Banner",
      "clicks-number-Banner"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the banner ID from the request\n   - Retrieve the existing banner data using the ID\n   - Display the edit form with pre-populated banner data\n   - Required fields include:\n     * banner_id (system-generated, mandatory)\n     * name (mandatory)\n     * description (mandatory)\n     * type (mandatory)\n     * active status (mandatory, default: 1 for active)\n     * width (mandatory)\n     * height (mandatory)\n     * url (mandatory)\n     * placement (mandatory)\n     * weight (mandatory, default: 1)\n     * views (mandatory, default: 0)\n     * clicks (mandatory, default: 0)\n     * comment (optional)\n\n2. Data Validation:\n   - Validate banner ID:\n     * Must be a positive integer\n     * Must correspond to an existing banner in the system\n     * Error message if banner not found: \"Banner not found\"\n   - Validate name:\n     * Must not be empty\n     * Maximum length check (255 characters)\n     * Error message: \"Banner name is required and cannot exceed 255 characters\"\n   - Validate description:\n     * Must not be empty\n     * Error message: \"Banner description is required\"\n   - Validate dimensions:\n     * Width must be a positive integer\n     * Height must be a positive integer\n     * Error message: \"Width and height must be positive numbers\"\n   - Validate URL:\n     * Must not be empty\n     * Must be a valid URL format\n     * Error message: \"Valid URL is required\"\n   - Validate type:\n     * Must be a valid banner type value\n     * Error message: \"Invalid banner type\"\n   - Validate placement:\n     * Must be a valid placement value\n     * Error message: \"Invalid placement value\"\n\n3. Business Rule Processing:\n   - Check if user has administrative permissions\n     * IF user does not have admin permissions THEN\n       - Display error message: \"Insufficient permissions\"\n       - Return to banner list\n   - Check if banner exists\n     * IF banner with provided ID does not exist THEN\n       - Display error message: \"Banner not found\"\n       - Return to banner list\n   - Check if banner is currently in use\n     * IF banner is in use and critical fields are being modified THEN\n       - Display warning: \"Modifying this banner may affect its display on active pages\"\n\n4. Core Operation Execution:\n   - Create a Banner object with the updated information\n   - Set all properties from the form inputs:\n     * comment\n     * active status\n     * type\n     * name\n     * description\n     * width\n     * height\n     * url\n     * placement\n     * weight\n     * views\n     * clicks\n   - Update the banner record in the database\n   - IF update fails THEN\n     * Display error message: \"Failed to update banner\"\n     * Maintain form with entered values\n   - IF update succeeds THEN\n     * Record the update action in the system log\n     * Proceed to success response\n\n5. Response Generation:\n   - Upon successful update:\n     * Display success message: \"Banner updated successfully\"\n     * Return to the banner list view showing all banners including the updated one\n   - Upon failure:\n     * Display appropriate error message based on the failure reason\n     * Return to the edit form with previously entered values preserved\n     * Highlight fields with errors",
    "databaseEntities": [
      "Banner"
    ],
    "validationRules": [
      "Banner ID must be a positive integer",
      "Banner name must not be empty",
      "Banner description must not be empty",
      "Width must be a positive integer",
      "Height must be a positive integer",
      "URL must not be empty and must be valid",
      "Type must be a valid banner type value",
      "Placement must be a valid placement value",
      "Active status must be either 0 or 1",
      "Weight must be a positive integer",
      "Views must be a non-negative integer",
      "Clicks must be a non-negative integer"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Banner": {
        "id": "number",
        "name": "string",
        "description": "string",
        "comment": "string",
        "active": "boolean",
        "type": "number",
        "width": "number",
        "height": "number",
        "url": "string",
        "placement": "number",
        "weight": "number",
        "views": "number",
        "clicks": "number"
      }
    }
  },
  {
    "featureName": "ListCacheStatus",
    "description": "Displays the status of various system caches in the admin interface.",
    "inputValues": [],
    "businessLogic": "1. Input Collection:\n   - No user inputs required for initial display\n   - System will gather cache information automatically\n\n2. Data Validation:\n   - No user input validation required for initial display\n   - System will verify access permissions\n     - IF user is not an administrator THEN\n       - Display access denied message\n       - End process\n     - END IF\n\n3. Business Rule Processing:\n   - System checks availability of all cache repositories\n     - Verify BBCode repository is accessible\n     - Verify Modules repository is accessible\n     - Verify Ranking repository is accessible\n     - Verify Smilies repository is accessible\n     - Verify Security repository is accessible\n     - Verify Forum repository is accessible\n     - Verify Topic repository is accessible\n     - Verify Session repository is accessible\n     - Verify Posts repository is accessible\n   - IF any repository is not accessible THEN\n     - Record error information for display\n   - END IF\n\n4. Core Operation Execution:\n   - System retrieves status information from each cache repository:\n     - For BBCode repository:\n       - Retrieve number of cached items\n       - Retrieve last update timestamp\n     - For Modules repository:\n       - Retrieve list of loaded modules\n       - Retrieve configuration status\n     - For Ranking repository:\n       - Retrieve number of rank definitions\n       - Retrieve last update timestamp\n     - For Smilies repository:\n       - Retrieve number of smilies cached\n       - Retrieve last update timestamp\n     - For Security repository:\n       - Retrieve security configuration status\n     - For Forum repository:\n       - Retrieve number of forums cached\n       - Retrieve categories information\n     - For Topic repository:\n       - Retrieve number of topics in cache\n       - Retrieve cache hit statistics if available\n     - For Session repository:\n       - Retrieve number of active sessions\n       - Retrieve session timeout settings\n     - For Posts repository:\n       - Retrieve number of cached posts\n       - Retrieve cache efficiency statistics if available\n\n5. Response Generation:\n   - System prepares cache status display:\n     - Format cache information in a structured layout\n     - For each cache repository:\n       - Display name and current status (active/inactive)\n       - Display item count and memory usage if available\n       - Display last update timestamp if applicable\n       - Provide reload/clear buttons for each cache type\n     - IF detailed information is requested for Topics cache THEN\n       - Display additional information organized by categories\n       - Show forum-specific topic cache statistics\n       - Provide forum-specific cache clearing options\n     - END IF\n     - IF detailed information is requested for Posts cache THEN\n       - Display cached topics list with post counts\n       - Show post cache hit statistics if available\n       - Provide topic-specific cache clearing options\n     - END IF",
    "databaseEntities": [
      "jforum_users",
      "jforum_groups",
      "jforum_categories",
      "jforum_forums",
      "jforum_topics",
      "jforum_posts",
      "jforum_smilies",
      "jforum_sessions"
    ],
    "validationRules": [
      "User must have administrator privileges to access cache management",
      "Cache repositories must be properly initialized before status can be displayed",
      "Topic cache must be enabled to view detailed topic cache information",
      "Posts cache must be enabled to view detailed post cache information"
    ],
    "dbSeedingOperations": [],
    "schema": {}
  },
  {
    "featureName": "ReloadBBCodeCache",
    "description": "Reloads BBCode definitions from storage into the system cache.",
    "inputValues": [],
    "businessLogic": "1. Input Collection:\n   - No user inputs required for this operation\n   - System-generated request to reload BBCode cache\n\n2. Data Validation:\n   - Verify user has administrative permissions\n   - IF user does not have administrative permissions THEN\n     - Generate access denied error\n     - Terminate process\n   - END IF\n\n3. Business Rule Processing:\n   - Verify system is in a state where cache reload is possible\n   - Check if BBCode repository is accessible\n   - IF BBCode repository is not accessible THEN\n     - Generate system error message\n     - Terminate process\n   - END IF\n\n4. Core Operation Execution:\n   - Retrieve all BBCode definitions from storage\n   - Clear existing BBCode cache\n   - Parse BBCode definitions\n     - Process each BBCode pattern\n     - Process each BBCode replacement\n     - Validate BBCode syntax\n   - Load parsed BBCode definitions into cache\n   - Update cache timestamp\n   - Record cache reload event in system log\n\n5. Response Generation:\n   - Generate success message indicating BBCode cache was reloaded\n   - Display updated cache statistics:\n     - Number of BBCode definitions loaded\n     - Cache last updated timestamp\n   - Provide navigation options to return to cache management interface",
    "databaseEntities": [
      "jforum_posts",
      "jforum_posts_text"
    ],
    "validationRules": [
      "User must have administrative permissions to reload cache",
      "BBCode repository must be accessible",
      "System must be in a state where cache reload is possible"
    ],
    "dbSeedingOperations": [],
    "schema": {}
  },
  {
    "featureName": "ClearSessionCache",
    "description": "Clears all user session data from the cache to refresh system state and free up resources.",
    "inputValues": [
      "confirmAction-boolean-CacheAction"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect confirmation input (confirmAction) from the administrator\n   - System identifies the current user as an administrator with appropriate permissions\n   - No additional inputs required as this is a system-wide operation\n\n2. Data Validation:\n   - Validate that the user has administrative privileges\n     * IF user is not an administrator THEN\n       - Generate access denied error\n       - Terminate the operation\n     * END IF\n   - Validate the confirmation flag is set to true\n     * IF confirmation is not provided or false THEN\n       - Display confirmation request to the administrator\n       - Terminate the operation until confirmation is received\n     * END IF\n\n3. Business Rule Processing:\n   - Check if there are any critical system processes running\n     * IF critical processes are running THEN\n       - Generate warning message about potential impact\n       - Request additional confirmation\n     * END IF\n   - Verify system stability for cache clearing operation\n     * IF system is in unstable state THEN\n       - Generate warning about potential system impact\n       - Log the attempt with warning status\n     * END IF\n\n4. Core Operation Execution:\n   - Prepare system for session cache clearing\n     * Log the initiation of cache clearing operation\n     * Record the current number of active sessions for reporting\n   - Execute session cache clearing\n     * Remove all user session data from memory\n     * Release associated resources\n     * Reset session counters and tracking mechanisms\n   - Handle any exceptions during clearing process\n     * IF exceptions occur during clearing THEN\n       - Log the specific error details\n       - Attempt partial clearing if possible\n       - Prepare error report for administrator\n     * END IF\n\n5. Response Generation:\n   - Generate success response\n     * Include count of cleared sessions\n     * Include timestamp of operation\n     * Include system performance metrics before and after clearing\n   - Prepare cache status report\n     * Show current memory usage\n     * Show available system resources\n     * Display cache statistics after clearing\n   - Provide next steps information\n     * Suggest monitoring system performance\n     * Note that users will need to log in again\n     * Provide option to view system logs for detailed operation results",
    "databaseEntities": [
      "jforum_sessions"
    ],
    "validationRules": [
      "User must have administrative privileges to clear session cache",
      "Confirmation must be provided before clearing session cache",
      "System must be in a stable state for cache clearing operation"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "CacheAction": {
        "type": "object",
        "properties": {
          "confirmAction": {
            "type": "boolean",
            "description": "Flag indicating administrator confirmation to clear the session cache"
          }
        },
        "required": [
          "confirmAction"
        ]
      }
    }
  },
  {
    "featureName": "ReloadModulesCache",
    "description": "Reloads system modules configuration from the config directory.",
    "inputValues": [],
    "businessLogic": "1. Input Collection:\n   - No user inputs required for this operation\n   - System will use the configured config directory path from system globals\n\n2. Data Validation:\n   - Verify system administrator privileges\n     - IF user does not have administrator privileges THEN\n       - Generate access denied error\n       - Terminate process\n     - END IF\n   - Verify config directory exists and is accessible\n     - IF config directory is not found or not accessible THEN\n       - Generate configuration error\n       - Log error details\n       - Terminate process\n     - END IF\n\n3. Business Rule Processing:\n   - Check if system is in a state that allows module reloading\n     - IF system is currently processing critical operations THEN\n       - Queue reload request for later execution\n       - Notify administrator that reload will be delayed\n       - Terminate process\n     - END IF\n   - Verify module configuration files integrity\n     - FOR EACH module configuration file\n       - Check file exists and is readable\n       - Validate file format integrity\n       - IF any file fails validation THEN\n         - Log specific file error\n         - Continue to next file\n       - END IF\n     - END FOR\n\n4. Core Operation Execution:\n   - Prepare system for module reload\n     - Create backup of current module configuration\n     - Set system flag indicating reload in progress\n   - Execute modules reload operation\n     - Initialize modules repository with config directory path\n     - Load all module configuration files\n     - Parse configuration data\n     - Build new module registry\n   - Apply new module configuration\n     - Replace current module definitions with newly loaded ones\n     - Update module references throughout the system\n   - Finalize reload process\n     - Clear system flag indicating reload in progress\n     - Log successful reload completion\n\n5. Response Generation:\n   - Generate operation summary\n     - Include total number of modules reloaded\n     - List any modules with warnings or errors\n   - Return to cache management interface\n     - Display success message to administrator\n     - Show updated module cache information\n     - Provide option to reload other cache types",
    "databaseEntities": [],
    "validationRules": [
      "User must have administrator privileges",
      "Config directory must exist and be accessible",
      "System must not be processing critical operations during reload",
      "Module configuration files must be valid and readable"
    ],
    "dbSeedingOperations": [],
    "schema": {}
  },
  {
    "featureName": "ReloadSmiliesCache",
    "description": "Reloads emoticon definitions into the system cache.",
    "inputValues": [],
    "businessLogic": "1. Input Collection:\n   - No user inputs required\n   - System-generated trigger for cache reload operation\n\n2. Data Validation:\n   - Verify administrator privileges\n     - IF user does not have administrator privileges THEN\n       - Generate access denied error\n       - Terminate process\n     - END IF\n   - Verify system readiness for cache operation\n     - IF system is in maintenance mode THEN\n       - Queue operation for later execution\n       - Notify administrator of deferred execution\n       - Terminate process\n     - END IF\n\n3. Business Rule Processing:\n   - Check system resource availability\n     - IF system memory usage is above threshold THEN\n       - Log warning about potential performance impact\n     - END IF\n   - Verify smilies data source accessibility\n     - IF data source is unavailable THEN\n       - Generate data source error\n       - Log failure to access smilies data\n       - Terminate process\n     - END IF\n\n4. Core Operation Execution:\n   - Clear existing smilies from cache\n     - Remove all current emoticon definitions from memory\n     - Release associated resources\n   - Load smilies from data source\n     - Retrieve all emoticon definitions from database\n     - Parse emoticon data (codes, image paths, descriptions)\n     - Create optimized cache structure for emoticons\n   - Store smilies in system cache\n     - Organize emoticons by categories if applicable\n     - Index emoticons for efficient lookup\n     - Apply any configured sorting rules\n   - IF any errors occur during loading THEN\n     - Attempt to restore previous cache state\n     - Log cache restoration attempt result\n   - END IF\n\n5. Response Generation:\n   - Generate operation summary\n     - Include number of emoticons loaded\n     - Include cache memory usage statistics\n     - Include operation timestamp\n   - Display success message to administrator\n     - Confirm successful cache reload\n     - Show cache statistics summary\n   - Log cache reload event\n     - Record administrator who performed action\n     - Record operation timestamp\n     - Record operation success status",
    "databaseEntities": [
      "jforum_smilies"
    ],
    "validationRules": [
      "User must have administrator privileges",
      "System must not be in critical maintenance mode",
      "Smilies data source must be accessible",
      "System must have sufficient memory for cache operation"
    ],
    "dbSeedingOperations": [],
    "schema": {}
  },
  {
    "featureName": "ReloadRankingCache",
    "description": "Reloads user ranking definitions into the system cache.",
    "inputValues": [
      "adminRequest-boolean-System"
    ],
    "businessLogic": "1. Input Collection:\n   - adminRequest: boolean - Indicates if the request is from an authorized administrator (mandatory)\n   - System will use the current user's session information for authorization\n\n2. Data Validation:\n   - Validate user authorization\n     * IF user is not an administrator THEN\n       - Generate authorization error\n       - Terminate process\n     * END IF\n   - Validate system state\n     * IF system is in maintenance mode THEN\n       - Generate system unavailable error\n       - Terminate process\n     * END IF\n\n3. Business Rule Processing:\n   - Check system resources\n     * IF system memory is critically low THEN\n       - Log resource warning\n       - Continue with caution\n     * END IF\n   - Check concurrent operations\n     * IF another cache reload operation is in progress THEN\n       - Generate concurrent operation warning\n       - Wait for completion or terminate based on system policy\n     * END IF\n\n4. Core Operation Execution:\n   - Prepare for cache reload\n     * Lock ranking cache to prevent concurrent access\n     * Create backup of current ranking definitions\n   - Load ranking definitions\n     * Retrieve all ranking definitions from the database\n     * Parse ranking criteria and thresholds\n     * Organize rankings in memory structure\n   - Update system cache\n     * Clear existing ranking cache\n     * Store new ranking definitions in cache\n     * Update timestamp of last cache refresh\n   - Release resources\n     * Unlock ranking cache\n     * Remove temporary backup if operation successful\n\n5. Response Generation:\n   - Generate success response\n     * Include number of ranking definitions loaded\n     * Include timestamp of cache refresh\n     * Return to cache management interface\n   - Handle potential errors\n     * IF any error occurs during reload THEN\n       - Restore from backup if available\n       - Generate detailed error message\n       - Include troubleshooting information\n     * END IF",
    "databaseEntities": [
      "jforum_users",
      "jforum_groups"
    ],
    "validationRules": [
      "User must have administrator privileges to reload cache",
      "System must not be in maintenance mode",
      "Ranking definitions must be properly formatted in the database",
      "Cache reload operation cannot be performed while another reload is in progress"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "RankingDefinition": {
        "type": "object",
        "properties": {
          "id": {
            "type": "number",
            "description": "Unique identifier for the ranking"
          },
          "title": {
            "type": "string",
            "description": "Display name of the ranking"
          },
          "minPoints": {
            "type": "number",
            "description": "Minimum points required for this ranking"
          },
          "maxPoints": {
            "type": "number",
            "description": "Maximum points for this ranking level"
          },
          "imageUrl": {
            "type": "string",
            "description": "Optional image associated with the ranking"
          },
          "special": {
            "type": "boolean",
            "description": "Indicates if this is a special ranking not based on points"
          }
        },
        "required": [
          "id",
          "title",
          "minPoints",
          "special"
        ]
      }
    }
  },
  {
    "featureName": "ViewTopicCacheDetails",
    "description": "Displays detailed information about cached forum topics.",
    "inputValues": [
      "forumId-number-Forum"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect forumId (number) - The identifier of the forum to view cached topics for\n   - System will determine if topic caching is enabled\n\n2. Data Validation:\n   - Validate forumId:\n     a. Check if forumId is a valid number\n     b. Verify forumId exists in the system\n     c. Return appropriate error message if validation fails\n   - Validate system configuration:\n     a. Check if topic caching is enabled in system settings\n     b. IF topic caching is disabled, THEN\n        i. Redirect user to the main cache information page\n        ii. Display notification that topic caching is not enabled\n        iii. End process\n\n3. Business Rule Processing:\n   - Check user permissions:\n     a. Verify current user has administrative access to view cache details\n     b. IF user lacks proper permissions, THEN\n        i. Display access denied message\n        ii. Log unauthorized access attempt\n        iii. End process\n   - Verify forum existence:\n     a. Check if the specified forum exists in the system\n     b. IF forum does not exist, THEN\n        i. Display error message indicating invalid forum\n        ii. End process\n\n4. Core Operation Execution:\n   - Retrieve category information:\n     a. Get all categories from the forum repository\n     b. Organize forums by their respective categories\n   - Retrieve topic cache information:\n     a. Get list of all cached topics for the specified forum\n     b. For each cached topic:\n        i. Retrieve topic metadata (title, creation date, last update)\n        ii. Calculate memory usage of cached topic\n        iii. Determine cache age (how long it has been in cache)\n        iv. Record number of times accessed from cache\n   - Prepare display data:\n     a. Organize topics by categories and forums\n     b. Sort topics by relevant criteria (e.g., most recently accessed)\n     c. Calculate summary statistics (total topics cached, memory usage)\n\n5. Response Generation:\n   - Success response:\n     a. Display forum hierarchy (categories and forums)\n     b. Show list of cached topics with their details\n     c. Provide cache statistics summary\n     d. Include options to clear specific topic caches\n     e. Provide navigation back to main cache management page\n   - Error response:\n     a. Display appropriate error message based on failure point\n     b. Provide troubleshooting information if applicable\n     c. Include navigation options to return to previous screens",
    "databaseEntities": [
      "jforum_categories",
      "jforum_forums",
      "jforum_topics",
      "jforum_posts"
    ],
    "validationRules": [
      "Topic caching must be enabled in system settings to view topic cache details",
      "User must have administrative permissions to access cache information",
      "Forum ID must be a valid numeric identifier",
      "Forum ID must reference an existing forum in the system"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Forum": {
        "id": "number",
        "name": "string",
        "description": "string",
        "categoryId": "number"
      },
      "Topic": {
        "id": "number",
        "title": "string",
        "forumId": "number",
        "lastPostDate": "date",
        "cacheAge": "number",
        "accessCount": "number",
        "memoryUsage": "number"
      },
      "Category": {
        "id": "number",
        "name": "string",
        "order": "number"
      }
    }
  },
  {
    "featureName": "ViewPostCacheDetails",
    "description": "Displays detailed information about cached forum posts.",
    "inputValues": [
      "topic_id-number-Topic"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect topic_id (number, mandatory) to identify the specific topic whose cached posts will be displayed\n   - System will retrieve cached post information based on this identifier\n\n2. Data Validation:\n   - Validate topic_id:\n     a. Check if topic_id is provided\n     b. Verify topic_id is a positive integer\n     c. IF topic_id is missing or invalid, THEN display appropriate error message\n   - Verify post cache system status:\n     a. Check if post caching is enabled in system settings\n     b. IF post caching is disabled, THEN redirect to main cache listing page\n\n3. Business Rule Processing:\n   - Verify user permissions:\n     a. Check if current user has administrative access rights\n     b. IF user lacks proper permissions, THEN display access denied message\n   - Verify topic existence:\n     a. Check if the specified topic exists in the system\n     b. IF topic does not exist, THEN display appropriate error message\n\n4. Core Operation Execution:\n   - Retrieve cached topics information:\n     a. Get collection of all topic IDs that have cached posts\n     b. Retrieve topic titles for all cached topics from database\n   - Retrieve specific topic cache details:\n     a. Get cache statistics for the specified topic (if topic_id was provided)\n     b. Collect information about number of cached posts for the topic\n     c. Retrieve timestamp of when posts were cached\n     d. Calculate memory usage of cached posts\n   - Prepare display data:\n     a. Format cache statistics for presentation\n     b. Organize topic information for display\n     c. Prepare cache management options\n\n5. Response Generation:\n   - Generate success response:\n     a. Display topic title and identification information\n     b. Show number of posts cached for this topic\n     c. Display cache creation/last update timestamp\n     d. Show estimated memory usage\n     e. Provide option to clear cache for this specific topic\n   - Generate error response (if applicable):\n     a. Display appropriate error message based on validation failures\n     b. Provide navigation options to return to main cache management page",
    "databaseEntities": [
      "jforum_topics",
      "jforum_posts",
      "jforum_posts_text"
    ],
    "validationRules": [
      "Topic ID must be a positive integer",
      "Post caching must be enabled in system settings",
      "User must have administrative access rights",
      "Topic must exist in the system"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Topic": {
        "id": "number",
        "title": "string",
        "postCount": "number",
        "lastPostDate": "date"
      },
      "CacheInfo": {
        "enabled": "boolean",
        "itemCount": "number",
        "memoryUsage": "string",
        "lastUpdated": "date"
      }
    }
  },
  {
    "featureName": "ClearPostCache",
    "description": "Clears the cache for posts in a specific topic.",
    "inputValues": [
      "topicId-number-Topic"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect topicId (mandatory) - The unique identifier of the topic whose post cache needs to be cleared\n\n2. Data Validation:\n   - Validate topicId:\n     a. Check if topicId is provided\n        IF topicId is missing THEN\n          Display error message \"Topic ID is required\"\n          Abort operation\n     b. Verify topicId is a positive integer\n        IF topicId is not a positive integer THEN\n          Display error message \"Topic ID must be a positive number\"\n          Abort operation\n     c. Verify topicId exists in the system\n        IF topicId does not exist in the system THEN\n          Display error message \"The specified topic does not exist\"\n          Abort operation\n\n3. Business Rule Processing:\n   - Check if post caching is enabled in the system\n     IF post caching is disabled THEN\n       Display message \"Post caching is not enabled in the system\"\n       Redirect to cache management overview\n       Abort operation\n   - Verify user has administrative privileges\n     IF user does not have administrative privileges THEN\n       Display error message \"Insufficient permissions to clear cache\"\n       Abort operation\n\n4. Core Operation Execution:\n   - Locate all cached posts associated with the specified topic\n   - Remove all cached post entries for the specified topic from the cache storage\n   - Record cache clearing event in system logs with following information:\n     a. Administrator who performed the action\n     b. Timestamp of the action\n     c. Topic ID affected\n     d. Number of post entries cleared\n\n5. Response Generation:\n   - Display success message \"Cache cleared successfully for topic [topicId]\"\n   - Show updated cache statistics:\n     a. Total number of topics currently in cache\n     b. Memory usage before and after clearing\n   - Provide option to:\n     a. Return to post cache management screen\n     b. View the topic whose cache was cleared\n     c. Clear cache for another topic",
    "databaseEntities": [
      "jforum_topics",
      "jforum_posts",
      "jforum_posts_text"
    ],
    "validationRules": [
      "Topic ID must be provided",
      "Topic ID must be a positive integer",
      "Topic must exist in the system",
      "User must have administrative privileges to clear cache",
      "Post caching must be enabled in the system"
    ],
    "dbSeedingOperations": [],
    "schema": {}
  },
  {
    "featureName": "ListSystemConfiguration",
    "description": "Displays all system configuration properties and available locales in the admin interface.",
    "inputValues": [],
    "businessLogic": "1. Input Collection:\n   - No user inputs required for initial display\n   - System will retrieve configuration data automatically\n\n2. Data Validation:\n   - No input validation required for initial display\n   - System will validate access permissions\n     - IF user is not an administrator THEN\n       - Display access denied message\n       - Redirect to appropriate page\n     - END IF\n\n3. Business Rule Processing:\n   - Verify system configuration files accessibility\n     - IF configuration files are not accessible THEN\n       - Log error details\n       - Prepare error message for display\n       - Skip to Response Generation step\n     - END IF\n   - Check locale configuration file accessibility\n     - IF locale files are not accessible THEN\n       - Log error details\n       - Prepare partial response with only system configuration\n     - END IF\n\n4. Core Operation Execution:\n   - Retrieve system configuration properties\n     - Create empty properties collection\n     - Fetch all configuration keys from system\n     - FOR each configuration key\n       - Get corresponding value\n       - Add key-value pair to properties collection\n     - END FOR\n   - Load available locales\n     - Create empty locales collection\n     - Open locales properties file from configuration directory\n     - Load all locale definitions\n     - FOR each locale entry\n       - Add locale to locales list\n     - END FOR\n     - Close locale file resources\n\n5. Response Generation:\n   - Prepare display data\n     - Format configuration properties for display\n     - Format locales list for display\n   - Generate configuration display view\n     - Display all system properties in organized sections\n     - Display all available locales\n   - IF any errors occurred during processing THEN\n     - Include error messages in the response\n   - END IF",
    "databaseEntities": [],
    "validationRules": [
      "User must have administrator privileges to view system configuration",
      "Configuration files must be accessible",
      "Locale files should be accessible for complete functionality"
    ],
    "dbSeedingOperations": [],
    "schema": {}
  },
  {
    "featureName": "SaveSystemConfiguration",
    "description": "Updates and persists system configuration properties with validation for URL fields.",
    "inputValues": [
      "configProperties-object-ConfigProperties",
      "localeSettings-object-LocaleSettings"
    ],
    "businessLogic": "1. Input Collection\n   - Collect all configuration properties from the form submission\n     1.1. Extract all form fields that start with 'p_' prefix\n     1.2. For each field, remove the prefix to get the actual property key\n     1.3. Store the property key and its corresponding value\n   - Identify special configuration properties that require validation:\n     1.4. URL fields (homepage.link, forum.link)\n     1.5. Text fields requiring sanitization (encoding, forum.name, forum.page.metatag.description, forum.page.metatag.keywords, forum.page.title)\n\n2. Data Validation\n   - Validate URL fields\n     2.1. For each URL field (homepage.link, forum.link):\n        2.1.1. Check if the URL is properly formatted\n        2.1.2. Verify the URL can be parsed as a valid URI\n        2.1.3. IF validation fails, generate appropriate error message\n   - Sanitize text fields\n     2.2. For text fields (encoding, forum.name, forum.page.metatag fields, forum.page.title):\n        2.2.1. Apply HTML safety measures to prevent script injection\n        2.2.2. Remove any potentially harmful content\n\n3. Business Rule Processing\n   - Check for special configuration changes that require system updates\n     3.1. Store the current value of topics per page setting\n     3.2. Compare with new value after update to detect changes\n     3.3. IF topics per page setting has changed, flag for cache refresh\n   - Verify locale settings compatibility\n     3.4. Ensure the selected locale is available in the system\n     3.5. Verify encoding settings are compatible with selected locale\n\n4. Core Operation Execution\n   - Update system configuration values\n     4.1. For each validated property:\n        4.1.1. Update the corresponding system configuration value\n     4.2. Persist all configuration changes to storage\n   - Apply immediate configuration changes\n     4.3. Update the default language setting if changed\n     4.4. IF topics per page setting has changed:\n        4.4.1. Retrieve all forum categories\n        4.4.2. For each category, get all forums\n        4.4.3. For each forum, clear the topic cache to force reload with new pagination\n\n5. Response Generation\n   - Prepare confirmation response\n     5.1. Generate success message indicating configuration was updated\n     5.2. Reload configuration list with updated values\n     5.3. Display available locales for selection\n   - Handle any errors\n     5.4. IF errors occurred during validation or saving:\n        5.4.1. Display specific error messages for each failed validation\n        5.4.2. Preserve user input for correction",
    "databaseEntities": [
      "jforum_categories",
      "jforum_forums",
      "jforum_topics"
    ],
    "validationRules": [
      "URL fields must be properly formatted and parseable",
      "Text fields must be sanitized to prevent script injection",
      "Configuration changes must be persisted to storage",
      "Topics per page changes require cache refresh for all forums"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "ConfigProperties": {
        "type": "object",
        "properties": {
          "homepage.link": {
            "type": "string",
            "description": "URL for the homepage"
          },
          "forum.link": {
            "type": "string",
            "description": "URL for the forum"
          },
          "encoding": {
            "type": "string",
            "description": "Character encoding for the system"
          },
          "forum.name": {
            "type": "string",
            "description": "Name of the forum"
          },
          "forum.page.metatag.description": {
            "type": "string",
            "description": "Meta description for forum pages"
          },
          "forum.page.metatag.keywords": {
            "type": "string",
            "description": "Meta keywords for forum pages"
          },
          "forum.page.title": {
            "type": "string",
            "description": "Title for forum pages"
          },
          "topics_per_page": {
            "type": "string",
            "description": "Number of topics to display per page"
          },
          "i18n_default": {
            "type": "string",
            "description": "Default language/locale setting"
          }
        }
      },
      "LocaleSettings": {
        "type": "object",
        "properties": {
          "availableLocales": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "List of available locales in the system"
          },
          "selectedLocale": {
            "type": "string",
            "description": "Currently selected locale"
          }
        }
      }
    }
  },
  {
    "featureName": "ListCategories",
    "description": "Displays a list of all forum categories with repository information.",
    "inputValues": [],
    "businessLogic": "1. Input Collection:\n   - No user inputs required for this feature\n   - System will retrieve all categories from the database\n\n2. Data Validation:\n   - Verify user has appropriate permissions to view categories\n   - IF user does not have required permissions THEN\n     - Display access denied message\n     - Redirect to appropriate page\n   - END IF\n\n3. Business Rule Processing:\n   - Verify the category repository is accessible\n   - IF repository is not accessible THEN\n     - Log system error\n     - Prepare error message for display\n   - END IF\n   - Determine if user has administrative privileges\n   - IF user has administrative privileges THEN\n     - Enable category management options (edit, delete, reorder)\n   - ELSE\n     - Disable category management options\n   - END IF\n\n4. Core Operation Execution:\n   - Retrieve all categories from the data source\n   - Sort categories according to their defined order\n   - FOR each category:\n     - Retrieve associated forum information\n     - Calculate statistics (number of forums, topics, posts)\n     - Determine category status (active, locked, moderated)\n   - END FOR\n   - Prepare category list for display\n   - Include repository information with each category\n\n5. Response Generation:\n   - Format the category list for presentation\n   - IF no categories exist THEN\n     - Display appropriate message indicating no categories are available\n   - ELSE\n     - Display the list of categories with their details\n     - IF user has administrative privileges THEN\n       - Include category management controls (edit, delete, reorder buttons)\n     - END IF\n   - END IF\n   - Provide navigation options for other system areas",
    "databaseEntities": [
      "jforum_categories",
      "jforum_forums"
    ],
    "validationRules": [
      "User must have permission to view categories",
      "Category repository must be accessible",
      "Categories must be displayed in their defined order"
    ],
    "dbSeedingOperations": [],
    "schema": {}
  },
  {
    "featureName": "InsertCategory",
    "description": "Prepares the form for creating a new forum category.",
    "inputValues": [
      "category_name-string-Category",
      "moderated-boolean-Category",
      "groups-object-GroupSelection"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the following inputs:\n     a. category_name (string, mandatory): The name of the new category\n     b. moderated (boolean, optional): Whether the category is moderated\n     c. groups (array of IDs, optional): List of group IDs that have access to this category\n\n2. Data Validation:\n   - Validate category_name:\n     a. IF category_name is empty THEN\n        i. Generate error message: \"Category name cannot be empty\"\n        ii. Return to form with error message\n     b. IF category_name exceeds maximum length THEN\n        i. Generate error message: \"Category name is too long\"\n        ii. Return to form with error message\n   - Validate moderated flag:\n     a. Ensure value is either true or false\n     b. Default to false if not provided\n   - Validate groups selection:\n     a. IF groups are selected THEN\n        i. Ensure all group IDs exist in the system\n        ii. IF any invalid group ID is found THEN\n            1. Generate error message: \"One or more selected groups are invalid\"\n            2. Return to form with error message\n\n3. Business Rule Processing:\n   - Check user permissions:\n     a. IF current user does not have administrative privileges THEN\n        i. Generate error message: \"Insufficient permissions to create categories\"\n        ii. Redirect to access denied page\n   - Check system constraints:\n     a. IF system has reached maximum allowed categories THEN\n        i. Generate error message: \"Maximum number of categories reached\"\n        ii. Return to form with error message\n\n4. Core Operation Execution:\n   - Prepare form for category creation:\n     a. Retrieve all available user groups from the system\n     b. Initialize an empty list for selected groups\n     c. Set the form action to \"insertSave\"\n     d. Prepare the category creation template\n     e. Make all retrieved data available to the template\n\n5. Response Generation:\n   - Display the category creation form:\n     a. Show input field for category name\n     b. Show checkbox for moderated status\n     c. Show multi-select list of available groups\n     d. Include submit and cancel buttons\n   - Provide clear instructions:\n     a. Explain the purpose of each field\n     b. Indicate which fields are mandatory\n     c. Explain the implications of making a category moderated",
    "databaseEntities": [
      "jforum_categories",
      "jforum_groups",
      "jforum_user_groups"
    ],
    "validationRules": [
      "Category name must not be empty",
      "Category name must not exceed maximum length",
      "User must have administrative privileges to create categories",
      "Selected groups must exist in the system"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "GroupSelection": {
        "type": "array",
        "items": {
          "type": "integer",
          "description": "Group ID"
        }
      }
    }
  },
  {
    "featureName": "SaveNewCategory",
    "description": "Creates a new forum category with moderation settings and security permissions.",
    "inputValues": [
      "categoryName-string-Category",
      "isModerated-boolean-Category",
      "securityGroups-object-SecurityGroups"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the following inputs:\n     1.1. categoryName (string, mandatory): The name for the new category\n     1.2. isModerated (boolean, mandatory): Flag indicating if the category should be moderated\n     1.3. securityGroups (array, optional): List of group IDs that have access to this category\n\n2. Data Validation:\n   2.1. Validate categoryName:\n      2.1.1. Check if categoryName is not empty\n      2.1.2. Check if categoryName length is within acceptable limits (3-100 characters)\n      2.1.3. IF validation fails, THEN display appropriate error message\n   2.2. Validate isModerated:\n      2.2.1. Ensure isModerated is a valid boolean value\n      2.2.2. IF validation fails, THEN use default value (false)\n   2.3. Validate securityGroups (if provided):\n      2.3.1. Verify each group ID exists in the system\n      2.3.2. IF any group ID is invalid, THEN remove it from the list\n\n3. Business Rule Processing:\n   3.1. Check system state:\n      3.1.1. Verify the user has administrative permissions to create categories\n      3.1.2. IF user lacks permissions, THEN display access denied message and terminate process\n   3.2. Check category constraints:\n      3.2.1. Verify the maximum number of categories has not been reached\n      3.2.2. IF maximum reached, THEN display limit error message and terminate process\n\n4. Core Operation Execution:\n   4.1. Create new category record:\n      4.1.1. Generate a new Category object with provided name\n      4.1.2. Set moderation status based on isModerated input\n      4.1.3. Assign default display order (typically at the end of the list)\n      4.1.4. Save the category to the database\n      4.1.5. Retrieve the generated category ID\n   4.2. Update repository:\n      4.2.1. Add the new category to the forum repository for runtime access\n   4.3. Set security permissions:\n      4.3.1. IF securityGroups is provided and not empty, THEN:\n         4.3.1.1. For each group ID in securityGroups:\n            - Create security role for category access\n            - Associate the role with the group\n            - Set the category ID as the role value\n      4.3.2. ELSE:\n         4.3.2.1. Apply default security settings based on system configuration\n   4.4. Update security repositories:\n      4.4.1. Clear security cache\n      4.4.2. Clear roles repository\n\n5. Response Generation:\n   5.1. Generate success response:\n      5.1.1. Include the newly created category ID\n      5.1.2. Include confirmation message\n   5.2. Prepare view:\n      5.2.1. Retrieve updated list of all categories\n      5.2.2. Display the category listing page with success message\n   5.3. Error handling:\n      5.3.1. IF any errors occurred during processing, THEN:\n         - Display appropriate error message\n         - Maintain any valid input for correction",
    "databaseEntities": [
      "jforum_categories",
      "jforum_groups"
    ],
    "validationRules": [
      "Category name must not be empty",
      "Category name must be between 3 and 100 characters",
      "User must have administrative permissions to create categories",
      "Security groups must exist in the system"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "SecurityGroups": {
        "type": "array",
        "items": {
          "type": "integer",
          "description": "Group ID with access to the category"
        }
      }
    }
  },
  {
    "featureName": "EditCategory",
    "description": "Prepares the form for editing an existing forum category.",
    "inputValues": [
      "category_id-number-Category"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the category_id (mandatory) from the request\n   - System will use this ID to retrieve the existing category information\n\n2. Data Validation:\n   - Validate that category_id is provided\n     - IF category_id is missing or invalid THEN\n       - Display error message indicating invalid category ID\n       - Return user to category list page\n     - END IF\n   - Validate that category with provided ID exists in the system\n     - IF category does not exist THEN\n       - Display error message indicating category not found\n       - Return user to category list page\n     - END IF\n\n3. Business Rule Processing:\n   - Check if the current user has permission to edit categories\n     - IF user lacks edit permission THEN\n       - Display access denied message\n       - Return user to previous page\n     - END IF\n   - Retrieve complete category information from the database\n     - Include category name, moderation status, and any other relevant attributes\n     - IF retrieval fails THEN\n       - Log the error\n       - Display system error message\n       - Return user to category list page\n     - END IF\n\n4. Core Operation Execution:\n   - Prepare the edit form with the retrieved category data\n     - Populate form fields with current category values\n     - Set form action to the appropriate save endpoint\n   - Load any additional context data needed for the form\n     - Load moderation options\n   - Prepare the user interface for category editing\n     - Set the template to category edit view\n     - Set the form submission action to \"editSave\"\n\n5. Response Generation:\n   - Display the category edit form to the user\n     - Show current category name and settings\n     - Provide form fields for modifying category attributes\n     - Include submit and cancel buttons\n   - IF any errors occurred during processing THEN\n     - Display appropriate error messages\n     - Maintain any user-entered data where possible\n   - END IF",
    "databaseEntities": [
      "jforum_categories"
    ],
    "validationRules": [
      "Category ID must be a valid integer",
      "Category must exist in the system",
      "User must have permission to edit categories"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Category": {
        "id": "number",
        "name": "string",
        "moderated": "boolean",
        "order": "number"
      }
    }
  },
  {
    "featureName": "DeleteCategories",
    "description": "Removes selected forum categories with validation to prevent deletion of non-empty categories.",
    "inputValues": [
      "categories_id-string-Category"
    ],
    "businessLogic": "1. Input Collection\n   - Collect the following inputs:\n     1.1. categories_id (array of strings, mandatory): The IDs of categories to be deleted\n\n2. Data Validation\n   - Validate each category ID for deletion:\n     2.1. Verify each category ID exists in the system\n        2.1.1. IF any category ID does not exist THEN\n              - Generate an error message indicating invalid category ID\n              - Skip deletion for this ID\n        2.1.2. ELSE continue to next validation\n     2.2. Check if each category can be deleted\n        2.2.1. Verify the category has no associated forums\n        2.2.2. IF category has associated forums THEN\n              - Generate an error message indicating category cannot be deleted\n              - Add to error list with category ID reference\n              - Skip deletion for this ID\n        2.2.3. ELSE mark category as eligible for deletion\n\n3. Business Rule Processing\n   - Process deletion eligibility for each category:\n     3.1. FOR each valid category ID in the input list:\n        3.1.1. Retrieve the complete category information\n        3.1.2. Check for any dependencies that would prevent deletion\n              - Verify no active references exist in other system components\n              - Ensure no ongoing operations involve this category\n        3.1.3. IF dependencies exist THEN\n              - Add to error list with reason\n              - Skip deletion for this ID\n        3.1.4. ELSE mark as ready for deletion\n\n4. Core Operation Execution\n   - Execute deletion for eligible categories:\n     4.1. FOR each category marked for deletion:\n        4.1.1. Retrieve the category object by ID\n        4.1.2. Delete the category from the database\n        4.1.3. Remove the category from the repository cache\n        4.1.4. IF deletion fails THEN\n              - Log the error\n              - Add to error list\n              - Attempt to restore previous state if possible\n        4.1.5. ELSE mark deletion as successful\n     4.2. Update any related security permissions\n        4.2.1. Remove any role values associated with deleted categories\n        4.2.2. Update security repositories as needed\n\n5. Response Generation\n   - Generate appropriate response based on operation results:\n     5.1. IF any errors occurred during deletion THEN\n        5.1.1. Compile all error messages into a consolidated error list\n        5.1.2. Include specific details about which categories could not be deleted and why\n        5.1.3. Return error list to the user interface\n     5.2. ELSE IF all deletions were successful THEN\n        5.2.1. Generate success message indicating all selected categories were deleted\n     5.3. ELSE IF some deletions succeeded and some failed THEN\n        5.3.1. Generate partial success message listing which categories were deleted\n        5.3.2. Include error details for categories that could not be deleted\n     5.4. Return to the category listing view showing updated category list",
    "databaseEntities": [
      "jforum_categories",
      "jforum_forums",
      "jforum_user_groups"
    ],
    "validationRules": [
      "Category must exist in the system to be deleted",
      "Category must not contain any forums to be eligible for deletion",
      "Category IDs must be valid integers",
      "At least one category ID must be selected for deletion"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Category": {
        "id": "integer",
        "name": "string",
        "order": "integer",
        "moderated": "boolean"
      }
    }
  },
  {
    "featureName": "ChangeCategoryOrder",
    "description": "Moves categories up or down in the display order sequence.",
    "inputValues": [
      "categoryId-number-Category",
      "direction-string-OrderDirection"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the following inputs:\n     a. categoryId (required): The unique identifier of the category to be reordered\n     b. direction (required): The direction to move the category (up or down)\n     c. System will retrieve the current list of categories in their existing order\n\n2. Data Validation:\n   - Validate categoryId:\n     a. Verify categoryId is a positive integer\n     b. Verify categoryId exists in the system\n     c. IF categoryId is invalid or not found, THEN display error message and abort operation\n   - Validate direction:\n     a. Verify direction is either 'up' or 'down'\n     b. IF direction is invalid, THEN display error message and abort operation\n   - Validate movement possibility:\n     a. IF direction is 'up' AND category is already at the top position, THEN display notification and abort operation\n     b. IF direction is 'down' AND category is already at the bottom position, THEN display notification and abort operation\n\n3. Business Rule Processing:\n   - Determine the current position of the category in the ordered list:\n     a. Find the index of the category in the current ordered list\n     b. IF category is not found in the list, THEN display error message and abort operation\n   - Identify the adjacent category for swapping:\n     a. IF direction is 'up', THEN identify the category immediately above (at index - 1)\n     b. IF direction is 'down', THEN identify the category immediately below (at index + 1)\n     c. IF no adjacent category exists in the specified direction, THEN display notification and abort operation\n\n4. Core Operation Execution:\n   - Swap the order values between the selected category and the adjacent category:\n     a. Retrieve the current order value of the selected category\n     b. Retrieve the current order value of the adjacent category\n     c. Update the selected category with the adjacent category's order value\n     d. Update the adjacent category with the selected category's order value\n   - Persist the updated order values to the database:\n     a. Save the updated order value for the selected category\n     b. Save the updated order value for the adjacent category\n     c. IF any database operation fails, THEN rollback all changes and display error message\n   - Update the in-memory category repository:\n     a. Refresh the category data in the system repository\n     b. Ensure the updated order is reflected in the system\n\n5. Response Generation:\n   - Generate success response:\n     a. Indicate successful reordering of the category\n     b. Display the updated list of categories in their new order\n   - IF any errors occurred during the process:\n     a. Display appropriate error message indicating the nature of the failure\n     b. Maintain the original ordering of categories",
    "databaseEntities": [
      "jforum_categories"
    ],
    "validationRules": [
      "Category ID must exist in the system",
      "Direction must be either 'up' or 'down'",
      "Category cannot be moved up if it's already at the top position",
      "Category cannot be moved down if it's already at the bottom position"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Category": {
        "id": "number",
        "name": "string",
        "order": "number",
        "moderated": "boolean"
      },
      "OrderDirection": {
        "type": "string",
        "enum": [
          "up",
          "down"
        ]
      }
    }
  },
  {
    "featureName": "ListForums",
    "description": "Displays all forums organized by categories for administration.",
    "inputValues": [
      "lang-string-Language"
    ],
    "businessLogic": "1. Input Collection:\n   - Optional language parameter ('lang') may be provided for guest users\n   - System will retrieve all necessary data automatically including:\n     - Categories and forums data\n     - System configuration values\n     - User session information\n\n2. Data Validation:\n   - Verify administrator access permissions\n   - IF user does not have administrator privileges THEN\n     - Display access denied message\n     - Redirect to appropriate error page\n   - END IF\n   - IF optional language parameter is provided THEN\n     - Verify language exists in the system\n     - IF language does not exist THEN\n       - Ignore the parameter and use default language\n     - END IF\n   - END IF\n\n3. Business Rule Processing:\n   - Verify system state for forum listing\n   - Check if categories exist in the system\n     - IF no categories exist THEN\n       - Prepare empty category list for display\n       - Add notification message about no categories\n     - ELSE\n       - Proceed with normal category and forum retrieval\n     - END IF\n   - Calculate system statistics\n     - Total messages in the system\n     - Total registered users\n     - Last registered user information\n     - Current date and time\n     - User's last visit timestamp\n\n4. Core Operation Execution:\n   - Retrieve all categories from the database\n     - Sort categories according to their defined order\n   - For EACH category:\n     - Retrieve all forums belonging to the category\n     - Sort forums according to their defined order within the category\n     - Collect forum metadata (name, description, moderation status)\n   - Prepare forum repository data structure\n     - Organize forums hierarchically under their respective categories\n     - Include forum counts and status information\n   - Process online user information\n     - Count total online users\n     - Count registered online users\n     - Count anonymous users\n     - Prepare list of online user sessions\n     - IF only guest users are online THEN\n       - Register a single guest user for display\n     - END IF\n   - Check for record online user count\n     - IF current online users count > most users ever online THEN\n       - Update most users ever online record with new count\n       - Update timestamp of the record\n     - END IF\n\n5. Response Generation:\n   - Prepare administrative view of forums\n     - Display categories as main grouping elements\n     - Under each category, list all associated forums\n     - For each forum display:\n       - Forum name\n       - Forum description\n       - Moderation status\n       - Order position controls (up/down arrows)\n       - Edit and delete options\n   - Include administrative controls:\n     - Option to create new forums\n     - Option to delete selected forums\n     - Option to reorder forums\n   - Display system statistics:\n     - Total messages\n     - Total registered users\n     - Last registered user\n     - Current date/time\n     - User's last visit time\n   - Display online users information:\n     - Total users online\n     - Number of registered users online\n     - Number of anonymous users\n     - List of online users\n     - Most users ever online record\n   - Display confirmation of successful operation if applicable",
    "databaseEntities": [
      "jforum_categories",
      "jforum_forums",
      "jforum_users",
      "jforum_sessions",
      "jforum_posts",
      "jforum_topics"
    ],
    "validationRules": [
      "User must have administrator privileges to access forum listing",
      "Categories must be displayed in their correct order",
      "Forums must be displayed under their respective categories",
      "Forums must be displayed in their correct order within each category",
      "If language parameter is provided, it must exist in the system",
      "Only authenticated users can see detailed online user information",
      "System statistics must be accurate and up-to-date"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Language": {
        "type": "object",
        "properties": {
          "code": {
            "type": "string",
            "description": "Language code identifier"
          }
        }
      }
    }
  },
  {
    "featureName": "InsertForumForm",
    "description": "Prepares the form for creating a new forum with category and group options.",
    "inputValues": [
      "forum_name-string-Forum",
      "description-string-Forum",
      "categories_id-number-Category",
      "moderate-boolean-Forum",
      "groups-object-GroupSelection"
    ],
    "businessLogic": "1. Input Collection:\n   - Prepare form for creating a new forum\n   - Required inputs:\n     a. forum_name (mandatory): Name of the forum\n     b. description (mandatory): Description of the forum\n     c. categories_id (mandatory): Category to which forum belongs\n     d. moderate (optional): Whether forum is moderated, default is false\n     e. groups (mandatory): Selection of user groups for permission settings\n\n2. Data Validation:\n   - Validate forum name:\n     a. IF forum_name is empty THEN\n        i. Display error message \"Forum name cannot be empty\"\n     b. IF forum_name length exceeds maximum allowed THEN\n        i. Display error message \"Forum name too long\"\n   - Validate description:\n     a. IF description is empty THEN\n        i. Display error message \"Description cannot be empty\"\n     b. IF description length exceeds maximum allowed THEN\n        i. Display error message \"Description too long\"\n   - Validate category selection:\n     a. IF categories_id is not selected THEN\n        i. Display error message \"Please select a category\"\n     b. IF selected category does not exist THEN\n        i. Display error message \"Invalid category selected\"\n\n3. Business Rule Processing:\n   - Load available categories:\n     a. Retrieve all categories from the system\n     b. Format categories for display in selection dropdown\n   - Load available user groups:\n     a. Retrieve all user groups from the system\n     b. Organize groups in tree structure for hierarchical display\n   - Initialize permission selections:\n     a. Create empty selected list for permissions\n     b. Set default permission options for new forums\n\n4. Core Operation Execution:\n   - Prepare form context:\n     a. Set form action to \"insertSave\" for submission handling\n     b. Add categories to form context\n     c. Add groups to form context\n     d. Add empty selected list to form context for permissions\n   - Display permission options:\n     a. Group access permissions (who can see the forum)\n     b. Anonymous posting permissions\n     c. Read-only access permissions\n     d. HTML usage permissions\n\n5. Response Generation:\n   - Display form with the following sections:\n     a. Basic forum information fields (name, description)\n     b. Category selection dropdown\n     c. Moderation option checkbox\n     d. Group permission selection checkboxes\n   - Include submission and cancel buttons\n   - On submission error:\n     a. Display validation error messages\n     b. Preserve user-entered data\n   - On cancel:\n     a. Return to forum listing page without saving",
    "databaseEntities": [
      "jforum_forums",
      "jforum_categories",
      "jforum_groups",
      "jforum_user_groups"
    ],
    "validationRules": [
      "Forum name must not be empty",
      "Forum description must not be empty",
      "A category must be selected for the forum",
      "At least one user group must have access permission to the forum",
      "Selected category must exist in the system"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "GroupSelection": {
        "type": "object",
        "properties": {
          "groupsAccess": {
            "type": "array",
            "description": "Groups that can access the forum",
            "items": {
              "type": "string"
            }
          },
          "groupsAnonymous": {
            "type": "array",
            "description": "Groups that can post anonymously",
            "items": {
              "type": "string"
            }
          },
          "groupsReadOnly": {
            "type": "array",
            "description": "Groups with read-only access",
            "items": {
              "type": "string"
            }
          },
          "groupsHtml": {
            "type": "array",
            "description": "Groups with HTML disabled",
            "items": {
              "type": "string"
            }
          }
        }
      }
    }
  },
  {
    "featureName": "EditForumForm",
    "description": "Prepares the form for editing an existing forum's details.",
    "inputValues": [
      "forum_id-number-Forum"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the forum_id (mandatory) from the request\n   - System will retrieve the following information:\n     - List of all categories\n     - Current forum details\n\n2. Data Validation:\n   - Validate forum_id:\n     - Must be a valid integer\n     - Must correspond to an existing forum in the system\n     - IF forum_id is invalid or not found THEN\n       - Display error message\n       - Redirect to forum list page\n     - END IF\n\n3. Business Rule Processing:\n   - Retrieve forum data from the database:\n     - Fetch forum details using the provided forum_id\n     - Fetch all available categories for selection\n   - Prepare form data:\n     - Set form action to 'editSave'\n     - Pre-populate form fields with current forum values\n\n4. Core Operation Execution:\n   - Construct the edit form with the following fields:\n     - Forum name (pre-populated with current value)\n     - Forum description (pre-populated with current value)\n     - Category selection dropdown (with current category selected)\n     - Moderation status checkbox (checked if forum is currently moderated)\n   - Prepare context data for the form template:\n     - Add forum object containing current forum details\n     - Add categories list for dropdown selection\n     - Set action parameter to 'editSave'\n\n5. Response Generation:\n   - Display the forum edit form with pre-populated values\n   - Provide options to:\n     - Save changes\n     - Cancel and return to forum list\n   - Include validation feedback mechanisms for form submission",
    "databaseEntities": [
      "jforum_forums",
      "jforum_categories"
    ],
    "validationRules": [
      "Forum ID must correspond to an existing forum",
      "Forum name must not be empty",
      "Forum must belong to a valid category"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Forum": {
        "id": "number",
        "name": "string",
        "description": "string",
        "categoryId": "number",
        "moderated": "boolean"
      }
    }
  },
  {
    "featureName": "SaveForumChanges",
    "description": "Updates an existing forum with new details and handles moderation status changes.",
    "inputValues": [
      "forum_id-number-Forum",
      "forum_name-string-Forum",
      "description-string-Forum",
      "categories_id-number-Category",
      "moderate-string-Forum"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the following inputs:\n     a. forum_id (mandatory): Unique identifier of the forum to update\n     b. forum_name (mandatory): New name for the forum\n     c. description (mandatory): Updated description for the forum\n     d. categories_id (mandatory): Category identifier to which the forum belongs\n     e. moderate (optional): Flag indicating if forum should be moderated ('1' for yes, otherwise no)\n\n2. Data Validation:\n   - Validate forum_id:\n     a. Verify forum_id is provided\n     b. Verify forum_id is a valid number\n     c. Verify forum_id corresponds to an existing forum\n     d. IF forum does not exist, THEN display error message and terminate process\n   - Validate forum_name:\n     a. Verify forum_name is provided\n     b. Verify forum_name is not empty\n     c. Verify forum_name length is within acceptable limits\n     d. IF validation fails, THEN display appropriate error message\n   - Validate description:\n     a. Verify description is provided\n     b. Verify description length is within acceptable limits\n     c. IF validation fails, THEN display appropriate error message\n   - Validate categories_id:\n     a. Verify categories_id is provided\n     b. Verify categories_id is a valid number\n     c. Verify categories_id corresponds to an existing category\n     d. IF category does not exist, THEN display error message\n\n3. Business Rule Processing:\n   - Check system state:\n     a. Verify the user has permission to modify forums\n     b. IF user lacks permission, THEN display access denied message and terminate process\n   - Check forum state:\n     a. Retrieve current forum data using forum_id\n     b. Store current moderation status for later comparison\n     c. Store current category ID for later comparison\n     d. IF forum cannot be retrieved, THEN display error message and terminate process\n\n4. Core Operation Execution:\n   - Update forum details:\n     a. Set forum name to the provided forum_name\n     b. Set forum description to the provided description\n     c. Set forum category ID to the provided categories_id\n     d. Set forum moderation status based on the moderate input ('1' means moderated)\n     e. Save updated forum information to the database\n   - Handle moderation status changes:\n     a. Compare previous moderation status with new status\n     b. IF moderation status has changed, THEN:\n        i. Update moderation status for all topics in the forum\n        ii. Apply appropriate moderation rules to existing topics\n   - Handle category changes:\n     a. Compare previous category ID with new category ID\n     b. IF category has changed, THEN:\n        i. Remove forum from old category\n        ii. Add forum to new category\n        iii. Update forum repository to reflect the change\n     c. ELSE:\n        i. Reload forum data in the repository to reflect other changes\n\n5. Response Generation:\n   - Success response:\n     a. Display confirmation message that forum has been updated successfully\n     b. Refresh the forum listing to show updated information\n     c. Show updated forum in its proper category and order\n   - Error response:\n     a. Display specific error message based on the failure point\n     b. Maintain user input to allow corrections\n     c. Provide guidance on resolving the issue",
    "databaseEntities": [
      "jforum_forums",
      "jforum_categories",
      "jforum_topics"
    ],
    "validationRules": [
      "Forum ID must correspond to an existing forum",
      "Forum name must not be empty",
      "Category ID must correspond to an existing category",
      "User must have permission to modify forums",
      "Moderation status must be either '1' (moderated) or not provided (unmoderated)"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Forum": {
        "id": "number",
        "name": "string",
        "description": "string",
        "categoryId": "number",
        "isModerated": "boolean",
        "order": "number"
      },
      "Category": {
        "id": "number",
        "name": "string",
        "order": "number",
        "forums": "array"
      }
    }
  },
  {
    "featureName": "MoveForumUp",
    "description": "Moves a forum up in the display order within its category.",
    "inputValues": [
      "forum_id-number-Forum"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the forum_id (mandatory) from the user selection\n   - System will use this ID to identify which forum to move up in order\n\n2. Data Validation:\n   - Validate that forum_id exists in the system\n     * IF forum_id is not found THEN display error message \"Forum not found\"\n     * IF forum_id is invalid format THEN display error message \"Invalid forum ID format\"\n   - Validate that the forum is not already at the top position in its category\n     * IF forum is already at the top position THEN skip reordering and notify user \"Forum is already at the top position\"\n\n3. Business Rule Processing:\n   - Retrieve the current forum object using the forum_id\n   - Identify the category to which the forum belongs\n   - Retrieve all forums within the same category\n   - Determine the current position (index) of the forum in the category's forum list\n   - Verify that moving up is possible\n     * IF current position is the first position (index 0) THEN\n       - Skip reordering as the forum is already at the top\n       - Return to forum listing without changes\n     * ELSE\n       - Proceed with reordering\n\n4. Core Operation Execution:\n   - Identify the forum that is currently positioned above the selected forum\n   - Swap the display order values between the selected forum and the forum above it\n     * Save the current order value of the selected forum as tempOrder\n     * Set the selected forum's order value to the order value of the forum above\n     * Set the forum above's order value to tempOrder\n   - Update both forums in the database with their new order values\n   - Refresh the category data in the system repository to reflect the new ordering\n\n5. Response Generation:\n   - Refresh the forum listing display to show the updated order\n   - Highlight the moved forum briefly to indicate successful movement\n   - IF any errors occurred during the process THEN\n     * Display appropriate error message\n     * Maintain the original ordering\n   - IF successful THEN\n     * Display the updated forum list with the new ordering",
    "databaseEntities": [
      "jforum_forums",
      "jforum_categories"
    ],
    "validationRules": [
      "Forum ID must exist in the system",
      "Forum must not already be at the top position in its category",
      "Forum must belong to a valid category"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Forum": {
        "id": "number",
        "name": "string",
        "description": "string",
        "categoryId": "number",
        "displayOrder": "number",
        "moderated": "boolean"
      },
      "Category": {
        "id": "number",
        "name": "string",
        "displayOrder": "number",
        "forums": "array"
      }
    }
  },
  {
    "featureName": "MoveForumDown",
    "description": "Moves a forum down in the display order within its category.",
    "inputValues": [
      "forum_id-number-Forum"
    ],
    "businessLogic": "1. Input Collection\n   - Collect the forum_id of the forum to be moved down\n   - The forum_id is mandatory and must be a valid integer\n\n2. Data Validation\n   - Validate that the forum_id exists in the system\n   - Verify that the forum is not already at the bottom position of its category\n   - IF forum_id is invalid or not found THEN\n     - Return an error message indicating the forum does not exist\n   - IF forum is already at the bottom position THEN\n     - No action needed, return to the forum list without changes\n\n3. Business Rule Processing\n   - Retrieve the current forum object using the forum_id\n   - Retrieve the category that contains this forum\n   - Get the list of all forums in this category\n   - Determine the current position (index) of the forum in the category\n   - Verify that there is a forum after the current forum in the list\n   - IF current forum is the last forum in the category THEN\n     - No action needed, return to the forum list without changes\n\n4. Core Operation Execution\n   - Identify the forum that comes immediately after the current forum in the display order\n   - Swap the display order positions of the current forum and the forum below it\n   - Update the display order values in the database for both forums\n   - Update the category's internal forum order\n   - Refresh the category data in the system repository\n\n5. Response Generation\n   - Redirect to the forum list view\n   - Display the updated list of forums with the new ordering\n   - The moved forum should now appear one position lower in its category",
    "databaseEntities": [
      "jforum_forums",
      "jforum_categories"
    ],
    "validationRules": [
      "Forum ID must be a valid integer",
      "Forum must exist in the system",
      "Forum must not be the last forum in its category"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Forum": {
        "id": "number",
        "name": "string",
        "description": "string",
        "categoryId": "number",
        "displayOrder": "number",
        "moderated": "boolean"
      },
      "Category": {
        "id": "number",
        "name": "string",
        "forums": "array"
      }
    }
  },
  {
    "featureName": "DeleteForums",
    "description": "Removes selected forums and their associated topics from the system.",
    "inputValues": [
      "forum_id-string-Forum"
    ],
    "businessLogic": "1. Input Collection\n   - Collect the selected forum IDs to be deleted\n   - Input is provided as an array of forum identifiers\n   - All forum IDs are mandatory for the deletion process\n\n2. Data Validation\n   - Verify that at least one forum ID has been selected for deletion\n     - IF no forum IDs are selected THEN\n       - Display error message indicating that at least one forum must be selected\n       - Return to forum listing without performing any deletion\n   - Validate that each forum ID exists in the system\n     - FOR EACH forum ID in the selection\n       - Verify the forum exists in the database\n       - IF any forum ID is invalid THEN\n         - Log the error for the specific forum ID\n         - Continue with valid forums\n\n3. Business Rule Processing\n   - Check system permissions for forum deletion\n     - Verify the current user has administrative rights to delete forums\n     - IF user lacks required permissions THEN\n       - Display access denied message\n       - Abort the deletion process\n   - Check for any system constraints that might prevent deletion\n     - Verify that deleting these forums won't violate system integrity\n     - IF any constraint violations are found THEN\n       - Display specific constraint violation messages\n       - Abort the deletion process\n\n4. Core Operation Execution\n   - FOR EACH valid forum ID in the selection\n     - Retrieve the forum information from the repository\n     - Delete all topics associated with the forum\n       - Find all topics linked to the current forum\n       - Remove all topic records from the database\n     - Delete the forum record from the database\n     - Remove the forum from the forum repository cache\n   - Clean up security-related caches\n     - Clear security repository cache\n     - Clear roles repository\n   - Update any dependent data structures\n     - Refresh category listings\n     - Update forum ordering if necessary\n\n5. Response Generation\n   - IF deletion completed successfully THEN\n     - Display confirmation message indicating forums were deleted\n     - Show updated forum listing without the deleted forums\n   - IF errors occurred during deletion THEN\n     - Display error messages for any forums that could not be deleted\n     - Show partial forum listing reflecting successful deletions",
    "databaseEntities": [
      "jforum_forums",
      "jforum_topics",
      "jforum_categories"
    ],
    "validationRules": [
      "At least one forum must be selected for deletion",
      "User must have administrative permissions to delete forums",
      "Selected forum IDs must exist in the system"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Forum": {
        "id": "number",
        "name": "string",
        "description": "string",
        "categoryId": "number",
        "moderated": "boolean",
        "order": "number"
      }
    }
  },
  {
    "featureName": "CreateNewForum",
    "description": "Creates a new forum with specified details and security permissions.",
    "inputValues": [
      "forumName-string-Forum",
      "description-string-Forum",
      "categoryId-number-Category",
      "isModerated-boolean-Forum",
      "securityGroups-object-SecurityGroups"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the following required inputs:\n     a. Forum name (mandatory string)\n     b. Forum description (mandatory string)\n     c. Category ID (mandatory number)\n     d. Moderation status (boolean flag)\n     e. Security group permissions (object containing group access settings)\n   - System will generate a unique forum ID automatically\n\n2. Data Validation:\n   - Validate forum name:\n     a. Check if forum name is not empty\n     b. Check if forum name length is within acceptable limits\n     c. IF validation fails, THEN display appropriate error message\n   - Validate forum description:\n     a. Check if description is not empty\n     b. Check if description length is within acceptable limits\n     c. IF validation fails, THEN display appropriate error message\n   - Validate category ID:\n     a. Check if category ID is provided\n     b. Check if category exists in the system\n     c. IF validation fails, THEN display error message about invalid category\n   - Validate security groups:\n     a. Check if at least one security group is selected for forum access\n     b. IF no security groups are selected, THEN use default security settings\n\n3. Business Rule Processing:\n   - Check if the user has administrative privileges to create forums\n     a. IF user lacks required permissions, THEN display access denied message\n   - Verify that the selected category is active\n     a. IF category is inactive, THEN display error message\n   - Determine the display order for the new forum\n     a. Count existing forums in the selected category\n     b. Set the new forum's display order to appear at the end of the category's forum list\n\n4. Core Operation Execution:\n   - Create new forum record with the following attributes:\n     a. Forum name\n     b. Forum description\n     c. Category ID\n     d. Moderation status\n     e. Display order\n   - Process security permissions:\n     a. Set forum access permissions for selected groups\n     b. Set anonymous posting permissions for selected groups\n     c. Set read-only permissions for selected groups\n     d. Set HTML usage permissions for selected groups\n     e. Set reply-only permissions for all groups\n   - Update forum repository:\n     a. Add the new forum to the system's forum repository\n     b. Update security repository with new forum permissions\n     c. Clear security caches to ensure new permissions take effect\n\n5. Response Generation:\n   - IF forum creation is successful:\n     a. Generate success message indicating forum was created\n     b. Provide forum ID for reference\n     c. Display updated list of forums\n   - IF forum creation fails:\n     a. Generate error message with failure reason\n     b. Preserve user inputs for correction\n     c. Provide guidance on resolving the issue",
    "databaseEntities": [
      "jforum_forums",
      "jforum_categories",
      "jforum_groups",
      "jforum_user_groups"
    ],
    "validationRules": [
      "Forum name must not be empty",
      "Forum description must not be empty",
      "Selected category must exist in the system",
      "At least one security group must have access to the forum",
      "User must have administrative privileges to create forums"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "SecurityGroups": {
        "type": "object",
        "properties": {
          "accessGroups": {
            "type": "array",
            "items": {
              "type": "number",
              "description": "Group IDs with access permission"
            }
          },
          "anonymousPostGroups": {
            "type": "array",
            "items": {
              "type": "number",
              "description": "Group IDs with anonymous posting permission"
            }
          },
          "readOnlyGroups": {
            "type": "array",
            "items": {
              "type": "number",
              "description": "Group IDs with read-only permission"
            }
          },
          "htmlGroups": {
            "type": "array",
            "items": {
              "type": "number",
              "description": "Group IDs with HTML usage permission"
            }
          }
        }
      }
    }
  },
  {
    "featureName": "ManageMailIntegration",
    "description": "Configures email integration settings for forums.",
    "inputValues": [
      "forumId-number-Forum",
      "mailIntegrationEnabled-boolean-MailIntegration",
      "forumEmail-string-MailIntegration",
      "popHost-string-MailIntegration",
      "popUsername-string-MailIntegration",
      "popPassword-string-MailIntegration",
      "popPort-number-MailIntegration",
      "requiresSSL-boolean-MailIntegration"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the following inputs:\n     a. forumId (mandatory): Identifier of the forum to configure mail integration for\n     b. mailIntegrationEnabled (mandatory): Boolean flag indicating if mail integration is enabled\n     c. forumEmail (required if enabled): Email address associated with the forum\n     d. popHost (required if enabled): POP server hostname\n     e. popUsername (required if enabled): Username for POP server authentication\n     f. popPassword (required if enabled): Password for POP server authentication\n     g. popPort (required if enabled): Port number for POP server connection\n     h. requiresSSL (optional): Boolean flag indicating if SSL is required, default is false\n\n2. Data Validation:\n   - Validate forumId:\n     a. Ensure forumId is a positive integer\n     b. Verify forum exists in the system\n     c. Display error message if forum not found\n   - IF mailIntegrationEnabled is true, THEN:\n     a. Validate forumEmail:\n        i. Ensure it is not empty\n        ii. Verify it follows valid email format\n        iii. Display error message for invalid email format\n     b. Validate popHost:\n        i. Ensure it is not empty\n        ii. Verify it is a valid hostname or IP address\n        iii. Display error message for invalid host format\n     c. Validate popUsername:\n        i. Ensure it is not empty\n        ii. Display error message for missing username\n     d. Validate popPassword:\n        i. Ensure it is not empty\n        ii. Display error message for missing password\n     e. Validate popPort:\n        i. Ensure it is a positive integer\n        ii. Verify it is within valid port range (1-65535)\n        iii. Display error message for invalid port number\n\n3. Business Rule Processing:\n   - Check if user has administrative permissions:\n     a. Verify current user has forum administration rights\n     b. Display error message if permission denied\n   - Check if forum is in valid state for mail integration:\n     a. Verify forum is active and not marked for deletion\n     b. Display error message if forum is in invalid state\n   - IF mailIntegrationEnabled is true, THEN:\n     a. Verify system can support mail integration functionality\n     b. Check if POP server connection can be established with provided details\n     c. Display warning if connection test fails\n\n4. Core Operation Execution:\n   - Retrieve existing mail integration configuration:\n     a. Query database for existing mail integration settings for the forum\n     b. Determine if this is an update or new configuration\n   - IF mailIntegrationEnabled is true, THEN:\n     a. Create mail integration object with all provided settings\n     b. IF existing configuration found, THEN:\n        i. Update the existing mail integration record\n     c. ELSE:\n        i. Create a new mail integration record\n   - ELSE (mail integration disabled):\n     a. IF existing configuration found, THEN:\n        i. Remove the mail integration configuration for the forum\n   - Update forum repository to reflect changes\n   - Log the configuration change with administrator information\n\n5. Response Generation:\n   - IF operation successful, THEN:\n     a. Generate success message indicating mail integration settings were saved\n     b. Include summary of configured settings if enabled\n     c. Provide information about when settings will take effect\n   - ELSE:\n     a. Generate error message with details about what went wrong\n     b. Include suggestions for resolving the issue\n     c. Provide option to retry the operation\n   - Return to forum management interface with updated status",
    "databaseEntities": [
      "jforum_forums",
      "jforum_mail_integration"
    ],
    "validationRules": [
      "Forum ID must exist in the system",
      "Forum email must be in valid email format if mail integration is enabled",
      "POP host must not be empty if mail integration is enabled",
      "POP username must not be empty if mail integration is enabled",
      "POP password must not be empty if mail integration is enabled",
      "POP port must be a valid port number (1-65535) if mail integration is enabled",
      "User must have administrative permissions to configure mail integration"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "MailIntegration": {
        "forumId": "number",
        "forumEmail": "string",
        "popHost": "string",
        "popUsername": "string",
        "popPassword": "string",
        "popPort": "number",
        "requiresSSL": "boolean"
      },
      "Forum": {
        "id": "number",
        "name": "string",
        "description": "string",
        "categoryId": "number",
        "isModerated": "boolean"
      }
    }
  },
  {
    "featureName": "ListGroups",
    "description": "Displays a list of all user groups in a tree structure.",
    "inputValues": [],
    "businessLogic": "1. Input Collection\n   - No user inputs required for this feature\n   - System will retrieve all group data automatically\n\n2. Data Validation\n   - No input validation required as this is a read-only operation\n   - System will verify user has appropriate permissions to view groups\n     - IF user does not have sufficient permissions THEN\n       - Display access denied message\n       - Terminate operation\n     - END IF\n\n3. Business Rule Processing\n   - System verifies the user session is active\n     - IF session is expired THEN\n       - Redirect to login page\n       - Terminate operation\n     - END IF\n   - System checks if groups data is accessible\n     - IF groups data cannot be accessed THEN\n       - Generate appropriate error message\n       - Terminate operation\n     - END IF\n\n4. Core Operation Execution\n   - System retrieves all group records from the data store\n     - Fetch all group records with their attributes\n     - Include group ID, name, description, and parent-child relationships\n   - System organizes groups into hierarchical tree structure\n     - Sort groups based on their parent-child relationships\n     - Groups with no parent are placed at the root level\n     - Child groups are nested under their respective parents\n     - Maintain proper indentation to represent hierarchy levels\n   - System prepares the display data\n     - Format group names and descriptions for display\n     - Apply appropriate styling for different hierarchy levels\n     - Include visual indicators for expandable/collapsible nodes\n\n5. Response Generation\n   - System generates the tree view display\n     - Present groups in hierarchical format with proper indentation\n     - Display group names as primary identifiers\n     - Include group descriptions where appropriate\n     - Provide visual cues for hierarchy levels\n   - System includes action options for each group\n     - Edit option for modifying group details\n     - Delete option for removing groups\n     - Permissions option for managing group access rights\n   - System provides option to add new groups\n     - Include 'Add Group' button or link\n   - IF no groups exist THEN\n     - Display appropriate message indicating no groups are available\n   - END IF",
    "databaseEntities": [
      "jforum_groups",
      "jforum_user_groups"
    ],
    "validationRules": [
      "User must have administrative privileges to view group list",
      "Group hierarchy must be properly displayed with parent-child relationships",
      "All groups in the system must be included in the list"
    ],
    "dbSeedingOperations": [],
    "schema": {}
  },
  {
    "featureName": "InsertGroup",
    "description": "Provides interface for creating a new user group in the system.",
    "inputValues": [
      "group_name-string-Group",
      "group_description-string-Group",
      "parent_id-number-Group"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the following required inputs:\n     a. group_name (string): The name of the new group\n     b. group_description (string): A description of the group's purpose\n     c. parent_id (number): The ID of the parent group if this is a subgroup\n   - All fields are mandatory except parent_id which defaults to 0 if not specified\n\n2. Data Validation:\n   - Validate group_name:\n     a. Check if group_name is not empty\n     b. Check if group_name is unique in the system\n     c. If validation fails, display appropriate error message\n   - Validate group_description:\n     a. Check if group_description is not empty\n     b. If validation fails, display appropriate error message\n   - Validate parent_id:\n     a. Check if parent_id refers to an existing group\n     b. Check if parent_id is not the same as the current group being created\n     c. If parent_id is invalid, set to 0 (no parent)\n\n3. Business Rule Processing:\n   - Verify user has permission to create groups\n   - Check if maximum number of allowed groups has not been exceeded\n   - Verify parent group exists if parent_id is provided\n   - IF parent_id equals the current group's ID THEN\n     a. Set parent_id to 0 to prevent circular reference\n\n4. Core Operation Execution:\n   - Create a new Group object with the following properties:\n     a. Set the group name from the input\n     b. Set the group description from the input\n     c. Set the parent ID from the input (or 0 if not applicable)\n   - Save the new group to the database\n   - Generate a unique identifier for the new group\n   - Create default permissions for the new group\n   - IF saving fails THEN\n     a. Roll back any partial changes\n     b. Generate appropriate error message\n     c. Return to the group creation form with entered values\n\n5. Response Generation:\n   - IF group creation is successful THEN\n     a. Display success message indicating the group was created\n     b. Redirect user to the group listing page\n     c. Show the newly created group in the list\n   - IF group creation fails THEN\n     a. Display detailed error message\n     b. Maintain entered form values for correction\n     c. Provide guidance on resolving the issue",
    "databaseEntities": [
      "jforum_groups",
      "jforum_user_groups"
    ],
    "validationRules": [
      "Group name must not be empty",
      "Group name must be unique in the system",
      "Group description must not be empty",
      "Parent group must exist in the system if specified",
      "Parent group ID cannot be the same as the group being created"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Group": {
        "id": "number",
        "name": "string",
        "description": "string",
        "parentId": "number"
      }
    }
  },
  {
    "featureName": "EditGroup",
    "description": "Allows modification of an existing user group's details.",
    "inputValues": [
      "group_id-number-Group",
      "group_name-string-Group",
      "group_description-string-Group",
      "parent_id-number-Group"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the following inputs:\n     a. group_id (mandatory): Unique identifier of the group to be edited\n     b. group_name (mandatory): New name for the group\n     c. group_description (mandatory): New description for the group\n     d. parent_id (optional): Identifier of the parent group, if hierarchical structure is used\n\n2. Data Validation:\n   - Validate group_id:\n     a. Verify that group_id is a positive integer\n     b. Verify that group_id corresponds to an existing group in the system\n     c. IF group_id is invalid or not found, THEN display an error message and abort operation\n   - Validate group_name:\n     a. Verify that group_name is not empty\n     b. Verify that group_name does not exceed the maximum allowed length\n     c. IF group_name is invalid, THEN display an error message\n   - Validate group_description:\n     a. Verify that group_description is not empty\n     b. Verify that group_description does not exceed the maximum allowed length\n     c. IF group_description is invalid, THEN display an error message\n   - Validate parent_id:\n     a. IF parent_id is provided, THEN verify it corresponds to an existing group\n     b. Verify that parent_id is not equal to group_id (a group cannot be its own parent)\n     c. IF parent_id equals group_id, THEN set parent_id to 0 (no parent)\n     d. IF parent_id is invalid, THEN display an error message\n\n3. Business Rule Processing:\n   - Check user permissions:\n     a. Verify that the current user has administrative rights to edit groups\n     b. IF user lacks necessary permissions, THEN display an access denied message and abort operation\n   - Check group dependencies:\n     a. Determine if changing the group's parent would create circular references in the hierarchy\n     b. IF circular reference would be created, THEN display an error message and prevent the change\n\n4. Core Operation Execution:\n   - Retrieve the existing group record using group_id\n   - Update the group record with new values:\n     a. Set the group name to the provided group_name\n     b. Set the group description to the provided group_description\n     c. Set the parent group ID to the provided parent_id (or 0 if no valid parent)\n   - Save the updated group record to the database\n   - IF any database operation fails:\n     a. Roll back any partial changes\n     b. Log the error details\n     c. Display an appropriate error message to the user\n\n5. Response Generation:\n   - IF update is successful:\n     a. Display a success message indicating the group was updated successfully\n     b. Refresh the group listing to show the updated information\n     c. Provide options to further edit the group, manage group permissions, or return to group list\n   - IF update fails:\n     a. Display an error message with details about the failure\n     b. Maintain the form with the user's input values for correction\n     c. Provide guidance on how to resolve any issues",
    "databaseEntities": [
      "jforum_groups",
      "jforum_user_groups"
    ],
    "validationRules": [
      "Group ID must correspond to an existing group",
      "Group name must not be empty",
      "Group description must not be empty",
      "Parent group ID must correspond to an existing group if provided",
      "A group cannot be its own parent",
      "Group hierarchy must not contain circular references"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Group": {
        "id": "number",
        "name": "string",
        "description": "string",
        "parentId": "number"
      }
    }
  },
  {
    "featureName": "SaveGroupChanges",
    "description": "Persists changes to an existing user group in the system.",
    "inputValues": [
      "group_id-number-Group",
      "group_name-string-Group",
      "group_description-string-Group",
      "parent_id-number-Group"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the following inputs:\n     a. group_id (mandatory): Unique identifier for the group being updated\n     b. group_name (mandatory): New name for the group\n     c. group_description (mandatory): Updated description for the group\n     d. parent_id (optional): Identifier of the parent group, if hierarchical structure is used\n\n2. Data Validation:\n   - Validate group_id:\n     a. Ensure group_id is provided and is a valid number\n     b. Verify the group exists in the system\n     c. IF group_id is invalid or not found, THEN display error message and abort operation\n   - Validate group_name:\n     a. Ensure group_name is not empty\n     b. Verify the length meets system requirements\n     c. IF validation fails, THEN display appropriate error message\n   - Validate group_description:\n     a. Ensure description is provided\n     b. Verify the length meets system requirements\n     c. IF validation fails, THEN display appropriate error message\n   - Validate parent_id:\n     a. IF parent_id is provided, THEN verify it exists in the system\n     b. Ensure parent_id is not the same as group_id (prevent self-reference)\n     c. IF parent_id equals group_id, THEN set parent_id to 0 (no parent)\n     d. IF parent_id is invalid, THEN display error message\n\n3. Business Rule Processing:\n   - Check for circular references in group hierarchy:\n     a. Ensure the parent_id does not create a circular reference in the group hierarchy\n     b. IF circular reference is detected, THEN display error message and abort operation\n   - Check for name conflicts:\n     a. Verify the new group name doesn't conflict with existing groups (excluding the current group)\n     b. IF name conflict exists, THEN display error message and abort operation\n   - Check for system-protected groups:\n     a. Verify the group is not a system-protected group that cannot be modified\n     b. IF group is protected, THEN display error message and abort operation\n\n4. Core Operation Execution:\n   - Prepare group data for update:\n     a. Create group object with updated information\n     b. Set group ID, name, description, and parent ID\n   - Update group record in the system:\n     a. Save the updated group information to the database\n     b. Update any related hierarchical structures if parent_id changed\n     c. IF update fails, THEN log error details and display error message\n   - Update related data if necessary:\n     a. Update any cached group information in the system\n     b. Update any dependent relationships affected by the changes\n\n5. Response Generation:\n   - For successful update:\n     a. Generate success message indicating the group was updated successfully\n     b. Provide updated group details in the response\n     c. Return to the group listing page showing all groups\n   - For failed update:\n     a. Generate appropriate error message explaining the failure reason\n     b. Preserve user input to allow correction\n     c. Provide guidance on how to resolve the issue",
    "databaseEntities": [
      "jforum_groups",
      "jforum_user_groups"
    ],
    "validationRules": [
      "Group ID must exist in the system",
      "Group name must not be empty",
      "Group description must not be empty",
      "Parent ID must not create a circular reference",
      "Parent ID cannot be the same as the group ID",
      "Group name must be unique across the system"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Group": {
        "id": "number",
        "name": "string",
        "description": "string",
        "parentId": "number"
      }
    }
  },
  {
    "featureName": "DeleteGroups",
    "description": "Removes selected user groups with validation to prevent deletion of essential groups.",
    "inputValues": [
      "group_id-number-Group"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect group_id values from the selection list\n   - System identifies which groups are selected for deletion\n   - All selected group IDs are gathered as an array of values\n\n2. Data Validation:\n   - Verify that at least one group is selected for deletion\n     * IF no groups are selected THEN\n       - Skip deletion process\n       - Return to group listing view\n     * END IF\n   - For each selected group, validate deletion eligibility:\n     * Check if the group is an essential system group\n     * Verify the group is not currently assigned to users\n     * Confirm the group doesn't have special permissions that cannot be removed\n\n3. Business Rule Processing:\n   - Create a list to track any errors during the deletion process\n   - For each group ID in the selection:\n     * Verify if the group can be safely deleted\n       - Check if group has dependent relationships\n       - Ensure group is not required by the system\n     * IF group cannot be deleted THEN\n       - Add error message to the error list with group identifier\n       - Continue to next group in selection\n     * END IF\n\n4. Core Operation Execution:\n   - For each group that passed validation:\n     * Remove group permissions and security settings\n     * Delete group associations with users\n     * Remove group from the system\n     * Update any related caches or repositories\n   - IF any errors occurred during deletion THEN\n     * Store error messages for display\n   * END IF\n\n5. Response Generation:\n   - IF errors exist THEN\n     * Display list of groups that could not be deleted with reasons\n   * END IF\n   - Refresh and display the updated group listing\n   - Provide confirmation of successfully deleted groups",
    "databaseEntities": [
      "jforum_groups",
      "jforum_user_groups",
      "jforum_moderator_groups"
    ],
    "validationRules": [
      "At least one group must be selected for deletion",
      "Essential system groups cannot be deleted",
      "Groups with active user assignments cannot be deleted",
      "Groups with special permissions may be restricted from deletion"
    ],
    "dbSeedingOperations": [],
    "schema": {}
  },
  {
    "featureName": "ManageGroupPermissions",
    "description": "Displays and configures security permissions for a specific user group.",
    "inputValues": [
      "groupId-number-Group",
      "permissionSettings-object-PermissionSettings"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the following inputs:\n     a. groupId (mandatory): Numeric identifier of the group to manage permissions for\n     b. permissionSettings (optional): Collection of permission settings to be applied\n     c. System will generate permission configuration data based on XML configuration\n\n2. Data Validation:\n   - Validate groupId:\n     a. Check if groupId is provided and is a valid number\n     b. Verify groupId exists in the system\n     c. Return error message if group does not exist: \"Invalid group identifier provided\"\n   - Validate permissionSettings (when provided for saving):\n     a. Ensure all permission values are valid boolean flags\n     b. Verify all permission keys match defined system permissions\n     c. Return error message for invalid permissions: \"One or more permission settings are invalid\"\n\n3. Business Rule Processing:\n   - Check user authorization:\n     a. Verify current user has administrative privileges to manage permissions\n     b. IF user lacks required privileges, THEN\n        i. Return error message: \"Insufficient privileges to manage group permissions\"\n        ii. Terminate the operation\n   - Verify group status:\n     a. Check if the group is active and can have permissions modified\n     b. IF group is in a locked or special state, THEN\n        i. Return error message: \"This group's permissions cannot be modified\"\n        ii. Terminate the operation\n\n4. Core Operation Execution:\n   - IF operation is to display permissions:\n     a. Load permission configuration schema from system configuration\n     b. Retrieve current permission settings for the specified group\n     c. Organize permissions into logical sections based on configuration\n     d. Prepare permission data for display with current values\n   - IF operation is to save permissions:\n     a. For each permission in the permissionSettings:\n        i. Update the permission value for the group\n        ii. Track changes for audit purposes\n     b. Save all permission changes to the database\n     c. Clear any cached permission data in the system\n     d. Rebuild security repositories and access control lists\n     e. IF any error occurs during saving, THEN\n        i. Roll back all permission changes\n        ii. Return error message: \"Failed to save permission changes\"\n\n5. Response Generation:\n   - For display operation:\n     a. Return success response with:\n        i. Group details (name, description, ID)\n        ii. Organized permission sections with settings\n        iii. Available permission options\n   - For save operation:\n     a. Return success response with:\n        i. Confirmation message: \"Permissions updated successfully\"\n        ii. Summary of changes made\n        iii. Option to view updated permissions",
    "databaseEntities": [
      "jforum_groups",
      "jforum_user_groups",
      "jforum_roles"
    ],
    "validationRules": [
      "Group ID must be a valid positive integer",
      "Group must exist in the system",
      "User must have administrative privileges to manage permissions",
      "Permission settings must contain valid permission keys",
      "Permission values must be valid boolean flags"
    ],
    "dbSeedingOperations": [
      "Ensure default permission roles exist in the system",
      "Ensure XML permission configuration is properly loaded"
    ],
    "schema": {
      "PermissionSettings": {
        "type": "object",
        "properties": {
          "sections": {
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "name": {
                  "type": "string",
                  "description": "Name of the permission section"
                },
                "permissions": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "name": {
                        "type": "string",
                        "description": "Name of the permission"
                      },
                      "value": {
                        "type": "boolean",
                        "description": "Whether the permission is granted or not"
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  },
  {
    "featureName": "SaveGroupPermissions",
    "description": "Persists permission changes for a user group and refreshes security repositories.",
    "inputValues": [
      "groupId-number-Group",
      "permissions-object-PermissionSet"
    ],
    "businessLogic": "1. Input Collection\n   - Collect the following inputs:\n     1.1. groupId (mandatory): Unique identifier for the user group\n     1.2. permissions (mandatory): Set of permission selections for the group\n         1.2.1. Each permission has an associated role and access level\n         1.2.2. Permissions are organized by functional sections\n\n2. Data Validation\n   2.1. Validate Group Existence\n       2.1.1. Check if groupId corresponds to an existing group\n       2.1.2. IF group does not exist, THEN\n           2.1.2.1. Generate error message \"Invalid group identifier\"\n           2.1.2.2. Abort operation\n   2.2. Validate Permission Format\n       2.2.1. Ensure all permission entries have valid role identifiers\n       2.2.2. Verify permission values are within allowed range\n       2.2.3. IF any permission is invalid, THEN\n           2.2.3.1. Generate error message \"Invalid permission format\"\n           2.2.3.2. Abort operation\n\n3. Business Rule Processing\n   3.1. Check User Authorization\n       3.1.1. Verify current user has administrative privileges\n       3.1.2. IF user lacks required privileges, THEN\n           3.1.2.1. Generate error message \"Insufficient privileges to modify group permissions\"\n           3.1.2.2. Abort operation\n   3.2. Validate System Constraints\n       3.2.1. Check if system is in maintenance mode\n       3.2.2. IF system is in maintenance mode, THEN\n           3.2.1.1. Generate error message \"System is in maintenance mode. Try again later.\"\n           3.2.1.2. Abort operation\n\n4. Core Operation Execution\n   4.1. Prepare Permission Data\n       4.1.1. Organize permissions by security role\n       4.1.2. Map permission values to system-recognized format\n   4.2. Remove Existing Permissions\n       4.2.1. Delete all current permission entries for the specified group\n       4.2.2. IF deletion fails, THEN\n           4.2.2.1. Log error details\n           4.2.2.2. Generate error message \"Failed to remove existing permissions\"\n           4.2.2.3. Abort operation\n   4.3. Save New Permissions\n       4.3.1. For EACH permission in the permission set:\n           4.3.1.1. Create permission record linking group to role with specified access level\n           4.3.1.2. Save permission record to database\n           4.3.1.3. IF any save operation fails, THEN\n               4.3.1.3.1. Rollback all permission changes\n               4.3.1.3.2. Generate error message \"Failed to save permissions\"\n               4.3.1.3.3. Abort operation\n   4.4. Refresh Security Repositories\n       4.4.1. Clear security cache\n       4.4.2. Reload role definitions\n       4.4.3. Update forum moderator lists\n       4.4.4. IF refresh operations fail, THEN\n           4.4.4.1. Log warning about stale security data\n           4.4.4.2. Continue operation (non-fatal error)\n\n5. Response Generation\n   5.1. Success Response\n       5.1.1. Generate confirmation message \"Group permissions successfully updated\"\n       5.1.2. Include summary of permission changes\n       5.1.3. Return to group listing view\n   5.2. Error Response\n       5.2.1. Include specific error message from failed step\n       5.2.2. Provide guidance for resolving the issue\n       5.2.3. Maintain form data for correction",
    "databaseEntities": [
      "jforum_groups",
      "jforum_roles",
      "jforum_role_values",
      "jforum_user_groups"
    ],
    "validationRules": [
      "Group ID must correspond to an existing group",
      "User must have administrative privileges to modify permissions",
      "All permission entries must have valid role identifiers",
      "Permission values must be within allowed range for each role type",
      "System must not be in maintenance mode during permission updates"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "PermissionSet": {
        "type": "object",
        "properties": {
          "sections": {
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "name": {
                  "type": "string",
                  "description": "Name of the permission section"
                },
                "roles": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "id": {
                        "type": "string",
                        "description": "Role identifier"
                      },
                      "value": {
                        "type": "string",
                        "description": "Permission value for the role"
                      }
                    },
                    "required": [
                      "id",
                      "value"
                    ]
                  }
                }
              },
              "required": [
                "name",
                "roles"
              ]
            }
          }
        },
        "required": [
          "sections"
        ]
      }
    }
  },
  {
    "featureName": "ListLuceneStats",
    "description": "Displays statistics about the Lucene search index including status, document count, and index location.",
    "inputValues": [],
    "businessLogic": "1. Input Collection:\n   - No user inputs required for initial display\n   - System will gather the following information:\n     * Index directory location\n     * Index existence status\n     * Current indexing status\n     * Index lock status\n     * Last modification date\n     * Index version\n     * Number of documents in index\n     * Total messages in system\n\n2. Data Validation:\n   - Verify search engine configuration\n     * IF search engine is not Lucene THEN\n       - Display notification that Lucene is not enabled\n       - Exit process\n     * END IF\n   - Verify index directory accessibility\n     * IF index directory cannot be accessed THEN\n       - Set information availability flag to false\n     * ELSE\n       - Set information availability flag to true\n     * END IF\n\n3. Business Rule Processing:\n   - Check if index exists\n     * IF index directory exists THEN\n       - Set index exists flag to true\n     * ELSE\n       - Set index exists flag to false\n     * END IF\n   - Check if indexing is currently in progress\n     * IF system is currently indexing THEN\n       - Set currently indexing flag to true\n     * ELSE\n       - Set currently indexing flag to false\n     * END IF\n   - IF information is available THEN\n     * Check if index is locked\n     * Retrieve last modification date\n     * Retrieve index location path\n     * Count total messages in system\n     * Retrieve index version\n     * Count number of documents in index\n   * END IF\n\n4. Core Operation Execution:\n   - Gather all statistics data into a structured format\n   - Prepare display context with all collected information\n   - Handle any exceptions during data collection\n     * IF exception occurs during data collection THEN\n       - Log error details\n       - Set appropriate error flags\n     * END IF\n   - Ensure proper resource cleanup\n     * Close any open index readers\n\n5. Response Generation:\n   - Display statistics dashboard with the following sections:\n     * Index Status Information:\n       - Whether index exists\n       - Whether system is currently indexing\n       - Whether index is locked (if information available)\n     * Index Details (if information available):\n       - Last modification date\n       - Index location path\n       - Index version\n       - Number of documents in index\n       - Total messages in system\n     * Index Management Options:\n       - Create index directory (if doesn't exist)\n       - Reconstruct index options\n       - Cancel indexing option (if currently indexing)",
    "databaseEntities": [
      "jforum_posts",
      "jforum_topics",
      "jforum_forums",
      "jforum_categories"
    ],
    "validationRules": [
      "Search engine must be configured as Lucene",
      "Index directory must be properly configured in system settings",
      "User must have administrative privileges to view statistics"
    ],
    "dbSeedingOperations": [],
    "schema": {}
  },
  {
    "featureName": "CreateIndexDirectory",
    "description": "Creates a new Lucene index directory for search functionality.",
    "inputValues": [
      "indexDirectoryPath-string-IndexDirectory"
    ],
    "businessLogic": "1. Input Collection:\n   1.1. Collect the index directory path (mandatory):\n       - The path where the search index will be created\n       - System will use default path if not explicitly provided\n   1.2. Verify user has administrative privileges (system-generated)\n\n2. Data Validation:\n   2.1. Validate index directory path:\n       - Check if the path string is not empty\n       - Verify the path format is valid for the operating system\n       - Ensure the path is accessible and has proper permissions\n       - Generate error message if path is invalid or inaccessible\n   2.2. Validate if search functionality is enabled:\n       - Check if the search engine configuration is set to use indexing\n       - Return appropriate error if search indexing is not enabled\n\n3. Business Rule Processing:\n   3.1. Check system state:\n       - Verify no indexing operation is currently in progress\n       - IF indexing is in progress THEN\n           - Generate busy state error message\n           - Abort operation\n       - END IF\n   3.2. Check directory status:\n       - IF directory already exists THEN\n           - Determine if overwrite is allowed\n           - IF overwrite not allowed THEN\n               - Generate directory exists error\n               - Abort operation\n           - END IF\n       - END IF\n\n4. Core Operation Execution:\n   4.1. Create index directory structure:\n       - Attempt to create the directory at the specified path\n       - Create any necessary subdirectories for index organization\n       - Set appropriate file permissions for the created directories\n       - IF directory creation fails THEN\n           - Log the specific error reason\n           - Generate directory creation failure message\n           - Abort operation\n       - END IF\n   4.2. Initialize index structure:\n       - Create initial index files and structure\n       - Set up necessary configuration for the index\n       - Record creation timestamp and version information\n       - IF initialization fails THEN\n           - Clean up any partially created files\n           - Log the specific error reason\n           - Generate index initialization failure message\n           - Abort operation\n       - END IF\n\n5. Response Generation:\n   5.1. Create success response:\n       - Generate confirmation message that index directory was created\n       - Include the path where the index was created\n       - Include timestamp of creation\n       - Provide next steps for index population\n   5.2. Update system status:\n       - Update system configuration to reference new index location if needed\n       - Record the index creation in system logs\n   5.3. Return to index management interface:\n       - Display updated index information\n       - Show available index operations",
    "databaseEntities": [
      "jforum_posts",
      "jforum_posts_text",
      "jforum_topics",
      "jforum_forums"
    ],
    "validationRules": [
      "Index directory path must not be empty",
      "Index directory path must be accessible with write permissions",
      "Search functionality must be enabled in the system",
      "No indexing operation should be currently in progress",
      "System must have sufficient disk space for index creation"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "IndexDirectory": {
        "type": "object",
        "properties": {
          "path": {
            "type": "string",
            "description": "File system path where the index will be created"
          },
          "isWritable": {
            "type": "boolean",
            "description": "Whether the directory has write permissions"
          },
          "exists": {
            "type": "boolean",
            "description": "Whether the directory already exists"
          }
        },
        "required": [
          "path"
        ]
      }
    }
  },
  {
    "featureName": "ReconstructSearchIndex",
    "description": "Rebuilds the Lucene search index from scratch with configurable parameters.",
    "inputValues": [
      "indexOperationType-string-IndexOperation",
      "fromDate-date-DateRange",
      "toDate-date-DateRange",
      "firstPostId-number-PostRange",
      "lastPostId-number-PostRange",
      "avoidDuplicatedRecords-boolean-IndexOption",
      "type-number-IndexType"
    ],
    "businessLogic": "1. Input Collection\n   - Collect the following inputs:\n     a. indexOperationType (mandatory): Determines if the index should be recreated or updated\n     b. fromDate (optional): Starting date for filtering content to be indexed\n     c. toDate (optional): Ending date for filtering content to be indexed\n     d. firstPostId (optional): Starting post ID for filtering content to be indexed\n     e. lastPostId (optional): Ending post ID for filtering content to be indexed\n     f. avoidDuplicatedRecords (optional): Flag to prevent duplicate entries in the index\n     g. type (mandatory): Numeric value indicating the type of content to index\n\n2. Data Validation\n   - Validate indexOperationType:\n     a. IF indexOperationType is empty THEN display error message \"Index operation type must be specified\"\n     b. IF indexOperationType is not one of the allowed values THEN display error message \"Invalid index operation type\"\n   - Validate date ranges:\n     a. IF fromDate is provided AND toDate is provided THEN\n        i. IF fromDate is after toDate THEN display error message \"Start date cannot be after end date\"\n   - Validate post ID ranges:\n     a. IF firstPostId is provided AND lastPostId is provided THEN\n        i. IF firstPostId > lastPostId THEN display error message \"First post ID cannot be greater than last post ID\"\n        ii. IF firstPostId < 0 THEN display error message \"First post ID cannot be negative\"\n   - Validate type parameter:\n     a. IF type is not a valid index type THEN display error message \"Invalid index type specified\"\n\n3. Business Rule Processing\n   - Check system state for indexing:\n     a. IF system is currently performing another indexing operation THEN\n        i. Display error message \"Another indexing operation is in progress\"\n        ii. Abort the current operation\n     b. Check if search functionality is enabled:\n        i. IF search functionality is not enabled THEN\n           1. Display error message \"Search functionality is not enabled\"\n           2. Abort the current operation\n     c. Check if index directory exists:\n        i. IF index directory does not exist THEN\n           1. Create the index directory\n           2. IF directory creation fails THEN display error message \"Failed to create index directory\"\n\n4. Core Operation Execution\n   - Prepare indexing arguments:\n     a. Create indexing configuration with all provided parameters\n     b. Set system flag indicating indexing is in progress\n   - Start the indexing process:\n     a. IF indexOperationType is \"recreate\" THEN\n        i. Initialize a new empty index\n     b. ELSE\n        i. Prepare to update existing index\n     c. Begin background indexing process:\n        i. For each content item matching the criteria (date range, post ID range, type):\n           1. Extract searchable content\n           2. Add content to search index\n           3. Update progress indicators\n        ii. IF avoidDuplicatedRecords is true THEN\n            1. Perform additional checks to prevent duplicate entries\n     d. Upon completion:\n        i. Update index metadata\n        ii. Clear the system flag indicating indexing is in progress\n\n5. Response Generation\n   - Generate success response:\n     a. Display confirmation message that indexing has started\n     b. Show current indexing status information:\n        i. Whether indexing is currently in progress\n        ii. Index statistics (if available):\n           1. Total number of documents in index\n           2. Last modification date\n           3. Index location\n           4. Index version\n     c. Provide option to cancel the indexing process if it's running",
    "databaseEntities": [
      "jforum_posts",
      "jforum_posts_text",
      "jforum_topics",
      "jforum_forums",
      "jforum_categories"
    ],
    "validationRules": [
      "Index operation type must be a valid value",
      "If date range is specified, start date must be before end date",
      "If post ID range is specified, first post ID must be less than or equal to last post ID",
      "First post ID cannot be negative",
      "Index type must be a valid value",
      "System cannot start indexing if another indexing operation is in progress"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "IndexOperation": {
        "type": "string",
        "enum": [
          "recreate",
          "update"
        ],
        "description": "Type of index operation to perform"
      },
      "DateRange": {
        "type": "object",
        "properties": {
          "day": {
            "type": "string"
          },
          "month": {
            "type": "string"
          },
          "year": {
            "type": "string"
          },
          "hour": {
            "type": "string"
          },
          "minutes": {
            "type": "string"
          }
        }
      },
      "PostRange": {
        "type": "number",
        "minimum": 0,
        "description": "Post ID for range filtering"
      },
      "IndexOption": {
        "type": "boolean",
        "description": "Option to control indexing behavior"
      },
      "IndexType": {
        "type": "number",
        "description": "Type of content to index"
      }
    }
  },
  {
    "featureName": "CancelIndexing",
    "description": "Stops an ongoing Lucene indexing process.",
    "inputValues": [],
    "businessLogic": "1. Input Collection:\n   - No user inputs are required for this operation\n   - System identifies the current indexing process status\n\n2. Data Validation:\n   - Verify system state validation\n     2.1. Check if there is an active indexing process running\n     2.2. IF no active indexing process is running THEN\n          2.2.1. Generate appropriate message indicating no active process to cancel\n          2.2.2. END process\n\n3. Business Rule Processing:\n   - Verify system resources and state\n     3.1. Check if the user has administrative privileges\n        3.1.1. IF user does not have administrative privileges THEN\n               3.1.1.1. Generate access denied error message\n               3.1.1.2. END process\n     3.2. Check if the indexing process can be safely interrupted\n        3.2.1. Determine the current stage of indexing\n        3.2.2. Evaluate if interruption at current stage would cause data corruption\n        3.2.3. IF interruption would cause data corruption THEN\n               3.2.3.1. Generate warning message about potential data issues\n               3.2.3.2. Request confirmation before proceeding\n\n4. Core Operation Execution:\n   - Stop the indexing process\n     4.1. Update system flag to indicate indexing should stop\n     4.2. Signal the background indexing process to terminate\n     4.3. Release any locks held by the indexing process\n     4.4. Update system status to reflect indexing is no longer in progress\n     4.5. Record the cancellation event in the system log with timestamp and user information\n     4.6. IF any cleanup operations are needed THEN\n          4.6.1. Perform necessary cleanup of temporary files\n          4.6.2. Reset any counters or progress indicators\n\n5. Response Generation:\n   - Generate confirmation of cancellation\n     5.1. Create success message indicating indexing was successfully cancelled\n     5.2. Include information about the state of the index (complete, partial, or potentially corrupted)\n     5.3. Provide options for next steps (restart indexing, view index status)\n     5.4. Display the updated system status showing indexing is no longer in progress",
    "databaseEntities": [],
    "validationRules": [
      "User must have administrative privileges to cancel indexing",
      "An indexing process must be currently running to be cancelled",
      "System must be in a state where cancellation won't corrupt data"
    ],
    "dbSeedingOperations": [],
    "schema": {}
  },
  {
    "featureName": "ListPendingModerationItems",
    "description": "Displays a list of categories with pending moderation items.",
    "inputValues": [
      "userId-number-User"
    ],
    "businessLogic": "1. Input Collection\n   - Collect user identification information\n     1.1. Retrieve userId from the current session\n     1.2. No additional input parameters are required from the user\n\n2. Data Validation\n   - Validate user permissions\n     2.1. Verify the user has administrator or moderator privileges\n     2.2. IF user does not have required permissions THEN\n          2.2.1. Generate access denied error message\n          2.2.2. Redirect user to appropriate error page\n          2.2.3. Log unauthorized access attempt\n     2.3. IF user has required permissions THEN\n          2.3.1. Proceed to next step\n\n3. Business Rule Processing\n   - Prepare data for display\n     3.1. Check system configuration for moderation settings\n     3.2. Verify moderation feature is enabled\n     3.3. IF moderation is disabled THEN\n          3.3.1. Display notification that moderation is not active\n          3.3.2. End process\n     3.4. IF moderation is enabled THEN\n          3.4.1. Proceed to retrieve moderation data\n\n4. Core Operation Execution\n   - Retrieve pending moderation items\n     4.1. Query the database for categories with pending moderation items\n     4.2. For each category with pending items:\n          4.2.1. Retrieve forum information within the category\n          4.2.2. Count number of pending topics per forum\n          4.2.3. Collect metadata about pending posts (creation date, author)\n     4.3. Organize the data hierarchically by category and forum\n     4.4. Sort categories and forums according to system configuration\n     4.5. Prepare summary statistics (total pending items, oldest pending item)\n\n5. Response Generation\n   - Display moderation list interface\n     5.1. Generate category listing with pending moderation counts\n     5.2. For each category:\n          5.2.1. Display category name\n          5.2.2. Show number of pending items\n          5.2.3. Provide link to view detailed forum listing\n     5.3. Include action buttons for bulk operations if applicable\n     5.4. Display timestamp of when the list was generated\n     5.5. Provide refresh option to update the list",
    "databaseEntities": [
      "User",
      "Category",
      "Forum",
      "Topic",
      "Post"
    ],
    "validationRules": [
      "User must have administrator or moderator privileges",
      "Moderation feature must be enabled in system configuration",
      "Only posts marked for moderation should be included in the list"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "ModerationInfo": {
        "categoryId": "number",
        "categoryName": "string",
        "forumId": "number",
        "forumName": "string",
        "pendingCount": "number"
      }
    }
  },
  {
    "featureName": "ViewForumModerationQueue",
    "description": "Shows topics pending moderation for a specific forum.",
    "inputValues": [
      "forum_id-number-Forum"
    ],
    "businessLogic": "1. Input Collection\n   - Collect forum_id (mandatory) to identify which forum's moderation queue to display\n   - System will use current user's authentication context (mandatory, system-generated)\n\n2. Data Validation\n   - Validate forum_id\n     - Verify forum_id is a positive integer\n     - Verify forum_id corresponds to an existing forum\n     - IF forum_id is invalid or missing THEN\n       - Generate error message \"Invalid forum selected\"\n       - Abort operation and return error\n   - Validate user permissions\n     - Verify current user has moderation privileges for the specified forum\n     - IF user lacks moderation privileges THEN\n       - Generate error message \"Insufficient permissions to view moderation queue\"\n       - Abort operation and return error\n\n3. Business Rule Processing\n   - Check forum status\n     - Verify forum is active and not locked\n     - IF forum is inactive or locked THEN\n       - Generate appropriate notification message\n       - Continue processing with this context information\n   - Check moderation settings\n     - Verify forum has moderation enabled\n     - IF moderation is disabled for this forum THEN\n       - Generate notification \"Moderation is not enabled for this forum\"\n       - Return empty queue with notification\n\n4. Core Operation Execution\n   - Retrieve forum details\n     - Load forum name, description, and settings\n   - Retrieve pending topics\n     - Fetch all topics requiring moderation in the specified forum\n     - For each topic, collect:\n       - Topic ID\n       - Topic title\n       - Creator username\n       - Creation date\n       - Post content preview\n       - Number of posts in the topic\n   - Sort pending topics\n     - Order topics by submission date (newest first)\n   - Prepare moderation actions\n     - For each topic, prepare approve/reject action options\n\n5. Response Generation\n   - Generate success response\n     - Include forum details (name, description)\n     - Include list of pending topics with their details\n     - Include moderation action controls for each topic\n     - IF no pending topics exist THEN\n       - Include notification \"No topics pending moderation\"\n   - In case of errors\n     - Return appropriate error message\n     - Include navigation options to return to forum list",
    "databaseEntities": [
      "Forum",
      "Topic",
      "Post",
      "User"
    ],
    "validationRules": [
      "Forum ID must be a positive integer",
      "Forum must exist in the system",
      "User must have moderation privileges for the specified forum",
      "Only topics pending moderation should be displayed"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Forum": {
        "id": "number",
        "name": "string",
        "description": "string",
        "moderationEnabled": "boolean"
      },
      "Topic": {
        "id": "number",
        "title": "string",
        "creationDate": "date",
        "userId": "number",
        "forumId": "number",
        "pendingModeration": "boolean",
        "totalPosts": "number"
      },
      "Post": {
        "id": "number",
        "topicId": "number",
        "userId": "number",
        "content": "string",
        "postDate": "date",
        "pendingModeration": "boolean"
      },
      "User": {
        "id": "number",
        "username": "string"
      }
    }
  },
  {
    "featureName": "ApproveModeratedPosts",
    "description": "Approves selected posts from the moderation queue and updates forum statistics.",
    "inputValues": [
      "postIds-object-PostSelection",
      "moderationAction-string-ActionType"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the list of post IDs selected for moderation (postIds)\n   - Collect the moderation action to perform (moderationAction: 'approve', 'reject', or 'defer')\n   - System will use current moderator's user ID from session\n\n2. Data Validation:\n   - Validate that postIds contains at least one valid post ID\n     * IF postIds is empty or null THEN return error message \"No posts selected for moderation\"\n   - Validate that moderationAction is one of the allowed values\n     * IF moderationAction is not 'approve', 'reject', or 'defer' THEN return error message \"Invalid moderation action\"\n   - Validate that the current user has moderation privileges for the forums containing the selected posts\n     * IF user lacks moderation privileges THEN return error message \"Insufficient permissions to moderate selected posts\"\n\n3. Business Rule Processing:\n   - FOR EACH post ID in the selection:\n     * Verify the post exists in the system\n     * Verify the post is currently awaiting moderation\n     * IF post doesn't exist THEN skip to next post\n     * IF post is not awaiting moderation THEN skip to next post\n\n4. Core Operation Execution:\n   - FOR EACH valid post awaiting moderation:\n     * IF moderationAction is 'defer':\n       - Skip processing this post (leave in moderation queue)\n     * ELSE IF moderationAction is 'approve':\n       - Mark post as approved in the system\n       - Retrieve post details (author, content, timestamp)\n       - Retrieve associated topic information\n       - Check if this is the first post in the topic\n         * IF this is the first post in the topic THEN mark topic as visible\n       - Update topic statistics:\n         * Update last post information (ID, author, timestamp)\n         * IF not the first post THEN increment reply count\n       - Update forum statistics:\n         * Update last post information\n         * Increment post count\n       - Increment post count for the post author\n       - Send notifications to subscribed users\n     * ELSE IF moderationAction is 'reject':\n       - Delete the post from the system\n       - Delete any attachments associated with the post\n       - Check if this was the only post in the topic\n         * IF topic now has zero posts THEN delete the topic\n\n5. Response Generation:\n   - Generate summary of moderation actions taken:\n     * Number of posts approved\n     * Number of posts rejected\n     * Number of posts deferred\n   - Provide list of affected topics and forums\n   - Return to the moderation queue view with updated list of pending posts",
    "databaseEntities": [
      "jforum_posts",
      "jforum_topics",
      "jforum_forums",
      "jforum_users",
      "jforum_attachments"
    ],
    "validationRules": [
      "At least one post must be selected for moderation",
      "Moderation action must be one of: approve, reject, or defer",
      "User must have moderation privileges for the forums containing selected posts",
      "Posts must exist in the system",
      "Posts must be awaiting moderation"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "PostSelection": {
        "type": "object",
        "properties": {
          "postIds": {
            "type": "array",
            "items": {
              "type": "number",
              "description": "ID of a post to be moderated"
            }
          }
        }
      },
      "ActionType": {
        "type": "string",
        "enum": [
          "approve",
          "reject",
          "defer"
        ],
        "description": "Type of moderation action to perform on selected posts"
      }
    }
  },
  {
    "featureName": "RejectModeratedPosts",
    "description": "Rejects and deletes posts from the moderation queue including their attachments.",
    "inputValues": [
      "postIds-object-PostIdList",
      "forumId-number-Forum"
    ],
    "businessLogic": "1. Input Collection\n   - Collect the following inputs:\n     a. postIds (mandatory): List of post identifiers to be rejected\n     b. forumId (mandatory): Identifier of the forum containing the posts\n\n2. Data Validation\n   - Validate post identifiers:\n     a. Check if postIds array is not empty\n        IF postIds array is empty THEN\n          Return error message \"No posts selected for rejection\"\n     b. Verify each postId is a valid number\n        FOR EACH postId in postIds\n          IF postId is not a valid number THEN\n            Return error message \"Invalid post identifier format\"\n   - Validate forum identifier:\n     a. Check if forumId is provided\n        IF forumId is not provided THEN\n          Return error message \"Forum identifier is required\"\n     b. Verify forumId is a valid number\n        IF forumId is not a valid number THEN\n          Return error message \"Invalid forum identifier format\"\n\n3. Business Rule Processing\n   - Verify user permissions:\n     a. Check if current user has moderation privileges for the specified forum\n        IF user does not have moderation privileges THEN\n          Return error message \"Insufficient permissions to moderate this forum\"\n   - Verify forum exists:\n     a. Check if forum with forumId exists in the system\n        IF forum does not exist THEN\n          Return error message \"Forum not found\"\n   - Verify posts are in moderation queue:\n     a. FOR EACH postId in postIds\n        Check if post exists and is awaiting moderation\n        IF post does not exist THEN\n          Skip this post and continue with next\n        IF post is not awaiting moderation THEN\n          Skip this post and continue with next\n\n4. Core Operation Execution\n   - Process each post for rejection:\n     a. FOR EACH postId in postIds\n        i. Retrieve post details from database\n        ii. Delete any attachments associated with the post\n           - Identify all attachments linked to the post\n           - Remove attachment files from storage\n           - Delete attachment records from database\n        iii. Delete the post content from database\n        iv. Check if this was the only post in its topic\n            IF topic has no remaining posts THEN\n              Delete the topic\n              Update forum statistics to reflect removed topic\n            ELSE\n              Update topic statistics (post count, last post information)\n        v. Update forum statistics to reflect removed post\n\n5. Response Generation\n   - Prepare success response:\n     a. Count of successfully rejected posts\n     b. Count of topics that were deleted (if any)\n     c. Updated forum statistics\n   - Handle potential errors:\n     a. IF any posts failed to be rejected\n        Include details of which posts could not be processed and why\n   - Return confirmation message:\n     a. \"Successfully rejected [count] posts from moderation queue\"",
    "databaseEntities": [
      "jforum_posts",
      "jforum_topics",
      "jforum_forums",
      "jforum_attachments",
      "jforum_posts_text"
    ],
    "validationRules": [
      "User must have moderation privileges for the forum",
      "Post IDs must be valid and exist in the system",
      "Posts must be in the moderation queue awaiting approval",
      "Forum ID must be valid and exist in the system"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "PostIdList": {
        "type": "array",
        "items": {
          "type": "number",
          "description": "Unique identifier of a post"
        }
      }
    }
  },
  {
    "featureName": "SaveModerationDecisions",
    "description": "Processes moderation decisions and refreshes the forum view.",
    "inputValues": [
      "post_id-string-Post",
      "status-string-ModerationStatus",
      "forum_id-number-Forum"
    ],
    "businessLogic": "1. Input Collection\n   - Collect the following inputs:\n     1.1. post_id (array of identifiers, mandatory): The identifiers of posts pending moderation\n     1.2. status_{post_id} (string, mandatory): The moderation decision for each post ('aprove', 'reject', or 'defer')\n     1.3. forum_id (number, mandatory): The identifier of the forum being moderated\n\n2. Data Validation\n   2.1. Validate post identifiers\n      - Verify that post_id values are provided\n      - Verify that each post_id is valid and exists in the system\n      - Generate error if no posts are selected for moderation\n   2.2. Validate moderation status\n      - Verify that a status is provided for each post\n      - Verify that each status is one of the allowed values ('aprove', 'reject', or 'defer')\n      - Generate error if any status is invalid\n   2.3. Validate forum identifier\n      - Verify that forum_id is provided\n      - Verify that forum_id corresponds to an existing forum\n      - Generate error if forum does not exist\n\n3. Business Rule Processing\n   3.1. Check user permissions\n      - Verify that the current user has moderation privileges for the specified forum\n      - Generate error if user lacks moderation permissions\n   3.2. Verify post moderation status\n      - For each post, verify that it is actually pending moderation\n      - Skip processing for posts that are not awaiting moderation\n\n4. Core Operation Execution\n   4.1. Process each post based on moderation decision\n      - FOR EACH post in the selected posts:\n         4.1.1. IF status is 'defer'\n            - Skip processing this post and continue to the next one\n         4.1.2. IF status is 'aprove'\n            - Retrieve complete post information\n            - Verify post is awaiting moderation\n            - IF post is not awaiting moderation\n               - Skip to next post\n            - Retrieve post author information\n            - Retrieve associated topic information\n            - Update post status to approved\n            - Determine if this is the first post in the topic\n            - Update topic statistics (reply count, last post information)\n            - Update forum statistics\n            - Notify subscribed users about the new post\n            - Increment the post count for the author\n            - Update any relevant caches\n         4.1.3. IF status is 'reject'\n            - Retrieve complete post information\n            - Verify post is awaiting moderation\n            - IF post is not awaiting moderation\n               - Skip to next post\n            - Delete the post from the system\n            - Delete any attachments associated with the post\n            - Check if this was the only post in the topic\n            - IF no posts remain in the topic\n               - Delete the topic\n            - Update forum statistics\n\n5. Response Generation\n   5.1. Prepare view data\n      - Retrieve updated forum information\n      - Retrieve updated list of topics in the forum\n      - Prepare context data for display\n   5.2. Generate success response\n      - Display updated moderation view with current forum state\n      - Show confirmation message about processed moderation actions\n   5.3. Handle error conditions\n      - IF any errors occurred during processing\n         - Display appropriate error messages\n         - Maintain form state for correction",
    "databaseEntities": [
      "jforum_posts",
      "jforum_topics",
      "jforum_forums",
      "jforum_users",
      "jforum_attachments"
    ],
    "validationRules": [
      "User must have moderation privileges for the forum",
      "Posts must exist and be in pending moderation status",
      "Each post must have a valid moderation decision (approve, reject, or defer)",
      "Forum must exist in the system"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Post": {
        "id": "number",
        "topicId": "number",
        "forumId": "number",
        "userId": "number",
        "time": "date",
        "formatedTime": "string",
        "moderationNeeded": "boolean"
      },
      "ModerationStatus": {
        "type": "string",
        "enum": [
          "aprove",
          "reject",
          "defer"
        ]
      },
      "Forum": {
        "id": "number",
        "name": "string"
      }
    }
  },
  {
    "featureName": "ProcessPermissionData",
    "description": "Processes permission data from request parameters and updates role-based permissions for groups.",
    "inputValues": [
      "permissionControl-object-PermissionControl",
      "groupId-number-Group",
      "requestParameters-object-RequestParameters"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the following inputs:\n     - Permission Control (mandatory): The permission control system interface\n     - Group ID (mandatory): The identifier of the group to update permissions for\n     - Request Parameters (mandatory): Collection of permission-related parameters\n\n2. Data Validation:\n   - Validate Group ID:\n     - Check if Group ID is a positive integer\n     - Verify Group ID exists in the system\n     - IF Group ID is invalid THEN generate appropriate error message\n   - Validate Permission Control:\n     - Ensure Permission Control system is initialized\n     - Verify Permission Control has access to required permission repositories\n     - IF Permission Control is invalid THEN generate appropriate error message\n   - Validate Request Parameters:\n     - Ensure Request Parameters collection is not empty\n     - Verify Request Parameters contain permission-related entries\n     - IF Request Parameters collection is invalid THEN generate appropriate error message\n\n3. Business Rule Processing:\n   - Initialize Permission Processing:\n     - Clear all existing roles for the specified group\n     - Prepare permission storage for new role assignments\n     - Set up role value collections for complex permissions\n   - Verify Permission Structure:\n     - Check that permission parameter names follow required format\n     - Validate that permission values are within allowed ranges\n     - Ensure no conflicting permission assignments exist\n\n4. Core Operation Execution:\n   - Process Permission Parameters:\n     - Iterate through all request parameters\n     - FOR EACH parameter that starts with \"perm_\":\n       - IF parameter ends with \"$single\":\n         - Extract parameter value\n         - IF value equals \"deny\" THEN skip this permission\n         - Extract the base permission name by removing the \"$single\" suffix\n         - Create a new role with the extracted name\n         - Add the role to the group's permission set\n       - ELSE (parameter represents multiple values):\n         - Extract all parameter values\n         - Create a role value collection\n         - IF first value is \"all\":\n           - Add all possible values for this permission type to the collection\n         - ELSE:\n           - Determine which values are allowed by comparing selected values against all possible values\n           - Add only allowed values to the role value collection\n         - Create a new role with the parameter name\n         - Add the role with its value collection to the group's permission set\n   - Finalize Permission Updates:\n     - Ensure all permission changes are properly recorded\n     - Update permission indexes if necessary\n     - Prepare confirmation of successful permission updates\n\n5. Response Generation:\n   - Generate Success Response:\n     - Create confirmation message indicating permissions were updated successfully\n     - Include summary of permission changes made\n     - Provide group identifier in the response\n   - Handle Potential Errors:\n     - Generate appropriate error messages for any failures during processing\n     - Include specific details about which permissions could not be updated\n     - Provide guidance on resolving permission-related issues",
    "databaseEntities": [
      "Group",
      "Role",
      "RoleValue",
      "RoleValueCollection",
      "Permission"
    ],
    "validationRules": [
      "Group ID must be a positive integer",
      "Group ID must exist in the system",
      "Permission Control must be properly initialized",
      "Request Parameters must contain permission-related entries",
      "Permission parameter names must follow the required format",
      "Permission values must be within allowed ranges",
      "No conflicting permission assignments should exist"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "PermissionControl": {
        "type": "object",
        "properties": {
          "addRole": {
            "type": "function",
            "description": "Adds a role to a group"
          },
          "deleteAllRoles": {
            "type": "function",
            "description": "Deletes all roles for a group"
          }
        }
      },
      "RequestParameters": {
        "type": "object",
        "properties": {
          "parameterNames": {
            "type": "array",
            "description": "Collection of parameter names"
          },
          "getParameter": {
            "type": "function",
            "description": "Gets a parameter value by name"
          },
          "getParameterValues": {
            "type": "function",
            "description": "Gets multiple values for a parameter"
          }
        }
      }
    }
  },
  {
    "featureName": "InitializePermissions",
    "description": "Initializes the permission system by deleting all existing roles for a group.",
    "inputValues": [
      "groupId-number-Group"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the group ID (mandatory) for which permissions will be initialized\n   - System will use the permission control system (optional input or system-provided)\n\n2. Data Validation:\n   - Validate that the group ID is a positive integer\n   - Verify that the group ID corresponds to an existing group in the system\n   - IF group ID is invalid or not found THEN\n      - Generate appropriate error message\n      - Terminate the operation\n   - ELSE continue to the next step\n\n3. Business Rule Processing:\n   - Verify that the current user has administrative privileges to modify permissions\n   - Check if the permission system is active and properly configured\n   - IF user lacks necessary privileges THEN\n      - Generate access denied error\n      - Log the unauthorized attempt\n      - Terminate the operation\n   - ELSE continue to the next step\n\n4. Core Operation Execution:\n   - Initialize the permission control system for the specified group\n   - Delete all existing role assignments for the specified group\n   - Prepare the system for new role assignments\n   - IF deletion of existing roles fails THEN\n      - Log the error details\n      - Attempt to restore previous state if possible\n      - Generate appropriate error message\n      - Terminate the operation\n   - ELSE continue to the next step\n\n5. Response Generation:\n   - Generate success response indicating permissions have been initialized\n   - Include the group ID in the response\n   - Provide information about next steps (such as assigning new permissions)\n   - Return control to the calling process",
    "databaseEntities": [
      "jforum_groups",
      "jforum_user_groups"
    ],
    "validationRules": [
      "Group ID must be a positive integer",
      "Group ID must correspond to an existing group",
      "User must have administrative privileges to initialize permissions",
      "Permission system must be active and properly configured"
    ],
    "dbSeedingOperations": [],
    "schema": {}
  },
  {
    "featureName": "ListRankings",
    "description": "Retrieves and displays all user rankings in the system.",
    "inputValues": [],
    "businessLogic": "1. Input Collection:\n   - No user inputs required for this feature\n   - System will retrieve all ranking data automatically\n\n2. Data Validation:\n   - Verify user has appropriate permissions to view rankings\n     - IF user does not have admin privileges THEN\n       - Display access denied message\n       - Terminate process\n     - END IF\n\n3. Business Rule Processing:\n   - Verify ranking system is enabled in system settings\n     - IF ranking system is disabled THEN\n       - Display appropriate notification\n       - Provide option to enable ranking system\n       - Terminate process\n     - END IF\n   - Check if ranking data is accessible\n     - IF ranking data cannot be accessed THEN\n       - Log access failure\n       - Display error message\n       - Terminate process\n     - END IF\n\n4. Core Operation Execution:\n   - Retrieve all ranking records from data store\n     - Include both special and regular rankings\n     - Sort rankings by:\n       - Special rankings first\n       - Regular rankings by minimum post requirement (ascending)\n   - Prepare ranking data for display\n     - For each ranking record:\n       - Format title for display\n       - Determine if ranking is special or regular\n       - For regular rankings, include minimum post requirement\n       - Include ranking ID for reference\n\n5. Response Generation:\n   - Display rankings list with the following information:\n     - Ranking title\n     - Ranking type (special or regular)\n     - Minimum posts required (for regular rankings)\n     - Options for each ranking:\n       - Edit ranking\n       - Delete ranking\n   - Provide option to add new ranking\n   - IF no rankings exist THEN\n     - Display message indicating no rankings are defined\n     - Provide prominent option to create first ranking\n   - END IF",
    "databaseEntities": [
      "jforum_users"
    ],
    "validationRules": [
      "User must have administrative privileges to view rankings",
      "Ranking system must be enabled to display rankings"
    ],
    "dbSeedingOperations": [],
    "schema": {}
  },
  {
    "featureName": "InsertRanking",
    "description": "Displays the form for creating a new user ranking and processes the submitted data.",
    "inputValues": [
      "rank_title-string-Ranking",
      "rank_special-boolean-Ranking",
      "rank_min-number-Ranking"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the following inputs from the user:\n     a. rank_title (mandatory): The title of the ranking\n     b. rank_special (mandatory): Boolean flag indicating if this is a special ranking\n     c. rank_min (conditional): Minimum post count required for this ranking, required only if rank_special is false\n\n2. Data Validation:\n   - Validate rank_title:\n     a. Check if rank_title is not empty\n     b. Check if rank_title length is within acceptable limits\n     c. IF validation fails, THEN display appropriate error message\n   - Validate rank_special:\n     a. Ensure rank_special is a valid boolean value\n     b. IF validation fails, THEN display appropriate error message\n   - Validate rank_min:\n     a. IF rank_special is false, THEN:\n        i. Ensure rank_min is provided\n        ii. Verify rank_min is a positive integer\n        iii. Check if rank_min does not overlap with existing non-special rankings\n     b. IF validation fails, THEN display appropriate error message\n\n3. Business Rule Processing:\n   - Check system state:\n     a. Verify the user has appropriate permissions to create rankings\n     b. IF user lacks permissions, THEN display access denied message and terminate process\n   - Verify ranking constraints:\n     a. IF rank_special is false, THEN:\n        i. Check if the rank_min value conflicts with existing rankings\n        ii. IF conflict exists, THEN notify user and request modification\n\n4. Core Operation Execution:\n   - Create new Ranking object:\n     a. Set the title to the provided rank_title\n     b. Set the special flag to the provided rank_special value\n     c. IF rank_special is false, THEN set the minimum post count to rank_min\n   - Save the new ranking to the database:\n     a. Generate a unique identifier for the new ranking\n     b. Store the ranking information\n     c. IF storage operation fails, THEN display error message and allow user to retry\n   - Update ranking repository:\n     a. Refresh the system's cached ranking information\n     b. IF refresh fails, THEN log the error but continue process\n\n5. Response Generation:\n   - On successful creation:\n     a. Display confirmation message that the ranking was created successfully\n     b. Show the updated list of all rankings in the system\n     c. Provide option to create another ranking or return to management screen\n   - On failure:\n     a. Display specific error message based on the failure reason\n     b. Preserve user inputs to allow correction and resubmission\n     c. Provide option to cancel the operation",
    "databaseEntities": [
      "Ranking"
    ],
    "validationRules": [
      "Ranking title must not be empty",
      "Ranking title must have an acceptable length",
      "Special ranking flag must be a valid boolean value",
      "For non-special rankings, minimum post count must be provided",
      "For non-special rankings, minimum post count must be a positive integer",
      "For non-special rankings, minimum post count must not overlap with existing rankings"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Ranking": {
        "id": "number",
        "title": "string",
        "special": "boolean",
        "min": "number"
      }
    }
  },
  {
    "featureName": "EditRanking",
    "description": "Displays and processes the form for editing an existing user ranking in the system.",
    "inputValues": [
      "rank_id-number-Ranking",
      "rank_title-string-Ranking",
      "rank_special-boolean-Ranking",
      "rank_min-number-Ranking"
    ],
    "businessLogic": "1. Input Collection:\n   - Retrieve the ranking ID from the request\n   - Prepare the form for editing with the following fields:\n     a. Ranking title (mandatory string)\n     b. Special ranking flag (boolean)\n     c. Minimum posts threshold (number, required only if not a special ranking)\n   - System retrieves existing ranking data based on the provided ID\n\n2. Data Validation:\n   - Validate ranking ID:\n     a. Check if ID exists in the system\n     b. Return error if ranking not found\n   - Validate ranking title:\n     a. Ensure title is not empty\n     b. Ensure title length is within acceptable limits\n   - Validate minimum posts threshold:\n     a. IF special ranking flag is FALSE, THEN\n        i. Ensure minimum posts value is provided\n        ii. Ensure minimum posts value is a positive integer\n     b. IF special ranking flag is TRUE, THEN\n        i. Minimum posts field is ignored\n\n3. Business Rule Processing:\n   - Check user permissions:\n     a. Verify current user has administrative rights to edit rankings\n     b. Return error if permission check fails\n   - Validate ranking relationships:\n     a. Check if ranking is currently in use\n     b. Determine impact of changes on existing users\n   - IF changing from non-special to special ranking, THEN\n     a. Verify this change won't disrupt user ranking assignments\n   - IF changing minimum post threshold, THEN\n     a. Check for conflicts with other ranking thresholds\n     b. Ensure new threshold maintains proper ordering with other rankings\n\n4. Core Operation Execution:\n   - Create ranking object with updated information:\n     a. Set ranking ID from input\n     b. Set ranking title from input\n     c. Set special flag from input\n     d. IF not a special ranking, THEN set minimum posts threshold\n   - Update ranking record in the database\n   - Refresh ranking cache/repository to reflect changes\n   - Log the ranking modification action\n\n5. Response Generation:\n   - IF update successful, THEN\n     a. Display success message\n     b. Redirect to ranking list view\n     c. Show updated ranking in the list\n   - IF any errors occurred, THEN\n     a. Display appropriate error messages\n     b. Retain entered values in the form\n     c. Allow user to correct and resubmit",
    "databaseEntities": [
      "Ranking"
    ],
    "validationRules": [
      "Ranking ID must exist in the system",
      "Ranking title must not be empty",
      "If ranking is not special, minimum posts threshold must be provided",
      "Minimum posts threshold must be a positive integer",
      "User must have administrative permissions to edit rankings"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Ranking": {
        "id": "number",
        "title": "string",
        "special": "boolean",
        "min": "number"
      }
    }
  },
  {
    "featureName": "SaveRankingChanges",
    "description": "Updates an existing ranking with new title, special status, and minimum post requirements.",
    "inputValues": [
      "rankId-number-Ranking",
      "title-string-Ranking",
      "isSpecial-boolean-Ranking",
      "minimumPosts-number-Ranking"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the following inputs:\n     a. rankId (mandatory): Unique identifier for the ranking to be updated\n     b. title (mandatory): New title for the ranking\n     c. isSpecial (mandatory): Boolean flag indicating if this is a special ranking\n     d. minimumPosts (optional): Minimum number of posts required for this ranking\n\n2. Data Validation:\n   a. Validate rankId:\n      - IF rankId is empty or not a positive integer THEN\n        - Generate error message: \"Ranking ID must be a valid positive number\"\n      - VERIFY ranking with rankId exists in the system\n        - IF not found THEN\n          - Generate error message: \"Ranking with specified ID does not exist\"\n   \n   b. Validate title:\n      - IF title is empty THEN\n        - Generate error message: \"Ranking title cannot be empty\"\n      - IF title length exceeds maximum allowed characters THEN\n        - Generate error message: \"Ranking title exceeds maximum allowed length\"\n   \n   c. Validate minimumPosts:\n      - IF isSpecial is FALSE THEN\n        - IF minimumPosts is empty or negative THEN\n          - Generate error message: \"Minimum posts must be a non-negative number for non-special rankings\"\n\n3. Business Rule Processing:\n   a. Check system state:\n      - VERIFY ranking system is available and operational\n        - IF system is in maintenance mode THEN\n          - Generate error message: \"Ranking system is currently unavailable for updates\"\n   \n   b. Check user permissions:\n      - VERIFY current user has administrative privileges to modify rankings\n        - IF user lacks required permissions THEN\n          - Generate error message: \"Insufficient permissions to modify rankings\"\n   \n   c. Apply business rules:\n      - IF isSpecial is TRUE THEN\n        - Set minimumPosts to NULL as special rankings don't require post counts\n      - IF isSpecial is FALSE and minimumPosts is provided THEN\n        - VERIFY minimumPosts does not conflict with existing rankings\n          - IF another non-special ranking has the same minimumPosts value THEN\n            - Generate warning: \"Another ranking already uses this minimum post value\"\n\n4. Core Operation Execution:\n   a. Retrieve existing ranking record using rankId\n   \n   b. Update ranking attributes:\n      - Set title to new value\n      - Set isSpecial flag to new value\n      - IF isSpecial is FALSE THEN\n        - Set minimumPosts to new value\n      - ELSE\n        - Set minimumPosts to NULL\n   \n   c. Save updated ranking to database:\n      - Perform database update operation\n      - IF database error occurs THEN\n        - Log error details\n        - Rollback changes\n        - Generate error message: \"Failed to save ranking changes due to database error\"\n   \n   d. Refresh ranking cache:\n      - Update system cache with new ranking information\n      - IF cache refresh fails THEN\n        - Log warning\n        - Continue process as database update was successful\n\n5. Response Generation:\n   a. For successful update:\n      - Generate success message: \"Ranking '{title}' has been successfully updated\"\n      - Include updated ranking details in response\n      - Provide link to ranking list\n   \n   b. For failed update:\n      - Include specific error message from validation or processing steps\n      - Preserve user input values for correction\n      - Provide guidance on how to resolve the issue",
    "databaseEntities": [
      "jforum_ranks"
    ],
    "validationRules": [
      "Ranking ID must be a valid positive number",
      "Ranking title cannot be empty",
      "Minimum posts must be a non-negative number for non-special rankings",
      "User must have administrative privileges to modify rankings"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Ranking": {
        "id": "number",
        "title": "string",
        "special": "boolean",
        "min": "number"
      }
    }
  },
  {
    "featureName": "DeleteRankings",
    "description": "Removes selected user rankings from the system.",
    "inputValues": [
      "rank_id-number-Ranking"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the following inputs:\n     a. rank_id (mandatory): Array of numeric identifiers for rankings to be deleted\n   - System will retrieve these values from the user selection in the interface\n\n2. Data Validation:\n   - Validate rank_id input:\n     a. Check if at least one ranking is selected for deletion\n     b. Verify all rank_id values are valid numeric identifiers\n     c. Confirm each rank_id exists in the system\n   - IF no rankings are selected THEN:\n     a. Generate validation error message: \"No rankings selected for deletion\"\n     b. Return to ranking list view without performing deletion\n   - IF any rank_id is invalid THEN:\n     a. Generate validation error message: \"One or more invalid ranking selections\"\n     b. Return to ranking list view without performing deletion\n\n3. Business Rule Processing:\n   - Check system dependencies for each ranking:\n     a. Verify if any users are currently assigned to these rankings\n     b. Determine if any selected rankings are system default rankings\n   - IF any ranking is a system default ranking THEN:\n     a. Generate warning message: \"Cannot delete system default rankings\"\n     b. Remove these rankings from the deletion list\n   - IF any ranking is currently assigned to users THEN:\n     a. Generate confirmation message: \"Selected rankings are assigned to users. Deletion will remove these assignments.\"\n     b. Require user confirmation before proceeding\n\n4. Core Operation Execution:\n   - FOR EACH valid rank_id in the selection:\n     a. Locate the ranking record in the system\n     b. Remove the ranking record from the database\n     c. Log the deletion operation with timestamp and user information\n   - Update the ranking repository to reflect the changes\n   - IF any deletion operation fails THEN:\n     a. Roll back any partial deletions\n     b. Generate error message with details of the failure\n     c. Log the error for system administrators\n\n5. Response Generation:\n   - IF all deletions complete successfully THEN:\n     a. Generate success message: \"Selected rankings successfully deleted\"\n     b. Refresh the ranking list to show current rankings\n     c. Log the successful operation\n   - IF deletion partially succeeds THEN:\n     a. Generate partial success message: \"Some rankings could not be deleted\"\n     b. Display details of which rankings were deleted and which failed\n     c. Refresh the ranking list to show current rankings\n   - IF deletion completely fails THEN:\n     a. Generate failure message: \"Unable to delete rankings\"\n     b. Provide error details and suggest contacting system administrator\n     c. Return to ranking list view without changes",
    "databaseEntities": [
      "Ranking"
    ],
    "validationRules": [
      "At least one ranking must be selected for deletion",
      "All ranking IDs must be valid numeric identifiers",
      "All ranking IDs must exist in the system",
      "System default rankings cannot be deleted"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Ranking": {
        "id": "number",
        "title": "string",
        "special": "boolean",
        "min": "number"
      }
    }
  },
  {
    "featureName": "CreateNewRanking",
    "description": "Creates a new user ranking with title, special status, and minimum post requirements.",
    "inputValues": [
      "title-string-Ranking",
      "isSpecial-boolean-Ranking",
      "minimumPosts-number-Ranking"
    ],
    "businessLogic": "1. Input Collection:\n   1.1. Collect the following required inputs:\n       - title (string): The name of the ranking to be displayed to users\n       - isSpecial (boolean): Flag indicating if this is a special ranking not tied to post count\n       - minimumPosts (number): The minimum number of posts required to achieve this ranking\n   1.2. Note that minimumPosts is only required when isSpecial is false\n\n2. Data Validation:\n   2.1. Validate title input:\n       - Check if title is not empty or null\n       - Check if title length is within acceptable limits (e.g., 1-50 characters)\n       - IF validation fails, THEN display appropriate error message\n   2.2. Validate isSpecial input:\n       - Ensure isSpecial is a valid boolean value (true or false)\n       - IF validation fails, THEN display appropriate error message\n   2.3. Validate minimumPosts input:\n       - IF isSpecial is false, THEN:\n           - Check if minimumPosts is provided\n           - Verify minimumPosts is a positive integer\n           - Ensure minimumPosts does not conflict with existing ranking thresholds\n       - IF validation fails, THEN display appropriate error message\n\n3. Business Rule Processing:\n   3.1. Check system state:\n       - Verify the ranking system is active and operational\n       - Ensure the user has proper permissions to create rankings\n   3.2. Check for duplicate rankings:\n       - IF a ranking with the same title already exists, THEN display error message\n   3.3. Check for ranking threshold conflicts:\n       - IF isSpecial is false, THEN:\n           - Check if the minimumPosts value overlaps with existing non-special rankings\n           - IF overlap exists, THEN display warning or error message\n\n4. Core Operation Execution:\n   4.1. Create new ranking record:\n       - Generate a new ranking object with the provided title\n       - Set the special status flag based on isSpecial input\n       - IF isSpecial is false, THEN set the minimum posts threshold\n   4.2. Save the ranking to the system:\n       - Store the new ranking in the database\n       - Update the ranking repository/cache to include the new ranking\n   4.3. Handle potential failures:\n       - IF database operation fails, THEN:\n           - Log the error details\n           - Roll back any partial changes\n           - Prepare appropriate error message\n\n5. Response Generation:\n   5.1. For successful creation:\n       - Generate success message indicating the ranking was created\n       - Prepare to display the updated list of all rankings\n   5.2. For failed creation:\n       - Generate appropriate error message explaining the failure reason\n       - Preserve user input for correction\n   5.3. Return to the ranking management interface:\n       - Display either the success message with updated ranking list\n       - OR display the error message with form for correction",
    "databaseEntities": [
      "jforum_users"
    ],
    "validationRules": [
      "Ranking title must not be empty",
      "Special rankings do not require minimum post count",
      "Non-special rankings must have a positive minimum post count",
      "Minimum post count must not conflict with existing ranking thresholds"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Ranking": {
        "id": "number",
        "title": "string",
        "special": "boolean",
        "min": "number"
      }
    }
  },
  {
    "featureName": "ListSmilies",
    "description": "Displays a list of all available smilies in the system.",
    "inputValues": [],
    "businessLogic": "1. Input Collection:\n   - No user inputs required for this feature\n   - System will retrieve all smilies from the repository\n\n2. Data Validation:\n   - Verify user has appropriate access permissions to view smilies\n   - IF user does not have required permissions THEN\n     - Display access denied message\n     - Terminate process\n   - END IF\n\n3. Business Rule Processing:\n   - Verify smilies repository is accessible\n   - IF repository is not accessible THEN\n     - Log system error\n     - Display appropriate error message to user\n     - Terminate process\n   - END IF\n\n4. Core Operation Execution:\n   - Retrieve complete collection of smilies from repository\n   - Sort smilies in appropriate order (alphabetical by code or other defined order)\n   - Prepare smilie data for display including:\n     - Smilie code representation\n     - Smilie image reference\n     - Smilie identifier\n   - IF no smilies exist in the system THEN\n     - Prepare empty list indication\n   - END IF\n\n5. Response Generation:\n   - Set appropriate template for displaying smilies\n   - Display formatted list of all smilies showing:\n     - Smilie image representation\n     - Corresponding text code\n     - Action options (edit, delete) for each smilie if user has admin permissions\n   - Include option to add new smilies for users with appropriate permissions\n   - Display navigation elements if list is paginated\n   - Provide feedback if list is empty\n   - Present smilies in a user-friendly grid or table format for easy selection",
    "databaseEntities": [
      "jforum_smilies"
    ],
    "validationRules": [
      "User must have appropriate permissions to view smilies",
      "Smilies repository must be accessible"
    ],
    "dbSeedingOperations": [],
    "schema": {}
  },
  {
    "featureName": "InsertSmilie",
    "description": "Displays the form for adding a new smilie to the system.",
    "inputValues": [
      "code-string-Smilie",
      "smilie_img-object-FileItem"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the following inputs:\n     1.1. code (string, mandatory): The text code that represents the smilie\n     1.2. smilie_img (file, mandatory): The image file for the smilie\n\n2. Data Validation:\n   2.1. Validate smilie code:\n      2.1.1. Check if code is not empty\n      2.1.2. Check if code follows the required format (typically starts and ends with special characters)\n      2.1.3. IF validation fails, THEN display appropriate error message\n   2.2. Validate uploaded image:\n      2.2.1. Check if file is present\n      2.2.2. Verify file is a valid image format (jpg, gif, png)\n      2.2.3. Ensure file size is within acceptable limits\n      2.2.4. IF validation fails, THEN display appropriate error message\n\n3. Business Rule Processing:\n   3.1. Check system constraints:\n      3.1.1. Verify the smilie code is unique in the system\n      3.1.2. Ensure the system has not reached maximum allowed smilies (if applicable)\n      3.1.3. Confirm the upload directory exists and is writable\n      3.1.4. IF any constraint fails, THEN display appropriate error message\n\n4. Core Operation Execution:\n   4.1. Process the uploaded image:\n      4.1.1. Generate a unique name for the image file\n      4.1.2. Save the uploaded file to the smilie images directory\n      4.1.3. Create the URL pattern for accessing the smilie\n   4.2. Create new smilie record:\n      4.2.1. Create a new Smilie object\n      4.2.2. Set the code attribute with the provided input\n      4.2.3. Set the URL attribute with the generated image URL\n      4.2.4. Set the disk name attribute with the saved file name\n      4.2.5. Save the new smilie to the database\n   4.3. Update system repository:\n      4.3.1. Reload the smilies repository to reflect the changes\n      4.3.2. IF any operation fails, THEN display error message and roll back changes\n\n5. Response Generation:\n   5.1. On success:\n      5.1.1. Display confirmation message that the smilie was added successfully\n      5.1.2. Redirect to the smilie listing page showing all smilies including the new one\n   5.2. On failure:\n      5.2.1. Display appropriate error message\n      5.2.2. Retain entered values in the form\n      5.2.3. Allow user to correct errors and resubmit",
    "databaseEntities": [
      "jforum_smilies"
    ],
    "validationRules": [
      "Smilie code must not be empty",
      "Smilie image file must be provided",
      "Image must be a valid format (jpg, gif, png)",
      "Image file size must be within system limits",
      "Smilie code must be unique in the system"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "FileItem": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "description": "Original filename of the uploaded file"
          },
          "content": {
            "type": "binary",
            "description": "Binary content of the uploaded file"
          },
          "size": {
            "type": "number",
            "description": "Size of the uploaded file in bytes"
          },
          "contentType": {
            "type": "string",
            "description": "MIME type of the uploaded file"
          }
        },
        "required": [
          "name",
          "content"
        ]
      }
    }
  },
  {
    "featureName": "SaveNewSmilie",
    "description": "Processes and saves a new smilie with uploaded image to the system.",
    "inputValues": [
      "code-string-Smilie",
      "smilie_img-object-FileItem"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the following inputs:\n     a. code (string, mandatory): The text code that represents the smilie\n     b. smilie_img (file, mandatory): The image file to be used as the smilie\n   - System will generate:\n     a. imgName: A unique identifier for the image file\n     b. url: The URL pattern to access the smilie\n     c. diskName: The name of the file as stored on disk\n\n2. Data Validation:\n   - Validate smilie code:\n     a. Check if code is not empty\n     b. Verify code follows proper format (special characters surrounded by colons)\n     c. Generate error message if code is invalid\n   - Validate uploaded image:\n     a. Verify file is present\n     b. Check if file is a valid image format (gif, jpg, png)\n     c. Verify file size is within acceptable limits\n     d. Generate error message if image is invalid or missing\n\n3. Business Rule Processing:\n   - Check if the system is ready to accept new smilies:\n     a. Verify smilie directory exists and is writable\n     b. Check if maximum number of smilies has not been reached\n   - Check if similar smilie code already exists:\n     a. IF duplicate code exists THEN\n        i. Generate warning about potential confusion\n        ii. Require confirmation to proceed\n     b. ELSE continue processing\n\n4. Core Operation Execution:\n   - Process the uploaded image:\n     a. Generate a unique filename using encryption of original filename\n     b. Determine file extension from uploaded file\n     c. Save the physical file to the smilie directory\n     d. Create the complete image name with extension\n   - Create new smilie record:\n     a. Set the smilie code from input\n     b. Set the URL using system pattern and new image name\n     c. Set the disk name for future reference\n     d. Save the new smilie to the database\n   - Update smilie repository:\n     a. Reload all smilies to refresh the system cache\n     b. Make new smilie immediately available\n   - IF any operation fails THEN:\n     a. Remove any partially created files\n     b. Revert any database changes\n     c. Generate appropriate error message\n\n5. Response Generation:\n   - On success:\n     a. Provide confirmation message that smilie was created\n     b. Display the new smilie in the list of available smilies\n     c. Offer option to create another smilie\n   - On failure:\n     a. Display specific error message about what went wrong\n     b. Preserve user input for correction\n     c. Provide guidance on how to fix the issue",
    "databaseEntities": [
      "jforum_smilies"
    ],
    "validationRules": [
      "Smilie code must not be empty",
      "Image file must be uploaded",
      "Image file must be a valid image format",
      "Image file size must be within acceptable limits",
      "Smilie directory must exist and be writable"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "FileItem": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "description": "Original filename of the uploaded file"
          },
          "contentType": {
            "type": "string",
            "description": "MIME type of the uploaded file"
          },
          "size": {
            "type": "number",
            "description": "Size of the uploaded file in bytes"
          },
          "content": {
            "type": "binary",
            "description": "Binary content of the uploaded file"
          }
        },
        "required": [
          "name",
          "contentType",
          "size",
          "content"
        ]
      }
    }
  },
  {
    "featureName": "EditSmilie",
    "description": "Displays the form for editing an existing smilie and processes the update.",
    "inputValues": [
      "id-number-Smilie",
      "code-string-Smilie",
      "smilie_img-object-FileItem"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the following inputs:\n     - id (mandatory): The unique identifier of the smilie to be edited\n     - code (mandatory): The text code that represents the smilie\n     - smilie_img (optional): The image file for the smilie\n\n2. Data Validation:\n   - Validate smilie ID:\n     - IF id is not provided or invalid THEN\n       - Display error message \"Valid smilie ID is required\"\n       - Abort operation\n     - ENDIF\n   - Validate smilie code:\n     - IF code is empty THEN\n       - Display error message \"Smilie code cannot be empty\"\n       - Abort operation\n     - ENDIF\n   - Validate image file (if provided):\n     - IF image file is provided THEN\n       - Check if file is a valid image format\n       - IF file is not a valid image THEN\n         - Display error message \"Invalid image format\"\n         - Abort operation\n       - ENDIF\n       - Check if file size is within allowed limits\n       - IF file size exceeds limit THEN\n         - Display error message \"Image file size exceeds maximum allowed\"\n         - Abort operation\n       - ENDIF\n     - ENDIF\n\n3. Business Rule Processing:\n   - Check if smilie exists:\n     - Retrieve smilie record using the provided ID\n     - IF smilie does not exist THEN\n       - Display error message \"Smilie not found\"\n       - Abort operation\n     - ENDIF\n   - Check if system allows smilie modification:\n     - Verify user has appropriate permissions to modify smilies\n     - IF user lacks permission THEN\n       - Display error message \"Insufficient permissions to edit smilies\"\n       - Abort operation\n     - ENDIF\n\n4. Core Operation Execution:\n   - Load existing smilie data:\n     - Retrieve current smilie information from database\n     - Populate edit form with existing values\n   - Process form submission when user saves changes:\n     - Update smilie code with new value\n     - IF new image is provided THEN\n       - Process image upload:\n         - Generate unique name for image file\n         - Save uploaded file to smilie directory\n         - Update smilie record with new image information\n     - ENDIF\n     - Save updated smilie information to database\n     - Refresh smilie repository cache\n\n5. Response Generation:\n   - IF update operation succeeds THEN\n     - Display success message \"Smilie updated successfully\"\n     - Redirect to smilie listing page\n   - ELSE\n     - Display appropriate error message\n     - Return to edit form with entered values preserved\n   - ENDIF",
    "databaseEntities": [
      "jforum_smilies"
    ],
    "validationRules": [
      "Smilie ID must be a valid integer",
      "Smilie code must not be empty",
      "Image file must be a valid image format if provided",
      "Image file size must be within system limits if provided",
      "User must have permission to edit smilies"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "FileItem": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "description": "Original filename of the uploaded file"
          },
          "contentType": {
            "type": "string",
            "description": "MIME type of the uploaded file"
          },
          "size": {
            "type": "number",
            "description": "Size of the uploaded file in bytes"
          },
          "content": {
            "type": "binary",
            "description": "Binary content of the uploaded file"
          }
        }
      }
    }
  },
  {
    "featureName": "DeleteSmilies",
    "description": "Removes selected smilies from the system including their image files.",
    "inputValues": [
      "id-number-Smilie"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the IDs of smilies to be deleted\n     1.1. Retrieve the list of selected smilie IDs from the user interface\n     1.2. IDs are system-generated numeric identifiers\n     1.3. At least one ID must be selected for deletion\n\n2. Data Validation:\n   - Validate the selected smilie IDs\n     2.1. Verify that each ID represents an existing smilie in the system\n     2.2. Check that the ID is a valid positive integer\n     2.3. IF any ID is invalid or does not exist in the system THEN\n          2.3.1. Generate an error message indicating invalid selection\n          2.3.2. Abort the deletion process\n     2.4. IF no IDs are selected THEN\n          2.4.1. Generate an error message indicating that at least one smilie must be selected\n          2.4.2. Abort the deletion process\n\n3. Business Rule Processing:\n   - Verify system constraints before deletion\n     3.1. Check if any of the selected smilies are currently in use in posts\n     3.2. IF smilies are in use THEN\n          3.2.1. Determine if deletion would impact existing content\n          3.2.2. IF impact is significant THEN\n                 3.2.2.1. Generate a warning message for user confirmation\n                 3.2.2.2. Require explicit confirmation before proceeding\n     3.3. Verify that the user has appropriate permissions to delete smilies\n     3.4. IF user lacks permission THEN\n          3.4.1. Generate an access denied error message\n          3.4.2. Abort the deletion process\n\n4. Core Operation Execution:\n   - Process the deletion of selected smilies\n     4.1. FOR EACH selected smilie ID:\n          4.1.1. Retrieve the complete smilie information including disk name\n          4.1.2. Delete the smilie record from the database\n          4.1.3. Locate the associated image file on the file system\n          4.1.4. IF image file exists THEN\n                 4.1.4.1. Delete the image file from the file system\n                 4.1.4.2. IF file deletion fails THEN\n                          4.1.4.2.1. Log the failure but continue with other deletions\n          4.1.5. IF any database operation fails THEN\n                 4.1.5.1. Log the error\n                 4.1.5.2. Roll back any partial changes if possible\n                 4.1.5.3. Generate an error message\n     4.2. Refresh the system's smilie repository to reflect the changes\n          4.2.1. Clear any cached smilie data\n          4.2.2. Reload smilie information from the database\n\n5. Response Generation:\n   - Provide feedback on the deletion operation\n     5.1. IF all deletions completed successfully THEN\n          5.1.1. Generate a success message indicating the number of smilies deleted\n          5.1.2. Display the updated list of remaining smilies\n     5.2. IF some deletions failed THEN\n          5.2.1. Generate a partial success message indicating which smilies were deleted\n          5.2.2. Include information about which smilies could not be deleted and why\n     5.3. IF all deletions failed THEN\n          5.3.1. Generate an error message with details about the failure\n          5.3.2. Provide suggestions for resolving the issue",
    "databaseEntities": [
      "jforum_smilies"
    ],
    "validationRules": [
      "At least one smilie must be selected for deletion",
      "Selected smilie IDs must exist in the system",
      "User must have administrative permissions to delete smilies",
      "Smilie image files must be located in the configured smilie directory"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Smilie": {
        "id": "number",
        "code": "string",
        "url": "string",
        "diskName": "string"
      }
    }
  },
  {
    "featureName": "SetForumsModerationStatus",
    "description": "Updates moderation status for all forums within a category and their associated topics.",
    "inputValues": [
      "category-object-Category",
      "status-boolean-ModerationStatus"
    ],
    "businessLogic": "1. Input Collection:\n   1.1. Collect the Category object which contains:\n       - Category ID\n       - Current moderation status\n       - List of forums belonging to the category\n   1.2. Collect the boolean status value indicating whether moderation should be enabled or disabled\n\n2. Data Validation:\n   2.1. Validate Category object\n       - Verify the Category object is not null\n       - Ensure the Category ID is valid\n       - Confirm the Category contains a valid list of forums\n       - IF any validation fails, THEN generate appropriate error message and terminate process\n   2.2. Validate status parameter\n       - Ensure the status parameter is a valid boolean value\n       - IF validation fails, THEN generate appropriate error message and terminate process\n\n3. Business Rule Processing:\n   3.1. Check if category moderation status change is necessary\n       - Compare the provided status with the current category moderation status\n       - IF status is the same as current category moderation status, THEN no action is needed\n       - IF status is different, THEN proceed with the update\n   3.2. Verify system permissions\n       - Ensure the current user has administrative privileges to modify moderation settings\n       - IF user lacks required permissions, THEN generate access denied error and terminate process\n\n4. Core Operation Execution:\n   4.1. Update forums moderation status\n       - FOR EACH forum in the category's forum list:\n           - Compare forum's current moderation status with the new category moderation status\n           - IF forum's moderation status is different from the new category status, THEN:\n               - Update the forum's moderation status to match the category's new status\n               - Update all topics within the forum to have the same moderation status\n   4.2. Persist category moderation status\n       - Update the category's moderation status in the system\n       - Save the updated category information\n   4.3. Handle any failures during the update process\n       - IF any forum or topic update fails, THEN:\n           - Log the failure details\n           - Determine whether to continue with remaining updates or roll back\n           - IF critical failure, THEN roll back all changes\n\n5. Response Generation:\n   5.1. Generate success response\n       - Include confirmation that the moderation status was updated\n       - Include the number of forums and topics affected by the change\n       - Include the new moderation status value\n   5.2. Generate error response if needed\n       - Include specific error details if the operation failed\n       - Provide guidance on how to resolve the issue",
    "databaseEntities": [
      "jforum_categories",
      "jforum_forums",
      "jforum_topics"
    ],
    "validationRules": [
      "Category object must not be null",
      "Category ID must be a valid identifier",
      "Category must contain a valid list of forums",
      "Moderation status must be a boolean value",
      "User must have administrative privileges to modify moderation settings"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Category": {
        "type": "object",
        "properties": {
          "id": {
            "type": "number",
            "description": "Unique identifier for the category"
          },
          "isModerated": {
            "type": "boolean",
            "description": "Current moderation status of the category"
          },
          "forums": {
            "type": "array",
            "description": "List of forums belonging to this category",
            "items": {
              "type": "object",
              "properties": {
                "id": {
                  "type": "number",
                  "description": "Unique identifier for the forum"
                },
                "isModerated": {
                  "type": "boolean",
                  "description": "Current moderation status of the forum"
                }
              }
            }
          }
        },
        "required": [
          "id",
          "isModerated",
          "forums"
        ]
      }
    }
  },
  {
    "featureName": "ViewPendingActivations",
    "description": "Shows list of users with pending account activations.",
    "inputValues": [],
    "businessLogic": "1. Input Collection:\n   - No user inputs required for initial display\n   - System will retrieve all users with pending activation status\n\n2. Data Validation:\n   - Verify user has administrative access rights\n   - IF user does not have administrative rights THEN\n     - Display access denied message\n     - Redirect to appropriate error page\n   - ELSE continue processing\n\n3. Business Rule Processing:\n   - Check system configuration for user activation settings\n   - IF user activation feature is disabled in system settings THEN\n     - Display appropriate message indicating feature is not available\n     - Provide link to system settings page\n   - ELSE continue processing\n\n4. Core Operation Execution:\n   - Retrieve all user accounts with pending activation status from database\n   - Sort users by registration date (newest first)\n   - Group users by registration source if applicable\n   - Prepare user data for display including:\n     - Username\n     - Email address\n     - Registration date\n     - Registration IP address\n     - Any additional relevant user information\n   - IF no pending activations exist THEN\n     - Display message indicating no pending activations\n   - ELSE\n     - Display list of users with pending activations\n     - Include checkboxes for selecting users for batch activation\n     - Provide activation button for processing selected users\n\n5. Response Generation:\n   - Display formatted list of pending activation users\n   - Include pagination if number of users exceeds display limit\n   - Provide action buttons for:\n     - Activating selected accounts\n     - Rejecting/deleting selected accounts\n     - Viewing detailed information for specific accounts\n   - Include summary statistics (total pending activations)\n   - Provide refresh option to update the list",
    "databaseEntities": [
      "jforum_users",
      "jforum_user_groups"
    ],
    "validationRules": [
      "User must have administrative privileges to view pending activations",
      "User activation feature must be enabled in system settings",
      "Only users with pending activation status should be displayed in the list"
    ],
    "dbSeedingOperations": [],
    "schema": {}
  },
  {
    "featureName": "ActivateUserAccounts",
    "description": "Activates selected user accounts from the pending activations list.",
    "inputValues": [
      "user_ids-object-UserIdList"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect list of user IDs to be activated (user_ids)\n   - System retrieves current administrator credentials\n   \n2. Data Validation:\n   - Validate administrator has proper permissions to activate accounts\n     - IF administrator lacks activation permissions THEN\n       - Display error message \"Insufficient permissions to activate accounts\"\n       - Terminate process\n     - END IF\n   - Validate user_ids is not empty\n     - IF user_ids list is empty THEN\n       - Display message \"No accounts selected for activation\"\n       - Terminate process\n     - END IF\n   - Validate each user ID exists in the system\n     - FOR EACH user ID in user_ids\n       - Check if user ID exists in the system\n       - IF user ID does not exist THEN\n         - Log invalid user ID\n         - Continue to next user ID\n       - END IF\n     - END FOR\n   - Validate each user account is in pending activation status\n     - FOR EACH valid user ID\n       - Check if user account status is \"pending activation\"\n       - IF account is not in pending status THEN\n         - Log user ID as already activated or in different status\n         - Continue to next user ID\n       - END IF\n     - END FOR\n\n3. Business Rule Processing:\n   - Check system activation settings\n     - IF account activation feature is disabled in system settings THEN\n       - Display error message \"Account activation feature is currently disabled\"\n       - Terminate process\n     - END IF\n   - Check for any system maintenance that would prevent activation\n     - IF system is in maintenance mode THEN\n       - Display error message \"Cannot activate accounts during system maintenance\"\n       - Terminate process\n     - END IF\n   - Verify activation quota is not exceeded\n     - IF daily activation limit is reached THEN\n       - Display warning message \"Daily activation limit reached\"\n       - Prompt for confirmation to proceed\n     - END IF\n\n4. Core Operation Execution:\n   - Begin activation transaction\n     - FOR EACH valid user ID in pending status\n       - Update user account status from \"pending\" to \"active\"\n       - Record activation timestamp\n       - Record administrator who performed activation\n       - Update user permissions based on default group assignments\n       - IF activation fails for a user THEN\n         - Log failure reason\n         - Continue with next user\n       - END IF\n     - END FOR\n   - Send notifications\n     - FOR EACH successfully activated user\n       - Generate activation confirmation notification\n       - Queue notification for delivery to user\n     - END FOR\n   - Commit activation transaction\n   - Update system statistics for activated accounts\n\n5. Response Generation:\n   - Prepare activation summary\n     - Count of successfully activated accounts\n     - Count of accounts that failed activation\n     - List of specific accounts that failed with reasons\n   - Display success message \"X user accounts have been successfully activated\"\n   - Provide option to view pending activations list\n   - Provide option to view newly activated accounts",
    "databaseEntities": [
      "jforum_users",
      "jforum_user_groups",
      "jforum_groups"
    ],
    "validationRules": [
      "Administrator must have activation permissions",
      "At least one user ID must be selected for activation",
      "Selected user accounts must exist in the system",
      "Selected user accounts must be in pending activation status",
      "System activation feature must be enabled",
      "System must not be in maintenance mode"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "UserIdList": {
        "type": "array",
        "items": {
          "type": "integer",
          "description": "User ID to be activated"
        }
      }
    }
  },
  {
    "featureName": "SearchUsersByGroup",
    "description": "Searches and displays users filtered by their group membership.",
    "inputValues": [
      "group_id-number-Group"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the group_id (number) from the user input\n   - The group_id is mandatory to filter users by group membership\n   - If no group_id is provided, the system should default to showing all users\n\n2. Data Validation:\n   - Validate that the group_id is a valid number\n   - Verify that the group_id corresponds to an existing group in the system\n   - IF group_id equals 0, THEN treat as a request to show all users\n   - IF group_id is invalid or does not exist, THEN generate appropriate error message\n\n3. Business Rule Processing:\n   - Verify that the current user has permission to view users by group\n   - Check if the requested group exists in the system\n   - Determine the total number of users in the specified group for pagination purposes\n   - Calculate pagination parameters based on system configuration for users per page\n\n4. Core Operation Execution:\n   - Retrieve the list of users belonging to the specified group\n   - Apply pagination to limit the number of users displayed per page\n   - Sort the user list according to the system's default sorting criteria\n   - Prepare the group information for display in the selection interface\n   - Mark the selected group as active in the interface\n\n5. Response Generation:\n   - Format the user list for display with relevant user information\n   - Include pagination controls if the number of users exceeds the display limit\n   - Provide group selection interface with the current group marked as selected\n   - Display the total number of users found in the group\n   - Provide options for further actions on the displayed users",
    "databaseEntities": [
      "jforum_users",
      "jforum_groups",
      "jforum_user_groups"
    ],
    "validationRules": [
      "Group ID must be a valid number",
      "Group ID must correspond to an existing group in the system",
      "User must have permission to view users by group",
      "Pagination parameters must be valid"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Group": {
        "id": "number",
        "name": "string",
        "description": "string"
      },
      "User": {
        "id": "number",
        "username": "string",
        "email": "string",
        "registrationDate": "date",
        "active": "boolean"
      }
    }
  },
  {
    "featureName": "SearchUsersByUsername",
    "description": "Searches and displays users by matching username pattern.",
    "inputValues": [
      "username-string-User"
    ],
    "businessLogic": "1. Input Collection:\n   1.1. Collect the username search pattern from the user\n       1.1.1. Username pattern is optional\n       1.1.2. If not provided, system will default to listing all users\n\n2. Data Validation:\n   2.1. Validate the username search pattern\n       2.1.1. Check if username pattern is not null\n       2.1.2. Check if username pattern is not empty\n       2.1.3. IF username pattern is null or empty, THEN proceed to list all users\n\n3. Business Rule Processing:\n   3.1. Determine the search type based on input\n       3.1.1. IF username pattern is provided, THEN perform username search\n       3.1.2. IF username pattern is not provided, THEN perform standard user listing\n   3.2. Check user permissions\n       3.2.1. Verify current user has permission to search users\n       3.2.2. IF user does not have permission, THEN display access denied message\n\n4. Core Operation Execution:\n   4.1. Execute the search operation\n       4.1.1. IF username pattern is provided, THEN search for users matching the pattern\n           4.1.1.1. Retrieve all users whose username contains the search pattern\n           4.1.1.2. Sort results alphabetically by username\n       4.1.2. IF username pattern is not provided, THEN retrieve all users with pagination\n           4.1.2.1. Calculate pagination parameters (start position, items per page)\n           4.1.2.2. Retrieve users for the current page\n   4.2. Prepare the result data\n       4.2.1. Format user data for display\n       4.2.2. Include relevant user information (username, registration date, status)\n\n5. Response Generation:\n   5.1. Display search results to the user\n       5.1.1. Show the list of matching users\n       5.1.2. IF no users found, THEN display appropriate message\n       5.1.3. IF listing all users, THEN include pagination controls\n   5.2. Provide options for further actions\n       5.2.1. Allow selection of users for administrative actions\n       5.2.2. Provide option to perform a new search",
    "databaseEntities": [
      "jforum_users",
      "jforum_groups",
      "jforum_user_groups"
    ],
    "validationRules": [
      "Username search pattern must be a valid string",
      "User must have permission to search users",
      "Pagination parameters must be valid integers"
    ],
    "dbSeedingOperations": [],
    "schema": {}
  },
  {
    "featureName": "EditUserProfile",
    "description": "Displays form for editing user profile information and allows users to update their personal details.",
    "inputValues": [
      "userId-number-User",
      "username-string-User",
      "email-string-User",
      "signature-string-User",
      "avatar-string-User",
      "website-string-User",
      "location-string-User",
      "biography-string-User",
      "password-string-User",
      "avatarExternalUrl-boolean-System"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect user identifier (userId) from the request\n   - System retrieves the following user profile information:\n     * Username (mandatory)\n     * Email address (mandatory)\n     * Password (for verification)\n     * Signature (optional)\n     * Avatar image URL (optional)\n     * Website URL (optional)\n     * Location (optional)\n     * Biography/personal information (optional)\n   - System determines if external avatar URLs are allowed based on system configuration\n   - Default values are populated from the user's existing profile data\n\n2. Data Validation:\n   - Validate user access permissions:\n     * Verify the user is logged in\n     * Verify the user is editing their own profile or has administrative rights\n     * If validation fails, redirect to profile view instead of edit mode\n   - For each input field, perform appropriate validation:\n     * Username: Verify it's not empty and does not exceed maximum length\n     * Username: Verify it doesn't contain invalid characters (like < or >)\n     * Email: Verify it's a valid email format\n     * Email: Verify it's not already associated with another account\n     * Password: Verify it meets minimum security requirements if changed\n     * Website: If provided, verify it's a valid URL format\n     * Avatar URL: If external URLs are allowed and one is provided, verify it's a valid image URL\n   - Generate appropriate error messages for any validation failures\n\n3. Business Rule Processing:\n   - Verify the user account exists and is active\n   - Check if the user has permission to edit their profile\n   - Determine which profile fields can be modified based on system configuration\n   - If changing username, verify the new username is not already taken by another user\n   - If changing email, verify the new email is not already associated with another account\n   - Apply any system-wide restrictions on profile content (e.g., prohibited words, content filtering)\n\n4. Core Operation Execution:\n   - Display the user profile edit form with current values pre-populated\n   - When form is submitted:\n     * Validate all input fields according to validation rules\n     * If validation passes, update the user record with the new information\n     * If avatar was changed, update the avatar information\n     * Record the modification timestamp\n   - If any errors occur during the update:\n     * Maintain the entered values in the form\n     * Display appropriate error messages\n     * Allow the user to correct and resubmit\n\n5. Response Generation:\n   - Upon successful update:\n     * Redirect to a confirmation page indicating the profile was updated successfully\n     * Provide option to view the updated profile\n   - If update fails:\n     * Display specific error messages for each validation or processing failure\n     * Maintain the form state with entered values\n     * Provide guidance on how to resolve the issues",
    "databaseEntities": [
      "jforum_users",
      "jforum_sessions"
    ],
    "validationRules": [
      "User must be logged in to edit profile",
      "User can only edit their own profile unless they have administrative rights",
      "Username must not be empty",
      "Username must not exceed maximum allowed length",
      "Username must not contain invalid characters (< or >)",
      "Email must be in valid format",
      "Email must not already be associated with another account",
      "Password must meet minimum security requirements if changed",
      "Website URL must be in valid format if provided",
      "Avatar URL must be in valid format if external URLs are allowed"
    ],
    "dbSeedingOperations": [],
    "schema": {}
  },
  {
    "featureName": "SaveUserProfile",
    "description": "Saves changes to user profile information.",
    "inputValues": [
      "userId-number-User",
      "username-string-User",
      "email-string-User",
      "currentPassword-string-User",
      "newPassword-string-User",
      "avatar-object-Avatar",
      "avatarUrl-string-User",
      "avatarDelete-boolean-User",
      "signature-string-User",
      "website-string-User",
      "location-string-User",
      "biography-string-User",
      "icq-string-User",
      "aim-string-User",
      "msn-string-User",
      "yim-string-User",
      "occupation-string-User",
      "interests-string-User",
      "viewEmailEnabled-boolean-User",
      "viewOnlineEnabled-boolean-User",
      "notifyPrivateMessages-boolean-User",
      "notifyOnMessages-boolean-User",
      "attachSignature-boolean-User",
      "htmlEnabled-boolean-User",
      "language-string-User",
      "bbCodeEnabled-boolean-User",
      "smiliesEnabled-boolean-User",
      "notifyAlways-boolean-User",
      "notifyText-boolean-User",
      "specialRankId-number-Rank"
    ],
    "businessLogic": "1. Input Collection:\n   1.1. Collect user profile information:\n       - userId (mandatory): Numeric identifier of the user\n       - username (optional): String containing user's display name\n       - email (optional): String containing user's email address\n       - currentPassword (optional): String containing user's current password\n       - newPassword (optional): String containing user's new password\n       - avatar (optional): Object containing avatar image file\n       - avatarUrl (optional): String containing URL to external avatar image\n       - avatarDelete (optional): Boolean indicating if avatar should be deleted\n       - signature (optional): String containing user's forum signature\n       - website (optional): String containing user's website URL\n       - location (optional): String containing user's geographical location\n       - biography (optional): String containing user's personal information\n       - icq (optional): String containing user's ICQ identifier\n       - aim (optional): String containing user's AIM identifier\n       - msn (optional): String containing user's MSN identifier\n       - yim (optional): String containing user's Yahoo Messenger identifier\n       - occupation (optional): String containing user's occupation\n       - interests (optional): String containing user's interests\n       - viewEmailEnabled (optional): Boolean indicating if email is visible to others\n       - viewOnlineEnabled (optional): Boolean indicating if online status is visible\n       - notifyPrivateMessages (optional): Boolean for private message notifications\n       - notifyOnMessages (optional): Boolean for message reply notifications\n       - attachSignature (optional): Boolean for attaching signature to posts\n       - htmlEnabled (optional): Boolean for allowing HTML in posts\n       - language (optional): String containing user's preferred language\n       - bbCodeEnabled (optional): Boolean for enabling BBCode in posts\n       - smiliesEnabled (optional): Boolean for enabling smilies in posts\n       - notifyAlways (optional): Boolean for always receiving notifications\n       - notifyText (optional): Boolean for receiving text notifications\n       - specialRankId (optional): Numeric identifier for special rank assignment\n\n2. Data Validation:\n   2.1. Validate userId:\n       - Verify userId is a positive integer\n       - Verify userId corresponds to an existing user in the system\n       - Verify current user has permission to edit this profile\n       - IF userId is invalid or not found, THEN generate error message \"Invalid user identifier\"\n       - IF current user lacks permission, THEN generate error message \"Insufficient permissions\"\n   2.2. Validate username (if provided and user is admin):\n       - Verify username is not empty\n       - Verify username meets minimum and maximum length requirements\n       - Verify username contains only allowed characters\n       - Verify username does not contain HTML tags\n       - IF username validation fails, THEN generate appropriate error message\n   2.3. Validate email address (if provided):\n       - Verify email is not empty\n       - Verify email follows standard email format (contains @ and domain)\n       - Verify email domain appears valid\n       - IF email validation fails, THEN generate error message \"Invalid email format\"\n   2.4. Validate password information (if provided):\n       - IF new password is provided, THEN verify current password is also provided\n       - Verify current password matches the stored password for the user\n       - Verify new password meets security requirements\n       - IF password validation fails, THEN generate error message \"Current password is invalid\"\n   2.5. Validate avatar (if provided):\n       - IF avatar file is uploaded, THEN verify file type is supported (JPG, JPEG, GIF, PNG)\n       - Verify avatar dimensions do not exceed maximum allowed size\n       - IF external avatar URL is provided, THEN verify URL format is valid and starts with \"http://\"\n       - IF avatar validation fails, THEN generate appropriate error message\n   2.6. Validate signature (if provided):\n       - Verify signature does not exceed maximum allowed length\n       - Verify signature does not contain disallowed content\n       - IF signature validation fails, THEN generate error message\n   2.7. Validate website URL (if provided):\n       - Verify URL format is valid\n       - Ensure URL starts with \"http://\"\n       - IF website validation fails, THEN generate error message\n   2.8. Validate special rank (if provided and user is admin):\n       - Verify specialRankId exists in the system\n       - Verify user is eligible for the specified rank\n       - IF rank validation fails, THEN generate error message\n\n3. Business Rule Processing:\n   3.1. Check user account status:\n       - Verify user account is active and not deleted\n       - Verify user has permission to update their profile\n       - Verify current user is the same as the profile being edited or has admin rights\n       - IF user account is inactive or deleted, THEN generate error message \"Account is inactive or deleted\"\n       - IF user lacks permission, THEN generate error message \"Insufficient permissions\"\n   3.2. Check for duplicate information:\n       - IF username is changed, THEN verify new username is not already taken\n       - IF email is changed, THEN verify new email is not already registered\n       - IF duplicates found, THEN generate error message \"Username or email already in use\"\n   3.3. Check content policy compliance:\n       - Verify signature, biography, and other user-provided content comply with system policies\n       - Sanitize all text inputs to prevent security issues\n       - IF content violates policies, THEN generate error message \"Content violates system policies\"\n   3.4. Determine if email verification is required:\n       - IF email address has changed, THEN determine if verification is required\n       - IF verification required, THEN prepare verification process\n   3.5. Check avatar processing requirements:\n       - IF avatar file is uploaded, THEN verify system can process the image type\n       - IF external avatar URL is provided, THEN verify system allows external URLs\n       - IF avatar deletion is requested, THEN verify avatar file exists\n       - IF any avatar requirements fail, THEN generate appropriate error message\n\n4. Core Operation Execution:\n   4.1. Prepare user data for update:\n       - Retrieve user object with current values based on userId\n       - Update user object with new values from input\n       - Sanitize all text inputs to prevent security issues\n   4.2. Process password changes:\n       - IF new password is provided AND current password is valid, THEN\n           - Encrypt the new password\n           - Update the user's password in the system\n       - ELSE IF new password is provided but current password is invalid, THEN\n           - Add error to the list of errors\n           - Continue processing other fields\n   4.3. Process avatar changes:\n       - IF avatar deletion is requested, THEN\n           - Locate and delete the avatar file from the system\n           - Set user's avatar field to null\n       - ELSE IF avatar file is uploaded, THEN\n           - Generate unique filename for the avatar\n           - Process and resize avatar to meet system requirements\n           - Save the processed avatar file\n           - Update user's avatar field with new filename\n       - ELSE IF external avatar URL is provided AND external URLs are allowed, THEN\n           - Verify the image at the URL exists and meets size requirements\n           - Update user's avatar field with the URL\n       - IF any avatar processing fails, THEN add error to the list but continue with other updates\n   4.4. Update user profile in the system:\n       - Save all updated user information to the database\n       - Update any related user settings or preferences\n       - Update special rank assignment if changed and user is admin\n       - IF any database operation fails, THEN rollback all changes and generate error message\n   4.5. Process security implications:\n       - IF username changed, THEN update references in the system\n       - Clear any cached user information in the system\n       - Update session information if necessary\n       - IF current user's language preference changed, THEN update session language\n\n5. Response Generation:\n   5.1. Generate success response:\n       - IF no errors occurred, THEN\n           - Prepare confirmation message \"User profile successfully updated\"\n           - Include summary of changes made\n           - Redirect user to confirmation page or updated profile view\n   5.2. Handle error responses:\n       - IF any errors occurred, THEN\n           - Provide detailed error messages for each validation or processing failure\n           - Include guidance on how to correct the errors\n           - Preserve valid input values for resubmission\n           - Return user to the edit form with errors highlighted\n   5.3. Provide next steps:\n       - Suggest related actions (view updated profile, etc.)\n       - IF email verification is pending, THEN provide instructions",
    "databaseEntities": [
      "jforum_users",
      "jforum_groups",
      "jforum_user_groups",
      "jforum_sessions",
      "jforum_ranks"
    ],
    "validationRules": [
      "User ID must be a positive integer",
      "Username must not be empty",
      "Username must be unique in the system",
      "Username must not contain HTML tags",
      "Username must not exceed maximum length",
      "Email must be in valid format",
      "Email must be unique in the system",
      "Current password must match stored password when changing email or password",
      "New password must meet security requirements",
      "Avatar file must be of supported type (JPG, JPEG, GIF, PNG)",
      "Avatar dimensions must not exceed maximum allowed size",
      "External avatar URL must start with http:// if provided",
      "Signature must not exceed maximum allowed length",
      "Website URL must start with http:// if provided",
      "Special rank must exist in the system if specified",
      "User account must be active",
      "User can only edit their own profile unless they have administrative privileges"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Avatar": {
        "type": "object",
        "properties": {
          "fileItem": {
            "type": "object",
            "description": "File upload item containing avatar image data"
          },
          "fileName": {
            "type": "string",
            "description": "Original filename of the uploaded avatar"
          },
          "fileSize": {
            "type": "number",
            "description": "Size of the uploaded avatar file in bytes"
          },
          "contentType": {
            "type": "string",
            "description": "MIME type of the uploaded avatar file"
          }
        }
      }
    }
  },
  {
    "featureName": "DeleteOrUndeleteUsers",
    "description": "Deletes or undeletes selected users based on their current status.",
    "inputValues": [
      "user_ids-object-UserIds"
    ],
    "businessLogic": "1. Input Collection\n   - Collect the following inputs:\n     1.1. user_ids (mandatory): List of user identifiers to be processed\n\n2. Data Validation\n   - Validate the provided inputs:\n     2.1. Verify user_ids is not empty\n       IF user_ids is empty THEN\n         Display error message: \"No users selected for operation\"\n         Exit process\n     2.2. Verify each user ID is valid\n       FOR EACH user_id in user_ids\n         IF user_id is not a valid identifier THEN\n           Display error message: \"Invalid user identifier detected\"\n           Exit process\n\n3. Business Rule Processing\n   - Verify system constraints before proceeding:\n     3.1. Check user permissions\n       IF current user does not have administrative privileges THEN\n         Display error message: \"Insufficient permissions to modify user accounts\"\n         Exit process\n     3.2. Verify users can be modified\n       FOR EACH user_id in user_ids\n         IF user is a system account or protected account THEN\n           Display error message: \"Cannot modify system or protected accounts\"\n           Exit process\n\n4. Core Operation Execution\n   - Process each user account:\n     4.1. Retrieve current status for each user\n       FOR EACH user_id in user_ids\n         Retrieve user's current deletion status\n     4.2. Toggle deletion status based on current state\n       FOR EACH user in retrieved users\n         IF user is currently deleted THEN\n           4.2.1. Undelete the user\n             - Mark user as active in the system\n             - Restore user's access to the system\n         ELSE\n           4.2.2. Delete the user\n             - Check if user is currently logged in\n               IF user is in active session THEN\n                 - Terminate user's active session\n             - Mark user as deleted in the system\n             - Revoke user's access to the system\n     4.3. Update user records\n       - Save changes to user records\n       - Update any related security information\n\n5. Response Generation\n   - Generate appropriate response:\n     5.1. Prepare success message\n       - Count number of users deleted and undeleted\n       - Create summary message with operation results\n     5.2. Return to user listing view\n       - Display updated list of users with current status\n       - Show confirmation message of successful operation",
    "databaseEntities": [
      "jforum_users",
      "jforum_sessions",
      "jforum_user_groups"
    ],
    "validationRules": [
      "User IDs must be provided for deletion/undeletion",
      "Current user must have administrative privileges",
      "System accounts cannot be deleted",
      "Each user ID must exist in the system"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "UserIds": {
        "type": "array",
        "items": {
          "type": "integer",
          "description": "Unique identifier for a user account"
        }
      }
    }
  },
  {
    "featureName": "ManageUserGroups",
    "description": "Displays and manages group associations for a specific user.",
    "inputValues": [
      "userId-number-User"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect userId (mandatory) to identify the user whose groups will be managed\n   - System will retrieve user information based on userId\n   - System will retrieve available groups from the system\n\n2. Data Validation:\n   - Validate userId:\n     a. Verify userId is a valid number\n     b. Verify userId exists in the system\n     c. IF userId is invalid or not found, THEN display appropriate error message\n\n3. Business Rule Processing:\n   - Verify current user has permission to manage user groups\n   - IF current user lacks permission, THEN display access denied message\n   - Retrieve all available groups in the system\n   - Retrieve groups currently associated with the specified user\n   - Create a list of selected groups for the user\n\n4. Core Operation Execution:\n   - Display User Information:\n     a. Show user details (username, etc.)\n     b. Display title indicating group management for specific user\n   - Display Group Management Interface:\n     a. Show list of all available groups in the system\n     b. Mark groups that are already associated with the user as selected\n     c. Provide interface for adding/removing group associations\n   - Process Group Association Changes:\n     a. IF save action is triggered:\n       i. Collect all selected groups from the interface\n       ii. Remove user from all previous group associations\n       iii. Add user to newly selected groups\n       iv. Clear any cached security permissions for the user\n\n5. Response Generation:\n   - IF operation is successful:\n     a. Display confirmation message\n     b. Return to user list or user management screen\n   - IF operation fails:\n     a. Display appropriate error message\n     b. Maintain current group selections\n     c. Allow user to retry the operation",
    "databaseEntities": [
      "jforum_users",
      "jforum_groups",
      "jforum_user_groups"
    ],
    "validationRules": [
      "User ID must be a valid number",
      "User ID must exist in the system",
      "Current user must have permission to manage user groups",
      "At least one group should be selected for the user"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "User": {
        "id": "number",
        "username": "string",
        "groupsList": "array"
      },
      "Group": {
        "id": "number",
        "name": "string",
        "description": "string"
      }
    }
  },
  {
    "featureName": "SaveUserGroupAssignments",
    "description": "Updates group memberships for a specific user.",
    "inputValues": [
      "userId-number-User",
      "selectedGroups-object-GroupSelection"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the following inputs:\n     a. userId (mandatory): Numeric identifier of the user\n     b. selectedGroups (mandatory): Collection of group identifiers the user should belong to\n     c. System retrieves current user information based on userId\n     d. System retrieves all available groups in the system\n\n2. Data Validation:\n   - Validate user identifier:\n     a. Check if userId is provided\n     b. Verify userId is a positive integer\n     c. IF validation fails, THEN display error message indicating invalid user identifier\n   - Validate selected groups:\n     a. Verify that selectedGroups is properly formatted\n     b. Ensure all group identifiers are valid positive integers\n     c. Confirm all selected groups exist in the system\n     d. IF validation fails, THEN display error message indicating invalid group selection\n\n3. Business Rule Processing:\n   - Check user existence:\n     a. Verify the user with the provided userId exists in the system\n     b. IF user does not exist, THEN display error message indicating user not found\n   - Check user modification permissions:\n     a. Verify current administrator has permission to modify user group assignments\n     b. IF permission check fails, THEN display error message indicating insufficient privileges\n   - Check for required group assignments:\n     a. Determine if the system requires users to belong to at least one group\n     b. IF required and no groups are selected, THEN display error message indicating at least one group must be selected\n\n4. Core Operation Execution:\n   - Retrieve current group memberships:\n     a. Get all groups the user currently belongs to\n     b. Create a list of current group identifiers for comparison\n   - Remove user from all current groups:\n     a. Generate a list of all group identifiers in the system\n     b. Remove the user from all groups to prepare for new assignments\n   - Assign user to selected groups:\n     a. For each selected group identifier:\n        i. Add the user to the group\n        ii. Update group membership records\n   - Update security context:\n     a. Clear any cached security information for the user\n     b. Force security information to be recalculated on next user action\n\n5. Response Generation:\n   - Success response:\n     a. Generate confirmation message indicating successful group assignment update\n     b. Include summary of updated group memberships\n     c. Provide navigation options to view user details or return to user list\n   - Error response:\n     a. Display specific error message based on the failure point\n     b. Maintain form state to allow corrections\n     c. Provide guidance on how to resolve the issue",
    "databaseEntities": [
      "jforum_users",
      "jforum_groups",
      "jforum_user_groups"
    ],
    "validationRules": [
      "User ID must be a valid positive integer",
      "User must exist in the system",
      "Selected groups must be valid group identifiers",
      "Administrator must have permission to modify user group assignments"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "GroupSelection": {
        "type": "array",
        "items": {
          "type": "number",
          "description": "Group identifier"
        }
      }
    }
  },
  {
    "featureName": "SendTestMail",
    "description": "Sends a test email with configurable SMTP settings and restores original configuration.",
    "inputValues": [
      "sender-string-EmailAddress",
      "host-string-SmtpServer",
      "port-string-SmtpPort",
      "auth-string-AuthenticationFlag",
      "ssl-string-SslFlag",
      "username-string-SmtpUsername",
      "password-string-SmtpPassword",
      "to-string-RecipientEmail"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the following required inputs:\n     a. sender: Email address to be used as the sender\n     b. host: SMTP server hostname or IP address\n     c. port: SMTP server port number\n     d. auth: Authentication flag (yes/no)\n     e. ssl: SSL connection flag (yes/no)\n     f. username: SMTP server username (required if auth is yes)\n     g. password: SMTP server password (required if auth is yes)\n     h. to: Recipient email address\n\n2. Data Validation:\n   - Validate sender email address:\n     a. Check if sender email is properly formatted\n     b. Verify sender email is not empty\n     c. IF validation fails, THEN return error message\n   - Validate SMTP host:\n     a. Check if host is not empty\n     b. IF validation fails, THEN return error message\n   - Validate port number:\n     a. Check if port is a valid numeric value\n     b. Verify port is within valid range (1-65535)\n     c. IF validation fails, THEN return error message\n   - Validate authentication parameters:\n     a. IF auth flag is set to yes, THEN:\n        i. Verify username is not empty\n        ii. Verify password is not empty\n        iii. IF either is empty, THEN return error message\n   - Validate recipient email address:\n     a. Check if recipient email is properly formatted\n     b. Verify recipient email is not empty\n     c. IF validation fails, THEN return error message\n\n3. Business Rule Processing:\n   - Check system state:\n     a. Verify email functionality is enabled in the system\n     b. IF email functionality is disabled, THEN return error message\n   - Prepare for configuration change:\n     a. Store current system email configuration values\n     b. Prepare rollback mechanism in case of failure\n\n4. Core Operation Execution:\n   - Apply temporary email configuration:\n     a. Set SMTP host to provided host value\n     b. Set SMTP authentication flag to provided auth value\n     c. Set SMTP username to provided username value\n     d. Set SMTP password to provided password value\n     e. Set email sender to provided sender value\n     f. Set SMTP SSL flag to provided ssl value\n     g. Set SMTP port to provided port value\n   - Prepare test email:\n     a. Create email with subject \"JForum Test Mail\"\n     b. Set email body to include current timestamp\n     c. Set recipient to provided email address\n   - Send test email:\n     a. Attempt to send the email using configured settings\n     b. IF sending fails, THEN capture detailed error information\n     c. IF sending succeeds, THEN prepare success message\n   - Restore original configuration:\n     a. Reset SMTP host to original value\n     b. Reset SMTP authentication flag to original value\n     c. Reset SMTP username to original value\n     d. Reset SMTP password to original value\n     e. Reset email sender to original value\n     f. Reset SMTP SSL flag to original value\n     g. Reset SMTP port to original value\n\n5. Response Generation:\n   - Prepare response:\n     a. IF email was sent successfully, THEN:\n        i. Set status message to \"OK\"\n     b. IF email sending failed, THEN:\n        i. Set status message to error details\n        ii. Include troubleshooting information\n   - Return response:\n     a. Include status message\n     b. Include timestamp of operation",
    "databaseEntities": [
      "jforum_users"
    ],
    "validationRules": [
      "Sender email must be a valid email address format",
      "SMTP host cannot be empty",
      "Port must be a valid number between 1 and 65535",
      "If authentication is enabled, username and password must be provided",
      "Recipient email must be a valid email address format",
      "Email functionality must be enabled in the system"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "EmailAddress": {
        "type": "string",
        "format": "email",
        "description": "A valid email address"
      },
      "SmtpServer": {
        "type": "string",
        "description": "SMTP server hostname or IP address"
      },
      "SmtpPort": {
        "type": "string",
        "pattern": "^[0-9]{1,5}$",
        "description": "SMTP server port number"
      },
      "AuthenticationFlag": {
        "type": "string",
        "enum": [
          "yes",
          "no"
        ],
        "description": "Flag indicating if SMTP authentication is required"
      },
      "SslFlag": {
        "type": "string",
        "enum": [
          "yes",
          "no"
        ],
        "description": "Flag indicating if SSL connection should be used"
      },
      "SmtpUsername": {
        "type": "string",
        "description": "Username for SMTP authentication"
      },
      "SmtpPassword": {
        "type": "string",
        "description": "Password for SMTP authentication"
      },
      "RecipientEmail": {
        "type": "string",
        "format": "email",
        "description": "Email address of the recipient"
      }
    }
  },
  {
    "featureName": "IsPostIndexed",
    "description": "Checks if a forum post is indexed in the search engine.",
    "inputValues": [
      "postId-number-Post"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the post ID (mandatory) from the user request\n   - System will use this ID to query the search index\n\n2. Data Validation:\n   - Validate that post ID is provided\n     - IF post ID is missing or invalid (not a positive integer)\n       - THEN return an error message indicating invalid post ID\n     - ELSE continue to the next step\n\n3. Business Rule Processing:\n   - Check if the user has permission to view post indexing status\n     - IF user lacks required permissions\n       - THEN return an access denied message\n       - EXIT process\n     - ELSE continue to next step\n   - Verify that the search functionality is enabled in the system\n     - IF search functionality is disabled\n       - THEN return a message indicating search is not available\n       - EXIT process\n     - ELSE continue to next step\n\n4. Core Operation Execution:\n   - Access the search index manager\n   - Query the search index for the document matching the provided post ID\n     - IF an error occurs during the search operation\n       - THEN log the error details\n       - Return an error message indicating search operation failed\n       - EXIT process\n     - ELSE continue to next step\n\n5. Response Generation:\n   - Prepare the response based on the search results\n     - IF the post is found in the search index\n       - THEN include the document information in the response\n       - Set indexing status as \"Indexed\"\n     - ELSE\n       - Set indexing status as \"Not Indexed\"\n   - Return the response with the indexing status and any relevant document information\n   - Include timestamp of when the check was performed",
    "databaseEntities": [
      "jforum_posts"
    ],
    "validationRules": [
      "Post ID must be a positive integer",
      "User must have permission to view post indexing status",
      "Search functionality must be enabled in the system"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Post": {
        "id": "number",
        "topicId": "number",
        "userId": "number",
        "text": "string",
        "subject": "string",
        "htmlEnabled": "boolean",
        "bbCodeEnabled": "boolean",
        "smiliesEnabled": "boolean"
      }
    }
  },
  {
    "featureName": "LoadPostContents",
    "description": "Retrieves and displays the content of a specific forum post.",
    "inputValues": [
      "id-number-Post"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect post ID (id) from the request\n   - Validate that post ID is a positive integer\n   - Mark post ID as mandatory\n\n2. Data Validation:\n   - Validate post ID format:\n     - Ensure post ID is a valid number\n     - Verify post ID is greater than zero\n   - IF validation fails, THEN:\n     - Generate appropriate error message\n     - Return error response\n\n3. Business Rule Processing:\n   - Check system state:\n     - Verify the forum system is operational\n     - Confirm post retrieval functionality is available\n   - Check user permissions:\n     - Verify if the current user has permission to view the requested post\n     - IF user lacks permission, THEN:\n       - Generate access denied error\n       - Return error response\n\n4. Core Operation Execution:\n   - Retrieve post data:\n     - Locate post record using the provided post ID\n     - IF post not found, THEN:\n       - Generate post not found error\n       - Return error response\n     - Extract post content and metadata\n   - Prepare post for display:\n     - Format post content according to system settings\n     - Process any special formatting (HTML, BBCode, etc.)\n     - Prepare user information associated with the post\n\n5. Response Generation:\n   - Construct success response:\n     - Include formatted post content\n     - Include post metadata (author, date, etc.)\n     - Include any relevant user information\n   - Return formatted post data to the user interface\n   - IF any errors occurred during processing, THEN:\n     - Generate appropriate error response\n     - Include error details and possible resolution steps",
    "databaseEntities": [
      "jforum_posts",
      "jforum_posts_text",
      "jforum_users"
    ],
    "validationRules": [
      "Post ID must be a valid positive integer",
      "Post must exist in the system",
      "User must have permission to view the post",
      "Post content must be properly formatted for display"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Post": {
        "id": "number",
        "userId": "number",
        "topicId": "number",
        "text": "string",
        "subject": "string",
        "htmlEnabled": "boolean",
        "bbCodeEnabled": "boolean",
        "smiliesEnabled": "boolean",
        "postDate": "date"
      }
    }
  },
  {
    "featureName": "SavePost",
    "description": "Updates a forum post's content with moderation logging and search index updates.",
    "inputValues": [
      "id-number-Post",
      "value-string-Post",
      "originalMessage-string-Post"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect post ID (mandatory, system-generated)\n   - Collect new post content (mandatory, user-provided)\n   - Retrieve current user session information (system-generated)\n\n2. Data Validation:\n   - Validate post ID:\n     * Ensure post ID is a valid number\n     * Verify post exists in the system\n     * IF post does not exist, THEN return error message\n   - Validate post content:\n     * Ensure content is not empty\n     * Check content length against system limits\n     * IF content exceeds limits, THEN return error message\n   - Validate user permissions:\n     * Check if current user has permission to edit the post\n     * IF user is not the post owner, THEN check if user has moderation privileges\n     * IF user has neither ownership nor moderation rights, THEN return permission denied error\n\n3. Business Rule Processing:\n   - Retrieve original post from database:\n     * Store original message content for comparison and logging purposes\n     * Check post status (locked, deleted, etc.)\n     * IF post is locked or deleted, THEN return appropriate error message\n   - Apply content formatting rules:\n     * Process HTML formatting if enabled for the post\n     * Apply safety filters to prevent malicious content\n     * Process BBCode if enabled for the post\n     * Process emoticons if enabled for the post\n\n4. Core Operation Execution:\n   - Update post content in database:\n     * Save new content to post record\n     * Update modification timestamp\n     * IF update fails, THEN rollback and return error message\n   - Handle moderation logging:\n     * IF user is a moderator AND not the post owner, THEN:\n       * Create moderation log entry\n       * Include original and new content in log\n       * Record moderator ID, timestamp, and action type\n   - Update search index:\n     * Remove old post content from search index\n     * Add updated content to search index\n     * IF indexing fails, log error but continue process\n   - Update post cache:\n     * IF post caching is enabled, THEN update post in cache\n     * Prepare post for display with proper formatting\n\n5. Response Generation:\n   - Prepare success response:\n     * Format updated post for display\n     * Include all post metadata (author, timestamp, etc.)\n     * Apply display formatting (HTML, BBCode, emoticons)\n   - Return formatted post content:\n     * Include post ID and topic ID for reference\n     * Include status confirmation message\n     * Return complete formatted post for display",
    "databaseEntities": [
      "jforum_posts",
      "jforum_posts_text",
      "jforum_users",
      "jforum_topics"
    ],
    "validationRules": [
      "Post ID must be a valid number",
      "Post must exist in the system",
      "Post content cannot be empty",
      "User must have permission to edit the post",
      "Post must not be locked or deleted",
      "Content must comply with system formatting rules"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Post": {
        "id": "number",
        "topicId": "number",
        "userId": "number",
        "text": "string",
        "subject": "string",
        "htmlEnabled": "boolean",
        "bbCodeEnabled": "boolean",
        "smiliesEnabled": "boolean"
      },
      "ModerationLog": {
        "id": "number",
        "userId": "number",
        "postId": "number",
        "topicId": "number",
        "originalMessage": "string",
        "timestamp": "date"
      }
    }
  },
  {
    "featureName": "PreviewPost",
    "description": "Generates a preview of a forum post with HTML safety, BBCode, and smilies processing.",
    "inputValues": [
      "text-string-Post",
      "subject-string-Post",
      "html-boolean-Post",
      "bbcode-boolean-Post",
      "smilies-boolean-Post"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the following inputs from the user:\n     a. Post text (mandatory): The main content of the post\n     b. Post subject (mandatory): The title or subject of the post\n     c. HTML enabled flag (optional): Whether HTML formatting is allowed in the post\n     d. BBCode enabled flag (optional): Whether BBCode formatting is allowed in the post\n     e. Smilies enabled flag (optional): Whether emoticon conversion is allowed in the post\n\n2. Data Validation:\n   - Validate post text:\n     a. Check if post text is not empty\n     b. Check if post text length is within allowed limits\n     c. IF validation fails, THEN return appropriate error message\n   - Validate post subject:\n     a. Check if subject is not empty\n     b. Check if subject length is within allowed limits\n     c. IF validation fails, THEN return appropriate error message\n   - Validate formatting flags:\n     a. Ensure HTML, BBCode, and Smilies flags are valid boolean values\n     b. IF any flag is invalid, THEN use system default values\n\n3. Business Rule Processing:\n   - Check user permissions:\n     a. Verify if the user has permission to use HTML in posts\n     b. IF HTML is enabled but user lacks permission, THEN disable HTML formatting\n   - Process content safety rules:\n     a. IF HTML is enabled, THEN apply HTML safety filtering to prevent XSS attacks\n     b. Check for forbidden words or content based on forum rules\n     c. IF forbidden content is found, THEN mark content for moderation or rejection\n\n4. Core Operation Execution:\n   - Create a temporary post object with the provided inputs\n   - Process the post content based on enabled formatting options:\n     a. IF HTML is enabled, THEN apply HTML safety filtering to the text\n     b. IF BBCode is enabled, THEN convert BBCode tags to their HTML equivalents\n     c. IF Smilies are enabled, THEN convert emoticon codes to their graphical representations\n   - Format the post for display:\n     a. Apply any additional formatting required for preview display\n     b. Escape special characters in the subject to prevent script injection\n     c. Escape special characters in the processed text to prevent script injection\n\n5. Response Generation:\n   - Generate a preview response containing:\n     a. The formatted post subject\n     b. The formatted post content with all applied formatting\n     c. Any system messages or warnings about the content\n   - Return the preview to the user interface for display\n   - Indicate that this is a preview only and not a saved post",
    "databaseEntities": [
      "jforum_posts",
      "jforum_posts_text",
      "jforum_smilies"
    ],
    "validationRules": [
      "Post text must not be empty",
      "Post subject must not be empty",
      "Post text length must be within allowed limits",
      "Post subject length must be within allowed limits",
      "HTML content must be sanitized if HTML formatting is enabled",
      "Formatting flags (HTML, BBCode, Smilies) must be valid boolean values"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Post": {
        "text": "string",
        "subject": "string",
        "htmlEnabled": "boolean",
        "bbCodeEnabled": "boolean",
        "smiliesEnabled": "boolean"
      }
    }
  },
  {
    "featureName": "BannerRedirectTracking",
    "description": "Tracks banner clicks and redirects users to the banner's target URL.",
    "inputValues": [
      "bannerId-number-Banner"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect bannerId (mandatory) from user interaction\n   - System will use this identifier to locate the correct banner record\n\n2. Data Validation:\n   - Validate bannerId:\n     a. Check if bannerId is provided\n     b. Verify bannerId is a valid numeric value\n     c. Return error if validation fails\n\n3. Business Rule Processing:\n   - Check banner display eligibility:\n     a. Verify if the banner with the provided ID exists in the system\n     b. Check if the banner is currently active\n     c. Verify if the banner is eligible for display based on system rules\n     d. IF banner is not eligible for display:\n        i. Return to default page without redirection\n        ii. End process\n\n4. Core Operation Execution:\n   - Retrieve banner information:\n     a. Fetch the banner record using the provided bannerId\n     b. Extract the target URL from the banner record\n     c. Extract current click count from the banner record\n   - Update banner statistics:\n     a. Increment the click count for the banner by 1\n     b. Update the banner record with the new click count\n     c. Save the updated information to maintain accurate metrics\n   - Prepare redirection:\n     a. Set the redirection target to the banner's URL\n     b. Ensure all banner data updates are completed before redirection\n\n5. Response Generation:\n   - Success scenario:\n     a. Redirect the user to the banner's target URL\n     b. Complete the tracking process in the background\n   - Error scenario:\n     a. If any error occurs during processing, redirect to default page\n     b. Log the error details for system administrators",
    "databaseEntities": [
      "Banner"
    ],
    "validationRules": [
      "Banner ID must be a valid number",
      "Banner must exist in the system",
      "Banner must be eligible for display",
      "Banner must have a valid target URL"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Banner": {
        "id": "number",
        "url": "string",
        "clicks": "number",
        "active": "boolean",
        "displayConditions": "object"
      }
    }
  },
  {
    "featureName": "InsertBookmark",
    "description": "Creates a new bookmark based on relation type (forum, topic, or user).",
    "inputValues": [
      "relation_type-number-Bookmark",
      "relation_id-number-Bookmark",
      "title-string-Bookmark",
      "description-string-Bookmark",
      "visible-boolean-Bookmark"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the following inputs:\n     a. relation_type (mandatory): Numeric identifier for the bookmark type (forum, topic, or user)\n     b. relation_id (mandatory): Numeric identifier of the entity to bookmark\n     c. title (optional): Custom title for the bookmark\n     d. description (optional): Custom description for the bookmark\n     e. visible (optional): Boolean flag indicating if the bookmark is publicly visible\n\n2. Data Validation:\n   - Validate relation_type:\n     a. IF relation_type is not provided or invalid, THEN generate error message \"Invalid bookmark type\"\n     b. IF relation_type is not one of the allowed values (forum, topic, user), THEN generate error message \"Invalid bookmark type\"\n   - Validate relation_id:\n     a. IF relation_id is not provided, THEN generate error message \"Missing entity identifier\"\n     b. IF relation_id is not a positive integer, THEN generate error message \"Invalid entity identifier\"\n   - Validate title:\n     a. IF title is provided and exceeds maximum length, THEN truncate or generate error message\n     b. Sanitize title input to prevent security issues\n   - Validate description:\n     a. IF description is provided and exceeds maximum length, THEN truncate or generate error message\n     b. Sanitize description input to prevent security issues\n\n3. Business Rule Processing:\n   - Check user authentication:\n     a. IF user is not logged in, THEN generate error message \"Anonymous users cannot create bookmarks\"\n   - Check feature availability:\n     a. IF bookmarks feature is disabled, THEN generate error message \"Bookmark feature is disabled\"\n   - Check entity existence based on relation_type:\n     a. IF relation_type is forum:\n        i. Check if forum with relation_id exists\n        ii. IF forum does not exist, THEN generate error message \"Forum not found\"\n     b. IF relation_type is topic:\n        i. Check if topic with relation_id exists\n        ii. IF topic does not exist, THEN generate error message \"Topic not found\"\n     c. IF relation_type is user:\n        i. Check if user with relation_id exists\n        ii. IF user does not exist, THEN generate error message \"User not found\"\n   - Check for existing bookmark:\n     a. Search for existing bookmark with same relation_type, relation_id, and user_id\n     b. IF bookmark exists, THEN prepare for update instead of insert\n\n4. Core Operation Execution:\n   - Prepare bookmark data:\n     a. IF relation_type is forum:\n        i. IF no custom title provided, THEN use forum name as default title\n        ii. IF no custom description provided, THEN use forum description as default\n     b. IF relation_type is topic:\n        i. IF no custom title provided, THEN use topic title as default title\n     c. IF relation_type is user:\n        i. IF no custom title provided, THEN use username as default title\n   - Create bookmark record:\n     a. Set bookmark title to provided or default title\n     b. Set bookmark description to provided or default description\n     c. Set public visibility flag based on visible input\n     d. Set relation_id to the provided entity identifier\n     e. Set relation_type to the provided type identifier\n     f. Set user_id to current user's identifier\n   - Save bookmark:\n     a. IF existing bookmark found, THEN update existing record\n     b. ELSE create new bookmark record\n     c. IF save operation fails, THEN generate error message \"Failed to save bookmark\"\n\n5. Response Generation:\n   - Success response:\n     a. Generate confirmation message \"Bookmark successfully created\"\n     b. Provide bookmark details including title and type\n     c. Offer navigation options to view all bookmarks\n   - Error response:\n     a. Display specific error message from validation or processing steps\n     b. Provide guidance on how to correct the issue\n     c. Offer option to retry or cancel operation",
    "databaseEntities": [
      "jforum_bookmarks",
      "jforum_forums",
      "jforum_topics",
      "jforum_users"
    ],
    "validationRules": [
      "Relation type must be one of the valid types (forum, topic, or user)",
      "Relation ID must be a valid positive integer",
      "User must be authenticated to create bookmarks",
      "Bookmarks feature must be enabled",
      "Referenced entity (forum, topic, or user) must exist",
      "Title and description must be sanitized to prevent security issues"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Bookmark": {
        "id": "number",
        "userId": "number",
        "relationId": "number",
        "relationType": "number",
        "title": "string",
        "description": "string",
        "publicVisible": "boolean"
      }
    }
  },
  {
    "featureName": "AddForumBookmark",
    "description": "Creates a bookmark for a specific forum with title and description.",
    "inputValues": [
      "forumId-number-Forum",
      "title-string-Bookmark",
      "description-string-Bookmark",
      "isPublic-boolean-Bookmark"
    ],
    "businessLogic": "1. Input Collection:\n   1.1. Collect the following inputs:\n       - forumId (number, mandatory): The identifier of the forum to bookmark\n       - title (string, optional): Custom title for the bookmark, defaults to forum name\n       - description (string, optional): Custom description for the bookmark, defaults to forum description\n       - isPublic (boolean, optional): Flag indicating if bookmark is visible to other users, defaults to false\n\n2. Data Validation:\n   2.1. Validate forumId:\n       - Check if forumId is provided\n       - Verify forumId is a positive integer\n       - IF forumId is invalid THEN display error message \"Invalid forum identifier\"\n   2.2. Validate title:\n       - IF title is provided THEN check if length is within acceptable range (1-100 characters)\n       - IF title exceeds maximum length THEN truncate or display error message\n   2.3. Validate description:\n       - IF description is provided THEN check if length is within acceptable range (0-255 characters)\n       - IF description exceeds maximum length THEN truncate or display error message\n\n3. Business Rule Processing:\n   3.1. Verify user authentication:\n       - Check if user is logged in\n       - IF user is anonymous/not logged in THEN display error message \"Anonymous users cannot create bookmarks\"\n   3.2. Verify forum exists:\n       - Retrieve forum information using forumId\n       - IF forum does not exist THEN display error message \"Forum not found\"\n   3.3. Check bookmark feature availability:\n       - Verify bookmark feature is enabled in system settings\n       - IF feature is disabled THEN display error message \"Bookmark feature is currently disabled\"\n   3.4. Check for duplicate bookmark:\n       - Search for existing bookmark with same forumId and userId\n       - IF bookmark already exists THEN prepare for update instead of creation\n\n4. Core Operation Execution:\n   4.1. Prepare bookmark data:\n       - IF title is not provided THEN use forum name as default title\n       - IF description is not provided THEN use forum description as default description\n       - Set current user as bookmark owner\n       - Set bookmark type as FORUM type\n       - Set public visibility flag based on isPublic input\n   4.2. Create or update bookmark record:\n       - IF existing bookmark was found THEN update existing record\n       - ELSE create new bookmark record\n   4.3. Process bookmark creation:\n       - Store bookmark data in database\n       - Associate bookmark with current user\n       - IF any database error occurs THEN display appropriate error message\n\n5. Response Generation:\n   5.1. Generate success response:\n       - Display confirmation message \"Forum bookmark successfully created\"\n       - Provide option to view all bookmarks\n       - Provide option to return to forum\n   5.2. Handle error responses:\n       - Display specific error message based on failure reason\n       - Provide option to retry or cancel operation",
    "databaseEntities": [
      "jforum_bookmarks",
      "jforum_forums",
      "jforum_users"
    ],
    "validationRules": [
      "User must be logged in to create bookmarks",
      "Forum must exist in the system",
      "Bookmark feature must be enabled in system settings",
      "Title length must be between 1 and 100 characters if provided",
      "Description length must not exceed 255 characters if provided",
      "Forum ID must be a positive integer"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Bookmark": {
        "id": "number",
        "userId": "number",
        "forumId": "number",
        "title": "string",
        "description": "string",
        "isPublic": "boolean",
        "creationDate": "date"
      },
      "Forum": {
        "id": "number",
        "name": "string",
        "description": "string"
      }
    }
  },
  {
    "featureName": "AddTopicBookmark",
    "description": "Creates a bookmark for a specific topic with title and description.",
    "inputValues": [
      "topicId-number-Topic",
      "title-string-Bookmark",
      "description-string-Bookmark",
      "isPublic-boolean-Bookmark"
    ],
    "businessLogic": "1. Input Collection:\n   1.1. Collect the following required inputs:\n       - topicId: Identifier of the topic to bookmark (mandatory, system-provided)\n       - title: Title for the bookmark (mandatory, user-provided)\n       - description: Description for the bookmark (optional, user-provided)\n       - isPublic: Flag indicating if bookmark is publicly visible (optional, user-provided, defaults to false)\n   1.2. System automatically collects:\n       - userId: Identifier of the current user (system-generated)\n       - bookmarkType: Set to TOPIC type (system-generated)\n\n2. Data Validation:\n   2.1. Validate Topic Existence:\n       2.1.1. Check if the provided topicId exists in the system\n       2.1.2. IF topic does not exist, THEN\n              - Generate error message: \"The specified topic does not exist\"\n              - Terminate the process\n   2.2. Validate Title:\n       2.2.1. Check if title is provided\n       2.2.2. IF title is empty, THEN\n              - Use the original topic title as default\n       2.2.3. Sanitize title to prevent security issues\n   2.3. Validate Description:\n       2.3.1. IF description is provided, THEN\n              - Sanitize description to prevent security issues\n   2.4. Validate User Authentication:\n       2.4.1. Verify user is logged in (not anonymous)\n       2.4.2. IF user is anonymous, THEN\n              - Generate error message: \"Anonymous users cannot create bookmarks\"\n              - Terminate the process\n\n3. Business Rule Processing:\n   3.1. Check Bookmark Feature Availability:\n       3.1.1. Verify the bookmark feature is enabled for the system\n       3.1.2. IF feature is disabled, THEN\n              - Generate error message: \"Bookmark feature is currently disabled\"\n              - Terminate the process\n   3.2. Check for Existing Bookmark:\n       3.2.1. Search for an existing bookmark with the same topicId, bookmarkType, and userId\n       3.2.2. IF bookmark already exists, THEN\n              - Prepare for update operation instead of creation\n              - Pre-populate form fields with existing values\n\n4. Core Operation Execution:\n   4.1. Create Bookmark Record:\n       4.1.1. IF updating existing bookmark, THEN\n              - Update the existing bookmark with new title, description, and visibility settings\n       4.1.2. ELSE (creating new bookmark)\n              - Create new bookmark record with:\n                * User ID\n                * Topic ID\n                * Bookmark type (TOPIC)\n                * Title\n                * Description\n                * Public visibility flag\n       4.1.3. Save the bookmark to the database\n       4.1.4. IF save operation fails, THEN\n              - Generate error message: \"Failed to save bookmark\"\n              - Terminate the process\n\n5. Response Generation:\n   5.1. Success Response:\n       5.1.1. Generate confirmation message: \"Topic successfully bookmarked\"\n       5.1.2. Provide options to:\n              - View all bookmarks\n              - Return to the bookmarked topic\n   5.2. Error Response:\n       5.2.1. Display appropriate error message based on the failure point\n       5.2.2. Provide options to:\n              - Try again\n              - Cancel the operation",
    "databaseEntities": [
      "jforum_bookmarks",
      "jforum_topics",
      "jforum_users"
    ],
    "validationRules": [
      "Topic must exist in the system",
      "User must be authenticated (not anonymous)",
      "Bookmark feature must be enabled in the system",
      "Title must not be empty (will default to topic title if not provided)",
      "Content must be sanitized to prevent security issues"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Bookmark": {
        "id": "number",
        "userId": "number",
        "relationId": "number",
        "relationType": "number",
        "title": "string",
        "description": "string",
        "publicVisible": "boolean"
      },
      "Topic": {
        "id": "number",
        "title": "string"
      }
    }
  },
  {
    "featureName": "AddUserBookmark",
    "description": "Creates a bookmark for a specific user with title and description.",
    "inputValues": [
      "userId-number-User",
      "title-string-Bookmark",
      "description-string-Bookmark",
      "publicVisible-boolean-Bookmark"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the following inputs:\n     a. userId (number, mandatory): The ID of the user to bookmark\n     b. title (string, optional): Custom title for the bookmark, defaults to username of bookmarked user\n     c. description (string, optional): Custom description for the bookmark\n     d. publicVisible (boolean, optional): Whether the bookmark is visible to other users, defaults to false\n\n2. Data Validation:\n   - Validate user authentication:\n     a. IF current user is not authenticated (anonymous) THEN\n        i. Return error message \"Anonymous users cannot create bookmarks\"\n     b. Check if bookmark feature is enabled in system\n        i. IF bookmark feature is disabled THEN\n           1. Return error message \"Bookmark feature is disabled\"\n   - Validate userId:\n     a. IF userId is not provided or invalid THEN\n        i. Return error message \"Invalid user ID\"\n     b. IF user with provided userId does not exist THEN\n        i. Return error message \"User not found\"\n   - Validate title:\n     a. IF title is provided THEN\n        i. Ensure title is properly sanitized to prevent security issues\n        ii. IF title exceeds maximum length THEN\n            1. Return error message \"Title exceeds maximum allowed length\"\n   - Validate description:\n     a. IF description is provided THEN\n        i. Ensure description is properly sanitized to prevent security issues\n        ii. IF description exceeds maximum length THEN\n            1. Return error message \"Description exceeds maximum allowed length\"\n\n3. Business Rule Processing:\n   - Check for existing bookmark:\n     a. Query database for existing bookmark with same userId and current user as owner\n     b. IF bookmark already exists THEN\n        i. Prepare for update operation instead of creation\n        ii. Pre-populate form fields with existing bookmark data\n   - Verify user permissions:\n     a. IF current user does not have permission to create bookmarks THEN\n        i. Return error message \"You don't have permission to create bookmarks\"\n\n4. Core Operation Execution:\n   - Prepare bookmark data:\n     a. Set relation type to USER type constant\n     b. Set relation ID to the provided userId\n     c. Set owner ID to current user's ID\n     d. IF title is not provided THEN\n        i. Set title to bookmarked user's username\n     e. Set description to provided description or empty if not provided\n     f. Set public visibility flag based on provided input\n   - Save bookmark:\n     a. IF updating existing bookmark THEN\n        i. Update bookmark record in database\n     b. ELSE\n        i. Create new bookmark record in database\n     c. IF database operation fails THEN\n        i. Roll back any changes\n        ii. Return error message \"Failed to save bookmark\"\n\n5. Response Generation:\n   - On success:\n     a. Generate success message \"Bookmark successfully saved\"\n     b. Provide link to view all bookmarks\n     c. Provide link to view bookmarked user's profile\n   - On failure:\n     a. Display appropriate error message from validation or processing steps\n     b. Maintain user input values for correction\n     c. Provide option to retry operation",
    "databaseEntities": [
      "jforum_bookmarks",
      "jforum_users"
    ],
    "validationRules": [
      "User must be authenticated to create bookmarks",
      "Bookmark feature must be enabled in the system",
      "User ID must be valid and exist in the system",
      "Title and description must be properly sanitized",
      "Title and description must not exceed maximum allowed length"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Bookmark": {
        "id": "number",
        "userId": "number",
        "relationId": "number",
        "relationType": "number",
        "title": "string",
        "description": "string",
        "publicVisible": "boolean"
      },
      "User": {
        "id": "number",
        "username": "string"
      }
    }
  },
  {
    "featureName": "SaveBookmark",
    "description": "Saves a new bookmark with user-provided details and visibility settings.",
    "inputValues": [
      "title-string-Bookmark",
      "description-string-Bookmark",
      "relationType-number-Bookmark",
      "relationId-number-Bookmark",
      "visible-boolean-Bookmark"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the following required inputs:\n     a. title (string): The title for the bookmark\n     b. description (string): Optional description for the bookmark\n     c. relationType (number): Type of bookmark (forum, topic, or user)\n     d. relationId (number): ID of the related entity\n     e. visible (boolean): Public visibility setting\n   - System will automatically associate the bookmark with the current user\n\n2. Data Validation:\n   - Validate title:\n     a. Check if title is not empty\n     b. Sanitize title input to prevent security issues\n     c. If invalid, display appropriate error message\n   - Validate description:\n     a. Sanitize description input to prevent security issues\n   - Validate relationType:\n     a. Verify relationType is one of the valid types (forum, topic, user)\n     b. IF relationType is invalid, THEN display error message\n   - Validate relationId:\n     a. Verify the relationId exists in the system\n     b. IF relationId does not exist, THEN display error message\n   - Validate user authentication:\n     a. Verify user is logged in (not anonymous)\n     b. IF user is anonymous, THEN deny access with appropriate message\n\n3. Business Rule Processing:\n   - Check feature availability:\n     a. Verify bookmarks feature is enabled in system settings\n     b. IF feature is disabled, THEN show appropriate message\n   - Check for existing bookmark:\n     a. Query database to determine if user already has a bookmark for this relation\n     b. IF bookmark exists, THEN prepare for update instead of creation\n   - Verify access permissions:\n     a. Ensure user has permission to create bookmarks\n     b. IF user lacks permission, THEN show access denied message\n\n4. Core Operation Execution:\n   - Create bookmark object with collected data:\n     a. Set title (sanitized)\n     b. Set description (sanitized)\n     c. Set relationType\n     d. Set relationId\n     e. Set userId to current user's ID\n     f. Set public visibility flag based on input\n   - Persist bookmark to database:\n     a. IF existing bookmark found, THEN update existing record\n     b. ELSE create new bookmark record\n     c. IF database operation fails, THEN display error message\n\n5. Response Generation:\n   - On success:\n     a. Display confirmation message that bookmark was saved\n     b. Provide option to view all bookmarks\n     c. Provide option to return to the bookmarked item\n   - On failure:\n     a. Display specific error message based on failure reason\n     b. Retain user inputs for correction\n     c. Provide option to retry or cancel operation",
    "databaseEntities": [
      "jforum_bookmarks",
      "jforum_users",
      "jforum_forums",
      "jforum_topics"
    ],
    "validationRules": [
      "User must be logged in to create a bookmark",
      "Bookmark title must not be empty",
      "Bookmark relation type must be valid (forum, topic, or user)",
      "Related entity must exist in the system",
      "Bookmarks feature must be enabled in system settings",
      "User must have permission to create bookmarks"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Bookmark": {
        "id": "number",
        "userId": "number",
        "relationType": "number",
        "relationId": "number",
        "title": "string",
        "description": "string",
        "publicVisible": "boolean",
        "creationDate": "date"
      }
    }
  },
  {
    "featureName": "EditBookmark",
    "description": "Displays form for editing an existing bookmark and updates the bookmark with new information.",
    "inputValues": [
      "bookmark_id-number-Bookmark",
      "title-string-Bookmark",
      "description-string-Bookmark",
      "visible-boolean-Bookmark"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the following inputs:\n     a. bookmark_id (mandatory): Unique identifier of the bookmark to edit\n     b. title (mandatory): New title for the bookmark\n     c. description (optional): New description for the bookmark\n     d. visible (optional): Boolean flag indicating if bookmark is publicly visible\n\n2. Data Validation:\n   - Validate bookmark_id:\n     a. Check if bookmark_id is provided\n     b. Verify bookmark_id is a positive integer\n     c. IF validation fails, THEN display error message \"Invalid bookmark identifier\"\n   - Validate title:\n     a. Check if title is provided\n     b. Verify title is not empty after trimming whitespace\n     c. IF validation fails, THEN display error message \"Bookmark title cannot be empty\"\n   - Validate description:\n     a. No specific validation required as description is optional\n   - Validate visible flag:\n     a. Convert to boolean value (true if present, false if absent)\n\n3. Business Rule Processing:\n   - Retrieve bookmark using bookmark_id\n     a. IF bookmark does not exist, THEN display error message \"Bookmark not found\"\n   - Verify current user is the owner of the bookmark\n     a. Compare bookmark's userId with current user's id\n     b. IF user is not the owner, THEN display error message \"You are not authorized to edit this bookmark\"\n   - Check if bookmarks feature is enabled in system\n     a. IF bookmarks feature is disabled, THEN display error message \"Bookmark feature is disabled\"\n   - Verify user is authenticated (not anonymous)\n     a. IF user is anonymous, THEN display error message \"Anonymous users cannot edit bookmarks\"\n\n4. Core Operation Execution:\n   - Prepare bookmark update:\n     a. Set new title value\n     b. Set new description value\n     c. Set new public visibility flag\n   - Sanitize input values to prevent security issues\n     a. Remove any potentially harmful HTML or script content from title\n     b. Remove any potentially harmful HTML or script content from description\n   - Update bookmark in storage\n     a. Save changes to bookmark record\n     b. IF update fails, THEN display error message \"Failed to update bookmark\"\n\n5. Response Generation:\n   - On successful update:\n     a. Display confirmation message \"Bookmark updated successfully\"\n     b. Provide option to view updated bookmark\n     c. Provide option to return to bookmarks list\n   - On failure:\n     a. Display appropriate error message\n     b. Retain entered values in form\n     c. Allow user to correct errors and resubmit",
    "databaseEntities": [
      "jforum_bookmarks",
      "jforum_users"
    ],
    "validationRules": [
      "Bookmark must exist in the system",
      "Current user must be the owner of the bookmark",
      "User must be authenticated (not anonymous)",
      "Bookmarks feature must be enabled in the system",
      "Bookmark title must not be empty"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Bookmark": {
        "id": "number",
        "userId": "number",
        "title": "string",
        "description": "string",
        "publicVisible": "boolean",
        "relationType": "number",
        "relationId": "number"
      }
    }
  },
  {
    "featureName": "DeleteBookmark",
    "description": "Removes a bookmark from the system.",
    "inputValues": [
      "bookmark_id-number-Bookmark"
    ],
    "businessLogic": "1. Input Collection\n   - Collect the bookmark_id (mandatory) from the user request\n   - System retrieves the current user's ID from the active session\n\n2. Data Validation\n   - Validate bookmark_id\n     2.1. Verify bookmark_id is provided\n     2.2. Verify bookmark_id is a valid positive integer\n     2.3. IF bookmark_id is missing or invalid THEN\n          2.3.1. Generate an error message indicating invalid bookmark ID\n          2.3.2. Terminate the process\n\n3. Business Rule Processing\n   - Verify bookmark existence and ownership\n     3.1. Retrieve the bookmark record using the bookmark_id\n     3.2. IF bookmark does not exist THEN\n          3.2.1. Generate a \"Bookmark not found\" error message\n          3.2.2. Terminate the process\n     3.3. Verify the current user is the owner of the bookmark\n          3.3.1. Compare the bookmark's user ID with the current user's ID\n          3.3.2. IF user IDs do not match THEN\n                 3.3.2.1. Generate a \"Not authorized to delete this bookmark\" error message\n                 3.3.2.2. Terminate the process\n\n4. Core Operation Execution\n   - Delete the bookmark\n     4.1. Remove the bookmark record from the system using the bookmark_id\n     4.2. IF deletion fails THEN\n          4.2.1. Generate a system error message\n          4.2.2. Log the error details\n          4.2.3. Terminate the process\n\n5. Response Generation\n   - Generate success response\n     5.1. Prepare confirmation message that the bookmark was successfully deleted\n     5.2. Redirect the user to their bookmark list page\n     5.3. Display the updated list of bookmarks for the user",
    "databaseEntities": [
      "jforum_bookmarks",
      "jforum_users"
    ],
    "validationRules": [
      "Bookmark ID must be a valid positive integer",
      "Bookmark must exist in the system",
      "User must be the owner of the bookmark to delete it",
      "User must be logged in to delete bookmarks"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Bookmark": {
        "id": "number",
        "userId": "number",
        "relationId": "number",
        "relationType": "number",
        "title": "string",
        "description": "string",
        "publicVisible": "boolean"
      }
    }
  },
  {
    "featureName": "ListBookmarks",
    "description": "Displays all bookmarks for a specific user.",
    "inputValues": [
      "user_id-number-User"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect user_id (mandatory) - The identifier of the user whose bookmarks are to be displayed\n   - System will determine if the requesting user is logged in or anonymous\n\n2. Data Validation:\n   - Validate that the user_id exists in the system\n     * IF user_id does not exist THEN\n       - Display appropriate error message\n       - End process\n   - Validate user permissions\n     * IF bookmarks feature is disabled THEN\n       - Display \"feature disabled\" message\n       - End process\n     * IF user is anonymous AND trying to access non-public bookmarks THEN\n       - Display \"access denied\" message\n       - End process\n\n3. Business Rule Processing:\n   - Determine the access level for bookmarks\n     * IF requesting user is the owner of the bookmarks THEN\n       - Allow full access to all bookmarks\n     * ELSE\n       - Only allow access to public bookmarks\n   - Check if the user has permission to view bookmarks\n     * IF user lacks required permissions THEN\n       - Display appropriate error message\n       - End process\n\n4. Core Operation Execution:\n   - Retrieve all bookmarks associated with the specified user_id\n     * Include bookmark title, description, type (forum, topic, or user), and visibility status\n   - Categorize bookmarks by type (forum, topic, user)\n   - Retrieve additional information for each bookmark based on its type:\n     * For forum bookmarks: forum name and description\n     * For topic bookmarks: topic title and related information\n     * For user bookmarks: username and profile information\n   - Prepare data for display, including:\n     * Bookmark details (title, description, type)\n     * Owner information\n     * Public/private status\n     * Creation/modification dates\n\n5. Response Generation:\n   - Display the list of bookmarks organized by type\n   - Show bookmark title, description, and type\n   - IF the current user is the owner of the bookmarks THEN\n     * Display edit and delete options for each bookmark\n   - IF no bookmarks exist THEN\n     * Display appropriate \"no bookmarks\" message\n   - Include pagination if the number of bookmarks exceeds the display limit\n   - Display the username of the bookmark owner in the page title",
    "databaseEntities": [
      "jforum_bookmarks",
      "jforum_users",
      "jforum_forums",
      "jforum_topics"
    ],
    "validationRules": [
      "User must exist in the system",
      "Requesting user must have permission to view bookmarks",
      "Anonymous users can only view public bookmarks",
      "Bookmarks feature must be enabled in the system"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Bookmark": {
        "id": "number",
        "userId": "number",
        "relationId": "number",
        "relationType": "number",
        "title": "string",
        "description": "string",
        "publicVisible": "boolean"
      },
      "User": {
        "id": "number",
        "username": "string"
      }
    }
  },
  {
    "featureName": "ShowForumTopics",
    "description": "Displays all topics in a specific forum with pagination and moderation options.",
    "inputValues": [
      "forum_id-number-Forum",
      "start-number-Pagination"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect forum_id (mandatory): Numeric identifier of the forum to display\n   - Collect start (optional): Pagination start position, defaults to 0\n\n2. Data Validation:\n   - Validate forum_id:\n     a. Check if forum_id is provided and is a valid number\n     b. Verify forum exists in the system\n     c. If invalid, display appropriate error message\n   - Validate start parameter:\n     a. Ensure start is a non-negative number\n     b. If invalid, default to 0\n\n3. Business Rule Processing:\n   - Check user access permissions:\n     a. Verify if the forum is accessible to the current user\n     b. IF forum is not accessible or does not exist THEN\n        i. Display access denied message\n        ii. Terminate further processing\n     c. Determine user's moderation privileges for this forum:\n        i. Check if user is logged in\n        ii. Check if user has moderator status for this forum\n        iii. Check if user has message approval permissions\n\n4. Core Operation Execution:\n   - Retrieve forum information:\n     a. Get forum details including name, description, and settings\n     b. Get total number of topics in the forum\n   - Retrieve topic list:\n     a. Calculate pagination parameters based on start value and system-defined topics per page\n     b. Retrieve topics for the current page\n     c. IF user has moderation privileges THEN\n        i. Retrieve topics requiring approval\n   - Process topic data:\n     a. Format each topic with required display information\n     b. Calculate unread status based on user's last visit\n     c. Add moderation options for eligible users\n   - Prepare additional context data:\n     a. Forum subscription status for logged-in users\n     b. Forum permission settings (read-only, reply-only)\n     c. Attachment settings and permissions\n     d. RSS availability based on system settings\n\n5. Response Generation:\n   - Generate pagination information:\n     a. Calculate total pages based on topics count and topics per page\n     b. Generate previous/next page links if applicable\n     c. Create page number links\n   - Prepare display data:\n     a. Format the list of topics with their metadata\n     b. Include moderation options if user has privileges\n     c. Include forum subscription status\n     d. Include forum navigation breadcrumbs\n   - Display the forum topics page:\n     a. Show forum name and description\n     b. Display topic listing with pagination\n     c. Show moderation controls for authorized users\n     d. Display forum subscription options",
    "databaseEntities": [
      "jforum_forums",
      "jforum_topics",
      "jforum_posts",
      "jforum_users",
      "jforum_categories",
      "jforum_sessions"
    ],
    "validationRules": [
      "Forum ID must be a valid number",
      "Forum must exist in the system",
      "User must have access permissions to view the forum",
      "Pagination start parameter must be a non-negative number",
      "Only moderators can see topics pending approval"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Forum": {
        "id": "number",
        "name": "string",
        "description": "string",
        "categoryId": "number",
        "totalTopics": "number"
      },
      "Topic": {
        "id": "number",
        "title": "string",
        "forumId": "number",
        "lastPostTime": "date",
        "totalReplies": "number",
        "status": "string",
        "type": "string",
        "userId": "number"
      },
      "User": {
        "id": "number",
        "username": "string",
        "registrationDate": "date",
        "lastVisit": "date"
      },
      "Pagination": {
        "start": "number",
        "itemsPerPage": "number",
        "totalItems": "number"
      }
    }
  },
  {
    "featureName": "ModerationView",
    "description": "Shows forum topics with moderation panel opened for authorized moderators.",
    "inputValues": [
      "forum_id-number-Forum"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect forum_id (mandatory) from the request\n   - System will determine current user session information automatically\n\n2. Data Validation:\n   - Validate that forum_id is provided and is a valid number\n     - IF forum_id is missing or invalid THEN\n       - Display error message indicating invalid forum selection\n       - Return user to forum listing page\n   - Validate that the forum exists in the system\n     - IF forum does not exist THEN\n       - Display error message indicating forum not found\n       - Return user to forum listing page\n   - Validate that the user has access to the specified forum\n     - IF user does not have access to the forum THEN\n       - Display access denied message\n       - Return user to forum listing page\n\n3. Business Rule Processing:\n   - Check if the current user is logged in\n     - IF user is not logged in THEN\n       - Redirect to login page\n       - Store original request for post-login redirection\n   - Check if the current user is a moderator for the specified forum\n     - IF user is not a moderator for this forum THEN\n       - Display access denied message\n       - Return user to forum listing page\n   - Check if the user has permission to approve messages\n     - IF user does not have message approval permission THEN\n       - Display limited moderation view without approval options\n\n4. Core Operation Execution:\n   - Retrieve forum information based on forum_id\n   - Retrieve topics in the forum with pagination\n     - Get current page number from request or default to first page\n     - Calculate offset based on page number and topics per page setting\n   - Retrieve topics pending approval for the forum\n   - Prepare topic data for display\n     - Format dates according to system settings\n     - Calculate unread status for each topic\n     - Prepare moderation options for each topic\n   - Set moderation panel to open state\n   - Prepare forum statistics and metadata\n     - Total topics count\n     - Total posts count\n     - Last post information\n   - Prepare moderation action buttons and options\n\n5. Response Generation:\n   - Display forum view with moderation panel opened\n   - Show standard forum information:\n     - Forum name and description\n     - Topic listing with pagination\n     - Forum statistics\n   - Show moderation-specific elements:\n     - Topics pending approval section\n     - Moderation action buttons (approve, reject, move, etc.)\n     - Batch operation options\n   - IF any errors occurred during processing THEN\n     - Display appropriate error messages\n     - Provide navigation options to return to valid state",
    "databaseEntities": [
      "jforum_forums",
      "jforum_topics",
      "jforum_posts",
      "jforum_users",
      "jforum_moderator_groups",
      "jforum_categories"
    ],
    "validationRules": [
      "Forum ID must be a valid number",
      "Forum must exist in the system",
      "User must have access to the specified forum",
      "User must be logged in to access moderation features",
      "User must be a moderator for the specified forum",
      "User must have appropriate permissions for moderation actions"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Forum": {
        "id": "number",
        "name": "string",
        "description": "string",
        "categoryId": "number",
        "totalTopics": "number",
        "totalPosts": "number",
        "lastPostId": "number",
        "moderated": "boolean"
      },
      "Topic": {
        "id": "number",
        "forumId": "number",
        "title": "string",
        "postTime": "date",
        "userId": "number",
        "totalReplies": "number",
        "lastPostId": "number",
        "status": "number",
        "type": "number",
        "pendingModeration": "boolean"
      }
    }
  },
  {
    "featureName": "MarkTopicsAsRead",
    "description": "Marks all topics in a forum as read for the current user.",
    "inputValues": [
      "forumId-number-Forum"
    ],
    "businessLogic": "1. Input Collection\n   - Collect forumId (mandatory): Unique identifier of the forum\n   - Retrieve current user session (system-generated): User's active session\n\n2. Data Validation\n   - Validate forumId:\n      * Check if forumId is provided\n      * Verify forumId is a valid number\n      * Verify the forum exists in the system\n      * IF forumId is invalid or not found, THEN display error message\n   - Validate user session:\n      * Verify user has an active session\n      * IF no active session exists, THEN create or use guest session\n\n3. Business Rule Processing\n   - Check forum accessibility:\n      * Verify the user has permission to access the specified forum\n      * IF user does not have access, THEN deny the operation\n   - Check tracking system availability:\n      * Verify the topic tracking system is operational\n      * IF tracking system is unavailable, THEN notify user and abort operation\n\n4. Core Operation Execution\n   - Retrieve user's topic tracking information:\n      * Get the current tracking map for the user\n      * IF tracking map does not exist, THEN create a new empty tracking map\n   - Update tracking information:\n      * Set the current timestamp as the read time for all topics in the forum\n      * Store the updated tracking map in the user's session\n   - Process forum-specific operations:\n      * IF forumId is provided, THEN mark only topics in that specific forum as read\n      * IF forumId is not provided, THEN mark topics in all accessible forums as read\n\n5. Response Generation\n   - Determine appropriate redirect destination:\n      * IF specific forum was marked as read, THEN redirect to that forum's topic listing\n      * IF all forums were marked as read, THEN redirect to forum list page\n   - Provide success feedback:\n      * Display confirmation message that topics have been marked as read\n      * Show updated visual indicators for read topics when displaying forum content",
    "databaseEntities": [
      "jforum_forums",
      "jforum_topics",
      "jforum_sessions"
    ],
    "validationRules": [
      "Forum ID must be a valid number",
      "Forum must exist in the system",
      "User must have an active session",
      "User must have permission to access the forum"
    ],
    "dbSeedingOperations": [],
    "schema": {}
  },
  {
    "featureName": "ViewNewMessages",
    "description": "Shows messages posted since the user's last visit.",
    "inputValues": [
      "lastVisitDate-date-UserSession",
      "currentDate-date-System"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the user's last visit timestamp from the session\n   - Use the current system date as the end date for the search\n   - Both inputs are system-generated and do not require user input\n\n2. Data Validation:\n   - Validate user session exists\n     - IF user session is not found THEN\n       - Redirect to login page\n       - Display appropriate message\n     - END IF\n   - Validate last visit date is available\n     - IF last visit date is not available THEN\n       - Use a default date (system registration date or earliest possible date)\n     - END IF\n   - Validate that last visit date is before current date\n     - IF last visit date is after current date THEN\n       - Use system registration date instead\n     - END IF\n\n3. Business Rule Processing:\n   - Check user permissions for viewing messages\n     - IF user does not have permission to view messages THEN\n       - Display access denied message\n       - Terminate the operation\n     - END IF\n   - Determine which forums the user has access to\n     - FOR each forum in the system\n       - Check if user has permission to view the forum\n       - Add accessible forums to a list\n     - END FOR\n   - IF no accessible forums found THEN\n     - Display appropriate message that no forums are available\n     - Terminate the operation\n   - END IF\n\n4. Core Operation Execution:\n   - Search for all messages posted between last visit date and current date\n     - Filter messages to only include those from forums the user can access\n     - Sort messages by date (newest first)\n     - Group messages by forum and topic\n   - Process search results\n     - Format dates according to user preferences\n     - Prepare message previews\n     - Count total number of new messages found\n   - IF no new messages found THEN\n     - Prepare \"no new messages\" notification\n   - END IF\n\n5. Response Generation:\n   - Prepare the view with the following information:\n     - List of new messages grouped by forum and topic\n     - For each message include:\n       - Author information\n       - Post date and time\n       - Message preview/excerpt\n       - Link to the full message\n     - Total count of new messages\n     - Last visit date used for the search\n     - Current date used for the search\n   - Display the new messages page to the user\n   - Provide navigation options to:\n     - View full messages\n     - Mark all as read\n     - Return to forum list",
    "databaseEntities": [
      "jforum_users",
      "jforum_forums",
      "jforum_topics",
      "jforum_posts",
      "jforum_posts_text",
      "jforum_sessions"
    ],
    "validationRules": [
      "User must be logged in to view new messages",
      "Last visit date must be a valid date",
      "Last visit date must be before current date",
      "User must have permission to view the forums containing the messages",
      "Only messages from accessible forums should be displayed"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "UserSession": {
        "type": "object",
        "properties": {
          "userId": {
            "type": "number"
          },
          "lastVisit": {
            "type": "date",
            "description": "Timestamp of user's last visit"
          }
        }
      },
      "Message": {
        "type": "object",
        "properties": {
          "id": {
            "type": "number"
          },
          "forumId": {
            "type": "number"
          },
          "topicId": {
            "type": "number"
          },
          "userId": {
            "type": "number"
          },
          "subject": {
            "type": "string"
          },
          "text": {
            "type": "string"
          },
          "postDate": {
            "type": "date"
          }
        }
      }
    }
  },
  {
    "featureName": "ApproveMessages",
    "description": "Allows moderators to approve pending messages in a forum.",
    "inputValues": [
      "forum_id-number-Forum",
      "messages-object-MessageList"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect forum_id (mandatory): The identifier of the forum where messages need approval\n   - Collect messages (mandatory): List of message identifiers to be approved\n   - System retrieves current user session information (system-generated)\n\n2. Data Validation:\n   - Validate forum_id:\n      * Check if forum_id is provided and is a valid number\n      * Verify the forum exists in the system\n      * If validation fails, display error message \"Invalid forum selected\"\n   - Validate messages list:\n      * Ensure the messages list is not empty\n      * Verify all message IDs in the list are valid numbers\n      * If validation fails, display error message \"No valid messages selected for approval\"\n   - Validate user permissions:\n      * Verify user is logged in\n      * Check if user is a moderator for the specified forum\n      * Verify user has message approval permissions\n      * If validation fails, display error message \"You do not have permission to approve messages\"\n\n3. Business Rule Processing:\n   - Check forum status:\n      * Verify the forum is active and not locked\n      * If forum is locked, display error message \"Cannot approve messages in a locked forum\"\n   - Verify message approval status:\n      * Check if all selected messages are in pending status\n      * If any message is already approved or deleted, exclude it from processing\n      * Generate a warning if some messages were excluded\n   - Check message ownership:\n      * Verify all messages belong to the specified forum\n      * If any message doesn't belong to the forum, exclude it from processing\n\n4. Core Operation Execution:\n   - For each valid message in the list:\n      * Update message status from pending to approved\n      * Update message visibility settings\n      * Update forum statistics (message count, last post information)\n      * Record approval action in moderation log with moderator ID, timestamp, and action details\n   - Update forum topic counts if necessary\n   - Update system-wide message counts\n   - If any operation fails:\n      * Roll back all changes for consistency\n      * Log the error details\n      * Display appropriate error message\n\n5. Response Generation:\n   - On success:\n      * Generate confirmation message showing number of messages approved\n      * Provide link to return to forum view\n      * Update forum display to show newly approved messages\n   - On partial success:\n      * Show number of messages successfully approved\n      * Show number of messages that couldn't be approved with reasons\n   - On failure:\n      * Display error message explaining the failure reason\n      * Provide guidance on how to resolve the issue\n      * Offer option to retry the operation",
    "databaseEntities": [
      "jforum_forums",
      "jforum_topics",
      "jforum_posts",
      "jforum_posts_text",
      "jforum_users",
      "jforum_sessions"
    ],
    "validationRules": [
      "User must be logged in to approve messages",
      "User must be a moderator of the specified forum",
      "User must have message approval permissions",
      "Forum must exist and be active",
      "Messages must be in pending status",
      "Messages must belong to the specified forum"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "MessageList": {
        "type": "object",
        "properties": {
          "messageIds": {
            "type": "array",
            "items": {
              "type": "number",
              "description": "Unique identifier for each message pending approval"
            }
          }
        },
        "required": [
          "messageIds"
        ]
      }
    }
  },
  {
    "featureName": "WatchForum",
    "description": "Subscribes a user to receive notifications for a specific forum.",
    "inputValues": [
      "forum_id-number-Forum",
      "user_id-number-User"
    ],
    "businessLogic": "1. Input Collection\n   - Collect forum_id (mandatory): The unique identifier of the forum to watch\n   - Collect user_id (system-generated): The identifier of the current logged-in user\n\n2. Data Validation\n   - Validate forum_id:\n      * Check if forum_id is provided\n      * Verify forum_id represents a valid forum in the system\n      * Generate error message if forum does not exist\n   - Validate user authentication:\n      * Verify user is logged in\n      * Generate error message if user is not authenticated\n      * Redirect to login page if authentication fails\n\n3. Business Rule Processing\n   - Check subscription status:\n      * Verify if the user is already subscribed to this forum\n      * Skip subscription process if user is already watching the forum\n   - Verify forum access permissions:\n      * Check if the user has access rights to the specified forum\n      * Generate error message if user lacks necessary permissions\n\n4. Core Operation Execution\n   - Create forum subscription:\n      * Record the association between user and forum in the subscription system\n      * Store timestamp of when the subscription was created\n      * Update user's notification preferences for this forum\n   - Handle subscription conflicts:\n      * If any errors occur during subscription process, provide clear error message\n      * Roll back any partial subscription data if process fails\n\n5. Response Generation\n   - Generate success response:\n      * Create confirmation message indicating successful subscription\n      * Include forum name in the confirmation message\n      * Provide information about how notifications will be delivered\n   - Redirect user:\n      * Return user to the forum view they were previously viewing\n      * Maintain any pagination or view state from before the action",
    "databaseEntities": [
      "jforum_users",
      "jforum_forums",
      "jforum_user_groups"
    ],
    "validationRules": [
      "User must be logged in to subscribe to a forum",
      "Forum must exist in the system",
      "User must have access permissions to the forum",
      "User should not already be subscribed to the forum"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Forum": {
        "id": "number",
        "name": "string",
        "description": "string",
        "categoryId": "number"
      },
      "User": {
        "id": "number",
        "username": "string",
        "email": "string"
      }
    }
  },
  {
    "featureName": "UnwatchForum",
    "description": "Unsubscribes a user from forum notifications.",
    "inputValues": [
      "forum_id-number-Forum",
      "userId-number-User"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect forum_id (mandatory): The identifier of the forum to unsubscribe from\n   - Collect userId (system-generated): The identifier of the current user\n\n2. Data Validation:\n   - Validate forum_id:\n     a. Check if forum_id is provided\n     b. Verify forum_id is a valid number\n     c. Verify forum_id exists in the system\n     d. If validation fails, display appropriate error message\n   - Validate user authentication:\n     a. Check if user is logged in\n     b. If user is not logged in, redirect to login page\n     c. If validation fails, display appropriate error message\n\n3. Business Rule Processing:\n   - Verify subscription status:\n     a. Check if the user is currently subscribed to the forum\n     b. If user is not subscribed, display appropriate message\n     c. If verification fails, display appropriate error message\n\n4. Core Operation Execution:\n   - Remove subscription:\n     a. Delete the subscription record linking the user to the forum\n     b. Update user notification preferences for the specific forum\n     c. If operation fails, display appropriate error message and rollback changes\n\n5. Response Generation:\n   - Success response:\n     a. Generate confirmation message that user has been unsubscribed\n     b. Provide link to return to forum view\n     c. Update user interface to reflect unsubscribed status\n   - Error response:\n     a. Display specific error message based on failure point\n     b. Provide guidance on how to resolve the issue\n     c. Offer support contact information if needed",
    "databaseEntities": [
      "jforum_forums",
      "jforum_users"
    ],
    "validationRules": [
      "User must be logged in to unsubscribe from a forum",
      "Forum ID must be valid and exist in the system",
      "User must be currently subscribed to the forum to unsubscribe"
    ],
    "dbSeedingOperations": [],
    "schema": {}
  },
  {
    "featureName": "ShowBannedMessage",
    "description": "Displays a message when a banned user attempts to access the forum.",
    "inputValues": [
      "userId-number-User",
      "forumId-number-Forum",
      "userSession-object-UserSession"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect userId (mandatory) from the current user session\n   - Collect forumId (mandatory) from the request parameters\n   - Collect userSession (mandatory) containing user status and permissions\n\n2. Data Validation:\n   - Validate userId:\n     a. Verify userId is a positive integer\n     b. Verify userId exists in the system\n     c. Return error if validation fails\n   - Validate forumId:\n     a. Verify forumId is a positive integer\n     b. Verify forumId exists in the system\n     c. Return error if validation fails\n   - Validate userSession:\n     a. Verify userSession is active\n     b. Verify userSession contains required user information\n     c. Return error if validation fails\n\n3. Business Rule Processing:\n   - Check user ban status:\n     a. Retrieve user status from user profile\n     b. IF user status is \"banned\":\n        i. Proceed to banned message display\n     c. ELSE:\n        i. Allow normal forum access\n   - Check forum access permissions:\n     a. Retrieve forum access rules\n     b. Verify if user has permission to access the requested forum\n     c. IF user lacks permission:\n        i. Proceed to banned message display\n     d. ELSE:\n        i. Allow normal forum access\n\n4. Core Operation Execution:\n   - Prepare banned message display:\n     a. Set appropriate template for banned message\n     b. Load localized message text based on user language preference\n     c. Add context information explaining the ban reason if available\n     d. Format the message for display\n   - Log the banned access attempt:\n     a. Record timestamp of access attempt\n     b. Record user information\n     c. Record requested resource\n     d. Store log entry\n\n5. Response Generation:\n   - Generate banned message response:\n     a. Set response template to banned message view\n     b. Include formatted ban message in the response\n     c. Include any available support contact information\n     d. Include any available appeal process information\n     e. Return the formatted response to the user",
    "databaseEntities": [
      "jforum_users",
      "jforum_forums",
      "jforum_sessions",
      "jforum_user_groups"
    ],
    "validationRules": [
      "User ID must be a valid positive integer",
      "Forum ID must be a valid positive integer",
      "User session must be active",
      "User ban status must be checked before forum access",
      "Access permissions must be verified for the requested forum"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "UserSession": {
        "type": "object",
        "properties": {
          "userId": {
            "type": "number",
            "description": "The unique identifier of the user"
          },
          "username": {
            "type": "string",
            "description": "The username of the user"
          },
          "isBanned": {
            "type": "boolean",
            "description": "Flag indicating if the user is banned"
          },
          "lastVisit": {
            "type": "date",
            "description": "Date and time of the user's last visit"
          },
          "permissions": {
            "type": "object",
            "description": "User's permission settings"
          }
        }
      }
    }
  },
  {
    "featureName": "ListHottestTopics",
    "description": "Displays a list of the hottest forum topics with pagination and access control.",
    "inputValues": [
      "page-number-Pagination",
      "postsPerPage-number-SystemConfig",
      "userId-number-User"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect pagination parameters:\n     a. Current page number (optional, defaults to 1)\n     b. Posts per page (system configuration value)\n   - Collect user information if accessing user-specific topics:\n     a. User ID (required for user-specific topic listing)\n\n2. Data Validation:\n   - Validate pagination parameters:\n     a. Ensure page number is a positive integer\n     b. Verify posts per page is within acceptable range\n   - IF accessing user-specific topics:\n     a. Validate user ID exists in the system\n     b. IF user not found:\n        i. Generate user not found message\n        ii. RETURN error response\n\n3. Business Rule Processing:\n   - Determine access permissions:\n     a. Check user's access rights to forums\n     b. Filter out forums and topics the user cannot access\n   - Determine topic listing type:\n     a. IF user ID is provided:\n        i. Set up for user-specific topic listing\n     b. ELSE:\n        i. Set up for general hottest topics listing\n   - Calculate pagination values:\n     a. Determine start index based on current page and items per page\n     b. Calculate total pages based on total topics and items per page\n\n4. Core Operation Execution:\n   - Retrieve topic data:\n     a. IF listing user-specific topics:\n        i. Fetch topics created by the specified user\n        ii. Count total topics by user for pagination\n     b. ELSE:\n        i. Fetch hottest topics from the system\n   - Process topic data:\n     a. For each topic:\n        i. Check if topic's forum is accessible to current user\n        ii. IF not accessible, remove from results\n        iii. IF accessible, retrieve forum information for the topic\n     b. Prepare topic data for display:\n        i. Format dates and times\n        ii. Calculate reply counts\n        iii. Determine if topic has new posts for current user\n   - Organize forum data:\n     a. Create mapping between topics and their respective forums\n     b. Include forum names and other relevant information\n\n5. Response Generation:\n   - Prepare display data:\n     a. Set page title based on listing type\n     b. Include processed topic list\n     c. Include forum information for each topic\n     d. Add pagination information:\n        i. Current page number\n        ii. Total pages\n        iii. Next/previous page links if applicable\n   - Format response:\n     a. IF successful:\n        i. Return topic listing with forum information and pagination\n     b. IF error occurred:\n        i. Return appropriate error message",
    "databaseEntities": [
      "jforum_users",
      "jforum_forums",
      "jforum_topics",
      "jforum_posts"
    ],
    "validationRules": [
      "Page number must be a positive integer",
      "Posts per page must be within system-defined limits",
      "User must exist in the system when listing user-specific topics",
      "User must have access rights to view the requested topics",
      "Topics must belong to forums the user has permission to access"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Topic": {
        "id": "number",
        "title": "string",
        "forumId": "number",
        "userId": "number",
        "postCount": "number",
        "lastPostDate": "date",
        "type": "number",
        "status": "number"
      },
      "Forum": {
        "id": "number",
        "name": "string",
        "description": "string",
        "categoryId": "number",
        "lastPostDate": "date",
        "topicCount": "number",
        "postCount": "number"
      },
      "User": {
        "id": "number",
        "username": "string",
        "registrationDate": "date",
        "postCount": "number"
      },
      "Pagination": {
        "currentPage": "number",
        "totalPages": "number",
        "itemsPerPage": "number",
        "totalItems": "number"
      }
    }
  },
  {
    "featureName": "ShowTopicsByUser",
    "description": "Retrieves and displays all topics created by a specific user with pagination.",
    "inputValues": [
      "userId-number-User",
      "startPage-number-Pagination"
    ],
    "businessLogic": "1. Input Collection\n   - Collect the following inputs:\n     a. userId (mandatory): Unique identifier of the user whose topics will be displayed\n     b. startPage (optional): Page number to display, defaults to 1 if not provided\n     c. System will use configured topicsPerPage setting (system-generated)\n     d. System will use configured postsPerPage setting (system-generated)\n\n2. Data Validation\n   - Validate user existence\n     a. Check if the provided userId corresponds to an existing user in the system\n     b. IF user does not exist THEN\n        i. Generate appropriate error message indicating user not found\n        ii. Terminate process and display error message\n     c. IF user exists THEN continue to next step\n   - Validate pagination parameters\n     a. Ensure startPage is a positive integer\n     b. IF startPage is invalid THEN default to page 1\n\n3. Business Rule Processing\n   - Calculate pagination parameters\n     a. Calculate the starting index based on startPage and topicsPerPage\n     b. Calculate total number of pages based on total topics and topicsPerPage\n   - Prepare access control checks\n     a. System must verify user has permission to view topics\n     b. System must filter out topics from forums the current user cannot access\n\n4. Core Operation Execution\n   - Retrieve total count of topics created by the specified user\n     a. Count all topics where the creator ID matches the provided userId\n   - Retrieve paginated list of topics\n     a. Fetch limited set of topics created by the user based on pagination parameters\n     b. Sort topics according to system default sorting (typically by creation date)\n   - Process topic list\n     a. FOR each topic in the retrieved list:\n        i. Retrieve the forum information for the topic\n        ii. IF current user does not have access to the forum THEN\n            - Remove topic from the result list\n            - Decrement total topic count\n        iii. ELSE include forum information with the topic\n     b. Prepare additional topic metadata (last post information, reply count, etc.)\n\n5. Response Generation\n   - Prepare display data\n     a. User information (username, profile details)\n     b. List of topics with their metadata\n     c. Associated forum information for each topic\n     d. Pagination information\n       i. Current page number\n       ii. Total pages\n       iii. Navigation links (previous/next page)\n   - Format response for display\n     a. Include page title with username\n     b. Include topic listing with relevant details\n     c. Include pagination controls\n   - Return formatted response to user",
    "databaseEntities": [
      "jforum_users",
      "jforum_topics",
      "jforum_forums",
      "jforum_posts",
      "jforum_categories"
    ],
    "validationRules": [
      "User ID must correspond to an existing user in the system",
      "Start page must be a positive integer",
      "User must have permission to view the topics",
      "Topics from forums the user cannot access must be filtered out"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Topic": {
        "id": "number",
        "title": "string",
        "forumId": "number",
        "creationDate": "date",
        "lastPostDate": "date",
        "userId": "number",
        "totalReplies": "number",
        "totalViews": "number"
      },
      "User": {
        "id": "number",
        "username": "string",
        "registrationDate": "date"
      },
      "Forum": {
        "id": "number",
        "name": "string",
        "description": "string",
        "categoryId": "number"
      },
      "Pagination": {
        "currentPage": "number",
        "totalPages": "number",
        "totalRecords": "number",
        "recordsPerPage": "number"
      }
    }
  },
  {
    "featureName": "LoadJavaScriptFile",
    "description": "Loads and parses JavaScript files with FreeMarker Template Language statements from the js directory.",
    "inputValues": [
      "js-string-File"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the JavaScript filename (js) from the request\n   - The filename is mandatory and must be provided as a string\n   - No default value is provided\n\n2. Data Validation:\n   - Validate the JavaScript filename parameter:\n     a. Check if the filename parameter exists\n        IF filename is null or empty THEN\n          Generate an error message indicating the filename is required\n          Return error response\n        END IF\n     b. Verify the filename contains only valid characters\n        IF filename contains invalid characters THEN\n          Generate an error message indicating invalid filename format\n          Return error response\n        END IF\n     c. Verify the filename is not attempting path traversal\n        IF filename contains path traversal sequences (..) THEN\n          Generate a security error message\n          Return error response\n        END IF\n\n3. Business Rule Processing:\n   - Verify the JavaScript file exists in the system:\n     a. Construct the complete template path to the JavaScript file\n        Set templatePath to \"js/\" + filename + \".js\"\n     b. Check if the file exists in the template directory\n        IF file does not exist THEN\n          Generate an error message indicating the file was not found\n          Return error response\n        END IF\n   - Verify the user has permission to access the JavaScript file:\n     a. Check if the current user has permission to access the requested file\n        IF user does not have permission THEN\n          Generate an access denied error message\n          Return error response\n        END IF\n\n4. Core Operation Execution:\n   - Set the response content type to JavaScript:\n     a. Set the content type header to \"text/javascript\"\n   - Prepare the template for processing:\n     a. Set the template name to the constructed path (\"js/\" + filename + \".js\")\n   - Process the JavaScript file through the template engine:\n     a. The template engine will parse any FreeMarker Template Language statements\n     b. The template engine will generate the final JavaScript content\n     c. IF any error occurs during template processing THEN\n          Log the error details\n          Generate an error message indicating template processing failed\n          Return error response\n        END IF\n\n5. Response Generation:\n   - For successful processing:\n     a. Return the processed JavaScript content with the proper content type\n     b. Include appropriate caching headers if configured\n   - For error scenarios:\n     a. Return an appropriate error message with details about the failure\n     b. Include proper HTTP status code based on the error type",
    "databaseEntities": [],
    "validationRules": [
      "JavaScript filename must not be empty",
      "JavaScript filename must contain only valid characters",
      "JavaScript filename must not contain path traversal sequences",
      "JavaScript file must exist in the template directory",
      "User must have permission to access the requested JavaScript file"
    ],
    "dbSeedingOperations": [],
    "schema": {}
  },
  {
    "featureName": "InsertKarma",
    "description": "Allows users to vote on posts by adding karma points with validation for permissions and voting rules.",
    "inputValues": [
      "post_id-number-Post",
      "points-number-Karma"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect post_id (mandatory): The identifier of the post to receive karma\n   - Collect points (mandatory): The number of karma points to assign\n   - System-generated values:\n     * fromUserId: The identifier of the current user\n\n2. Data Validation:\n   2.1. Permission Validation:\n       - IF user does not have karma permission THEN\n         * Display error message \"Karma feature is disabled\"\n         * Terminate process\n       - END IF\n\n   2.2. User Status Validation:\n       - IF current user is anonymous THEN\n         * Display error message \"Anonymous users cannot vote\"\n         * Terminate process\n       - END IF\n\n   2.3. Self-Voting Validation:\n       - Retrieve post details using post_id\n       - IF post author is the same as current user THEN\n         * Display error message \"Users cannot vote on their own posts\"\n         * Terminate process\n       - END IF\n\n   2.4. Previous Vote Validation:\n       - Check if current user has already voted on this post\n       - IF user has already voted THEN\n         * Display error message \"User has already voted on this post\"\n         * Terminate process\n       - END IF\n\n   2.5. Points Range Validation:\n       - IF points is less than minimum allowed karma points THEN\n         * Display error message \"Points below allowed minimum\"\n         * Terminate process\n       - END IF\n       - IF points is greater than maximum allowed karma points THEN\n         * Display error message \"Points above allowed maximum\"\n         * Terminate process\n       - END IF\n\n3. Business Rule Processing:\n   3.1. Prepare Karma Data:\n       - Create new karma record with:\n         * From user ID: Current user's ID\n         * Post user ID: ID of the post author\n         * Post ID: ID of the post receiving karma\n         * Topic ID: ID of the topic containing the post\n         * Points: Number of karma points assigned\n\n4. Core Operation Execution:\n   4.1. Save Karma Record:\n       - Add karma record to the database\n\n   4.2. Update Post Karma Status:\n       - Update the post's karma status with the new points\n       - IF post caching is enabled THEN\n         * Update the post in the cache repository\n       - END IF\n\n5. Response Generation:\n   5.1. Success Response:\n       - Redirect user to the topic page showing the post that received karma\n       - Position the view to show the specific post\n   5.2. Error Response:\n       - Display appropriate error message based on validation failure\n       - Provide link to return to the topic",
    "databaseEntities": [
      "jforum_karma",
      "jforum_posts",
      "jforum_users"
    ],
    "validationRules": [
      "User must have karma permission enabled",
      "Anonymous users cannot vote",
      "Users cannot vote on their own posts",
      "Users can only vote once per post",
      "Karma points must be within the configured minimum and maximum range"
    ],
    "dbSeedingOperations": [
      "System configuration for minimum karma points",
      "System configuration for maximum karma points"
    ],
    "schema": {
      "Karma": {
        "fromUserId": "number",
        "postUserId": "number",
        "postId": "number",
        "topicId": "number",
        "points": "number"
      },
      "KarmaStatus": {
        "postId": "number",
        "karmaPoints": "number"
      }
    }
  },
  {
    "featureName": "ListKarma",
    "description": "Displays karma information with an invalid action message.",
    "inputValues": [],
    "businessLogic": "1. Input Collection:\n   - No user inputs are required for this feature\n   - System automatically processes the request\n\n2. Data Validation:\n   - No input validation required as this is an informational display\n\n3. Business Rule Processing:\n   3.1. Check if user has permission to view karma information\n      IF user does not have permission to view karma THEN\n         Display appropriate error message\n         Exit process\n\n4. Core Operation Execution:\n   4.1. Prepare display context\n      Set the appropriate template for karma list display\n      Create message context with \"invalid action\" notification\n   4.2. Format karma information\n      Retrieve localized message for invalid action\n      Add message to display context\n\n5. Response Generation:\n   5.1. Generate response with karma list template\n      Display the invalid action message\n      Render the karma list template with the prepared context",
    "databaseEntities": [
      "jforum_karma",
      "jforum_users",
      "jforum_posts"
    ],
    "validationRules": [
      "User must have permission to view karma information"
    ],
    "dbSeedingOperations": [],
    "schema": {}
  },
  {
    "featureName": "ShowActivityLog",
    "description": "Displays moderation activity logs with pagination and access control.",
    "inputValues": [
      "startPage-number-Pagination",
      "recordsPerPage-number-Pagination"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect pagination parameters:\n     a. startPage: The starting page number for pagination (system-generated if not provided)\n     b. recordsPerPage: Number of records to display per page (system-generated from system configuration if not provided)\n\n2. Data Validation:\n   - Validate user access permissions:\n     a. Check if current user has moderation log access permission\n     b. IF user lacks required permission THEN\n        i. Generate access denied message\n        ii. Return access denied view\n        iii. STOP PROCESSING\n     c. ELSE continue to next step\n   - Validate pagination parameters:\n     a. Ensure startPage is a positive integer\n     b. Ensure recordsPerPage is a positive integer within system limits\n\n3. Business Rule Processing:\n   - Determine user's permission level:\n     a. Check if user has full moderation log access permission\n     b. Store permission level for later use in filtering displayed information\n   - Calculate pagination values:\n     a. Determine start record index based on startPage and recordsPerPage\n     b. Calculate total pages based on total records and recordsPerPage\n\n4. Core Operation Execution:\n   - Retrieve moderation log entries:\n     a. Fetch log entries from database based on pagination parameters\n     b. For each log entry:\n        i. IF entry references a post THEN\n           - Retrieve associated post information\n           - IF post's forum no longer exists THEN\n             * Remove entry from results\n             * CONTINUE to next entry\n        ii. IF entry references a topic THEN\n           - Retrieve associated topic information\n           - IF topic's forum no longer exists THEN\n             * Remove entry from results\n             * CONTINUE to next entry\n        iii. IF entry contains original message AND user has full moderation access THEN\n           - Format original message for display\n        iv. ELSE IF entry contains original message AND user lacks full access THEN\n           - Hide original message content\n   - Prepare pagination information:\n     a. Calculate total number of pages\n     b. Determine previous and next page numbers if applicable\n     c. Generate page navigation links\n\n5. Response Generation:\n   - Prepare activity log display:\n     a. Format each log entry for display including:\n        i. Action performed\n        ii. User who performed the action\n        iii. Date and time of action\n        iv. Affected content (post/topic) information\n        v. Original message content (if user has full access permission)\n     b. Include pagination controls:\n        i. Current page indicator\n        ii. Previous/next page links\n        iii. Total pages information\n   - Return formatted activity log view with:\n     a. List of moderation activities\n     b. Pagination controls\n     c. Access level indicator",
    "databaseEntities": [
      "jforum_users",
      "jforum_forums",
      "jforum_topics",
      "jforum_posts"
    ],
    "validationRules": [
      "User must have moderation log access permission",
      "Pagination start page must be a positive integer",
      "Records per page must be a positive integer within system limits",
      "Original message content is only visible to users with full moderation log access"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "ModerationLog": {
        "type": "object",
        "properties": {
          "id": {
            "type": "number"
          },
          "userId": {
            "type": "number"
          },
          "actionTime": {
            "type": "date"
          },
          "actionType": {
            "type": "string"
          },
          "postId": {
            "type": "number"
          },
          "topicId": {
            "type": "number"
          },
          "originalMessage": {
            "type": "string"
          }
        }
      },
      "Pagination": {
        "type": "object",
        "properties": {
          "startPage": {
            "type": "number"
          },
          "recordsPerPage": {
            "type": "number"
          },
          "totalRecords": {
            "type": "number"
          },
          "totalPages": {
            "type": "number"
          }
        }
      }
    }
  },
  {
    "featureName": "DoModeration",
    "description": "Performs moderation actions on forum content with return URL handling.",
    "inputValues": [
      "returnUrl-string-Navigation",
      "topicMove-string-Topic",
      "moderationAction-string-Moderation"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect returnUrl (mandatory): The URL to return to after moderation action\n   - Collect topicMove flag (optional): Indicates if topics should be moved\n   - Collect moderationAction (mandatory): The type of moderation action to perform\n   - System retrieves current user session information\n\n2. Data Validation:\n   - Validate user permissions:\n     a. Check if user has moderation privileges\n     b. IF user lacks moderation privileges THEN\n        i. Deny access and display error message\n        ii. END process\n     c. ELSE continue with moderation\n   - Validate returnUrl:\n     a. Check if returnUrl is provided\n     b. IF returnUrl is missing THEN\n        i. Set default return URL to forum index\n   - Validate moderationAction:\n     a. Check if moderationAction is valid\n     b. IF moderationAction is invalid THEN\n        i. Log error\n        ii. Display error message\n        iii. END process\n\n3. Business Rule Processing:\n   - Check forum-specific moderation rules:\n     a. Verify user has moderation rights for the specific forum\n     b. IF user lacks forum-specific rights THEN\n        i. Log unauthorized attempt\n        ii. Display permission denied message\n        iii. END process\n   - Check content status:\n     a. Verify content is available for moderation\n     b. IF content is locked or already moderated THEN\n        i. Log conflict\n        ii. Display appropriate message\n        iii. END process\n\n4. Core Operation Execution:\n   - Process moderation action:\n     a. IF moderationAction is delete THEN\n        i. Mark content for deletion\n        ii. Update related records\n        iii. Log deletion action\n     b. ELSE IF moderationAction is move THEN\n        i. IF topicMove flag is present THEN\n           1. Prepare topic move interface\n           2. Store selected topics for moving\n        ii. ELSE\n           1. Log error for missing move parameters\n           2. Display error message\n           3. END process\n     c. ELSE IF moderationAction is lock/unlock THEN\n        i. Toggle lock status on content\n        ii. Update related records\n        iii. Log lock/unlock action\n     d. ELSE IF moderationAction is approve/reject THEN\n        i. Update content approval status\n        ii. Update related records\n        iii. Log approval action\n   - Create moderation log entry:\n     a. Record user performing action\n     b. Record timestamp\n     c. Record action type\n     d. Record affected content\n     e. Store original content state if applicable\n\n5. Response Generation:\n   - Prepare response based on action:\n     a. IF action requires additional steps (like move) THEN\n        i. Display appropriate interface for next step\n        ii. Include returnUrl for later navigation\n     b. ELSE\n        i. Prepare success message\n        ii. Include returnUrl for navigation\n   - Format response:\n     a. Include action summary\n     b. Include affected content details\n     c. Include navigation options\n     d. IF errors occurred THEN\n        i. Include error details\n        ii. Include recovery options",
    "databaseEntities": [
      "jforum_topics",
      "jforum_posts",
      "jforum_forums",
      "jforum_users",
      "jforum_moderator_groups"
    ],
    "validationRules": [
      "User must have moderation privileges",
      "User must have moderation rights for the specific forum",
      "Content must be available for moderation",
      "Return URL must be valid if provided",
      "Moderation action must be a valid operation"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Moderation": {
        "type": "object",
        "properties": {
          "actionType": {
            "type": "string",
            "enum": [
              "delete",
              "move",
              "lock",
              "unlock",
              "approve",
              "reject"
            ]
          },
          "userId": {
            "type": "integer"
          },
          "contentId": {
            "type": "integer"
          },
          "contentType": {
            "type": "string",
            "enum": [
              "topic",
              "post"
            ]
          },
          "timestamp": {
            "type": "date"
          },
          "originalState": {
            "type": "object"
          }
        }
      }
    }
  },
  {
    "featureName": "MoveTopic",
    "description": "Relocates forum topics to different forums.",
    "inputValues": [
      "topicIds-object-TopicList",
      "targetForumId-number-Forum",
      "returnUrl-string-Navigation"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the following inputs:\n     1.1. topicIds (mandatory): List of topic identifiers to be moved\n     1.2. targetForumId (mandatory): Identifier of the destination forum\n     1.3. returnUrl (optional): URL to return to after operation completion\n\n2. Data Validation:\n   2.1. Validate Topic Selection\n     2.1.1. Check if at least one topic is selected for moving\n     2.1.2. IF no topics are selected, THEN display error message and abort operation\n     2.1.3. Verify that all selected topic IDs exist in the system\n     2.1.4. IF any topic ID is invalid, THEN display error message and abort operation\n   2.2. Validate Target Forum\n     2.2.1. Verify that the target forum ID exists in the system\n     2.2.2. IF target forum does not exist, THEN display error message and abort operation\n     2.2.3. Check if target forum is different from the source forum\n     2.2.4. IF target forum is the same as source forum, THEN display notification and abort operation\n   2.3. Validate User Permissions\n     2.3.1. Check if the current user has moderation permissions for both source and target forums\n     2.3.2. IF user lacks required permissions, THEN display access denied message and abort operation\n\n3. Business Rule Processing:\n   3.1. Check Forum Compatibility\n     3.1.1. Verify that the target forum accepts new topics\n     3.1.2. IF target forum is locked or read-only, THEN display error message and abort operation\n   3.2. Check Topic Status\n     3.2.1. Verify that none of the selected topics are locked by system processes\n     3.2.2. IF any topic is currently locked by a system process, THEN display error message and abort operation\n   3.3. Check Related Dependencies\n     3.3.1. Identify all posts associated with the selected topics\n     3.3.2. Check for any constraints that might prevent topic movement\n     3.3.3. IF any constraints are found, THEN display error message and abort operation\n\n4. Core Operation Execution:\n   4.1. Prepare Move Operation\n     4.1.1. Create a transaction to ensure data consistency\n     4.1.2. For each selected topic, store original forum information for logging purposes\n   4.2. Update Topic Records\n     4.2.1. FOR EACH topic in the selected topics list:\n       4.2.1.1. Update the forum ID reference to the target forum ID\n       4.2.1.2. Update any forum-specific metadata if necessary\n   4.3. Update Forum Statistics\n     4.3.1. Recalculate and update the topic count for the source forum(s)\n     4.3.2. Recalculate and update the topic count for the target forum\n     4.3.3. Update last post information for affected forums if necessary\n   4.4. Create Moderation Log Entry\n     4.4.1. Record the move operation details including user, timestamp, source forum, target forum, and topic IDs\n     4.4.2. Store the log entry in the moderation history\n   4.5. Commit Transaction\n     4.5.1. IF any step fails during execution, THEN rollback all changes\n     4.5.2. IF successful, THEN commit all changes to the database\n\n5. Response Generation:\n   5.1. Prepare Success Response\n     5.1.1. Generate confirmation message indicating successful topic move\n     5.1.2. Include summary of moved topics (count and titles)\n     5.1.3. Provide link to view topics in their new location\n   5.2. Handle Return Navigation\n     5.2.1. IF returnUrl is provided, THEN prepare to redirect user to that location\n     5.2.2. IF returnUrl is not provided, THEN prepare to show the target forum view\n   5.3. Display Completion Page\n     5.3.1. Show success message with operation summary\n     5.3.2. Provide navigation options to relevant pages (source forum, target forum, etc.)",
    "databaseEntities": [
      "jforum_topics",
      "jforum_forums",
      "jforum_posts"
    ],
    "validationRules": [
      "At least one topic must be selected for moving",
      "Target forum must exist in the system",
      "Target forum must be different from source forum",
      "User must have moderation permissions for both source and target forums",
      "Target forum must accept new topics (not locked or read-only)",
      "Selected topics must not be locked by system processes"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "TopicList": {
        "type": "array",
        "items": {
          "type": "number",
          "description": "Unique identifier of a topic to be moved"
        }
      }
    }
  },
  {
    "featureName": "ModerationDone",
    "description": "Completes the moderation process and displays a confirmation to the user.",
    "inputValues": [
      "returnUrl-string-System"
    ],
    "businessLogic": "1. Input Collection\n   - Collect the following inputs:\n     a. returnUrl (string, mandatory): The URL to return to after moderation is complete\n     b. System retrieves current moderation context from the session\n\n2. Data Validation\n   - Validate returnUrl:\n     a. IF returnUrl is null or empty THEN\n        i. Set returnUrl to default forum page\n        ii. Log validation error: \"Return URL is missing\"\n     b. ELSE\n        i. Verify returnUrl is a valid internal system URL\n        ii. IF not valid THEN\n           1. Set returnUrl to default forum page\n           2. Log security warning: \"Invalid return URL attempted\"\n\n3. Business Rule Processing\n   - Verify moderation permissions:\n     a. Check if current user has moderation privileges\n     b. IF user lacks moderation privileges THEN\n        i. Generate access denied message\n        ii. Log unauthorized access attempt\n        iii. RETURN with access denied template\n   - Verify moderation session:\n     a. Check if there is an active moderation session\n     b. IF no active moderation session THEN\n        i. Log error: \"No moderation in progress\"\n        ii. RETURN with error template\n\n4. Core Operation Execution\n   - Process moderation completion:\n     a. Retrieve moderation actions from session\n     b. FOR EACH moderation action in session:\n        i. Mark action as completed in the system\n        ii. Update moderation log with completion timestamp and user information\n        iii. IF action affects topics or posts THEN\n           1. Update relevant topic/post status flags\n           2. Update forum statistics if necessary\n     c. Clear moderation session data\n     d. Generate success notification\n\n5. Response Generation\n   - Prepare confirmation view:\n     a. Set template to moderation completion template\n     b. Include the following in the response context:\n        i. Success message: \"Moderation actions completed successfully\"\n        ii. Summary of moderation actions performed\n        iii. Return URL for navigation back to forum\n     c. IF any warnings occurred during processing THEN\n        i. Include warning messages in the response\n     d. RETURN moderation completion template",
    "databaseEntities": [
      "jforum_topics",
      "jforum_posts",
      "jforum_forums",
      "jforum_users"
    ],
    "validationRules": [
      "User must have moderation privileges to complete moderation",
      "An active moderation session must exist",
      "Return URL must be a valid internal system URL",
      "All moderation actions must be properly recorded in the moderation log"
    ],
    "dbSeedingOperations": [],
    "schema": {}
  },
  {
    "featureName": "ModerateForum",
    "description": "Performs forum moderation actions like removing, moving, locking, or unlocking topics.",
    "inputValues": [
      "topicIds-object-Topic",
      "forumId-number-Forum",
      "toForumId-number-Forum",
      "moderationAction-string-Action",
      "logDescription-string-ModerationLog",
      "logOriginalMessage-string-ModerationLog",
      "returnUrl-string-Navigation"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the following inputs:\n     a. topicIds: List of topic identifiers to be moderated\n     b. forumId: Current forum identifier where topics are located\n     c. toForumId: Target forum identifier (required only for move action)\n     d. moderationAction: Type of moderation action to perform (remove, move, lock, unlock)\n     e. logDescription: Description of the moderation action for logging\n     f. logOriginalMessage: Original content being moderated (if applicable)\n     g. returnUrl: URL to redirect after successful moderation\n\n2. Data Validation:\n   - Validate user permissions:\n     a. Verify user has general moderation access\n     b. Verify user has specific permission for the requested action:\n        i. For remove action: Verify post removal permission\n        ii. For move action: Verify topic move permission\n        iii. For lock/unlock actions: Verify topic lock/unlock permission\n   - Validate topic inputs:\n     a. Ensure at least one topic ID is provided\n     b. Verify all topic IDs exist in the system\n     c. For move action, verify target forum exists and is different from source forum\n   - Validate log information:\n     a. Ensure log description is provided\n     b. Ensure log type is valid\n\n3. Business Rule Processing:\n   - Check system state requirements:\n     a. Verify topics are in a state that allows the requested action\n     b. For move action, verify target forum can accept the topics\n     c. For lock action, verify topics are not already locked\n     d. For unlock action, verify topics are currently locked\n   - Prepare moderation log entry:\n     a. Set current user as the moderator\n     b. Set description and original message\n     c. Set appropriate log type based on action\n     d. Associate with affected topics\n\n4. Core Operation Execution:\n   - Based on moderation action, perform one of the following operations:\n     a. IF action is \"remove\":\n        i. For each topic in the list:\n           - Retrieve complete topic information\n           - Create moderation log entry\n           - Remove the topic and all associated posts\n           - Update forum statistics\n        ii. Clear topic caches\n        iii. Reload most recent topics\n     b. IF action is \"move\":\n        i. For each topic in the list:\n           - Move topic from source forum to target forum\n           - Create moderation log entry\n        ii. Update statistics for both source and target forums\n        iii. Clear topic caches for both forums\n        iv. Reload topic lists and forum information\n     c. IF action is \"lock\":\n        i. For each topic in the list:\n           - Set topic status to locked\n           - Create moderation log entry\n        ii. Clear relevant topic caches\n     d. IF action is \"unlock\":\n        i. For each topic in the list:\n           - Set topic status to unlocked\n           - Create moderation log entry\n        ii. Clear relevant topic caches\n\n5. Response Generation:\n   - Determine operation result status:\n     a. IF operation completed successfully:\n        i. IF return URL is provided:\n           - Redirect user to the specified return URL\n        ii. ELSE:\n           - Display success message with moderation completion details\n     b. IF permission check failed:\n        i. Display access denied message\n        ii. Log unauthorized access attempt\n     c. IF operation failed for other reasons:\n        i. Display appropriate error message\n        ii. Log the failure with details",
    "databaseEntities": [
      "jforum_users",
      "jforum_topics",
      "jforum_forums",
      "jforum_posts",
      "jforum_posts_text"
    ],
    "validationRules": [
      "User must have general moderation permission",
      "User must have specific permission for the requested moderation action",
      "At least one topic ID must be provided",
      "All topic IDs must exist in the system",
      "For move action, target forum must exist and be different from source forum",
      "Moderation log description must be provided"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Topic": {
        "id": "number",
        "title": "string",
        "forumId": "number",
        "postedBy": "number",
        "status": "number"
      },
      "Action": {
        "type": "string",
        "enum": [
          "remove",
          "move",
          "lock",
          "unlock"
        ]
      },
      "ModerationLog": {
        "userId": "number",
        "description": "string",
        "originalMessage": "string",
        "type": "number",
        "topicId": "number",
        "postId": "number"
      }
    }
  },
  {
    "featureName": "RemoveTopics",
    "description": "Deletes forum topics with proper permission checks and updates related forum data.",
    "inputValues": [
      "topic_id-string-Topic",
      "log_description-string-ModerationLog",
      "log_original_message-string-ModerationLog",
      "log_type-number-ModerationLog"
    ],
    "businessLogic": "1. Input Collection:\n   1.1. Collect the following inputs:\n       - topic_id: List of topic identifiers to be removed\n       - log_description: Description of the moderation action\n       - log_original_message: Original message content for logging\n       - log_type: Type of moderation action being performed\n   1.2. System will use the current user's session information for authorization\n\n2. Data Validation:\n   2.1. Validate user permissions:\n       - Check if user has general moderation access\n       - Check if user has specific permission to remove posts\n       - IF permissions are not valid, THEN set status to FAILURE\n   2.2. Validate topic identifiers:\n       - Ensure topic_id values are provided\n       - Verify that each topic_id represents a valid topic\n       - IF no valid topic identifiers are found, THEN abort operation\n\n3. Business Rule Processing:\n   3.1. Check system constraints:\n       - Verify that removing topics won't violate system integrity\n       - Identify all forums affected by the topic removal\n   3.2. Create moderation log entries:\n       - Create a log entry for each topic being removed\n       - Include user ID of moderator performing the action\n       - Include original poster information for each topic\n       - Store description and original message in log\n\n4. Core Operation Execution:\n   4.1. For each topic to be removed:\n       - Retrieve complete topic information\n       - Create and save moderation log entry\n       - Track forum ID for later updates\n       - Clear topic from cache system\n   4.2. Delete all selected topics:\n       - Remove topics and their associated data\n       - Update post counts in related forums\n   4.3. Update forum data:\n       - For each affected forum:\n           - Clear forum cache\n           - Find new last post ID\n           - Update forum's last post reference\n           - Reload forum data\n   4.4. Update global topic repositories:\n       - Refresh most recent topics list\n       - Clear topic caches\n\n5. Response Generation:\n   5.1. IF operation status is SUCCESS:\n       - Redirect user to return URL if provided\n   5.2. IF operation status is FAILURE:\n       - Display access denied message\n       - Show appropriate error information\n   5.3. Return operation status code:\n       - SUCCESS (1): Operation completed successfully\n       - FAILURE (2): Operation failed due to permissions or validation\n       - IGNORE (3): No action taken",
    "databaseEntities": [
      "jforum_topics",
      "jforum_forums",
      "jforum_posts",
      "jforum_users"
    ],
    "validationRules": [
      "User must have general moderation access permission",
      "User must have specific permission to remove posts",
      "At least one valid topic ID must be provided",
      "Topics must exist in the system to be removed"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Topic": {
        "id": "number",
        "forumId": "number",
        "postedBy": "number"
      },
      "ModerationLog": {
        "user": "object",
        "description": "string",
        "originalMessage": "string",
        "type": "number",
        "postId": "number",
        "topicId": "number",
        "posterUser": "number"
      },
      "User": {
        "id": "number"
      }
    }
  },
  {
    "featureName": "MoveTopicsSave",
    "description": "Executes the actual movement of topics between forums with permission validation.",
    "inputValues": [
      "topics-string-Topic",
      "forum_id-number-Forum",
      "to_forum-number-Forum",
      "log_description-string-ModerationLog",
      "log_original_message-string-ModerationLog",
      "log_type-number-ModerationLog",
      "successUrl-string-System"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the following inputs:\n     a. topics: Comma-separated list of topic IDs to be moved\n     b. forum_id: Source forum ID where topics currently reside\n     c. to_forum: Target forum ID where topics will be moved to\n     d. log_description: Description of the moderation action for logging\n     e. log_original_message: Original message content for logging\n     f. log_type: Type of moderation action being performed\n     g. successUrl: URL to redirect after successful operation\n\n2. Data Validation:\n   a. Permission Validation\n      - Verify user has topic movement moderation permission\n      - IF user lacks required permission THEN\n        - Set operation status to FAILURE\n        - Return with access denied message\n      - END IF\n   b. Input Validation\n      - Verify topics parameter is not null or empty\n      - Verify forum_id is a valid positive integer\n      - Verify to_forum is a valid positive integer\n      - Verify source and destination forums are different\n      - IF any validation fails THEN\n        - Set operation status to FAILURE\n        - Return with appropriate error message\n      - END IF\n\n3. Business Rule Processing:\n   a. Forum Access Verification\n      - Verify source forum exists and is accessible\n      - Verify destination forum exists and is accessible\n      - Verify user has access rights to both forums\n   b. Topic Ownership Verification\n      - Verify all topics exist in the source forum\n      - Verify topics are available for movement\n   c. Status Preparation\n      - Set initial operation status to SUCCESS\n\n4. Core Operation Execution:\n   a. Topic Movement\n      - Split the comma-separated topic list into individual topic IDs\n      - FOR each topic ID in the list:\n        - Convert string ID to integer\n        - Add to collection of topics to be moved\n      - END FOR\n      - Move all topics from source forum to destination forum\n   b. Moderation Logging\n      - Create new moderation log entry\n      - Set user ID to current user's ID\n      - Set log description from input\n      - Set log original message from input\n      - Set log type from input\n      - FOR each topic that was moved:\n        - Set topic ID in log\n        - Save moderation log entry\n      - END FOR\n   c. Cache Management\n      - Clear cache for source forum\n      - Clear cache for destination forum\n      - Reload forum data for source forum\n      - Reload forum data for destination forum\n      - Reload most recent topics list\n      - Reload hottest topics list\n\n5. Response Generation:\n   a. Status Handling\n      - IF operation status is FAILURE THEN\n        - Display access denied message\n      - ELSE\n        - Display moderation completed message\n        - Include success URL in the message\n      - END IF\n   b. Return Status\n      - Return the final operation status",
    "databaseEntities": [
      "jforum_topics",
      "jforum_forums",
      "jforum_users"
    ],
    "validationRules": [
      "User must have topic movement moderation permission",
      "Topics parameter must not be null or empty",
      "Source forum ID must be a valid positive integer",
      "Destination forum ID must be a valid positive integer",
      "Source and destination forums must be different",
      "All topics must exist in the source forum",
      "Source forum must exist and be accessible",
      "Destination forum must exist and be accessible"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Topic": {
        "id": "number",
        "forumId": "number",
        "title": "string",
        "status": "number"
      },
      "Forum": {
        "id": "number",
        "name": "string",
        "categoryId": "number"
      },
      "ModerationLog": {
        "id": "number",
        "userId": "number",
        "topicId": "number",
        "description": "string",
        "originalMessage": "string",
        "type": "number"
      }
    }
  },
  {
    "featureName": "SaveModerationLog",
    "description": "Records moderation actions in the system log.",
    "inputValues": [
      "log-object-ModerationLog"
    ],
    "businessLogic": "1. Input Collection\n   - Collect the moderation log object with the following attributes:\n     a. User ID (mandatory) - The ID of the moderator performing the action\n     b. Description (mandatory) - Description of the moderation action\n     c. Original Message (optional) - The original content before moderation\n     d. Type (mandatory) - The type of moderation action performed\n     e. Post ID (optional) - The ID of the post being moderated\n     f. Topic ID (optional) - The ID of the topic being moderated\n     g. Poster User ID (optional) - The ID of the user who created the content being moderated\n\n2. Data Validation\n   - Validate the moderation log data:\n     a. Verify user ID is present and valid\n        IF user ID is missing or invalid THEN\n          Return error message \"Invalid moderator user ID\"\n     b. Verify description is provided\n        IF description is empty THEN\n          Return error message \"Moderation action description is required\"\n     c. Verify moderation type is valid\n        IF type is not a recognized moderation action type THEN\n          Return error message \"Invalid moderation action type\"\n     d. Verify at least one content reference exists\n        IF both post ID and topic ID are null THEN\n          Return error message \"Either post ID or topic ID must be specified\"\n\n3. Business Rule Processing\n   - Check user permissions for moderation\n     a. Verify the user has proper moderation privileges\n        IF user does not have moderation permission THEN\n          Return error message \"User does not have moderation privileges\"\n     b. Verify the user has specific permission for the action type\n        IF user does not have permission for this specific action THEN\n          Return error message \"User does not have permission for this moderation action\"\n\n4. Core Operation Execution\n   - Process the moderation log entry:\n     a. Set the current timestamp for the log entry\n     b. Create a new moderation log record with all provided information\n     c. Store the moderation log entry in the system\n     d. IF storage operation fails THEN\n          Return error message \"Failed to save moderation log entry\"\n\n5. Response Generation\n   - Generate appropriate response:\n     a. IF log entry was successfully saved THEN\n          Return success status with log entry ID\n     b. ELSE\n          Return failure status with error details\n     c. Include timestamp of when the moderation action was logged",
    "databaseEntities": [
      "jforum_users",
      "jforum_topics",
      "jforum_posts"
    ],
    "validationRules": [
      "User ID must be present and valid",
      "Description must not be empty",
      "Moderation type must be a valid action type",
      "Either post ID or topic ID must be specified",
      "User must have moderation privileges",
      "User must have permission for the specific moderation action"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "ModerationLog": {
        "type": "object",
        "properties": {
          "user": {
            "type": "object",
            "properties": {
              "id": {
                "type": "integer",
                "description": "ID of the moderator performing the action"
              }
            },
            "required": [
              "id"
            ]
          },
          "description": {
            "type": "string",
            "description": "Description of the moderation action"
          },
          "originalMessage": {
            "type": "string",
            "description": "The original content before moderation"
          },
          "type": {
            "type": "integer",
            "description": "The type of moderation action performed"
          },
          "postId": {
            "type": "integer",
            "description": "ID of the post being moderated"
          },
          "topicId": {
            "type": "integer",
            "description": "ID of the topic being moderated"
          },
          "posterUser": {
            "type": "object",
            "properties": {
              "id": {
                "type": "integer",
                "description": "ID of the user who created the content being moderated"
              }
            }
          }
        },
        "required": [
          "user",
          "description",
          "type"
        ]
      }
    }
  },
  {
    "featureName": "BuildModerationLogFromRequest",
    "description": "Creates moderation log entries from request parameters.",
    "inputValues": [
      "request-object-RequestContext",
      "log_description-string-ModerationLog",
      "log_original_message-string-ModerationLog",
      "log_type-number-ModerationLog",
      "post_id-number-ModerationLog",
      "topic_id-string-ModerationLog",
      "user_session-object-UserSession"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the following inputs:\n     1.1. Current user session (mandatory, system-generated)\n     1.2. Log description (mandatory, string)\n     1.3. Original message (mandatory, string)\n     1.4. Log type (mandatory, number)\n     1.5. Post ID (optional, number)\n     1.6. Topic ID (optional, string array)\n\n2. Data Validation:\n   2.1. Validate user session:\n      - IF user session is null or invalid THEN\n        - Return error: \"Invalid user session\"\n      - END IF\n   2.2. Validate log description:\n      - IF log description is empty or null THEN\n        - Return error: \"Log description is required\"\n      - END IF\n   2.3. Validate log type:\n      - IF log type is not a valid moderation action type THEN\n        - Return error: \"Invalid moderation log type\"\n      - END IF\n\n3. Business Rule Processing:\n   3.1. Check if topic ID is provided as an array:\n      - IF topic_id parameter contains multiple values THEN\n        - Process as an array of topic IDs\n      - ELSE IF topic_id parameter contains a single value THEN\n        - Process as a single topic ID\n      - END IF\n   3.2. Check if post ID is provided:\n      - IF post_id parameter is present THEN\n        - Validate post ID exists\n      - END IF\n\n4. Core Operation Execution:\n   4.1. Create a new moderation log entry:\n      - Initialize a new moderation log object\n   4.2. Set the user information:\n      - Extract user ID from current session\n      - Create a user object with the ID\n      - Associate user with the moderation log\n   4.3. Set log details:\n      - Set description from request parameter\n      - Set original message from request parameter\n      - Set log type from request parameter\n   4.4. Set related content IDs:\n      - IF post ID is provided THEN\n        - Set post ID in the log\n      - END IF\n      - IF topic ID array has exactly one value THEN\n        - Set topic ID in the log\n      - END IF\n\n5. Response Generation:\n   5.1. Return the populated moderation log object:\n      - Include all set properties (user, description, original message, type, post ID, topic ID)\n   5.2. In case of validation errors:\n      - Return appropriate error message\n      - Include information about which validation failed",
    "databaseEntities": [
      "jforum_users",
      "jforum_topics",
      "jforum_posts"
    ],
    "validationRules": [
      "User session must be valid",
      "Log description must not be empty",
      "Log type must be a valid moderation action type",
      "Post ID must be valid if provided",
      "Topic ID must be valid if provided"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "RequestContext": {
        "properties": {
          "parameter": {
            "type": "function",
            "description": "Gets a string parameter value by name"
          },
          "intParameter": {
            "type": "function",
            "description": "Gets an integer parameter value by name"
          },
          "parameterValues": {
            "type": "function",
            "description": "Gets an array of string parameter values by name"
          }
        }
      },
      "UserSession": {
        "properties": {
          "userId": {
            "type": "number",
            "description": "ID of the current user"
          }
        }
      },
      "ModerationLog": {
        "properties": {
          "user": {
            "type": "object",
            "description": "User who performed the moderation action"
          },
          "description": {
            "type": "string",
            "description": "Description of the moderation action"
          },
          "originalMessage": {
            "type": "string",
            "description": "Original message content before moderation"
          },
          "type": {
            "type": "number",
            "description": "Type of moderation action performed"
          },
          "postId": {
            "type": "number",
            "description": "ID of the post being moderated"
          },
          "topicId": {
            "type": "number",
            "description": "ID of the topic being moderated"
          },
          "posterUser": {
            "type": "object",
            "description": "User who created the original content"
          }
        }
      }
    }
  },
  {
    "featureName": "ListTopicPosts",
    "description": "Displays posts within a topic with pagination, access control, and view tracking.",
    "inputValues": [
      "topic_id-number-Topic",
      "post_id-number-Post",
      "start-number-Pagination"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect topic_id (mandatory) to identify which topic's posts to display\n   - Collect start parameter (optional) for pagination purposes\n   - Collect post_id (optional) for direct navigation to specific post\n\n2. Data Validation:\n   - Validate topic_id exists in the system\n      * IF topic does not exist THEN display topic not found message\n      * IF topic exists THEN proceed with retrieval\n   - Validate user has permission to view the topic\n      * IF user is not logged in AND forum is not publicly accessible THEN redirect to login\n      * IF user is logged in AND does not have access to the forum THEN show access denied\n      * IF user has proper access THEN proceed\n\n3. Business Rule Processing:\n   - Check topic moderation status\n      * IF topic is moderated AND no posts are approved THEN show moderation pending message\n      * IF topic is not moderated OR has approved posts THEN proceed\n   - Determine user permissions for the topic\n      * Check if user can download attachments\n      * Check if user can vote on polls\n      * Check if user can edit posts\n      * Check if user can remove posts\n      * Check if user can post anonymously\n\n4. Core Operation Execution:\n   - Calculate pagination parameters\n      * Determine posts per page from system configuration\n      * Calculate starting post based on pagination parameters\n   - Retrieve topic information\n      * Get topic details including title, status, and view count\n      * IF topic has a poll THEN retrieve poll information\n   - Retrieve posts for the topic\n      * Get posts for the specified page range\n      * Include post content, author information, and timestamps\n   - Process post-related information\n      * Retrieve attachment information for posts\n      * Prepare user signatures and avatars\n      * Get karma/voting information if enabled\n   - Mark topic as read for the current user\n      * Update read status in user's session\n      * Record timestamp of viewing\n   - Increment topic view counter\n      * Update total views for the topic\n\n5. Response Generation:\n   - Prepare display data\n      * Format posts with proper author information\n      * Include pagination information (current page, total pages)\n      * Include topic information (title, status, total replies)\n      * Include forum context (forum name, category)\n      * Include poll information if applicable\n   - Generate navigation elements\n      * Create pagination links\n      * Include topic subscription status\n   - Display the complete topic view\n      * Show posts in chronological order\n      * Highlight the specific post if post_id was provided\n      * Include moderation options for authorized users",
    "databaseEntities": [
      "jforum_users",
      "jforum_topics",
      "jforum_posts",
      "jforum_posts_text",
      "jforum_forums",
      "jforum_categories",
      "jforum_attachments",
      "jforum_karma",
      "jforum_sessions"
    ],
    "validationRules": [
      "Topic must exist in the system",
      "User must have permission to view the forum containing the topic",
      "Posts must be approved if moderation is enabled",
      "Pagination parameters must be valid numbers",
      "User must be logged in to view restricted forums",
      "User must have permission to vote on polls",
      "User must not have already voted on the poll to be able to vote"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Topic": {
        "id": "number",
        "title": "string",
        "forumId": "number",
        "status": "number",
        "totalReplies": "number",
        "totalViews": "number",
        "isVote": "boolean",
        "voteId": "number",
        "isModerated": "boolean"
      },
      "Post": {
        "id": "number",
        "topicId": "number",
        "userId": "number",
        "text": "string",
        "time": "date",
        "hasAttachments": "boolean"
      },
      "Forum": {
        "id": "number",
        "name": "string",
        "categoryId": "number",
        "description": "string"
      },
      "User": {
        "id": "number",
        "username": "string",
        "karma": "number",
        "avatar": "string",
        "signature": "string"
      },
      "Poll": {
        "id": "number",
        "question": "string",
        "options": "object",
        "voteCount": "number"
      }
    }
  },
  {
    "featureName": "NavigateToSpecificPost",
    "description": "Redirects user to the correct page containing a specific post within a topic.",
    "inputValues": [
      "post_id-number-Post",
      "topic_id-number-Topic"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect post_id (mandatory): The unique identifier of the post to navigate to\n   - Collect topic_id (optional): The identifier of the topic containing the post\n\n2. Data Validation:\n   - Validate post_id:\n     a. Ensure post_id is provided\n     b. Verify post_id is a valid number\n     c. If validation fails, display appropriate error message\n   - Validate topic_id (if provided):\n     a. Verify topic_id is a valid number\n     b. If validation fails, display appropriate error message\n\n3. Business Rule Processing:\n   - IF topic_id is not provided THEN:\n     a. Retrieve the post information using post_id\n     b. Extract the topic_id from the retrieved post\n   - Calculate the position of the post within the topic:\n     a. Count the number of posts that appear before the specified post in the topic\n     b. Determine the posts per page setting from system configuration\n   - Determine the correct page number:\n     a. IF count of previous posts is greater than posts per page THEN:\n        i. Calculate the page number using formula: posts_per_page * ((count - 1) / posts_per_page)\n     b. ELSE:\n        i. Set page number to empty (first page)\n\n4. Core Operation Execution:\n   - Construct the destination URL:\n     a. Combine base path with posts/list/\n     b. Append page number and slash if not on first page\n     c. Append topic_id\n     d. Append system extension\n     e. Append fragment identifier with post_id to ensure browser scrolls to the specific post\n   - Set the system to redirect to the constructed URL\n\n5. Response Generation:\n   - Redirect the user to the constructed URL\n   - If any errors occurred during processing:\n     a. Display appropriate error message\n     b. Provide guidance on how to resolve the issue",
    "databaseEntities": [
      "jforum_posts",
      "jforum_topics"
    ],
    "validationRules": [
      "Post ID must be a valid number",
      "Post ID must exist in the database",
      "Topic ID (if provided) must be a valid number"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Post": {
        "id": "number",
        "topicId": "number"
      },
      "Topic": {
        "id": "number"
      }
    }
  },
  {
    "featureName": "ListUserPosts",
    "description": "Retrieves and displays posts made by a specific user with pagination.",
    "inputValues": [
      "userId-number-User",
      "page-number-Pagination"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect userId (mandatory): Numeric identifier of the user whose posts will be displayed\n   - Collect page number (optional): Current page number for pagination\n   - Set postsPerPage (system-generated): Number of posts to display per page from system configuration\n\n2. Data Validation:\n   - Validate userId:\n     a. Check if userId is provided\n     b. Verify userId is a positive integer\n     c. Return error if validation fails: \"Invalid user identifier provided\"\n   - Validate page number:\n     a. If not provided, default to page 1\n     b. Verify page is a positive integer\n     c. Return error if validation fails: \"Invalid page number\"\n\n3. Business Rule Processing:\n   - Verify user exists in the system:\n     a. Retrieve user information using userId\n     b. IF user not found, THEN\n        i. Prepare error message: \"User not found\"\n        ii. Display user not found page\n        iii. END process\n   - Calculate pagination parameters:\n     a. Calculate starting post index based on page number and posts per page\n     b. Calculate total pages based on total posts and posts per page\n   - Check permissions:\n     a. Determine if current user has access to view attachments\n     b. Determine if RSS functionality is enabled in the system\n\n4. Core Operation Execution:\n   - Retrieve user posts:\n     a. Query posts made by the specified user with pagination limits\n     b. Count total number of posts by the user for pagination calculation\n   - For each post retrieved:\n     a. Collect associated topic information\n     b. Collect associated forum information\n     c. Apply any content formatting rules\n     d. Check viewing permissions for each post\n     e. IF user doesn't have permission to view a forum, THEN\n        i. Remove the post from results\n        ii. Decrease total message count\n   - IF no posts found, THEN\n     a. Prepare message: \"No posts found for this user\"\n   - Prepare additional context information:\n     a. Gather forum categories for navigation\n     b. Retrieve karma configuration values\n     c. Determine if attachments are enabled and can be downloaded\n\n5. Response Generation:\n   - Prepare user information for display:\n     a. Include user profile details (username, join date, post count)\n     b. Include user avatar if available\n   - Prepare posts list for display:\n     a. Format each post with creation date, content, and topic reference\n     b. Include links to the original topics\n     c. Include forum information for each post\n     d. Include attachment information if available and permitted\n   - Prepare pagination controls:\n     a. Calculate previous and next page numbers\n     b. Generate page number links based on total pages\n     c. Include first and last page links if applicable\n   - Set page title to include username\n   - Display the complete user posts listing page",
    "databaseEntities": [
      "jforum_users",
      "jforum_posts",
      "jforum_posts_text",
      "jforum_topics",
      "jforum_forums",
      "jforum_categories",
      "jforum_attachments",
      "jforum_karma"
    ],
    "validationRules": [
      "User ID must be a positive integer",
      "User must exist in the system",
      "Page number must be a positive integer",
      "User must have permission to view the posts",
      "User must have permission to view the forums containing the posts",
      "User must have permission to view attachments if present"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "User": {
        "id": "number",
        "username": "string",
        "registrationDate": "date",
        "totalPosts": "number",
        "avatar": "string"
      },
      "Post": {
        "id": "number",
        "topicId": "number",
        "forumId": "number",
        "userId": "number",
        "subject": "string",
        "text": "string",
        "postDate": "date",
        "hasAttachments": "boolean"
      },
      "Topic": {
        "id": "number",
        "forumId": "number",
        "title": "string",
        "status": "number",
        "type": "number"
      },
      "Forum": {
        "id": "number",
        "name": "string",
        "description": "string",
        "categoryId": "number"
      },
      "Pagination": {
        "currentPage": "number",
        "totalPages": "number",
        "postsPerPage": "number",
        "totalPosts": "number",
        "startIndex": "number"
      },
      "Attachment": {
        "id": "number",
        "postId": "number",
        "filename": "string",
        "filesize": "number",
        "contentType": "string"
      }
    }
  },
  {
    "featureName": "ReviewTopicPosts",
    "description": "Shows posts in a topic in reverse chronological order for review purposes.",
    "inputValues": [
      "topic_id-number-Topic"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the topic_id (mandatory) from the user request\n   - System will determine the current user_id from the active session\n\n2. Data Validation:\n   - Validate that topic_id is provided and is a valid number\n     * IF topic_id is missing or invalid, THEN display error message\n   - Validate that the topic exists in the system\n     * IF topic does not exist, THEN display \"Topic not found\" message\n   - Validate user has permission to access the topic's forum\n     * IF user does not have access permission, THEN deny access\n\n3. Business Rule Processing:\n   - Check if the topic is accessible to the current user\n     * Verify the forum permissions for the current user\n     * IF user lacks permission to view the forum, THEN deny access\n   - Determine the number of posts to display per page from system configuration\n   - Calculate the starting position for pagination\n\n4. Core Operation Execution:\n   - Retrieve the topic information based on topic_id\n   - Retrieve all posts for the specified topic with pagination\n     * Get posts starting from the calculated position\n     * Limit results to the configured posts-per-page count\n   - Retrieve information about all users who posted in the topic\n   - Reverse the chronological order of posts (newest first)\n   - Prepare each post for display\n     * Format post content according to display rules\n     * Process any special formatting or tags\n\n5. Response Generation:\n   - Display the topic review page with the following information:\n     * List of posts in reverse chronological order\n     * User information for each post author\n     * Post content with proper formatting\n     * Post metadata (date, time, etc.)\n   - IF no posts are found, THEN display appropriate message",
    "databaseEntities": [
      "jforum_topics",
      "jforum_posts",
      "jforum_users",
      "jforum_forums"
    ],
    "validationRules": [
      "Topic ID must be a valid number",
      "Topic must exist in the system",
      "User must have permission to access the forum containing the topic",
      "Posts must be displayed in reverse chronological order (newest first)"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Topic": {
        "id": "number",
        "forumId": "number",
        "title": "string",
        "status": "number"
      },
      "Post": {
        "id": "number",
        "topicId": "number",
        "userId": "number",
        "forumId": "number",
        "content": "string",
        "postDate": "date"
      },
      "User": {
        "id": "number",
        "username": "string"
      }
    }
  },
  {
    "featureName": "ReplyToTopic",
    "description": "Allows users to reply to an existing topic with permission validation.",
    "inputValues": [
      "topic_id-number-Topic",
      "post_content-string-Post",
      "user_id-number-User",
      "notify-boolean-Notification",
      "attachments-object-Attachment"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect topic_id (mandatory): The identifier of the topic being replied to\n   - Collect post_content (mandatory): The content of the reply\n   - Collect user_id (system-generated): The identifier of the current user\n   - Collect notify (optional): Boolean flag indicating if user wants notifications for future replies\n   - Collect attachments (optional): Any files to be attached to the reply\n\n2. Data Validation:\n   - Validate topic_id:\n      * Verify topic_id is a positive integer\n      * Verify topic exists in the system\n      * IF topic does not exist THEN\n         - Display \"Topic not found\" message\n         - Terminate process\n   - Validate post_content:\n      * Verify post_content is not empty\n      * Verify post_content meets minimum length requirements\n      * Verify post_content does not exceed maximum length\n      * IF content validation fails THEN\n         - Display appropriate error message\n         - Allow user to correct the content\n   - Validate attachments (if provided):\n      * Verify each attachment meets size restrictions\n      * Verify total attachments do not exceed quota limit\n      * Verify file types are permitted\n      * IF attachment validation fails THEN\n         - Display specific error about attachment issues\n         - Allow user to modify attachments\n\n3. Business Rule Processing:\n   - Check user permissions:\n      * Verify user has access to the forum containing the topic\n      * Verify user has permission to reply to topics\n      * IF user lacks necessary permissions THEN\n         - Display \"Insufficient permissions\" message\n         - Terminate process\n   - Check topic status:\n      * Verify topic is not locked\n      * IF topic is locked AND user is not a moderator THEN\n         - Display \"Topic is locked\" message\n         - Terminate process\n   - Check forum status:\n      * Verify forum is not read-only\n      * IF forum is read-only THEN\n         - Display \"Forum is read-only\" message\n         - Terminate process\n   - Check user status:\n      * Verify user is not banned or restricted\n      * IF user is banned THEN\n         - Display appropriate message\n         - Terminate process\n\n4. Core Operation Execution:\n   - Prepare post data:\n      * Generate post timestamp\n      * Format post content according to system rules\n      * Process any special formatting or BBCode\n      * Handle HTML content if permitted for user\n   - Create new post record:\n      * Store post content in database\n      * Link post to the topic\n      * Set user as post author\n      * Update post count for user\n   - Process attachments (if any):\n      * Store attachment files\n      * Create attachment records linked to post\n      * Update user's attachment quota usage\n   - Update topic data:\n      * Update last post information\n      * Update reply count\n      * Update last poster information\n   - Update forum data:\n      * Update last post information\n      * Update post count\n   - Process notification settings:\n      * IF notify is true THEN\n         - Add user to topic notification list\n      * ELSE IF user previously subscribed THEN\n         - Remove user from topic notification list\n   - Send notifications:\n      * Identify users subscribed to topic\n      * Generate notification messages\n      * Queue notifications for delivery\n\n5. Response Generation:\n   - On success:\n      * Display confirmation message\n      * Redirect user to the topic view showing the new reply\n      * Position view to show the newly added post\n   - On failure:\n      * Display detailed error message\n      * Preserve user's post content for correction\n      * Provide guidance on resolving the issue\n   - Include support information:\n      * If system error occurs, provide reference code\n      * Include contact information for support if needed",
    "databaseEntities": [
      "jforum_users",
      "jforum_topics",
      "jforum_posts",
      "jforum_posts_text",
      "jforum_forums",
      "jforum_attachments"
    ],
    "validationRules": [
      "Topic must exist in the system",
      "User must have permission to access the forum",
      "User must have permission to reply to topics",
      "Topic must not be locked (unless user is a moderator)",
      "Forum must not be in read-only mode",
      "Post content must not be empty",
      "Post content must meet minimum length requirements",
      "Post content must not exceed maximum length",
      "Attachments must meet size restrictions",
      "Attachments must be of permitted file types",
      "Total attachments must not exceed quota limit"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Attachment": {
        "type": "object",
        "properties": {
          "file_name": {
            "type": "string",
            "description": "Original name of the uploaded file"
          },
          "file_content": {
            "type": "string",
            "format": "binary",
            "description": "Binary content of the file"
          },
          "file_size": {
            "type": "number",
            "description": "Size of the file in bytes"
          },
          "content_type": {
            "type": "string",
            "description": "MIME type of the file"
          }
        },
        "required": [
          "file_name",
          "file_content",
          "file_size",
          "content_type"
        ]
      }
    }
  },
  {
    "featureName": "CreateNewPost",
    "description": "Enables users to create new posts or topics with attachment support.",
    "inputValues": [
      "title-string-Post",
      "content-string-Post",
      "forumId-number-Forum",
      "topicId-number-Topic",
      "attachments-object-Attachment",
      "notifyOnReplies-boolean-Post",
      "topicType-number-Topic",
      "pollOptions-object-Poll"
    ],
    "businessLogic": "1. Input Collection\n   - Collect the following inputs:\n     a. If creating a new topic:\n        - Forum ID (mandatory)\n        - Topic title (mandatory)\n        - Message content (mandatory)\n        - Topic type (optional, default: normal)\n        - Notification preference (optional, default: false)\n        - Attachments (optional)\n        - Poll options (optional)\n     b. If replying to existing topic:\n        - Topic ID (mandatory)\n        - Message content (mandatory)\n        - Notification preference (optional, default: false)\n        - Attachments (optional)\n\n2. Data Validation\n   - Validate user permissions:\n     a. IF user is not logged in AND anonymous posting is not allowed for the forum THEN\n        - Display error message\n        - Terminate process\n     b. IF forum is read-only THEN\n        - Display error message\n        - Terminate process\n     c. IF creating a new topic AND user only has reply permissions THEN\n        - Display \"reply only\" error message\n        - Terminate process\n     d. IF replying to a topic AND topic is locked AND user is not a moderator THEN\n        - Display \"topic locked\" error message\n        - Terminate process\n   - Validate input fields:\n     a. IF creating a new topic THEN\n        - Verify topic title is not empty\n        - Verify topic title length is within allowed limits\n     b. Verify message content is not empty\n     c. Verify message content length is within allowed limits\n     d. IF attachments are provided THEN\n        - Verify attachments are enabled for the forum\n        - Verify user has permission to add attachments\n        - Verify number of attachments does not exceed maximum allowed\n        - Verify total attachment size does not exceed user's quota\n        - Verify each attachment has valid file extension\n     e. IF poll is provided THEN\n        - Verify user has permission to create polls\n        - Verify poll has at least 2 options\n        - Verify poll options are not empty\n\n3. Business Rule Processing\n   - Check forum accessibility:\n     a. Retrieve forum information using forum ID\n     b. IF forum does not exist THEN\n        - Display error message\n        - Terminate process\n     c. Verify user has access to the specified forum\n   - Check topic accessibility (for replies):\n     a. IF replying to a topic THEN\n        - Retrieve topic information using topic ID\n        - IF topic does not exist THEN\n           - Display \"topic not found\" error message\n           - Terminate process\n        - Verify topic belongs to the specified forum\n   - Process HTML permissions:\n     a. Check if HTML is allowed in the forum for the current user\n     b. IF HTML is not allowed THEN\n        - Strip HTML tags from message content\n   - Process captcha verification:\n     a. IF system requires captcha for posts THEN\n        - Verify captcha input matches expected value\n        - IF captcha verification fails THEN\n           - Display error message\n           - Request new captcha input\n           - Terminate process\n\n4. Core Operation Execution\n   - Prepare post data:\n     a. Create new post object with collected data\n     b. Set user ID from current session\n     c. Set post creation date to current time\n     d. Process message text (format BBCode, smilies, etc.)\n   - Save post to database:\n     a. IF creating new topic THEN\n        - Create new topic record\n        - Set first post ID to the new post\n        - Set topic type (normal, sticky, announcement)\n        - IF poll options provided THEN\n           - Create new poll record\n           - Associate poll with topic\n     b. Save post content to database\n     c. Update forum statistics (post count, last post info)\n     d. Update user statistics (post count)\n   - Process attachments:\n     a. IF attachments are provided THEN\n        - For each attachment:\n           - Save attachment metadata\n           - Associate attachment with post\n           - Update user's quota usage\n   - Set notification preferences:\n     a. IF user requested notifications THEN\n        - Add user to topic notification list\n\n5. Response Generation\n   - Generate success response:\n     a. IF operation successful THEN\n        - Prepare confirmation message\n        - Include link to newly created post/topic\n        - Redirect user to the appropriate page\n     b. IF any errors occurred THEN\n        - Display specific error messages\n        - Preserve user input for correction\n        - Provide guidance on resolving issues",
    "databaseEntities": [
      "jforum_users",
      "jforum_forums",
      "jforum_topics",
      "jforum_posts",
      "jforum_posts_text",
      "jforum_attachments",
      "jforum_sessions"
    ],
    "validationRules": [
      "User must have permission to post in the selected forum",
      "Forum must exist and be accessible to the user",
      "When replying, topic must exist and be accessible to the user",
      "When replying, topic must not be locked unless user is a moderator",
      "When creating a topic, user must have topic creation permission",
      "Message content cannot be empty",
      "Topic title cannot be empty when creating a new topic",
      "Attachments must not exceed the maximum allowed number per post",
      "Attachments total size must not exceed user's quota limit",
      "User must pass captcha verification if enabled",
      "Poll must have at least 2 options if provided",
      "User must have permission to create polls if poll is provided",
      "User must have permission to create sticky/announcement topics if specified"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Attachment": {
        "type": "object",
        "properties": {
          "fileName": {
            "type": "string"
          },
          "fileContent": {
            "type": "string",
            "format": "binary"
          },
          "fileSize": {
            "type": "number"
          },
          "contentType": {
            "type": "string"
          }
        }
      },
      "Poll": {
        "type": "object",
        "properties": {
          "question": {
            "type": "string"
          },
          "options": {
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "length": {
            "type": "number"
          },
          "allowMultipleVotes": {
            "type": "boolean"
          }
        }
      }
    }
  },
  {
    "featureName": "EditPost",
    "description": "Provides functionality to edit existing posts with permission checks.",
    "inputValues": [
      "post_id-number-Post",
      "post_content-string-Post",
      "subject-string-Post",
      "notify-boolean-Post",
      "attachments-object-Attachment",
      "topic_type-number-Topic",
      "poll-object-Poll",
      "preview-boolean-Post"
    ],
    "businessLogic": "1. Input Collection\n   - Collect the following inputs:\n     a. post_id (mandatory): Unique identifier of the post to edit\n     b. post_content (mandatory): Updated content for the post\n     c. subject (mandatory for first posts in topics): Updated subject line\n     d. notify (optional): Boolean indicating if user wants notifications\n     e. attachments (optional): Files to be attached to the post\n     f. topic_type (optional): Type of topic (normal, sticky, announcement)\n     g. poll (optional): Poll information if the post is the first in a topic\n     h. preview (optional): Boolean indicating if user wants to preview before saving\n\n2. Data Validation\n   - Validate post existence\n     a. Check if post with given post_id exists in the system\n     b. IF post not found, THEN\n        i. Display \"Post not found\" message\n        ii. End process\n   - Validate input fields\n     a. Ensure post_content is not empty\n     b. IF post is the first post in a topic, THEN\n        i. Ensure subject is not empty\n        ii. Validate subject length (minimum 2 characters, maximum 100 characters)\n     c. Validate attachments\n        i. Check if attachments are enabled for the forum\n        ii. Verify attachment size against quota limits\n        iii. Verify number of attachments against maximum allowed\n        iv. Validate file types against allowed extensions\n     d. Validate poll data if provided\n        i. Ensure poll has at least two options\n        ii. Verify poll question is not empty\n\n3. Business Rule Processing\n   - Permission verification\n     a. Determine if current user is the post author\n     b. Determine if current user has moderation privileges\n     c. IF user is neither post author nor moderator, THEN\n        i. Display \"Cannot edit post\" message\n        ii. End process\n   - Topic status verification\n     a. Retrieve topic information for the post\n     b. IF topic is locked AND user is not a moderator, THEN\n        i. Display \"Topic locked\" message\n        ii. End process\n   - Forum access verification\n     a. Check if user has access to the forum containing the post\n     b. IF user does not have access, THEN\n        i. Display access denied message\n        ii. End process\n   - Time limit verification\n     a. IF system has edit time limits AND user is not a moderator, THEN\n        i. Calculate time elapsed since post creation\n        ii. IF time elapsed exceeds allowed edit time, THEN\n           1. Display \"Edit time expired\" message\n           2. End process\n   - Special permissions checking\n     a. IF post is first post in topic AND topic_type is changed, THEN\n        i. Verify user has permission to create sticky/announcement topics\n     b. IF poll is being added or modified, THEN\n        i. Verify user has permission to create polls\n     c. IF HTML is used in post_content, THEN\n        i. Verify user has permission to use HTML in posts\n\n4. Core Operation Execution\n   - Preview handling\n     a. IF preview is requested, THEN\n        i. Prepare post with new content for display\n        ii. Show edit form with preview of post\n        iii. Retain all user inputs for further editing\n        iv. End process (no database changes)\n   - Prepare post data\n     a. Update post content with new post_content\n     b. IF post is first post in topic AND subject was changed, THEN\n        i. Update topic title as well\n     c. Set last edit time to current time\n     d. Set last edit user to current user\n     e. IF moderation logging is enabled AND user is a moderator editing another user's post, THEN\n        i. Store original message for moderation log\n        ii. Create moderation log entry\n   - Handle attachments\n     a. IF attachments feature is enabled, THEN\n        i. Process any new attachments uploaded\n        ii. Remove any attachments marked for deletion\n   - Handle poll changes\n     a. IF post is first post in topic, THEN\n        i. IF new poll provided AND topic didn't have poll before, THEN\n           1. Create new poll and associate with topic\n        ii. IF poll provided AND topic already had poll, THEN\n           1. Update existing poll with new options\n        iii. IF no poll provided AND topic had poll before, THEN\n           1. Delete existing poll\n   - Handle topic type changes\n     a. IF post is first post in topic AND topic_type changed, THEN\n        i. Update topic type in database\n   - Update notification preferences\n     a. IF notify parameter is present, THEN\n        i. Update user notification settings for this topic\n     b. IF notify parameter is not present, THEN\n        i. Remove any existing notification subscription\n   - Save changes\n     a. Update post record in database\n     b. IF post is first post in topic AND subject or topic type changed, THEN\n        i. Update topic record in database\n     c. IF operation fails at any point, THEN\n        i. Roll back any partial changes\n        ii. Display error message\n        iii. End process\n\n5. Response Generation\n   - Generate success response\n     a. Prepare confirmation message\n     b. Determine appropriate redirect location\n        i. Redirect to topic view showing the edited post\n     c. Include any warning messages about attachments if applicable\n     d. Include any information about moderation if post requires approval",
    "databaseEntities": [
      "jforum_posts",
      "jforum_posts_text",
      "jforum_topics",
      "jforum_users",
      "jforum_attachments",
      "jforum_forums",
      "jforum_polls",
      "jforum_vote_results",
      "jforum_moderation_log"
    ],
    "validationRules": [
      "User must be logged in to edit posts",
      "User must be either the post author or a moderator to edit a post",
      "Post content cannot be empty",
      "Subject cannot be empty for first posts in topics",
      "Cannot edit posts in locked topics unless user is a moderator",
      "User must have access to the forum containing the post",
      "Attachments must comply with size and quantity limits",
      "Attachments must be of allowed file types",
      "Only users with appropriate permissions can create sticky or announcement topics",
      "Only users with appropriate permissions can create or edit polls",
      "Polls must have at least two options",
      "HTML usage in posts is restricted to users with HTML permission"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Attachment": {
        "type": "object",
        "properties": {
          "id": {
            "type": "number",
            "description": "Unique identifier for the attachment"
          },
          "filename": {
            "type": "string",
            "description": "Original name of the uploaded file"
          },
          "fileContent": {
            "type": "string",
            "description": "Binary content of the file"
          },
          "filesize": {
            "type": "number",
            "description": "Size of the file in bytes"
          },
          "deleteAttachment": {
            "type": "boolean",
            "description": "Flag indicating if attachment should be deleted"
          }
        }
      },
      "Poll": {
        "type": "object",
        "properties": {
          "id": {
            "type": "number",
            "description": "Unique identifier for the poll"
          },
          "question": {
            "type": "string",
            "description": "The poll question"
          },
          "options": {
            "type": "array",
            "items": {
              "type": "string",
              "description": "Poll option text"
            },
            "description": "Available options for the poll"
          },
          "length": {
            "type": "number",
            "description": "Duration of the poll in days"
          }
        }
      }
    }
  },
  {
    "featureName": "QuotePost",
    "description": "Creates a reply to a post with quoted content after validating access permissions.",
    "inputValues": [
      "post_id-number-Post",
      "message-string-Post",
      "subject-string-Post",
      "notify-boolean-Post"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect post_id (mandatory): The ID of the post being quoted\n   - Collect message (mandatory): The reply text content\n   - Collect subject (mandatory): The subject line for the reply\n   - Collect notify (optional): Boolean indicating if user wants notifications\n   - System generates: current user ID, current timestamp\n\n2. Data Validation:\n   - Validate post_id:\n      * Verify post_id exists in the system\n      * Check if post requires moderation\n      * IF post requires moderation THEN\n        - Return error: \"Post not moderated yet\"\n      * END IF\n   - Validate message:\n      * Verify message is not empty\n      * Check message length against system limits\n   - Validate subject:\n      * Verify subject is not empty\n      * Check subject length against system limits\n\n3. Business Rule Processing:\n   - Check user permissions:\n      * Verify if anonymous posting is allowed in the forum\n      * IF anonymous posting not allowed AND user not logged in THEN\n        - Return error: \"Login required to post\"\n      * END IF\n   - Retrieve topic information:\n      * Get topic details using the post's topic ID\n      * IF topic not found THEN\n        - Return error: \"Topic not found\"\n      * END IF\n   - Check topic accessibility:\n      * Verify user has access to the forum where topic exists\n      * IF user does not have access THEN\n        - Return error: \"Access denied\"\n      * END IF\n   - Check topic status:\n      * IF topic is locked AND user is not a moderator THEN\n        - Return error: \"Topic is locked\"\n      * END IF\n   - Check attachment permissions:\n      * Verify if attachments are enabled for the forum\n      * Calculate attachment size limits based on user quota\n   - Check HTML permissions:\n      * Determine if HTML is allowed in posts for this forum\n\n4. Core Operation Execution:\n   - Prepare quoted content:\n      * Retrieve original post content\n      * Retrieve original post author username\n      * Format quoted content with author attribution\n   - Create new post record:\n      * Set post subject (typically \"Re: [Original Subject]\")\n      * Set post message with quoted content\n      * Set post creation time\n      * Set user ID of poster\n      * Set topic ID\n      * Set forum ID\n   - Process attachments if present:\n      * Validate attachment sizes against quota\n      * Validate attachment types\n      * Store attachment metadata\n      * Store attachment files\n   - Handle notification preferences:\n      * IF notify is selected THEN\n        - Add user to topic notification list\n      * ELSE\n        - Remove user from topic notification list if present\n      * END IF\n   - Update topic statistics:\n      * Increment reply count\n      * Update last post information\n      * Update last post time\n\n5. Response Generation:\n   - On success:\n      * Return confirmation message: \"Reply posted successfully\"\n      * Provide link to view the new post\n      * Update topic view with new post included\n   - On error:\n      * Return specific error message based on validation failure\n      * Preserve user input for correction\n      * Provide guidance on resolving the issue",
    "databaseEntities": [
      "jforum_users",
      "jforum_topics",
      "jforum_posts",
      "jforum_posts_text",
      "jforum_forums",
      "jforum_attachments"
    ],
    "validationRules": [
      "Post ID must exist in the system",
      "Post must not require moderation",
      "Topic must not be locked unless user is a moderator",
      "User must have access permissions to the forum",
      "Message content cannot be empty",
      "Subject cannot be empty",
      "Attachments must not exceed user quota limits",
      "Attachments must be of allowed file types"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Post": {
        "id": "number",
        "userId": "number",
        "topicId": "number",
        "forumId": "number",
        "subject": "string",
        "text": "string",
        "creationTime": "date",
        "hasAttachments": "boolean"
      },
      "Topic": {
        "id": "number",
        "forumId": "number",
        "title": "string",
        "status": "number",
        "firstPostId": "number",
        "lastPostId": "number",
        "type": "number",
        "isVote": "boolean",
        "voteId": "number"
      },
      "Forum": {
        "id": "number",
        "name": "string",
        "description": "string",
        "categoryId": "number"
      },
      "User": {
        "id": "number",
        "username": "string",
        "notifyOnMessagesEnabled": "boolean"
      },
      "Attachment": {
        "id": "number",
        "postId": "number",
        "userId": "number",
        "fileName": "string",
        "fileSize": "number",
        "contentType": "string"
      }
    }
  },
  {
    "featureName": "EditSavePost",
    "description": "Saves edited post content with attachments and handles poll modifications.",
    "inputValues": [
      "post_id-number-Post",
      "message-string-Post",
      "subject-string-Post",
      "topic_type-number-Topic",
      "notify-boolean-Notification",
      "poll-object-Poll",
      "attachments-object-Attachments"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect post_id (mandatory): Identifier of the post being edited\n   - Collect message (mandatory): The updated content of the post\n   - Collect subject (mandatory): The updated title of the post\n   - Collect topic_type (optional): The type of topic (normal, sticky, announcement)\n   - Collect notify (optional): Boolean indicating if user wants notifications\n   - Collect poll information (optional): Poll title, options, and settings\n   - Collect attachments (optional): Files to be attached to the post\n\n2. Data Validation:\n   - Validate post existence:\n     2.1. Check if post with provided post_id exists\n     2.2. IF post not found, THEN display error message and exit\n   - Validate edit permissions:\n     2.3. Check if current user has permission to edit the post\n     2.4. IF user cannot edit, THEN display permission error and exit\n   - Validate message content:\n     2.5. Check if message is not empty\n     2.6. Check if message meets minimum length requirements\n     2.7. Check if message meets maximum length requirements\n   - Validate subject:\n     2.8. Check if subject is not empty\n     2.9. Check if subject meets length requirements\n   - Validate attachments:\n     2.10. Check if attachments are within size limits\n     2.11. Check if number of attachments is within allowed limit\n     2.12. Verify attachment file types are permitted\n   - Validate poll (if provided):\n     2.13. Check if poll has a title\n     2.14. Verify poll has at least two options\n     2.15. Check if poll options are not empty\n\n3. Business Rule Processing:\n   - Check topic accessibility:\n     3.1. Retrieve topic associated with the post\n     3.2. Check if user has access to the forum containing the topic\n     3.3. IF forum is not accessible, THEN display error and exit\n   - Check topic lock status:\n     3.4. Check if topic is locked\n     3.5. IF topic is locked AND user is not a moderator, THEN display locked message and exit\n   - Check post moderation status:\n     3.6. Check if post requires moderation\n     3.7. IF post needs moderation, THEN handle accordingly\n   - Process poll modifications (if first post):\n     3.8. Check if post is the first post of the topic\n     3.9. IF first post, THEN check if poll should be added, modified, or removed\n\n4. Core Operation Execution:\n   - Update post data:\n     4.1. Update post content with new message\n     4.2. Update post subject if changed\n     4.3. Save updated post to database\n   - Process attachments:\n     4.4. Process any new attachments uploaded with the edit\n     4.5. Remove any attachments marked for deletion\n     4.6. Associate remaining and new attachments with the post\n   - Handle topic updates (if first post):\n     4.7. IF post is first post of topic, THEN update topic title\n     4.8. IF user has permission AND topic type changed, THEN update topic type\n   - Process poll changes (if applicable):\n     4.9. IF new poll added, THEN create poll and associate with topic\n     4.10. IF existing poll modified, THEN update poll options and settings\n     4.11. IF poll removed, THEN delete poll from database\n   - Handle notification preferences:\n     4.12. Update user notification settings for this topic based on input\n   - Log moderation activity (if applicable):\n     4.13. IF editor is moderator AND not post owner, THEN log moderation action\n\n5. Response Generation:\n   - Generate success response:\n     5.1. Prepare confirmation message about successful edit\n     5.2. Determine correct page to display after edit\n     5.3. Generate navigation link to return to topic view\n   - Handle preview mode:\n     5.4. IF preview requested, THEN format post for display\n     5.5. Show preview with edit form to allow further changes\n   - Error response handling:\n     5.6. IF any errors occurred, THEN display appropriate error message\n     5.7. Preserve user input to allow correction and resubmission",
    "databaseEntities": [
      "jforum_posts",
      "jforum_posts_text",
      "jforum_topics",
      "jforum_forums",
      "jforum_users",
      "jforum_attachments",
      "jforum_quota_limit",
      "jforum_extension_groups"
    ],
    "validationRules": [
      "User must have permission to edit the post",
      "Post must exist in the system",
      "Message content cannot be empty",
      "Subject cannot be empty",
      "Topic must not be locked unless user is a moderator",
      "Forum must be accessible to the user",
      "Attachments must not exceed size quota",
      "Number of attachments must not exceed maximum allowed",
      "Poll must have at least two options if included",
      "Only the first post of a topic can have a poll",
      "Only users with appropriate permissions can create sticky or announcement topics"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Poll": {
        "type": "object",
        "properties": {
          "id": {
            "type": "number"
          },
          "title": {
            "type": "string"
          },
          "options": {
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "voteId": {
            "type": "number"
          }
        }
      },
      "Attachments": {
        "type": "object",
        "properties": {
          "files": {
            "type": "array",
            "items": {
              "type": "object"
            }
          },
          "deletedAttachments": {
            "type": "array",
            "items": {
              "type": "number"
            }
          }
        }
      }
    }
  },
  {
    "featureName": "InsertSave",
    "description": "Creates new posts or topics with validation, attachments, polls, and notification handling.",
    "inputValues": [
      "forum_id-number-Forum",
      "topic_id-number-Topic",
      "subject-string-Post",
      "message-string-Post",
      "topic_type-number-Topic",
      "notify-boolean-Subscription",
      "attach_sig-boolean-User",
      "quick-boolean-Post",
      "captcha_anwser-string-Security",
      "preview-boolean-Post",
      "poll-object-Poll"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect forum ID (mandatory)\n   - Collect topic ID (optional - if not provided, a new topic will be created)\n   - Collect post message (mandatory)\n   - Collect post subject (mandatory for new topics, optional for replies)\n   - Collect topic type (optional - normal, sticky, or announcement)\n   - Collect notification preference (optional)\n   - Collect signature attachment preference (optional)\n   - Collect poll information (optional)\n   - Collect captcha answer (conditional - if system requires it)\n   - Collect preview flag (optional)\n\n2. Data Validation:\n   2.1. User Authentication Validation:\n      - IF user is not logged in AND anonymous posting is not allowed for the forum THEN\n         - Return error message about required login\n         - Redirect to login page\n      - END IF\n\n   2.2. Forum Access Validation:\n      - IF forum is not accessible to current user THEN\n         - Return access denied error\n         - Abort operation\n      - END IF\n\n   2.3. Forum Status Validation:\n      - IF forum is read-only AND this is a new topic THEN\n         - Return error message about read-only status\n         - Abort operation\n      - END IF\n      - IF forum is reply-only AND this is a new topic THEN\n         - Return error message about reply-only status\n         - Abort operation\n      - END IF\n\n   2.4. Topic Status Validation (for replies):\n      - IF topic exists THEN\n         - Verify topic ID is valid\n         - IF topic is locked THEN\n            - Return error message about locked topic\n            - Abort operation\n         - END IF\n      - END IF\n\n   2.5. Content Validation:\n      - IF post message is empty THEN\n         - Return error message about required content\n         - Redisplay form with entered data\n         - Abort operation\n      - END IF\n      - IF new topic AND subject is empty THEN\n         - Return error message about required subject\n         - Redisplay form with entered data\n         - Abort operation\n      - END IF\n\n   2.6. Poll Validation (if provided):\n      - IF poll is included AND poll has fewer than 2 options THEN\n         - Return error message about minimum poll options\n         - Redisplay form with entered data\n         - Abort operation\n      - END IF\n\n   2.7. Captcha Validation (if enabled):\n      - IF captcha is required AND captcha answer is incorrect THEN\n         - Return error message about invalid captcha\n         - Redisplay form with entered data\n         - Abort operation\n      - END IF\n\n   2.8. Post Timing Validation:\n      - IF minimum delay between posts is configured THEN\n         - Check time since user's last post\n         - IF elapsed time is less than required delay THEN\n            - Return error message about posting too soon\n            - Redisplay form with entered data\n            - Abort operation\n         - END IF\n      - END IF\n\n3. Business Rule Processing:\n   3.1. Preview Processing:\n      - IF preview flag is set THEN\n         - Prepare post for preview display\n         - Show preview along with form for editing\n         - Abort further processing\n      - END IF\n\n   3.2. Attachment Processing:\n      - IF attachments are included THEN\n         - Validate attachment sizes and types\n         - IF any attachment validation fails THEN\n            - Return error message about invalid attachment\n            - Redisplay form with entered data\n            - Abort operation\n         - END IF\n      - END IF\n\n   3.3. Moderation Status Determination:\n      - Set moderation flag to FALSE\n      - IF forum is moderated AND user does not have moderation exemption THEN\n         - Set moderation flag to TRUE\n      - END IF\n      - IF this is a reply AND user has permission to reply without moderation THEN\n         - Set moderation flag to FALSE\n      - END IF\n\n4. Core Operation Execution:\n   4.1. Topic Creation (if new topic):\n      - Create new topic record with:\n         - Forum ID\n         - Title (from subject input)\n         - Creation time (current time)\n         - Moderation status\n         - Posted by user information\n      - Save topic to database and get topic ID\n\n   4.2. Poll Creation (if applicable):\n      - IF poll is included AND this is a new topic THEN\n         - Create poll record with topic ID\n         - Save poll options\n         - Update topic with poll ID\n      - END IF\n\n   4.3. Post Creation:\n      - Create post record with:\n         - Topic ID\n         - Forum ID\n         - User ID\n         - Post content\n         - Post time\n         - Subject\n         - Moderation status\n      - Save post to database and get post ID\n\n   4.4. Topic Update:\n      - IF new topic THEN\n         - Update topic with first post ID\n      - END IF\n      - IF post is not moderated THEN\n         - Update topic with last post information\n      - END IF\n\n   4.5. Attachment Processing:\n      - IF attachments are included THEN\n         - Save attachments associated with the post\n      - END IF\n\n   4.6. Subscription Handling:\n      - IF notification requested THEN\n         - Add user to topic notification list\n      - ELSE\n         - Remove user from topic notification list if previously subscribed\n      - END IF\n\n   4.7. Statistics Update (if post not moderated):\n      - Increment user post count\n      - Update topic reply count (if reply)\n      - Update topic view count\n      - Update forum statistics\n      - Update board status\n\n5. Response Generation:\n   5.1. For Moderated Posts:\n      - Redirect to waiting moderation page\n      - Display message about post requiring moderation\n\n   5.2. For Non-Moderated Posts:\n      - Determine correct page number for viewing the post\n      - Generate redirect URL to the post\n      - IF new topic THEN\n         - Notify users subscribed to forum about new topic\n      - ELSE\n         - Notify users subscribed to topic about new reply\n      - END IF\n      - Update session with last post time\n      - Update topics read time for user",
    "databaseEntities": [
      "jforum_topics",
      "jforum_posts",
      "jforum_posts_text",
      "jforum_forums",
      "jforum_users",
      "jforum_attachments",
      "jforum_sessions"
    ],
    "validationRules": [
      "User must have permission to post in the forum",
      "Forum must not be read-only for new topics",
      "Topic must not be locked for replies",
      "Post message must not be empty",
      "New topics must have a subject",
      "Polls must have at least 2 options",
      "Captcha answer must be correct if captcha is enabled",
      "Minimum time between posts must be respected",
      "Attachments must meet size and type requirements",
      "User must have permission to create sticky/announcement topics"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Poll": {
        "id": "number",
        "topicId": "number",
        "options": "array",
        "length": "number"
      },
      "Topic": {
        "id": "number",
        "forumId": "number",
        "title": "string",
        "status": "number",
        "type": "number",
        "firstPostId": "number",
        "lastPostId": "number",
        "time": "date",
        "moderated": "boolean"
      },
      "Post": {
        "id": "number",
        "topicId": "number",
        "forumId": "number",
        "userId": "number",
        "text": "string",
        "subject": "string",
        "time": "date",
        "moderate": "boolean"
      }
    }
  },
  {
    "featureName": "WaitingModeration",
    "description": "Displays a waiting for moderation message after posting content requiring approval.",
    "inputValues": [
      "topic_id-number-Topic",
      "forum_id-number-Forum"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect topic_id (number, optional): The identifier of the topic if the post is a reply\n   - Collect forum_id (number, required): The identifier of the forum where content was posted\n   - System determines if this is a new topic (topic_id is 0) or a reply to existing topic\n\n2. Data Validation:\n   - Validate forum_id exists in the system\n     * IF forum_id is invalid or not provided\n       THEN display error message and terminate process\n   - Validate topic_id if provided\n     * IF topic_id is provided but does not exist\n       THEN display error message and terminate process\n\n3. Business Rule Processing:\n   - Determine appropriate return path based on post type\n     * IF topic_id is 0 (new topic submission)\n       THEN set return path to forum view\n     * ELSE set return path to topic view\n   - Format the complete return path with system extension\n     * Combine base path with appropriate identifier (forum_id or topic_id)\n     * Append system extension to create complete URL\n\n4. Core Operation Execution:\n   - Set template to display waiting for moderation message\n   - Prepare context with appropriate message\n     * Include formatted return path in the message\n     * Format message using localization system with appropriate parameters\n   - Store message in context for template rendering\n\n5. Response Generation:\n   - Display waiting for moderation template to user\n   - Show informative message explaining that content requires approval\n   - Provide link to return to appropriate location (forum or topic)\n   - Ensure user understands next steps in the moderation process",
    "databaseEntities": [
      "jforum_topics",
      "jforum_forums",
      "jforum_posts"
    ],
    "validationRules": [
      "Forum ID must exist in the system",
      "Topic ID must exist in the system if provided",
      "User must have permission to post in the specified forum"
    ],
    "dbSeedingOperations": [],
    "schema": {}
  },
  {
    "featureName": "NotModeratedYetNotification",
    "description": "Shows notification that content has not been moderated yet.",
    "inputValues": [
      "postId-number-Post",
      "topicId-number-Topic",
      "forumId-number-Forum"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect postId (number): Identifier of the post being viewed\n   - Collect topicId (number): Identifier of the topic containing the post\n   - Collect forumId (number): Identifier of the forum containing the topic\n   - System will determine current user session information\n\n2. Data Validation:\n   - Validate postId:\n     a. Check if postId is provided and is a valid number\n     b. If invalid, display appropriate error message\n   - Validate topicId:\n     a. Check if topicId is provided and is a valid number\n     b. If invalid, display appropriate error message\n   - Validate forumId:\n     a. Check if forumId is provided and is a valid number\n     b. If invalid, display appropriate error message\n   - Validate user permissions:\n     a. Check if current user has permission to view the specified forum\n     b. If not authorized, display access denied message\n\n3. Business Rule Processing:\n   - Check moderation status:\n     a. Retrieve post information from database\n     b. Check if post requires moderation\n     c. IF post is marked for moderation AND post has not been approved yet:\n        i. Proceed to notification display\n     d. ELSE:\n        i. Redirect to normal post view\n   - Check user role:\n     a. Determine if current user is a moderator or administrator\n     b. IF user is moderator or administrator:\n        i. Include additional context information about moderation options\n\n4. Core Operation Execution:\n   - Prepare notification message:\n     a. Generate appropriate message indicating content awaits moderation\n     b. Include any relevant timestamps or status information\n   - Set template for display:\n     a. Select the not-moderated-yet template\n     b. Populate template with notification message\n   - Record view activity:\n     a. Log that user has viewed the moderation notification\n     b. Update any relevant tracking metrics\n\n5. Response Generation:\n   - Display notification page:\n     a. Show message explaining that content has not been moderated yet\n     b. IF user is original content creator:\n        i. Include estimated wait time for moderation if available\n     c. Provide navigation options:\n        i. Return to forum view\n        ii. Return to topic list\n   - Include appropriate next steps:\n     a. For regular users: options to browse other content\n     b. For moderators: link to moderation queue if applicable",
    "databaseEntities": [
      "jforum_posts",
      "jforum_topics",
      "jforum_forums",
      "jforum_users",
      "jforum_sessions"
    ],
    "validationRules": [
      "Post ID must be a valid number if provided",
      "Topic ID must be a valid number if provided",
      "Forum ID must be a valid number if provided",
      "User must have permission to view the specified forum",
      "Post must exist in the database",
      "Post must be marked for moderation to show this notification"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Post": {
        "id": "number",
        "topicId": "number",
        "forumId": "number",
        "userId": "number",
        "subject": "string",
        "text": "string",
        "time": "date",
        "isModerated": "boolean",
        "isApproved": "boolean"
      },
      "Topic": {
        "id": "number",
        "forumId": "number",
        "title": "string",
        "status": "number",
        "isModerated": "boolean",
        "lastPostId": "number",
        "firstPostId": "number"
      },
      "Forum": {
        "id": "number",
        "name": "string",
        "description": "string",
        "isModerated": "boolean"
      }
    }
  },
  {
    "featureName": "EnsurePollMinimumOptions",
    "description": "Validates that polls have at least two options before allowing submission.",
    "inputValues": [
      "post-object-Post",
      "poll-object-Poll"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the Post object containing message content and metadata\n   - Collect the Poll object containing poll options\n   - System retrieves current request context\n\n2. Data Validation:\n   - Validate Poll Structure:\n     a. Check if poll object exists\n     b. Verify poll options collection is accessible\n     c. Count the number of poll options\n     d. IF number of options is less than 2, THEN validation fails\n\n3. Business Rule Processing:\n   - IF validation fails (less than 2 options):\n     a. Mark transaction for rollback to prevent partial data persistence\n     b. Preserve user's entered message text\n     c. Reset post ID to 0 to indicate non-persisted state\n     d. Prepare error message indicating more poll options are needed\n     e. Add post object to context for form repopulation\n     f. Add poll object to context for form repopulation\n     g. Redirect user back to edit form\n     h. RETURN false to indicate validation failure\n   - ELSE (validation passes):\n     a. RETURN true to indicate validation success and allow post submission\n\n4. Core Operation Execution:\n   - No direct data operations in this validation feature\n   - Function returns boolean result indicating validation status\n   - Calling process will use result to determine whether to proceed with post creation\n\n5. Response Generation:\n   - For validation failure:\n     a. Error message is prepared for display\n     b. User is returned to edit form with their data preserved\n     c. Form is populated with previously entered information\n   - For validation success:\n     a. No direct response - control returns to calling process\n     b. Post submission continues normally",
    "databaseEntities": [
      "jforum_topics",
      "jforum_posts",
      "jforum_posts_text"
    ],
    "validationRules": [
      "Poll must have at least two options to be valid",
      "Post content must be preserved if poll validation fails",
      "Error message must clearly indicate the need for more poll options"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Post": {
        "id": "number",
        "topicId": "number",
        "forumId": "number",
        "text": "string",
        "subject": "string",
        "time": "date"
      },
      "Poll": {
        "id": "number",
        "topicId": "number",
        "options": "array"
      }
    }
  },
  {
    "featureName": "WatchTopic",
    "description": "Subscribes a user to receive notifications for a specific topic.",
    "inputValues": [
      "topic_id-number-Topic",
      "user_id-number-User"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect topic_id (mandatory): The unique identifier of the topic to watch\n   - Collect user_id (mandatory): The unique identifier of the user who wants to watch the topic\n   - System will determine if this is a new subscription or an existing one\n\n2. Data Validation:\n   - Validate topic_id:\n      * Verify topic_id is a positive integer\n      * Verify topic exists in the system\n      * If topic does not exist, display error message and terminate process\n   - Validate user_id:\n      * Verify user_id is a positive integer\n      * Verify user exists in the system\n      * If user does not exist, display error message and terminate process\n   - Validate user authentication:\n      * Verify user is logged in\n      * If user is not logged in, redirect to login page\n\n3. Business Rule Processing:\n   - Check subscription status:\n      * Verify if the user is already subscribed to this topic\n      * IF user is already subscribed:\n         - Skip the subscription process\n         - Proceed to response generation\n      * ELSE:\n         - Proceed to core operation execution\n   - Check topic accessibility:\n      * Verify user has permission to access the topic\n      * IF user does not have permission:\n         - Display error message\n         - Terminate process\n\n4. Core Operation Execution:\n   - Create new subscription record:\n      * Associate user_id with topic_id in the subscription system\n      * Set subscription status to active\n      * Record subscription timestamp\n   - Update user preferences:\n      * Add topic to user's watched topics list\n      * Update notification settings if necessary\n\n5. Response Generation:\n   - Display confirmation message:\n      * Inform user they are now watching the topic\n      * Explain how they will receive notifications\n   - Provide navigation options:\n      * Return to topic view\n      * Manage watched topics\n      * Modify notification preferences",
    "databaseEntities": [
      "jforum_users",
      "jforum_topics",
      "jforum_forums"
    ],
    "validationRules": [
      "User must be logged in to watch a topic",
      "Topic must exist in the system",
      "User must have permission to access the topic",
      "User cannot subscribe to the same topic multiple times"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Topic": {
        "id": "number",
        "title": "string",
        "forumId": "number",
        "lastPostId": "number",
        "firstPostId": "number",
        "totalReplies": "number"
      },
      "User": {
        "id": "number",
        "username": "string",
        "email": "string"
      }
    }
  },
  {
    "featureName": "UnwatchTopic",
    "description": "Removes a user's subscription from a topic.",
    "inputValues": [
      "topic_id-number-Topic",
      "user_id-number-User"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the following inputs:\n     - topic_id (mandatory): Unique identifier of the topic to unsubscribe from\n     - user_id (system-generated): Identifier of the current logged-in user\n\n2. Data Validation:\n   - Validate user authentication:\n     - IF user is not logged in THEN\n       - Redirect to login page\n       - Display authentication required message\n       - Exit process\n     - END IF\n   - Validate topic existence:\n     - IF topic with provided topic_id does not exist THEN\n       - Display error message indicating topic not found\n       - Exit process\n     - END IF\n   - Validate subscription existence:\n     - IF user is not currently subscribed to the topic THEN\n       - Display notification that user is not subscribed\n       - Exit process\n     - END IF\n\n3. Business Rule Processing:\n   - Check user permissions:\n     - IF user does not have permission to manage subscriptions THEN\n       - Display access denied message\n       - Exit process\n     - END IF\n   - Determine return path:\n     - Calculate the appropriate page number based on current view\n     - Format the return URL with correct topic reference\n\n4. Core Operation Execution:\n   - Remove subscription record:\n     - Delete the subscription record linking the user to the topic\n     - Update any related counters or indicators\n   - Update user notification preferences:\n     - Ensure user will no longer receive notifications for this topic\n\n5. Response Generation:\n   - Prepare success message:\n     - Include confirmation that the topic has been unwatched\n     - Include link to return to the topic\n   - Display confirmation page:\n     - Show success message with return link\n     - Update page title to reflect the unwatched status",
    "databaseEntities": [
      "jforum_users",
      "jforum_topics"
    ],
    "validationRules": [
      "User must be logged in to unwatch a topic",
      "Topic must exist in the system",
      "User must be currently subscribed to the topic",
      "User must have permission to manage subscriptions"
    ],
    "dbSeedingOperations": [],
    "schema": {}
  },
  {
    "featureName": "DownloadAttachment",
    "description": "Handles file attachment downloads with permission checks and download tracking.",
    "inputValues": [
      "attach_id-number-Attachment"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect attachment ID from user request\n   - Attachment ID is mandatory\n   - User session information is retrieved from the system\n\n2. Data Validation:\n   - Validate attachment ID exists\n     * Verify attachment ID is a positive integer\n     * Check if attachment ID exists in the database\n     * IF attachment ID is invalid or not found, THEN display error message\n   - Validate user authentication status\n     * Check if user is logged in\n     * IF user is not logged in AND anonymous downloads are not allowed, THEN redirect to login page\n\n3. Business Rule Processing:\n   - Check user permissions\n     * Retrieve post associated with the attachment\n     * Identify forum ID from the post\n     * Verify if attachments are enabled in the forum\n     * Verify if user has download permissions for the forum\n     * IF user lacks necessary permissions, THEN display access denied message\n   - Verify attachment file existence\n     * Determine physical file location on server\n     * Check if file exists in the storage directory\n     * IF file does not exist, THEN display not found message\n\n4. Core Operation Execution:\n   - Prepare file for download\n     * Increment download counter for the attachment\n     * Update attachment record with new download count\n     * Determine appropriate content type based on file extension\n     * Set appropriate HTTP headers for download\n       > Content-Type header based on file type\n       > Content-Disposition header with filename\n       > Content-Length header with file size\n   - Process file download\n     * Open file input stream from storage location\n     * Stream file contents to user's browser\n     * Close all streams after transfer completes\n     * IF any errors occur during transfer, THEN handle gracefully\n\n5. Response Generation:\n   - For successful downloads:\n     * File is streamed directly to user's browser\n     * No additional UI response needed\n   - For error conditions:\n     * Display appropriate error message\n       > Authentication required message\n       > Permission denied message\n       > File not found message\n     * Provide guidance on how to resolve the issue",
    "databaseEntities": [
      "jforum_attachments",
      "jforum_posts",
      "jforum_forums",
      "jforum_users",
      "jforum_sessions"
    ],
    "validationRules": [
      "Attachment ID must be a valid positive integer",
      "Attachment must exist in the database",
      "User must be logged in if anonymous downloads are not allowed",
      "User must have permission to download attachments from the forum",
      "Attachment file must exist in the storage directory"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Attachment": {
        "id": "number",
        "postId": "number",
        "info": {
          "physicalFilename": "string",
          "realFilename": "string",
          "downloadCount": "number",
          "filesize": "number",
          "mimetype": "string",
          "extension": {
            "extensionGroupId": "number"
          }
        }
      }
    }
  },
  {
    "featureName": "ViewPrivateMessageInbox",
    "description": "Displays the user's private message inbox with a list of received messages.",
    "inputValues": [
      "userId-number-User"
    ],
    "businessLogic": "1. Input Collection\n   - Collect the following inputs:\n     a. userId (number, mandatory): The unique identifier of the user accessing their inbox\n     b. sessionToken (string, system-generated): Authentication token to verify user session\n\n2. Data Validation\n   - Validate user authentication\n     a. IF user is not logged in THEN\n        i. Redirect user to the login page\n        ii. END PROCESS\n     b. ELSE continue to next step\n   - Validate user existence\n     a. IF user with provided userId does not exist THEN\n        i. Display error message indicating invalid user\n        ii. END PROCESS\n     b. ELSE continue to next step\n\n3. Business Rule Processing\n   - Check user permissions\n     a. IF user does not have permission to view private messages THEN\n        i. Display access denied message\n        ii. END PROCESS\n     b. ELSE continue to next step\n   - Determine inbox view settings\n     a. Retrieve user preferences for message display (sorting, filtering)\n     b. Set default view parameters if user preferences are not available\n\n4. Core Operation Execution\n   - Retrieve private messages\n     a. Query the database for all messages where the recipient is the current user\n     b. Sort messages according to user preferences (default: newest first)\n     c. IF no messages are found THEN\n        i. Prepare empty inbox view\n     d. ELSE\n        i. Prepare message list with the following information for each message:\n           - Sender name\n           - Message subject\n           - Date/time received\n           - Message status (new, read, unread)\n           - Message preview (if applicable)\n   - Prepare inbox interface\n     a. Set page title to \"Private Messages - Inbox\"\n     b. Include navigation options for other message folders (sent items, drafts)\n     c. Include message management options (delete, mark as read/unread)\n     d. Include option to compose new message\n\n5. Response Generation\n   - Generate inbox view\n     a. Display header with inbox title and message count\n     b. Display message list with appropriate styling for different message statuses\n     c. IF inbox is empty THEN\n        i. Display \"No messages\" notification\n     d. ELSE\n        i. Display paginated list of messages\n        ii. Provide sorting and filtering options\n     e. Display action buttons for message management\n   - Handle view completion\n     a. Log successful inbox access for audit purposes\n     b. Update last activity timestamp for user session",
    "databaseEntities": [
      "jforum_users",
      "jforum_privmsgs",
      "jforum_privmsgs_text",
      "jforum_sessions"
    ],
    "validationRules": [
      "User must be logged in to view private messages",
      "User can only view their own private messages",
      "Message status must be one of: new, read, or unread",
      "Session must be valid and not expired"
    ],
    "dbSeedingOperations": [
      "Ensure message status types are defined in the system (NEW, READ, UNREAD)"
    ],
    "schema": {
      "PrivateMessage": {
        "id": "number",
        "fromUser": "object",
        "toUser": "object",
        "post": "object",
        "type": "number",
        "sentDate": "date"
      },
      "User": {
        "id": "number",
        "username": "string",
        "email": "string"
      },
      "Post": {
        "id": "number",
        "subject": "string",
        "text": "string",
        "date": "date"
      }
    }
  },
  {
    "featureName": "ViewPrivateMessageSentbox",
    "description": "Displays the user's sent private messages.",
    "inputValues": [
      "userId-number-User"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect userId (mandatory, system-generated from current session)\n   - No additional user inputs required for this view operation\n\n2. Data Validation:\n   - Authentication Validation:\n     a. Verify user is logged in to the system\n     b. IF user is not logged in, THEN redirect to login page\n     c. Display appropriate authentication error if needed\n\n3. Business Rule Processing:\n   - User Access Verification:\n     a. Verify the user has permission to view their sent messages\n     b. Retrieve user information based on the session userId\n     c. Prepare user context for display purposes\n\n4. Core Operation Execution:\n   - Message Retrieval:\n     a. Query the database for all private messages sent by the current user\n     b. Retrieve complete message details including recipient information\n     c. Sort messages by appropriate criteria (typically date sent, newest first)\n   - Message Type Classification:\n     a. Identify message status types (new, read, unread)\n     b. Prepare type information for display context\n   - View Preparation:\n     a. Mark the current view as the sentbox view\n     b. Set appropriate page title for the sentbox\n     c. Prepare the message list for display\n\n5. Response Generation:\n   - Success Response:\n     a. Display the list of sent messages with appropriate formatting\n     b. For each message, show recipient, subject, send date, and status\n     c. Provide options to view individual messages in detail\n     d. Include navigation elements for inbox/sentbox switching\n   - Empty State Handling:\n     a. IF no sent messages exist, THEN display appropriate empty state message\n     b. Provide guidance on how to create new messages\n   - Error Response:\n     a. Display appropriate error messages if message retrieval fails\n     b. Provide navigation options to return to main areas of the system",
    "databaseEntities": [
      "jforum_users",
      "jforum_privmsgs",
      "jforum_privmsgs_text"
    ],
    "validationRules": [
      "User must be logged in to view sent messages",
      "Only messages sent by the current user should be displayed",
      "Message list should be properly sorted by send date"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "PrivateMessage": {
        "id": "number",
        "fromUser": "object-User",
        "toUser": "object-User",
        "post": "object-Post",
        "type": "number"
      },
      "User": {
        "id": "number",
        "username": "string",
        "email": "string"
      },
      "Post": {
        "id": "number",
        "subject": "string",
        "text": "string",
        "date": "date"
      }
    }
  },
  {
    "featureName": "ComposePrivateMessage",
    "description": "Provides a form for composing and sending new private messages.",
    "inputValues": [
      "toUsername-string-User",
      "toUserId-number-User",
      "subject-string-PrivateMessage",
      "message-string-PrivateMessage"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the following inputs:\n     a. toUsername (string, optional): Username of the recipient\n     b. toUserId (number, optional): Unique identifier of the recipient\n     c. subject (string, mandatory): Subject of the private message\n     d. message (string, mandatory): Content of the private message\n     e. fromUserId (number, system-generated): Current logged-in user ID\n\n2. Data Validation:\n   a. Authentication Validation:\n      - Check if the user is logged in\n      - IF user is not logged in, THEN\n        - Redirect to login page\n        - Exit the process\n   b. Recipient Validation:\n      - IF toUserId is provided, THEN\n        - Verify the user exists in the system\n      - ELSE IF toUsername is provided, THEN\n        - Search for matching users in the system\n        - IF no matching user found, THEN\n          - Display error message \"User not found\"\n          - Return to composition form\n        - ELSE IF multiple matching users found, THEN\n          - Display list of matching users for selection\n          - Exit the process until user selects a specific recipient\n        - ELSE\n          - Set toUserId to the found user's ID\n      - ELSE\n        - Display error message \"Recipient is required\"\n        - Return to composition form\n   c. Subject Validation:\n      - Verify subject is not empty\n      - IF subject is empty, THEN\n        - Display error message \"Subject is required\"\n        - Return to composition form\n   d. Message Validation:\n      - Verify message is not empty\n      - IF message is empty, THEN\n        - Display error message \"Message content is required\"\n        - Return to composition form\n\n3. Business Rule Processing:\n   a. Permission Check:\n      - Verify sender has permission to send private messages\n      - IF sender does not have permission, THEN\n        - Display error message \"You do not have permission to send private messages\"\n        - Exit the process\n   b. Recipient Availability Check:\n      - Verify recipient can receive private messages\n      - IF recipient cannot receive messages, THEN\n        - Display error message \"User cannot receive private messages\"\n        - Return to composition form\n   c. Message Quota Check:\n      - Check if recipient's inbox has available space\n      - IF recipient's inbox is full, THEN\n        - Display error message \"Recipient's inbox is full\"\n        - Return to composition form\n\n4. Core Operation Execution:\n   a. Message Preparation:\n      - Create new private message record\n      - Set message status to \"NEW\"\n      - Associate sender information\n      - Associate recipient information\n      - Format message content according to system rules\n   b. Message Storage:\n      - Save the private message to the database\n      - IF save operation fails, THEN\n        - Display error message \"Failed to send message\"\n        - Return to composition form\n   c. Notification Processing:\n      - IF recipient has email notifications enabled, THEN\n        - Queue email notification about new private message\n      - IF recipient is currently online, THEN\n        - Update recipient's session with new message count\n\n5. Response Generation:\n   a. Success Response:\n      - Display confirmation message \"Message has been sent successfully\"\n      - Provide link to inbox\n      - Provide option to compose another message\n   b. Error Response:\n      - Display specific error message based on failure point\n      - Preserve entered message content\n      - Allow user to correct errors and resubmit",
    "databaseEntities": [
      "jforum_users",
      "jforum_privmsgs",
      "jforum_privmsgs_text",
      "jforum_sessions"
    ],
    "validationRules": [
      "User must be logged in to send private messages",
      "Recipient username or ID must be provided",
      "Recipient must exist in the system",
      "Subject field cannot be empty",
      "Message content cannot be empty",
      "Sender must have permission to send private messages",
      "Recipient must be able to receive private messages",
      "Recipient's inbox must not be full"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "PrivateMessage": {
        "id": "number",
        "fromUser": "object-User",
        "toUser": "object-User",
        "subject": "string",
        "message": "string",
        "type": "number",
        "sendDate": "date"
      },
      "User": {
        "id": "number",
        "username": "string",
        "email": "string",
        "signature": "string"
      }
    }
  },
  {
    "featureName": "SendPrivateMessageToUser",
    "description": "Initiates a private message composition to a specific user.",
    "inputValues": [
      "recipientUsername-string-User",
      "recipientId-number-User",
      "messageSubject-string-PrivateMessage",
      "messageContent-string-PrivateMessage"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the following inputs:\n     a. Recipient information (either username or user ID)\n     b. Message subject (mandatory)\n     c. Message content (mandatory)\n     d. System automatically captures sender information from current session\n\n2. Data Validation:\n   a. Authentication Validation:\n      - Verify user is logged in\n      - IF user is not authenticated THEN\n         - Redirect to login page\n         - Exit process\n\n   b. Recipient Validation:\n      - IF recipient ID is provided THEN\n         - Verify recipient ID exists in the system\n      - ELSE IF recipient username is provided THEN\n         - Search for user by username\n         - IF user found THEN\n            - Use found user's ID as recipient ID\n         - ELSE\n            - Display error message \"User not found\"\n            - Exit process\n      - IF no recipient information provided THEN\n         - Display error message \"Recipient is required\"\n         - Exit process\n\n   c. Message Content Validation:\n      - Verify message subject is not empty\n      - Verify message content is not empty\n      - IF either validation fails THEN\n         - Display appropriate error message\n         - Return to composition form preserving entered data\n\n3. Business Rule Processing:\n   a. Permission Verification:\n      - Verify sender has permission to send private messages\n      - Verify recipient accepts private messages\n      - IF any permission check fails THEN\n         - Display appropriate error message\n         - Exit process\n\n   b. Message Limit Check:\n      - Check if recipient's inbox has reached maximum capacity\n      - IF inbox is full THEN\n         - Display error message \"Recipient's inbox is full\"\n         - Exit process\n\n4. Core Operation Execution:\n   a. Message Preparation:\n      - Create new private message object\n      - Set message type as NEW\n      - Set sender information from current user session\n      - Set recipient information from validated recipient\n      - Set message subject and content\n      - Set current timestamp\n\n   b. Message Storage:\n      - IF preview mode requested THEN\n         - Prepare message preview\n         - Display composition form with preview\n         - Exit process without saving\n      - ELSE\n         - Save message to database\n         - Update sender's sent items folder\n         - Update recipient's inbox\n\n   c. Notification Processing:\n      - IF recipient has email notifications enabled THEN\n         - Generate email notification\n         - Send notification to recipient's email address\n      - IF recipient is currently online THEN\n         - Update recipient's session with new message count\n\n5. Response Generation:\n   a. Success Response:\n      - Display confirmation message \"Message sent successfully\"\n      - Provide link to inbox\n      - Provide option to compose another message\n\n   b. Error Response:\n      - Display specific error message based on failure point\n      - Preserve entered data where possible\n      - Provide guidance on how to correct the issue",
    "databaseEntities": [
      "jforum_users",
      "jforum_privmsgs",
      "jforum_privmsgs_text",
      "jforum_sessions"
    ],
    "validationRules": [
      "User must be logged in to send a private message",
      "Recipient must exist in the system",
      "Message subject cannot be empty",
      "Message content cannot be empty",
      "Sender must have permission to send private messages",
      "Recipient must accept private messages",
      "Recipient's inbox must not be full"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "PrivateMessage": {
        "id": "number",
        "type": "number",
        "fromUser": "object",
        "toUser": "object",
        "post": {
          "subject": "string",
          "text": "string",
          "time": "date"
        }
      },
      "User": {
        "id": "number",
        "username": "string",
        "email": "string"
      }
    }
  },
  {
    "featureName": "SavePrivateMessage",
    "description": "Processes and saves a composed private message with notification support.",
    "inputValues": [
      "toUserId-number-User",
      "toUsername-string-User",
      "messageContent-object-PrivateMessage"
    ],
    "businessLogic": "1. Input Collection\n   - Collect the following inputs:\n     a. toUserId (number, optional): The ID of the recipient user\n     b. toUsername (string, optional): The username of the recipient\n     c. messageContent (object, mandatory): Contains the message text, subject, and formatting options\n     d. preview (boolean, system-generated): Indicates if this is a preview request\n\n2. Data Validation\n   - Validate user authentication\n     a. IF user is not logged in THEN\n        i. Redirect to login page\n        ii. STOP processing\n     b. ELSE continue processing\n   - Validate recipient information\n     a. IF toUserId is empty or invalid THEN\n        i. IF toUsername is provided THEN\n           1. Search for user by username\n           2. IF user found THEN\n              a. Set toUserId to the found user's ID\n           3. ELSE\n              a. Display error message \"User not found\"\n              b. STOP processing\n        ii. ELSE\n           1. Display error message \"Recipient information required\"\n           2. STOP processing\n     b. ELSE continue with provided toUserId\n   - Validate message content\n     a. Check that subject is not empty\n     b. Check that message body is not empty\n     c. IF any validation fails THEN\n        i. Display appropriate error message\n        ii. Return to message composition form with entered data\n        iii. STOP processing\n\n3. Business Rule Processing\n   - Check if preview mode is requested\n     a. IF preview is requested THEN\n        i. Format message for display\n        ii. Return to composition form with preview\n        iii. STOP processing\n     b. ELSE continue with message saving\n   - Check recipient availability\n     a. Verify recipient user exists in the system\n     b. IF recipient not found THEN\n        i. Display error message\n        ii. STOP processing\n     c. ELSE continue processing\n\n4. Core Operation Execution\n   - Prepare message data\n     a. Create new private message object\n     b. Set sender information from current user session\n     c. Set recipient information from validated toUserId\n     d. Set message content from input\n     e. Set message status as NEW\n   - Save private message\n     a. Store message in database\n     b. IF save fails THEN\n        i. Display error message\n        ii. Return to composition form with entered data\n        iii. STOP processing\n     c. ELSE continue processing\n   - Update recipient notification status\n     a. IF recipient is currently online THEN\n        i. Increment recipient's unread message counter\n     b. IF recipient has email notifications enabled THEN\n        i. Queue email notification for sending\n\n5. Response Generation\n   - Generate success response\n     a. Display confirmation message that message was sent successfully\n     b. Provide link to inbox for further actions\n     c. Clear form data to prevent duplicate submissions",
    "databaseEntities": [
      "jforum_users",
      "jforum_privmsgs",
      "jforum_privmsgs_text",
      "jforum_sessions"
    ],
    "validationRules": [
      "User must be logged in to send private messages",
      "Recipient user must exist in the system",
      "Message must have a subject",
      "Message must have content",
      "Either recipient user ID or username must be provided"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "PrivateMessage": {
        "type": "object",
        "properties": {
          "subject": {
            "type": "string",
            "description": "Subject of the private message"
          },
          "text": {
            "type": "string",
            "description": "Content of the private message"
          },
          "htmlEnabled": {
            "type": "boolean",
            "description": "Whether HTML formatting is enabled in the message"
          }
        },
        "required": [
          "subject",
          "text"
        ]
      }
    }
  },
  {
    "featureName": "FindUserForPrivateMessage",
    "description": "Searches for users by username to select as private message recipients.",
    "inputValues": [
      "username-string-User"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the following inputs:\n     a. username (string, mandatory): The partial or complete username to search for\n\n2. Data Validation:\n   - Validate username input:\n     a. IF username is empty or null THEN\n        i. Set showResult flag to false\n        ii. Skip to Response Generation step\n     b. ELSE\n        i. Proceed to Business Rule Processing\n\n3. Business Rule Processing:\n   - Verify user session:\n     a. IF user is not logged in THEN\n        i. Redirect to login page\n        ii. End process\n     b. ELSE\n        i. Continue with search operation\n\n4. Core Operation Execution:\n   - Perform user search:\n     a. Search the system for users whose names match the provided username pattern\n     b. Retrieve matching user records including:\n        i. User ID\n        ii. Username\n        iii. Other relevant user information\n     c. Compile results into a list of matching users\n     d. Set showResult flag to true\n\n5. Response Generation:\n   - Prepare search results display:\n     a. IF search was performed (showResult is true) THEN\n        i. Include list of matching users in the response\n        ii. Display username search term used\n     b. ELSE\n        i. Display empty search form\n     c. Present interface for user selection\n     d. Provide option to select a user from results to compose a private message",
    "databaseEntities": [
      "jforum_users",
      "jforum_sessions",
      "jforum_privmsgs"
    ],
    "validationRules": [
      "User must be logged in to search for message recipients",
      "Username search term must not be empty to perform search"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "User": {
        "id": "number",
        "username": "string",
        "email": "string"
      }
    }
  },
  {
    "featureName": "ReadPrivateMessage",
    "description": "Displays the content of a private message and marks it as read.",
    "inputValues": [
      "id-number-PrivateMessage"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the private message ID (required, numeric)\n   - System retrieves current user ID from active session (system-generated)\n\n2. Data Validation:\n   - Validate user authentication\n     - IF user is not logged in THEN\n       - Redirect to login page\n       - Exit process\n     - END IF\n   - Validate message ID\n     - IF message ID is missing or invalid THEN\n       - Display error message\n       - Exit process\n     - END IF\n\n3. Business Rule Processing:\n   - Verify message access permissions\n     - Retrieve message details using provided ID\n     - Verify message exists\n       - IF message not found THEN\n         - Display error message\n         - Exit process\n       - END IF\n     - Check if current user is either sender or recipient\n       - IF current user is neither sender nor recipient THEN\n         - Display unauthorized access message\n         - Exit process\n       - END IF\n\n4. Core Operation Execution:\n   - Prepare message content for display\n     - Format message text according to system rules\n     - Process any special formatting or embedded content\n   - Update message status if needed\n     - IF message type is NEW AND current user is recipient THEN\n       - Change message type to READ\n       - Update message status in database\n       - Decrement user's unread message count\n     - END IF\n   - Load related message information\n     - Sender details\n     - Recipient details\n     - Message timestamp\n     - Message subject\n\n5. Response Generation:\n   - Display message content\n     - Show message subject\n     - Show sender information\n     - Show recipient information\n     - Show message timestamp\n     - Show formatted message content\n   - Provide navigation options\n     - Return to inbox\n     - Reply to message\n     - Delete message\n     - Other message management options",
    "databaseEntities": [
      "jforum_users",
      "jforum_privmsgs",
      "jforum_privmsgs_text",
      "jforum_sessions"
    ],
    "validationRules": [
      "User must be authenticated to read private messages",
      "User must be either the sender or recipient of the message",
      "Message ID must be valid and exist in the system",
      "Only messages that belong to the current user can be accessed"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "PrivateMessage": {
        "id": "number",
        "type": "number",
        "fromUser": "object",
        "toUser": "object",
        "post": "object"
      },
      "User": {
        "id": "number",
        "username": "string",
        "email": "string"
      },
      "Post": {
        "id": "number",
        "subject": "string",
        "text": "string",
        "date": "date"
      }
    }
  },
  {
    "featureName": "ReviewPrivateMessage",
    "description": "Displays a private message in review mode for users to examine message content before taking further actions.",
    "inputValues": [
      "messageId-number-PrivateMessage"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect messageId (mandatory): The unique identifier of the private message to be reviewed\n   - System will determine current user from active session (system-generated)\n\n2. Data Validation:\n   - Validate User Authentication:\n     a. Check if user is currently logged in\n     b. IF user is not logged in, THEN\n        i. Redirect to login page\n        ii. END process\n   - Validate Message ID:\n     a. Verify messageId is a valid number\n     b. Verify messageId exists in the system\n     c. IF messageId is invalid or not found, THEN\n        i. Display error message indicating invalid message reference\n        ii. END process\n\n3. Business Rule Processing:\n   - Verify Access Permissions:\n     a. Retrieve message details using messageId\n     b. Determine if current user is either the sender or recipient of the message\n     c. IF user is neither sender nor recipient, THEN\n        i. Display access denied message\n        ii. END process\n   - Check Message Status:\n     a. IF message was previously unread AND current user is recipient, THEN\n        i. Update message status to read\n        ii. Decrement user's unread message count\n\n4. Core Operation Execution:\n   - Prepare Message Content:\n     a. Retrieve complete message content including:\n        i. Subject line\n        ii. Message body\n        iii. Sender information\n        iv. Timestamp\n        v. Any formatting or special content\n     b. Process sender's signature if applicable\n     c. Format message for display in review mode\n   - Update User Interface Context:\n     a. Add message object to display context\n     b. Set template to review mode template\n\n5. Response Generation:\n   - Display Review Interface:\n     a. Present message in review format showing all message details\n     b. Show sender information with appropriate formatting\n     c. Display message content with proper formatting\n     d. Provide action options appropriate for review mode\n     e. IF any errors occurred during processing, THEN\n        i. Display appropriate error message\n        ii. Provide navigation options to return to message list",
    "databaseEntities": [
      "jforum_privmsgs",
      "jforum_privmsgs_text",
      "jforum_users",
      "jforum_sessions"
    ],
    "validationRules": [
      "User must be logged in to review messages",
      "User must be either the sender or recipient of the message",
      "Message ID must exist in the system",
      "Message ID must be a valid number"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "PrivateMessage": {
        "id": "number",
        "fromUser": "object-User",
        "toUser": "object-User",
        "post": "object-Post",
        "type": "number",
        "sentDate": "date"
      },
      "User": {
        "id": "number",
        "username": "string",
        "signature": "string",
        "privateMessages": "number"
      },
      "Post": {
        "subject": "string",
        "text": "string",
        "date": "date"
      }
    }
  },
  {
    "featureName": "ReplyToPrivateMessage",
    "description": "Creates a reply to an existing private message with prefixed subject.",
    "inputValues": [
      "messageId-number-PrivateMessage",
      "replyContent-string-Post",
      "user-object-User"
    ],
    "businessLogic": "1. Input Collection:\n   1.1. Collect the following inputs:\n       - messageId (mandatory): Identifier of the private message being replied to\n       - replyContent (mandatory): Content of the reply message\n       - user (system-generated): Current logged-in user information\n\n2. Data Validation:\n   2.1. Validate user authentication:\n       - IF user is not logged in THEN\n           - Redirect to login page\n           - Exit process\n   2.2. Validate message ID:\n       - IF messageId is not provided or invalid THEN\n           - Display error message \"Invalid message identifier\"\n           - Exit process\n   2.3. Validate reply content:\n       - IF replyContent is empty THEN\n           - Display error message \"Reply content cannot be empty\"\n           - Exit process\n\n3. Business Rule Processing:\n   3.1. Verify message access permissions:\n       - Retrieve the original private message using messageId\n       - IF current user is neither the sender nor the recipient of the original message THEN\n           - Display access denied message\n           - Exit process\n   3.2. Prepare reply message:\n       - Create new reply message object\n       - Set the sender as the current user\n       - Set the recipient as the sender of the original message\n       - Prefix the subject with reply indicator (e.g., \"Re: \")\n       - Include the reply content\n\n4. Core Operation Execution:\n   4.1. Process the reply message:\n       - Create new private message record\n       - Associate the reply with the original message\n       - Set message status to NEW for recipient\n       - Update recipient's unread message count\n   4.2. Handle any processing failures:\n       - IF message creation fails THEN\n           - Display error notification\n           - Preserve user input for correction\n           - Exit process\n\n5. Response Generation:\n   5.1. On successful reply:\n       - Display confirmation message that reply was sent\n       - Provide option to return to inbox\n       - Update message thread to include the new reply\n   5.2. On failure:\n       - Display appropriate error message\n       - Provide option to retry or cancel",
    "databaseEntities": [
      "jforum_users",
      "jforum_privmsgs",
      "jforum_privmsgs_text"
    ],
    "validationRules": [
      "User must be authenticated to reply to messages",
      "User must be either the sender or recipient of the original message",
      "Reply content cannot be empty",
      "Message ID must be valid"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "User": {
        "id": "number",
        "username": "string",
        "signature": "string"
      },
      "PrivateMessage": {
        "id": "number",
        "fromUser": "object",
        "toUser": "object",
        "post": "object",
        "type": "string"
      },
      "Post": {
        "subject": "string",
        "text": "string"
      }
    }
  },
  {
    "featureName": "QuotePrivateMessage",
    "description": "Creates a reply with quoted content from the original private message.",
    "inputValues": [
      "messageId-number-PrivateMessage",
      "userId-number-User"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect messageId (mandatory): Identifier of the private message to quote\n   - Collect userId (mandatory): Identifier of the current user performing the action\n   - System will generate quoteTimestamp (system-generated): Current date and time\n\n2. Data Validation:\n   - Validate messageId:\n      a. Check if messageId is provided and is a valid number\n      b. Verify messageId exists in the system\n      c. Return error if message does not exist: \"The specified message could not be found\"\n   - Validate userId:\n      a. Verify userId is provided and is a valid number\n      b. Confirm user is currently logged in\n      c. Return error if user is not logged in: \"You must be logged in to perform this action\"\n\n3. Business Rule Processing:\n   - Verify message access permissions:\n      a. Retrieve the private message using messageId\n      b. Check if current user is either the sender or recipient of the message\n      c. IF user is neither sender nor recipient THEN\n         i. Deny access with message: \"You do not have permission to access this private message\"\n         ii. Abort operation\n      d. END IF\n   - Prepare message content:\n      a. Format the subject line by adding reply prefix to original subject\n      b. Prepare the quoted content by formatting original message with sender information\n      c. Preserve original message metadata (date, sender information)\n\n4. Core Operation Execution:\n   - Create new reply form:\n      a. Set recipient as the sender of the original message\n      b. Set the prefixed subject line\n      c. Insert the quoted content into the message body\n      d. Mark the message as a quote-reply\n   - Prepare user interface:\n      a. Load user preferences for message composition\n      b. Set form mode to \"quote\"\n      c. Include original message reference\n\n5. Response Generation:\n   - Success response:\n      a. Display message composition form with quoted content\n      b. Show recipient information pre-filled\n      c. Show prefixed subject line pre-filled\n      d. Show quoted content in message body\n   - Error response:\n      a. Display appropriate error message based on validation failures\n      b. Provide navigation options to return to inbox",
    "databaseEntities": [
      "jforum_users",
      "jforum_privmsgs",
      "jforum_privmsgs_text"
    ],
    "validationRules": [
      "User must be logged in to quote a private message",
      "User must be either the sender or recipient of the original message",
      "The private message ID must exist in the system",
      "The private message must be accessible to the current user"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "PrivateMessage": {
        "id": "number",
        "fromUser": "object-User",
        "toUser": "object-User",
        "post": "object-Post",
        "type": "string"
      },
      "User": {
        "id": "number",
        "username": "string"
      },
      "Post": {
        "subject": "string",
        "text": "string"
      }
    }
  },
  {
    "featureName": "ListPrivateMessages",
    "description": "Displays a list of private messages for the logged-in user in their inbox.",
    "inputValues": [
      "userId-number-User",
      "pageNumber-number-Pagination",
      "itemsPerPage-number-Pagination"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect userId (mandatory, system-generated from current session)\n   - Collect pageNumber (optional, defaults to 1)\n   - Collect itemsPerPage (optional, defaults to system configuration value)\n\n2. Data Validation:\n   - Validate user authentication status\n     * IF user is not logged in THEN\n       - Redirect to login page\n       - Exit process\n     * END IF\n   - Validate pageNumber\n     * IF pageNumber is less than 1 THEN\n       - Set pageNumber to 1\n     * END IF\n   - Validate itemsPerPage\n     * IF itemsPerPage is less than 1 THEN\n       - Set itemsPerPage to default system value\n     * END IF\n\n3. Business Rule Processing:\n   - Verify user has permission to view private messages\n     * IF user does not have permission THEN\n       - Display access denied message\n       - Exit process\n     * END IF\n   - Check system status for private messaging functionality\n     * IF private messaging is disabled THEN\n       - Display feature unavailable message\n       - Exit process\n     * END IF\n\n4. Core Operation Execution:\n   - Retrieve total count of private messages for the user\n   - Calculate pagination parameters\n     * totalPages = ceiling(totalMessages / itemsPerPage)\n     * startIndex = (pageNumber - 1) * itemsPerPage\n   - Retrieve private messages for the current user\n     * Get messages where toUserId equals current userId\n     * Apply pagination (startIndex, itemsPerPage)\n     * Sort by date received (newest first)\n   - Process message list\n     * For each message:\n       - Determine message status (read/unread)\n       - Format date and time information\n       - Prepare sender information\n   - Update unread message count in user session if needed\n\n5. Response Generation:\n   - Prepare inbox view with the following information:\n     * List of private messages with:\n       - Message subject\n       - Sender name\n       - Date/time received\n       - Read/unread status\n     * Pagination controls\n       - Current page number\n       - Total pages\n       - Next/previous page links if applicable\n     * Message management options\n       - Delete selected messages\n       - Mark as read/unread\n     * Compose new message option\n   - Display inbox view to user",
    "databaseEntities": [
      "jforum_users",
      "jforum_privmsgs",
      "jforum_privmsgs_text"
    ],
    "validationRules": [
      "User must be logged in to view private messages",
      "User can only view their own private messages",
      "Page number must be a positive integer",
      "Items per page must be a positive integer within system limits"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "User": {
        "id": "number",
        "username": "string",
        "privateMessages": "number"
      },
      "PrivateMessage": {
        "id": "number",
        "fromUser": "object",
        "toUser": "object",
        "post": "object",
        "type": "number",
        "date": "date"
      },
      "Pagination": {
        "pageNumber": "number",
        "itemsPerPage": "number",
        "totalPages": "number"
      }
    }
  },
  {
    "featureName": "GenerateForumTopicsRSS",
    "description": "Generates RSS feed for the latest topics in a specified forum.",
    "inputValues": [
      "forumId-number-Forum"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect forumId (mandatory) - The unique identifier of the forum to generate RSS feed for\n   - System will use configuration values for number of topics to include\n\n2. Data Validation:\n   - Validate forumId:\n     a. Check if forumId is provided and is a valid number\n     b. Verify forumId exists in the system\n     c. Generate error message if forumId is invalid or not found\n   - Validate user access permissions:\n     a. Check if the current user has access rights to the specified forum\n     b. IF user does not have access rights, THEN\n        i. Request authentication\n        ii. Terminate further processing\n\n3. Business Rule Processing:\n   - Verify forum visibility:\n     a. Check if the forum is active and visible\n     b. IF forum is not active or visible, THEN return appropriate error message\n   - Apply content filtering rules:\n     a. Filter out any topics that should not appear in public feeds\n     b. Apply any content moderation policies\n\n4. Core Operation Execution:\n   - Retrieve forum information:\n     a. Get forum details including name and description\n     b. Prepare forum metadata for RSS header\n   - Fetch latest topics:\n     a. Retrieve the latest topics from the specified forum based on system configuration limit\n     b. For each topic, collect required information (title, content preview, author, date)\n     c. Sort topics by publication date (newest first)\n   - Generate RSS content:\n     a. Create RSS header with forum information\n     b. For each topic, create an RSS item entry with appropriate metadata\n     c. Format the complete RSS feed according to standard specifications\n   - Increment view counters:\n     a. Update forum view statistics\n\n5. Response Generation:\n   - Set content type to XML format\n   - Return the generated RSS feed content\n   - IF any errors occurred during processing, THEN\n     a. Generate appropriate error response in XML format\n     b. Include error details and suggestions for resolution\n   - Include appropriate caching headers for RSS feed",
    "databaseEntities": [
      "jforum_forums",
      "jforum_topics",
      "jforum_posts",
      "jforum_users"
    ],
    "validationRules": [
      "Forum ID must be a valid number",
      "Forum must exist in the system",
      "User must have access rights to the specified forum",
      "Forum must be active and visible"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Forum": {
        "id": "number",
        "name": "string",
        "description": "string"
      },
      "Topic": {
        "id": "number",
        "title": "string",
        "postDate": "date",
        "forumId": "number",
        "authorId": "number"
      }
    }
  },
  {
    "featureName": "ProcessRSSRequest",
    "description": "Processes RSS requests with proper authentication and content type handling.",
    "inputValues": [
      "requestType-string-RSSRequest",
      "forumId-number-Forum",
      "topicId-number-Topic",
      "authentication-object-Authentication"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the request type (forumTopics, topicPosts, recentTopics)\n   - Collect forumId (required for forumTopics request type)\n   - Collect topicId (required for topicPosts request type)\n   - System will use authentication information from the current session\n   - System will use configured system preferences for content limits\n\n2. Data Validation:\n   - Validate request type:\n     a. Verify request type is one of the supported types (forumTopics, topicPosts, recentTopics)\n     b. Return error message if request type is invalid\n   - Validate parameters based on request type:\n     a. IF request type is forumTopics:\n        i. Verify forumId is provided and is a valid number\n        ii. Return error message if forumId is missing or invalid\n     b. IF request type is topicPosts:\n        i. Verify topicId is provided and is a valid number\n        ii. Return error message if topicId is missing or invalid\n   - Validate authentication:\n     a. Check if user has access to the requested resource\n     b. IF authentication fails, request basic authentication\n     c. Return error message if authentication fails after basic authentication attempt\n\n3. Business Rule Processing:\n   - Check access permissions:\n     a. IF request type is forumTopics:\n        i. Verify user has access to the specified forum\n        ii. IF not accessible, request basic authentication\n        iii. Return error if still not accessible after authentication\n     b. IF request type is topicPosts:\n        i. Verify topic exists\n        ii. Verify user has access to the forum containing the topic\n        iii. IF not accessible, request basic authentication\n        iv. Return error if still not accessible after authentication\n   - Apply system constraints:\n     a. Determine maximum number of items to return based on system configuration\n     b. Apply content filtering rules based on user permissions\n\n4. Core Operation Execution:\n   - Process request based on type:\n     a. IF request type is forumTopics:\n        i. Retrieve forum information\n        ii. Retrieve latest posts from the forum (limited by system configuration)\n        iii. Increment view counters if applicable\n        iv. Format data for RSS output with forum name in title and description\n     b. IF request type is topicPosts:\n        i. Retrieve topic information\n        ii. Increment topic view counter\n        iii. Retrieve all posts for the topic\n        iv. Format data for RSS output with topic title in title and description\n     c. IF request type is recentTopics:\n        i. Retrieve system name for RSS title\n        ii. Retrieve hot/recent posts across the system (limited by system configuration)\n        iii. Format data for RSS output\n   - Generate RSS content:\n     a. Create appropriate RSS object based on request type\n     b. Generate XML content with proper RSS formatting\n     c. Store generated content for response\n\n5. Response Generation:\n   - Set response content type to XML\n   - Set template for RSS output\n   - Return generated RSS content\n   - IF any errors occurred during processing:\n     a. Generate appropriate error message\n     b. Set appropriate HTTP status code\n     c. Include error details in response",
    "databaseEntities": [
      "jforum_forums",
      "jforum_topics",
      "jforum_posts",
      "jforum_users",
      "jforum_sessions"
    ],
    "validationRules": [
      "Request type must be one of: forumTopics, topicPosts, recentTopics",
      "ForumId must be provided and valid when request type is forumTopics",
      "TopicId must be provided and valid when request type is topicPosts",
      "User must have access permissions to the requested forum or topic",
      "Topic must exist when requesting topic posts",
      "Forum must exist when requesting forum topics"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Authentication": {
        "type": "object",
        "properties": {
          "username": {
            "type": "string",
            "description": "User's login name"
          },
          "password": {
            "type": "string",
            "description": "User's password"
          },
          "isLoggedIn": {
            "type": "boolean",
            "description": "Whether the user is currently logged in"
          }
        }
      },
      "RSSRequest": {
        "type": "object",
        "properties": {
          "requestType": {
            "type": "string",
            "enum": [
              "forumTopics",
              "topicPosts",
              "recentTopics"
            ],
            "description": "Type of RSS content being requested"
          },
          "forumId": {
            "type": "number",
            "description": "ID of the forum when requesting forum topics"
          },
          "topicId": {
            "type": "number",
            "description": "ID of the topic when requesting topic posts"
          }
        }
      }
    }
  },
  {
    "featureName": "ListRecentTopics",
    "description": "Displays a paginated list of recent forum topics accessible to the current user.",
    "inputValues": [
      "pageNumber-number-Pagination",
      "postsPerPage-number-SystemConfig",
      "topicsPerPage-number-SystemConfig",
      "userId-number-User"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect pageNumber (optional, defaults to 1)\n   - System retrieves postsPerPage from system configuration\n   - System retrieves topicsPerPage from system configuration\n   - Collect userId (optional, for user-specific topic listing)\n\n2. Data Validation:\n   - Validate pageNumber:\n     * IF pageNumber is provided, THEN ensure it is a positive integer\n     * IF pageNumber is not provided, THEN default to 1\n   - Validate userId (when provided for user-specific listing):\n     * Ensure userId exists in the system\n     * IF userId does not exist, THEN display user not found message\n\n3. Business Rule Processing:\n   - Determine listing mode:\n     * IF userId is provided, THEN set mode to user-specific topics\n     * ELSE set mode to general recent topics\n   - Calculate pagination parameters:\n     * Calculate startIndex based on pageNumber and topicsPerPage\n     * Determine total pages based on total topics count and topicsPerPage\n\n4. Core Operation Execution:\n   - Retrieve topics based on mode:\n     * IF in general recent topics mode:\n       > Retrieve recent topics from repository\n       > Filter topics based on user access permissions\n       > FOR EACH topic in the list:\n         - Check if user has access to the forum containing the topic\n         - IF user does not have access, THEN remove topic from list\n     * IF in user-specific mode:\n       > Retrieve topics created by the specified user\n       > Apply pagination parameters (startIndex, topicsPerPage)\n       > Count total topics by user for pagination calculation\n   - Prepare topic data for display:\n     * FOR EACH topic in filtered list:\n       > Retrieve associated forum information\n       > Format creation date and last post date\n       > Calculate and include reply count\n       > Include author information\n\n5. Response Generation:\n   - Prepare display context:\n     * Include list of topics with their details\n     * Include associated forums information\n     * Include pagination information:\n       > Current page number\n       > Total pages\n       > Total topics\n     * Include page title based on mode\n   - Generate appropriate view:\n     * IF in general recent topics mode, THEN use recent topics template\n     * IF in user-specific mode, THEN use user topics template\n     * IF user not found, THEN use user not found template",
    "databaseEntities": [
      "jforum_users",
      "jforum_forums",
      "jforum_topics",
      "jforum_posts"
    ],
    "validationRules": [
      "Page number must be a positive integer",
      "User must exist in the system when filtering by user",
      "User must have access permissions to view topics in a forum",
      "Topics per page must not exceed system-defined maximum"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Topic": {
        "id": "number",
        "title": "string",
        "forumId": "number",
        "userId": "number",
        "creationDate": "date",
        "lastPostDate": "date",
        "replyCount": "number",
        "viewCount": "number",
        "status": "number"
      },
      "Forum": {
        "id": "number",
        "name": "string",
        "description": "string",
        "categoryId": "number",
        "lastPostDate": "date",
        "topicCount": "number",
        "postCount": "number"
      },
      "User": {
        "id": "number",
        "username": "string",
        "registrationDate": "date",
        "postCount": "number"
      },
      "Pagination": {
        "currentPage": "number",
        "totalPages": "number",
        "totalItems": "number",
        "itemsPerPage": "number"
      },
      "SystemConfig": {
        "postsPerPage": "number",
        "topicsPerPage": "number"
      }
    }
  },
  {
    "featureName": "FilterSearch",
    "description": "Displays search filters interface with categories for forum search.",
    "inputValues": [
      "categories-object-Category",
      "searchKeywords-string-Search",
      "searchAuthor-number-User",
      "sortBy-string-Search",
      "sortDirection-string-Search",
      "matchType-string-Search",
      "fromDate-date-Search",
      "toDate-date-Search",
      "forumId-number-Forum"
    ],
    "businessLogic": "1. Input Collection:\n   1.1. Collect search filter parameters from the user:\n       1.1.1. Gather optional search keywords text input\n       1.1.2. Gather optional author identifier\n       1.1.3. Gather optional sort criteria (field to sort by)\n       1.1.4. Gather optional sort direction (ascending or descending)\n       1.1.5. Gather optional match type (all keywords or any keyword)\n       1.1.6. Gather optional date range (from date and to date)\n       1.1.7. Gather optional forum identifier for limiting search scope\n   1.2. System retrieves all available categories and forums for selection\n       1.2.1. Load category hierarchy information\n       1.2.2. Load forums within each category\n\n2. Data Validation:\n   2.1. Validate search keywords if provided\n       2.1.1. IF keywords are provided, ensure they contain valid searchable text\n       2.1.2. IF keywords contain special characters, validate they are properly formatted\n   2.2. Validate author identifier if provided\n       2.2.1. IF author ID is provided, verify it represents a valid user in the system\n   2.3. Validate sort parameters if provided\n       2.3.1. IF sort field is provided, verify it is one of the allowed sort fields\n       2.3.2. IF sort direction is provided, verify it is either ascending or descending\n   2.4. Validate date range if provided\n       2.4.1. IF from date is provided, verify it is a valid date format\n       2.4.2. IF to date is provided, verify it is a valid date format\n       2.4.3. IF both dates are provided, verify from date is before or equal to to date\n   2.5. Validate forum ID if provided\n       2.5.1. IF forum ID is provided, verify it represents a valid forum in the system\n\n3. Business Rule Processing:\n   3.1. Process match type selection\n       3.1.1. IF match type is \"all\", configure search to match all provided keywords\n       3.1.2. IF match type is not specified or is \"any\", configure search to match any provided keyword\n   3.2. Process forum selection scope\n       3.2.1. IF specific forum is selected, limit search scope to that forum only\n       3.2.2. IF no forum is selected, configure search to include all accessible forums\n   3.3. Process date range filtering\n       3.3.1. IF date range is provided, configure search to filter content within that range\n       3.3.2. IF no date range is provided, configure search to include all time periods\n\n4. Core Operation Execution:\n   4.1. Prepare search filter interface display\n       4.1.1. Organize categories in hierarchical structure\n       4.1.2. Organize forums within their respective categories\n       4.1.3. Prepare input fields for all search parameters\n       4.1.4. Set default values for search parameters where appropriate\n   4.2. Generate search form with all available filter options\n       4.2.1. Create keyword input field\n       4.2.2. Create author selection field\n       4.2.3. Create forum selection dropdown with category grouping\n       4.2.4. Create date range selection fields\n       4.2.5. Create sort options and direction selectors\n       4.2.6. Create match type selection options\n   4.3. Prepare page display elements\n       4.3.1. Set page title to search-related text\n       4.3.2. Organize filter sections in logical groupings\n       4.3.3. Prepare form submission controls\n\n5. Response Generation:\n   5.1. Display the search filters interface to the user\n       5.1.1. Show category and forum selection options\n       5.1.2. Show keyword and author search fields\n       5.1.3. Show date range selection options\n       5.1.4. Show sorting and matching options\n       5.1.5. Show search submission button\n   5.2. Provide clear instructions for using search filters\n       5.2.1. Include helpful text explaining filter options\n       5.2.2. Include placeholder text in input fields as examples\n   5.3. Ensure accessibility of all filter elements\n       5.3.1. Provide proper labeling for all form fields\n       5.3.2. Ensure logical tab order through the form\n       5.3.3. Provide clear visual indication of selected filters",
    "databaseEntities": [
      "jforum_categories",
      "jforum_forums",
      "jforum_users",
      "jforum_topics",
      "jforum_posts"
    ],
    "validationRules": [
      "Search keywords must contain valid searchable text if provided",
      "Author ID must represent a valid user in the system if provided",
      "Sort field must be one of the allowed sort fields if provided",
      "Sort direction must be either ascending or descending if provided",
      "From date must be a valid date format if provided",
      "To date must be a valid date format if provided",
      "From date must be before or equal to to date if both are provided",
      "Forum ID must represent a valid forum in the system if provided"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Category": {
        "id": "number",
        "name": "string",
        "description": "string",
        "forums": "array"
      },
      "Forum": {
        "id": "number",
        "name": "string",
        "description": "string",
        "categoryId": "number"
      },
      "User": {
        "id": "number",
        "username": "string"
      },
      "Search": {
        "keywords": "string",
        "authorId": "number",
        "sortBy": "string",
        "sortDirection": "string",
        "matchType": "string",
        "fromDate": "date",
        "toDate": "date",
        "forumId": "number"
      }
    }
  },
  {
    "featureName": "SearchNewMessages",
    "description": "Searches for new messages in the forum using specialized search operation.",
    "inputValues": [
      "search_keywords-string-SearchCriteria",
      "search_author-number-User",
      "sort_by-string-SortOption",
      "sort_dir-string-SortDirection",
      "match_type-string-MatchType",
      "from_date-date-DateRange",
      "to_date-date-DateRange",
      "forum-number-Forum"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the following search parameters from the user:\n     a. Keywords (mandatory): Text to search for in messages\n     b. Author ID (optional): Numeric identifier of the message author\n     c. Sort criteria (optional): Field to sort results by\n     d. Sort direction (optional): Ascending or descending order\n     e. Match type (optional): How to match keywords (all keywords or any keyword)\n     f. Date range (optional): From date and to date to limit search period\n     g. Forum ID (optional): Specific forum to search within\n   - System will use default values for any missing optional parameters\n\n2. Data Validation:\n   - Validate search keywords:\n     a. IF keywords are provided THEN verify they meet minimum length requirements\n     b. IF keywords contain special characters THEN ensure they are properly formatted\n     c. Generate appropriate error message if validation fails\n   - Validate author ID:\n     a. IF author ID is provided THEN verify it exists in the system\n     b. Generate appropriate error message if validation fails\n   - Validate date range:\n     a. IF date range is provided THEN verify from_date is before or equal to to_date\n     b. Generate appropriate error message if validation fails\n   - Validate forum ID:\n     a. IF forum ID is provided THEN verify it exists in the system\n     b. Generate appropriate error message if validation fails\n\n3. Business Rule Processing:\n   - Verify user has permission to search for new messages:\n     a. Check if user is logged in\n     b. Check if user has appropriate access rights\n     c. IF user lacks permission THEN return appropriate error message\n   - Determine search scope based on inputs:\n     a. IF forum ID is provided THEN limit search to specified forum\n     b. IF no forum ID is provided THEN search across all forums user has access to\n   - Apply system constraints:\n     a. Check if search operation would exceed system resource limits\n     b. IF limits would be exceeded THEN return appropriate error message\n\n4. Core Operation Execution:\n   - Initialize new messages search operation:\n     a. Set up search parameters based on validated inputs\n     b. Configure pagination settings (start position and records per page)\n   - Execute search for new messages:\n     a. Query database for messages matching all criteria\n     b. Filter results to include only messages posted since user's last visit\n     c. Sort results according to specified sort criteria and direction\n     d. Apply pagination to limit number of results returned\n   - Process search results:\n     a. Format each result with relevant message details\n     b. Group results by forum and topic as needed\n     c. Calculate total number of matching messages\n     d. IF search fails THEN prepare appropriate error information\n\n5. Response Generation:\n   - Prepare search results for display:\n     a. Format message content snippets showing matched keywords\n     b. Include metadata (author, date, forum, topic) for each result\n     c. Generate pagination information (current page, total pages)\n   - Generate success response:\n     a. Include formatted search results\n     b. Include total count of matching messages\n     c. Include pagination details for navigation\n     d. Include search criteria used for reference\n   - IF no results found THEN:\n     a. Provide appropriate message indicating no new messages match criteria\n     b. Suggest alternative search terms or broader criteria",
    "databaseEntities": [
      "jforum_users",
      "jforum_topics",
      "jforum_posts",
      "jforum_posts_text",
      "jforum_forums",
      "jforum_categories",
      "jforum_sessions"
    ],
    "validationRules": [
      "Search keywords must meet minimum length requirements if provided",
      "Author ID must exist in the system if provided",
      "From date must be before or equal to to date if date range is provided",
      "Forum ID must exist in the system if provided",
      "User must have permission to access the specified forum",
      "User must be logged in to search for new messages"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "SearchCriteria": {
        "type": "object",
        "properties": {
          "keywords": {
            "type": "string",
            "description": "Text to search for in messages"
          },
          "authorId": {
            "type": "number",
            "description": "ID of the message author"
          },
          "sortBy": {
            "type": "string",
            "description": "Field to sort results by"
          },
          "sortDirection": {
            "type": "string",
            "description": "Direction of sorting (ascending or descending)"
          },
          "matchType": {
            "type": "string",
            "description": "How to match keywords (all or any)"
          },
          "fromDate": {
            "type": "string",
            "format": "date",
            "description": "Start date for search range"
          },
          "toDate": {
            "type": "string",
            "format": "date",
            "description": "End date for search range"
          },
          "forumId": {
            "type": "number",
            "description": "ID of forum to search within"
          }
        }
      }
    }
  },
  {
    "featureName": "SearchContent",
    "description": "Performs content search in forums based on keywords, author, date range and other criteria.",
    "inputValues": [
      "keywords-string-SearchArgs",
      "author-number-SearchArgs",
      "orderBy-string-SearchArgs",
      "orderDir-string-SearchArgs",
      "matchType-string-SearchArgs",
      "fromDate-date-SearchArgs",
      "toDate-date-SearchArgs",
      "forumId-number-SearchArgs",
      "startFrom-number-SearchArgs"
    ],
    "businessLogic": "1. Input Collection:\n   1.1. Collect search parameters from the user:\n       1.1.1. keywords (string): Search terms entered by the user\n       1.1.2. author (number, optional): User ID of the post author to filter by\n       1.1.3. orderBy (string, optional): Field to sort results by\n       1.1.4. orderDir (string, optional): Sort direction (ascending or descending)\n       1.1.5. matchType (string, optional): Type of keyword matching (all or any)\n       1.1.6. fromDate (date, optional): Start date for filtering posts by date range\n       1.1.7. toDate (date, optional): End date for filtering posts by date range\n       1.1.8. forumId (number, optional): Specific forum ID to limit search to\n       1.1.9. startFrom (number, optional): Pagination starting point\n   1.2. Set default values for optional parameters if not provided:\n       1.2.1. IF orderBy is not specified THEN set to default sort field\n       1.2.2. IF orderDir is not specified THEN set to descending\n       1.2.3. IF matchType is not specified THEN set to \"any\"\n       1.2.4. IF startFrom is not specified THEN set to 0\n\n2. Data Validation:\n   2.1. Validate keywords input:\n       2.1.1. IF keywords is empty or null THEN return error message \"Search keywords are required\"\n       2.1.2. IF keywords length is less than minimum allowed THEN return error message \"Search term must be at least X characters long\"\n   2.2. Validate author input (if provided):\n       2.2.1. IF author is provided THEN verify author ID exists in the system\n       2.2.2. IF author ID is invalid THEN return error message \"Invalid author specified\"\n   2.3. Validate date range (if provided):\n       2.3.1. IF fromDate is provided AND toDate is provided THEN:\n           2.3.1.1. Verify fromDate is not after toDate\n           2.3.1.2. IF fromDate is after toDate THEN return error message \"Start date cannot be after end date\"\n   2.4. Validate forum ID (if provided):\n       2.4.1. IF forumId is provided THEN verify forum exists\n       2.4.2. IF forum does not exist THEN return error message \"Invalid forum specified\"\n\n3. Business Rule Processing:\n   3.1. Check user permissions:\n       3.1.1. Verify current user has permission to search content\n       3.1.2. IF user lacks search permission THEN return error message \"You do not have permission to search\"\n   3.2. Check forum access permissions:\n       3.2.1. IF forumId is specified THEN verify user has access to that forum\n       3.2.2. IF user cannot access the specified forum THEN exclude it from search\n   3.3. Apply search rate limiting:\n       3.3.1. Check if user has performed too many searches in a short time period\n       3.3.2. IF search rate limit exceeded THEN return error message \"Search rate limit exceeded. Please try again later.\"\n   3.4. Determine search operation type:\n       3.4.1. IF search is for new messages THEN use NewMessagesSearchOperation\n       3.4.2. ELSE use ContentSearchOperation for regular searches\n\n4. Core Operation Execution:\n   4.1. Prepare search arguments:\n       4.1.1. Create a SearchArgs object with all validated parameters\n       4.1.2. IF matchType is \"all\" THEN configure search to match all keywords\n       4.1.3. Set pagination parameters based on system configuration\n   4.2. Execute search operation:\n       4.2.1. Perform the search using the appropriate search operation\n       4.2.2. Collect matching posts/topics based on search criteria\n       4.2.3. IF no results found THEN prepare empty result set\n   4.3. Process search results:\n       4.3.1. Filter results based on user permissions\n       4.3.2. Sort results according to orderBy and orderDir parameters\n       4.3.3. Apply pagination to limit number of results per page\n   4.4. Handle any search execution errors:\n       4.4.1. IF search execution fails THEN log error details\n       4.4.2. Return appropriate error message to user\n\n5. Response Generation:\n   5.1. Prepare search results for display:\n       5.1.1. Format each result item with relevant information (title, content snippet, author, date)\n       5.1.2. Include highlighting of matched keywords in results\n       5.1.3. Calculate total number of matching results\n   5.2. Generate pagination information:\n       5.2.1. Calculate total number of pages based on results count and page size\n       5.2.2. Determine current page number\n       5.2.3. Create navigation links for previous/next pages\n   5.3. Prepare additional context information:\n       5.3.1. Include forum categories for filtering options\n       5.3.2. Include original search parameters for form repopulation\n       5.3.3. Include any system messages or notifications\n   5.4. Return complete search results view to user:\n       5.4.1. IF successful search THEN display results page with findings\n       5.4.2. IF search had errors THEN display error message with search form\n       5.4.3. IF no results found THEN display \"No results found\" message with search form",
    "databaseEntities": [
      "jforum_users",
      "jforum_forums",
      "jforum_topics",
      "jforum_posts",
      "jforum_posts_text",
      "jforum_categories"
    ],
    "validationRules": [
      "Search keywords must not be empty",
      "Author ID must exist in the system if specified",
      "From date must not be after to date if date range is specified",
      "Forum ID must exist if specified",
      "User must have permission to search content",
      "User must have access to specified forum if forum ID is provided"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "SearchArgs": {
        "keywords": "string",
        "author": "number",
        "orderBy": "string",
        "orderDir": "string",
        "matchType": "string",
        "fromDate": "date",
        "toDate": "date",
        "forumId": "number",
        "startFrom": "number"
      },
      "SearchResult": {
        "results": "array",
        "numberOfHits": "number",
        "executionTime": "number"
      }
    }
  },
  {
    "featureName": "ListSearchFilters",
    "description": "Shows the search filters page as the default list action for forum content.",
    "inputValues": [
      "categories-object-Category",
      "pageTitle-string-PageTitle"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect system configuration settings\n     - Topics per page configuration\n     - Posts per page configuration\n   - No user inputs required at this stage as this is the initial filter display\n\n2. Data Validation:\n   - Verify user has permission to access search functionality\n     - IF user does not have search permission THEN\n       - Display appropriate error message\n       - Redirect to permission denied page\n     - END IF\n   - Verify system search functionality is enabled\n     - IF search functionality is disabled THEN\n       - Display appropriate system message\n       - Redirect to home page\n     - END IF\n\n3. Business Rule Processing:\n   - Retrieve all forum categories\n     - Fetch complete list of categories from the system\n     - Verify categories are properly sorted by display order\n     - IF no categories exist THEN\n       - Prepare empty category list for display\n     - END IF\n   - Prepare page title information\n     - Set page title to search-related text from language resources\n   - Determine user's search permissions\n     - Check if user can search in all forums or only specific ones\n     - Prepare list of searchable forums based on user permissions\n\n4. Core Operation Execution:\n   - Prepare search filter form\n     - Initialize search form with default values\n     - Set up category dropdown options\n     - Set up forum dropdown options based on categories\n     - Set up date range selector defaults\n     - Set up sorting options (relevance, date, etc.)\n     - Set up matching options (all keywords, any keywords)\n   - Prepare template data\n     - Add categories list to template context\n     - Add page title to template context\n     - Add any user-specific search preferences\n\n5. Response Generation:\n   - Display search filters template\n     - Show search form with all available filters\n     - Include appropriate help text for search options\n     - Ensure form is properly structured for submission\n     - Display category and forum selection options\n   - Provide clear instructions on search usage\n     - Include examples of effective search terms\n     - Show tips for advanced search techniques\n   - Prepare for subsequent search action\n     - Set up form submission target\n     - Ensure all necessary hidden fields are included",
    "databaseEntities": [
      "jforum_categories",
      "jforum_forums",
      "jforum_topics",
      "jforum_posts",
      "jforum_users"
    ],
    "validationRules": [
      "User must have permission to access search functionality",
      "System search functionality must be enabled",
      "At least one searchable forum must exist",
      "Search form must contain all required filter options"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Category": {
        "id": "number",
        "name": "string",
        "order": "number",
        "forums": "array"
      },
      "PageTitle": {
        "title": "string",
        "description": "string"
      }
    }
  },
  {
    "featureName": "CheckBannerDisplayEligibility",
    "description": "Determines if a banner should be displayed based on user rights and banner filter settings.",
    "inputValues": [
      "bannerId-number-Banner",
      "userRights-object-UserRights",
      "bannerFilterSettings-object-BannerFilterSettings"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the following inputs:\n     a. bannerId (mandatory): Unique identifier for the banner to check\n     b. userRights (mandatory): Object containing user permission settings\n     c. bannerFilterSettings (mandatory): Object containing filter criteria for banner display\n\n2. Data Validation:\n   a. Validate bannerId:\n      - Check if bannerId is a positive integer\n      - Verify bannerId exists in the system\n      - IF bannerId is invalid or not found THEN\n        - Return error indicating invalid banner identifier\n   b. Validate userRights:\n      - Ensure userRights object contains required permission attributes\n      - Verify userRights contains valid permission values\n      - IF userRights object is malformed THEN\n        - Return error indicating invalid user rights format\n   c. Validate bannerFilterSettings:\n      - Ensure bannerFilterSettings contains required filter attributes\n      - Verify filter values are within acceptable ranges\n      - IF bannerFilterSettings object is malformed THEN\n        - Return error indicating invalid filter settings\n\n3. Business Rule Processing:\n   a. Check banner active status:\n      - Retrieve banner details using bannerId\n      - Verify if banner is currently active\n      - IF banner is not active THEN\n        - Return false (banner should not be displayed)\n   b. Check placement compatibility:\n      - Verify if the banner's placement is appropriate for the current context\n      - IF placement is incompatible THEN\n        - Return false (banner should not be displayed)\n   c. Check user permission rules:\n      - Compare user rights with banner visibility requirements\n      - Determine if user has sufficient permissions to view the banner\n      - IF user lacks required permissions THEN\n        - Return false (banner should not be displayed)\n   d. Apply banner filter settings:\n      - Check if banner matches all filter criteria (e.g., category, date range, user group)\n      - IF banner does not match filter criteria THEN\n        - Return false (banner should not be displayed)\n\n4. Core Operation Execution:\n   a. Determine final display eligibility:\n      - Combine results from all previous checks\n      - Apply any additional business rules specific to banner types\n      - Make final determination on banner display eligibility\n   b. Update banner statistics if needed:\n      - If tracking is enabled, record that eligibility was checked\n      - Update any relevant counters or logs\n\n5. Response Generation:\n   a. Generate response with eligibility result:\n      - Return boolean result indicating if banner should be displayed\n      - Include any relevant context information if needed\n   b. Include any additional display instructions:\n      - If eligible for display, include any special display parameters\n      - If not eligible, include reason code for logging purposes",
    "databaseEntities": [
      "Banner",
      "User",
      "Group"
    ],
    "validationRules": [
      "Banner ID must be a positive integer",
      "Banner must exist in the system",
      "Banner must be active to be displayed",
      "User must have appropriate permissions to view the banner",
      "Banner must match all specified filter criteria",
      "Banner placement must be compatible with the current context"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "UserRights": {
        "type": "object",
        "properties": {
          "userGroups": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Groups the user belongs to"
          },
          "permissions": {
            "type": "object",
            "description": "User permission settings"
          },
          "accessLevel": {
            "type": "string",
            "description": "User's access level in the system"
          }
        },
        "required": [
          "userGroups",
          "permissions",
          "accessLevel"
        ]
      },
      "BannerFilterSettings": {
        "type": "object",
        "properties": {
          "placement": {
            "type": "number",
            "description": "Position identifier where the banner should be displayed"
          },
          "categoryFilters": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Categories where the banner can be displayed"
          },
          "dateRangeStart": {
            "type": "string",
            "format": "date",
            "description": "Start date for banner display period"
          },
          "dateRangeEnd": {
            "type": "string",
            "format": "date",
            "description": "End date for banner display period"
          },
          "weightThreshold": {
            "type": "number",
            "description": "Minimum weight threshold for banner display"
          }
        },
        "required": [
          "placement"
        ]
      }
    }
  },
  {
    "featureName": "CheckActiveBannerExistence",
    "description": "Verifies if any active banner exists at the specified placement position.",
    "inputValues": [
      "placement-number-Banner"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect placement position (number) - mandatory\n   - System will use this placement position to check for active banners\n\n2. Data Validation:\n   - Validate placement position:\n     a. Ensure placement position is a valid number\n     b. Verify placement position is within the allowed range of placement values\n     c. Return appropriate error if validation fails\n\n3. Business Rule Processing:\n   - Verify system state:\n     a. Ensure banner management system is operational\n     b. Check if banner data access is available\n     c. IF any system dependencies are unavailable, THEN return appropriate error\n\n4. Core Operation Execution:\n   - Query for active banners:\n     a. Search for all active banners matching the specified placement position\n     b. Collect all matching banners into a result set\n     c. IF query execution fails, THEN handle the error and return appropriate message\n   - Evaluate query results:\n     a. Check if the result set contains any banners\n     b. IF result set is empty or null, THEN set existence flag to false\n     c. ELSE set existence flag to true\n\n5. Response Generation:\n   - Generate response with banner existence status:\n     a. Return boolean value indicating whether active banners exist at the specified placement\n     b. Include placement position in response for reference\n     c. IF error occurred during processing, include appropriate error details",
    "databaseEntities": [
      "Banner"
    ],
    "validationRules": [
      "Placement position must be a valid number",
      "Placement position must be within allowed range of values",
      "Banner data access must be available"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Banner": {
        "id": "number",
        "placement": "number",
        "active": "boolean",
        "weight": "number",
        "views": "number"
      }
    }
  },
  {
    "featureName": "SelectBannerByWeight",
    "description": "Retrieves the appropriate banner based on weighted random selection and updates view count.",
    "inputValues": [
      "placement-number-Banner"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect placement number (mandatory) that identifies the position where the banner will be displayed\n   - System will use this placement to retrieve relevant banners\n\n2. Data Validation:\n   - Validate that placement is a positive integer\n     * IF placement is not a positive integer, THEN return error message indicating invalid placement value\n   - Check if active banners exist for the specified placement\n     * IF no active banners exist for the placement, THEN return empty result\n\n3. Business Rule Processing:\n   - Verify banner display eligibility\n     * Check if there are any active banners for the specified placement\n     * IF no active banners exist, THEN end process and return null\n   - Prepare for weighted random selection\n     * Ensure all banners have assigned weights\n     * Weights should ideally sum to 99 for the placement group\n\n4. Core Operation Execution:\n   - Generate a random number between 0 and 98 (inclusive)\n   - Perform weighted selection algorithm:\n     * Initialize weightFrom = 0 and weightTo = 0\n     * FOR each banner in the active banners list:\n       - Add current banner's weight to weightTo\n       - IF random number is between weightFrom and weightTo-1 (inclusive), THEN\n         * Select this banner\n         * Exit the loop\n       - Set weightFrom = weightTo\n     * IF no banner was selected (random number exceeded total weight), THEN\n       - Select the banner with the highest weight\n   - Update the selected banner's view count\n     * Increment the view count by 1\n     * Save the updated banner information\n\n5. Response Generation:\n   - Return the selected banner object with all its properties\n   - IF no banner could be selected, THEN return null\n   - Include updated view count in the returned banner object",
    "databaseEntities": [
      "Banner"
    ],
    "validationRules": [
      "Placement must be a positive integer",
      "At least one active banner must exist for the specified placement",
      "Each banner must have a defined weight value",
      "Banner weights should ideally sum to 99 for each placement group"
    ],
    "dbSeedingOperations": [
      "Seed sample banners with different weights for testing"
    ],
    "schema": {
      "Banner": {
        "id": "number",
        "placement": "number",
        "weight": "number",
        "views": "number",
        "active": "boolean",
        "content": "string"
      }
    }
  },
  {
    "featureName": "RegisterNewUser",
    "description": "Handles new user registration with form display and validation.",
    "inputValues": [
      "username-string-User",
      "password-string-User",
      "email-string-User",
      "captchaResponse-string-User"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the following user registration information:\n     a. username (mandatory): User's chosen identifier\n     b. password (mandatory): User's chosen password\n     c. email (mandatory): User's email address\n     d. captchaResponse (mandatory if enabled): User's response to security challenge\n   - System determines if registration is enabled\n   - System determines if email activation is required\n\n2. Data Validation:\n   - Validate username:\n     a. Check if username is not empty\n     b. Verify username length does not exceed maximum allowed length\n     c. Ensure username does not contain invalid characters (< or >)\n     d. Check if username is not already registered in the system\n   - Validate password:\n     a. Check if password is not empty\n   - Validate email:\n     a. Check if email is not already registered in the system\n   - Validate captcha (if enabled):\n     a. Verify user's captcha response matches the expected value\n   - IF any validation fails:\n     a. Display appropriate error message\n     b. Return user to registration form with entered values preserved\n     c. END process\n\n3. Business Rule Processing:\n   - Check if user registration is enabled in the system\n     a. IF registration is disabled AND current user does not have administration privileges:\n        i. Display registration disabled message\n        ii. END process\n   - Check if terms agreement is required\n     a. IF agreement is required AND user has not accepted agreement:\n        i. Display agreement terms to user\n        ii. Wait for user acceptance\n        iii. IF user accepts, continue process\n        iv. IF user rejects, END process\n\n4. Core Operation Execution:\n   - Create new user record with provided information:\n     a. Store username as provided\n     b. Encrypt password before storing\n     c. Store email as provided\n   - IF email activation is required:\n     a. Generate unique activation key for the user\n     b. Store activation key with user record\n     c. Send activation email to user's email address\n     d. Mark user account as inactive\n   - ELSE:\n     a. Mark user account as active\n   - Update system statistics:\n     a. Increment total user count\n     b. Update last registered user information\n\n5. Response Generation:\n   - IF email activation is required:\n     a. Display message instructing user to check email for activation instructions\n   - ELSE IF user was registered by administrator:\n     a. Redirect administrator to user management page\n   - ELSE:\n     a. Automatically log new user into the system\n     b. Create new session for the user\n     c. Display registration completion message\n     d. Provide links to profile editing page and homepage",
    "databaseEntities": [
      "jforum_users",
      "jforum_sessions",
      "jforum_user_groups"
    ],
    "validationRules": [
      "Username must not be empty",
      "Password must not be empty",
      "Username must not exceed maximum allowed length",
      "Username must not contain < or > characters",
      "Username must not already exist in the system",
      "Email must not already be registered in the system",
      "Captcha response must match expected value if captcha is enabled"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "User": {
        "properties": {
          "username": {
            "type": "string",
            "description": "User's chosen identifier"
          },
          "password": {
            "type": "string",
            "description": "User's encrypted password"
          },
          "email": {
            "type": "string",
            "description": "User's email address"
          },
          "activationKey": {
            "type": "string",
            "description": "Key for email account activation"
          },
          "active": {
            "type": "boolean",
            "description": "Indicates if user account is active"
          }
        },
        "required": [
          "username",
          "password",
          "email"
        ]
      }
    }
  },
  {
    "featureName": "SaveNewUser",
    "description": "Processes and saves new user registration with validation checks.",
    "inputValues": [
      "username-string-User",
      "password-string-User",
      "email-string-User",
      "captchaResponse-string-User"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the following user registration information:\n     a. username (mandatory): User's chosen identifier\n     b. password (mandatory): User's chosen password\n     c. email (mandatory): User's email address\n     d. captchaResponse (mandatory if captcha enabled): User's response to security challenge\n   - System generates:\n     a. activationKey (if email verification required): Unique verification code\n\n2. Data Validation:\n   - Username Validation:\n     a. Check if username is not empty\n     b. Verify username length does not exceed maximum allowed length\n     c. Ensure username does not contain invalid characters (< or >)\n     d. Verify username is not already registered in the system\n   - Password Validation:\n     a. Check if password is not empty\n   - Email Validation:\n     a. Verify email is not already registered in the system\n   - Captcha Validation (if enabled):\n     a. Verify the captcha response matches the expected value\n   - IF any validation fails THEN:\n     a. Collect all validation errors\n     b. Return to registration form with error messages\n     c. Preserve entered data for user convenience\n\n3. Business Rule Processing:\n   - Check if registration is enabled in system settings\n     a. IF registration is disabled AND current user does not have administration privileges THEN:\n        i. Display registration disabled message\n        ii. Terminate registration process\n   - Check if user agreement acceptance is required\n     a. IF agreement is required AND not yet accepted THEN:\n        i. Display agreement text\n        ii. Require user acceptance before proceeding\n        iii. Store acceptance status in session\n   - Check if email activation is required based on system settings\n\n4. Core Operation Execution:\n   - Create new user record with provided information:\n     a. Set username as provided\n     b. Encrypt password using MD5 algorithm\n     c. Set email as provided\n     d. IF email activation is required THEN:\n        i. Generate unique activation key\n        ii. Set user status as inactive\n     e. ELSE:\n        i. Set user status as active\n   - Save user record to database\n   - IF email activation is required THEN:\n     a. Send activation email to user\n     b. Display instructions to check email\n   - ELSE IF user was created by administrator THEN:\n     a. Redirect to admin user list\n   - ELSE:\n     a. Automatically log user in\n     b. Create new user session\n     c. Update system statistics (last registered user, total users)\n     d. Redirect to registration completion page\n\n5. Response Generation:\n   - Success Response:\n     a. IF email activation required:\n        i. Display message instructing user to check email\n     b. ELSE IF created by administrator:\n        i. Return to admin user list\n     c. ELSE:\n        i. Display registration completion message\n        ii. Provide links to profile page and forum homepage\n   - Error Response:\n     a. Display specific error messages for validation failures\n     b. Preserve user input for correction\n     c. Regenerate captcha if applicable",
    "databaseEntities": [
      "jforum_users",
      "jforum_user_groups",
      "jforum_sessions"
    ],
    "validationRules": [
      "Username must not be empty",
      "Password must not be empty",
      "Username must not exceed maximum allowed length",
      "Username must not contain < or > characters",
      "Username must not already exist in the system",
      "Email must not already be registered in the system",
      "Captcha response must match expected value if captcha is enabled"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "User": {
        "properties": {
          "username": {
            "type": "string",
            "description": "User's chosen identifier"
          },
          "password": {
            "type": "string",
            "description": "User's encrypted password"
          },
          "email": {
            "type": "string",
            "description": "User's email address"
          },
          "activationKey": {
            "type": "string",
            "description": "Key for email verification if required"
          },
          "active": {
            "type": "boolean",
            "description": "Indicates if user account is active"
          }
        },
        "required": [
          "username",
          "password",
          "email"
        ]
      }
    }
  },
  {
    "featureName": "DisplayUserAgreement",
    "description": "Shows terms and conditions agreement for user registration.",
    "inputValues": [
      "username-string-User",
      "email-string-User"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect user registration information:\n     - username (mandatory string)\n     - email (mandatory string)\n     - password (mandatory string)\n     - captcha response (mandatory string if captcha is enabled)\n   - System determines if agreement display is required based on configuration\n\n2. Data Validation:\n   - Validate if user registration is enabled in the system\n     - IF registration is disabled, THEN show registration disabled message\n     - IF using SSO authentication, THEN show registration disabled message\n   - Validate if agreement needs to be shown\n     - IF agreement display is configured AND agreement not yet accepted, THEN proceed to agreement display\n     - IF agreement already accepted OR not required, THEN proceed to registration form\n\n3. Business Rule Processing:\n   - Load agreement content:\n     - Attempt to load language-specific agreement file\n     - IF language-specific file not found, THEN load default agreement file\n     - IF no agreement file found, THEN display \"no agreement available\" message\n   - Present agreement content to user\n   - Provide option to accept or decline agreement\n     - IF user declines agreement, THEN registration process is terminated\n     - IF user accepts agreement, THEN:\n       - Record agreement acceptance in user session\n       - Proceed to registration form\n\n4. Core Operation Execution:\n   - Display agreement content to user\n   - Record user's acceptance decision\n   - IF accepted, THEN redirect user to registration form\n   - IF declined, THEN terminate registration process\n\n5. Response Generation:\n   - For agreement display:\n     - Show complete agreement text\n     - Provide accept/decline options\n   - For acceptance confirmation:\n     - Record acceptance in session\n     - Redirect to registration form\n   - For registration disabled:\n     - Show appropriate message explaining registration is not available",
    "databaseEntities": [
      "jforum_users"
    ],
    "validationRules": [
      "Registration must be enabled in system settings",
      "Agreement must be shown if configured in system settings",
      "User must accept agreement before proceeding with registration",
      "Agreement file must be available in the system"
    ],
    "dbSeedingOperations": [
      "Ensure agreement text files are available in the configured directory"
    ],
    "schema": {}
  },
  {
    "featureName": "AcceptUserAgreement",
    "description": "Processes user acceptance of the terms and conditions agreement before registration.",
    "inputValues": [
      "agreementText-string-Agreement",
      "userAcceptance-boolean-User"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect user agreement acceptance status (userAcceptance: boolean)\n   - System retrieves agreement text (agreementText: string)\n   - System identifies current user session\n\n2. Data Validation:\n   - Validate that agreement text is available\n     * IF agreement text is not available THEN\n       - Load default agreement text\n       - IF default agreement text is not available THEN\n         - Display error message indicating agreement text could not be found\n         - End process\n   - Validate user session exists\n     * IF user session does not exist THEN\n       - Create new user session\n       - Set session attributes to default values\n\n3. Business Rule Processing:\n   - Check if registration is enabled in system settings\n     * IF registration is disabled AND current user is not an administrator THEN\n       - Display registration disabled message\n       - End process\n   - Check if agreement must be shown based on system configuration\n     * IF agreement should not be shown THEN\n       - Skip agreement acceptance step\n       - Proceed to registration form\n       - End process\n   - Check if user has already accepted the agreement\n     * IF user has already accepted agreement THEN\n       - Skip agreement display\n       - Proceed to registration form\n       - End process\n\n4. Core Operation Execution:\n   - Display agreement text to user\n   - Provide acceptance option to user\n   - IF user accepts agreement THEN\n     * Store acceptance status in user session\n     * Mark agreement as accepted\n     * Proceed to registration form\n   - ELSE IF user declines agreement THEN\n     * Do not store acceptance status\n     * Return to previous page or homepage\n     * End registration process\n\n5. Response Generation:\n   - IF agreement was successfully accepted THEN\n     * Generate success response\n     * Redirect user to registration form\n     * Prepare registration form with any previously entered data\n   - ELSE\n     * Generate appropriate message based on user action\n     * Provide option to review agreement again if declined",
    "databaseEntities": [
      "jforum_users",
      "jforum_sessions"
    ],
    "validationRules": [
      "Agreement text must be available for user to review",
      "User must explicitly accept the agreement to proceed with registration",
      "System must verify if registration is enabled before showing agreement",
      "Agreement acceptance must be stored in user session",
      "User cannot proceed to registration without accepting agreement"
    ],
    "dbSeedingOperations": [
      "Ensure default agreement text file exists in the system"
    ],
    "schema": {
      "Agreement": {
        "type": "object",
        "properties": {
          "text": {
            "type": "string",
            "description": "The full text content of the user agreement"
          },
          "version": {
            "type": "string",
            "description": "Version identifier of the agreement"
          },
          "lastUpdated": {
            "type": "date",
            "description": "Date when the agreement was last updated"
          }
        }
      },
      "User": {
        "type": "object",
        "properties": {
          "sessionId": {
            "type": "string",
            "description": "Unique identifier for user session"
          },
          "hasAcceptedAgreement": {
            "type": "boolean",
            "description": "Flag indicating if user has accepted the agreement"
          }
        }
      }
    }
  },
  {
    "featureName": "RequestManualActivation",
    "description": "Provides interface for manual account activation when automatic activation fails.",
    "inputValues": [
      "username-string-User",
      "email-string-User",
      "activationKey-string-User"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the following required inputs:\n      a. Username (mandatory string)\n      b. Email address (mandatory string)\n      c. Activation key (mandatory string)\n   - System retrieves current date/time (system-generated)\n\n2. Data Validation:\n   - Validate username:\n      a. Check if username is not empty\n      b. Verify username exists in the system\n      c. Display error message if username is invalid\n   - Validate email address:\n      a. Check if email is not empty\n      b. Verify email format is valid\n      c. Confirm email matches the one associated with the username\n      d. Display error message if email is invalid\n   - Validate activation key:\n      a. Check if activation key is not empty\n      b. Display error message if activation key is empty\n\n3. Business Rule Processing:\n   - Check account status:\n      a. Verify the account is not already activated\n      b. IF account is already active THEN\n         i. Display message that account is already active\n         ii. Provide link to login page\n         iii. End process\n      c. ELSE continue\n   - Check activation request eligibility:\n      a. Verify the account was created within the allowed timeframe for activation\n      b. IF account creation date exceeds allowed activation period THEN\n         i. Display message that activation period has expired\n         ii. Provide instructions for contacting support\n         iii. End process\n      c. ELSE continue\n\n4. Core Operation Execution:\n   - Process manual activation request:\n      a. Create activation request record with:\n         i. Username\n         ii. Email\n         iii. Activation key\n         iv. Request timestamp\n         v. Request status set to 'Pending'\n      b. Generate unique request reference number\n      c. Notify administrators of pending activation request\n      d. IF request creation fails THEN\n         i. Log error details\n         ii. Display system error message\n         iii. Provide alternative contact method\n         iv. End process\n      e. ELSE continue\n\n5. Response Generation:\n   - Display confirmation page:\n      a. Show success message with request reference number\n      b. Provide estimated processing time information\n      c. Include instructions for checking request status\n      d. Offer alternative contact options if urgent\n   - Send confirmation email:\n      a. Include request reference number\n      b. Provide estimated processing time\n      c. Include contact information for support",
    "databaseEntities": [
      "jforum_users",
      "jforum_activation_requests"
    ],
    "validationRules": [
      "Username must not be empty",
      "Username must exist in the system",
      "Email must not be empty",
      "Email must be in valid format",
      "Email must match the one associated with the username",
      "Activation key must not be empty",
      "Account must not be already activated",
      "Account must be within allowed timeframe for activation"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "User": {
        "type": "object",
        "properties": {
          "id": {
            "type": "number"
          },
          "username": {
            "type": "string"
          },
          "email": {
            "type": "string"
          },
          "activationKey": {
            "type": "string"
          },
          "active": {
            "type": "boolean"
          },
          "registrationDate": {
            "type": "date"
          }
        },
        "required": [
          "username",
          "email",
          "activationKey"
        ]
      },
      "ActivationRequest": {
        "type": "object",
        "properties": {
          "id": {
            "type": "number"
          },
          "userId": {
            "type": "number"
          },
          "username": {
            "type": "string"
          },
          "email": {
            "type": "string"
          },
          "activationKey": {
            "type": "string"
          },
          "requestDate": {
            "type": "date"
          },
          "status": {
            "type": "string",
            "enum": [
              "Pending",
              "Approved",
              "Rejected"
            ]
          },
          "referenceNumber": {
            "type": "string"
          }
        },
        "required": [
          "username",
          "email",
          "activationKey",
          "requestDate",
          "status"
        ]
      }
    }
  },
  {
    "featureName": "CompleteRegistration",
    "description": "Finalizes user registration and shows confirmation message.",
    "inputValues": [
      "userId-number-User",
      "username-string-User"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect userId (number, system-generated)\n   - Collect username (string, mandatory)\n   - System retrieves current session information\n\n2. Data Validation:\n   - Validate userId:\n     a. Verify userId is a positive integer\n     b. Verify userId exists in the system\n     c. Return error if validation fails\n   - Validate username:\n     a. Verify username is not empty\n     b. Verify username follows system format rules\n     c. Return error if validation fails\n   - Validate user session:\n     a. Verify session is active\n     b. Verify session belongs to the registering user\n     c. Return error if validation fails\n\n3. Business Rule Processing:\n   - Check if user account is already active:\n     a. IF user account is already active THEN\n        i. Return error message indicating account is already active\n     b. ELSE continue with activation process\n   - Update user statistics in the system:\n     a. Increment total user count\n     b. Update last registered user information\n     c. Verify statistics update was successful\n   - Prepare navigation links:\n     a. Generate profile page link\n     b. Generate home page link\n     c. Store links for inclusion in confirmation message\n\n4. Core Operation Execution:\n   - Update user record status:\n     a. Set user account status to active\n     b. Record activation timestamp\n     c. IF update fails THEN\n        i. Log error details\n        ii. Return system error message\n     d. ELSE continue with process\n   - Create user session:\n     a. Initialize new user session\n     b. Set session parameters (auto-login, user ID, username)\n     c. Set session timestamps (last visit, start time)\n     d. Add session to active sessions\n     e. IF session creation fails THEN\n        i. Log error details\n        ii. Return system error message\n     f. ELSE continue with process\n\n5. Response Generation:\n   - Prepare confirmation message:\n     a. Include personalized greeting with username\n     b. Include profile page link\n     c. Include home page link\n     d. Include any additional guidance for new users\n   - Display registration completion page:\n     a. Show confirmation message\n     b. Provide navigation options\n     c. Suggest next steps for the user",
    "databaseEntities": [
      "jforum_users",
      "jforum_sessions",
      "jforum_user_groups"
    ],
    "validationRules": [
      "User ID must be a positive integer",
      "Username must not be empty",
      "User must exist in the system",
      "User session must be active",
      "User session must belong to the registering user"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "User": {
        "type": "object",
        "properties": {
          "userId": {
            "type": "number",
            "description": "Unique identifier for the user"
          },
          "username": {
            "type": "string",
            "description": "User's chosen display name"
          },
          "isActive": {
            "type": "boolean",
            "description": "Indicates if the user account is active"
          }
        },
        "required": [
          "userId",
          "username"
        ]
      }
    }
  },
  {
    "featureName": "CompleteUserRegistration",
    "description": "Finalizes user registration by updating system data and showing completion page.",
    "inputValues": [
      "userId-number-User"
    ],
    "businessLogic": "1. Input Collection\n   - Collect userId (number) from the user session\n   - System will retrieve the user information based on this ID\n\n2. Data Validation\n   - Validate that userId exists in the system\n     * IF userId is not found or invalid THEN\n       - Display error message to user\n       - Redirect user to registration page\n     * END IF\n   - Validate that user registration is in progress\n     * IF user registration is not in progress THEN\n       - Display appropriate error message\n       - Redirect to home page\n     * END IF\n\n3. Business Rule Processing\n   - Check if the user has already completed registration\n     * IF registration is already complete THEN\n       - Display notification message\n       - Redirect to user profile page\n       - Exit process\n     * END IF\n   - Verify all required registration steps are completed\n     * IF any required steps are incomplete THEN\n       - Identify missing information\n       - Redirect user to complete the missing steps\n       - Exit process\n     * END IF\n\n4. Core Operation Execution\n   - Update system records with new user information\n     * Update last registered user information in the system\n     * Increment total user count in the system\n   - Mark user registration as complete in the database\n     * Update user status to 'active' or equivalent\n     * Set registration completion timestamp\n   - Generate user profile links\n     * Create link to user profile page\n     * Create link to home page\n   - Prepare completion message for display\n     * Include links to profile and home pages in the message\n     * Format message according to system templates\n\n5. Response Generation\n   - Display registration completion page to user\n     * Show congratulatory message\n     * Display links to profile page for customization\n     * Display link to home page to start using the system\n   - Provide next steps information\n     * Suggest profile completion options\n     * Recommend initial system navigation paths\n     * Offer help resources if needed",
    "databaseEntities": [
      "jforum_users",
      "jforum_sessions",
      "jforum_user_groups"
    ],
    "validationRules": [
      "User ID must exist in the system",
      "User registration must be in progress",
      "All required registration steps must be completed"
    ],
    "dbSeedingOperations": [],
    "schema": {}
  },
  {
    "featureName": "ViewUserProfile",
    "description": "Displays user profile information including statistics and bookmarks.",
    "inputValues": [
      "userId-number-User"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the userId (mandatory) from the request\n   - System will use the current session for logged-in user information\n\n2. Data Validation:\n   - Validate that userId is a positive integer\n   - Verify userId exists in the system\n   IF userId is invalid or not found THEN\n      - Prepare user not found message\n      - Display user not found page\n      - End process\n   END IF\n\n3. Business Rule Processing:\n   - Check if the current user has permission to view karma information\n   - Determine which bookmarks are visible to the current user based on:\n     - Public visibility of bookmarks\n     - If the profile being viewed belongs to the current user\n\n4. Core Operation Execution:\n   - Retrieve user profile data:\n     - Basic user information (username, registration date, etc.)\n     - User avatar information\n     - User ranking information\n   - Calculate user statistics:\n     - Count number of visible bookmarks\n     - Count number of topics created by user\n     - Count number of posts made by user\n   - Prepare page title with user's name\n\n5. Response Generation:\n   - Compile all user information into profile view\n   - Display the following sections:\n     - User personal information\n     - User statistics (topics, posts, etc.)\n     - User ranking\n     - User avatar (if available)\n     - Visible bookmarks count\n   - If user not found, display appropriate error message",
    "databaseEntities": [
      "jforum_users",
      "jforum_bookmarks",
      "jforum_topics",
      "jforum_posts",
      "jforum_sessions"
    ],
    "validationRules": [
      "User ID must be a valid positive integer",
      "User ID must exist in the system",
      "Only public bookmarks are visible to other users",
      "All bookmarks are visible to the profile owner"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "User": {
        "id": "number",
        "username": "string",
        "email": "string",
        "registrationDate": "date",
        "lastVisit": "date",
        "avatar": "string",
        "karma": "number"
      },
      "Bookmark": {
        "id": "number",
        "userId": "number",
        "isPublicVisible": "boolean",
        "title": "string"
      }
    }
  },
  {
    "featureName": "LogoutUser",
    "description": "Logs out current user by removing session data and disabling auto-login.",
    "inputValues": [],
    "businessLogic": "1. Input Collection:\n   - No explicit user inputs required\n   - System will use current user session data\n\n2. Data Validation:\n   - Verify active user session exists\n     - IF no active session exists THEN\n       - Skip logout process\n       - Redirect user to default page\n     - ELSE continue with logout process\n\n3. Business Rule Processing:\n   - Check if user has active session\n     - IF user session exists THEN\n       - Prepare to store session data for historical purposes\n     - ELSE skip session data storage\n   - Check if auto-login is enabled for current session\n     - IF auto-login is enabled THEN\n       - Mark auto-login for disabling\n     - ELSE continue with standard logout\n\n4. Core Operation Execution:\n   - Store current session data to persistent storage\n     - Save session identifier\n     - Save session timestamp\n     - Save user activity information\n   - Remove user session from active sessions\n     - Delete session from memory storage\n     - Mark session as expired\n   - Disable auto-login functionality\n     - Set auto-login flag to false\n     - Remove authentication cookies\n   - Create new anonymous session\n     - Generate new session with guest privileges\n     - Associate minimal required data with session\n   - Add new anonymous session to session registry\n\n5. Response Generation:\n   - Prepare redirect to default page\n   - Return success status\n   - Clear sensitive user data from memory",
    "databaseEntities": [
      "jforum_users",
      "jforum_sessions"
    ],
    "validationRules": [
      "User must have an active session to logout",
      "Session data must be stored before removal",
      "Auto-login cookies must be removed if present",
      "New anonymous session must be created after logout"
    ],
    "dbSeedingOperations": [],
    "schema": {}
  },
  {
    "featureName": "ShowLoginForm",
    "description": "Displays the login form with optional return path handling.",
    "inputValues": [
      "returnPath-string-Navigation"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the following inputs:\n     a. returnPath (string, optional): The URL to redirect after successful login\n\n2. Data Validation:\n   - Validate authentication type:\n     a. IF authentication type is SSO THEN\n        i. Display registration disabled message\n        ii. Exit the process\n     b. ELSE continue with normal login form display\n\n3. Business Rule Processing:\n   - Process return path information:\n     a. IF returnPath parameter is provided THEN\n        i. Store returnPath value for use after login\n     b. ELSE IF system is configured to use referrer information THEN\n        i. Retrieve HTTP referrer header\n        ii. IF referrer exists THEN\n           1. Store referrer as returnPath for use after login\n\n4. Core Operation Execution:\n   - Prepare login form display:\n     a. Set page title to localized \"Login\" text\n     b. Set template to display login form\n     c. Include any stored returnPath in the form context\n\n5. Response Generation:\n   - Generate login form response:\n     a. Display login form with:\n        i. Username field\n        ii. Password field\n        iii. \"Remember me\" option if auto-login is enabled\n        iv. Hidden returnPath field if applicable\n        v. Submit button\n     b. Include any system messages or notifications",
    "databaseEntities": [
      "jforum_users",
      "jforum_sessions"
    ],
    "validationRules": [
      "Authentication type must not be SSO to display login form",
      "Return path must be preserved if provided"
    ],
    "dbSeedingOperations": [],
    "schema": {}
  },
  {
    "featureName": "HandleLostPassword",
    "description": "Provides password recovery functionality through email verification.",
    "inputValues": [
      "username-string-User",
      "email-string-User"
    ],
    "businessLogic": "1. Input Collection\n   - Collect user identification information\n     1.1. Obtain either username OR email address from the user\n     1.2. At least one field (username or email) must be provided\n     1.3. Both fields are optional, but at least one must be filled\n\n2. Data Validation\n   - Validate the provided information\n     2.1. IF email is provided THEN\n         2.1.1. Verify email format is valid\n         2.1.2. Check if email exists in the system\n     2.2. IF username is provided THEN\n         2.2.1. Verify username is not empty\n         2.2.2. Check if username exists in the system\n     2.3. IF neither email nor username is provided THEN\n         2.3.1. Return error message indicating one field must be filled\n\n3. Business Rule Processing\n   - Process the password recovery request\n     3.1. IF email is provided and username is empty THEN\n         3.1.1. Look up the username associated with the email\n     3.2. IF username is provided THEN\n         3.2.1. Find the user record by username\n     3.3. IF user cannot be found THEN\n         3.3.1. Return error message indicating user not found\n     3.4. Verify user account is active and eligible for password recovery\n\n4. Core Operation Execution\n   - Generate and store recovery information\n     4.1. Generate a unique password recovery hash\n         4.1.1. Combine user email, current timestamp, system hash sequence, and random number\n         4.1.2. Apply cryptographic hash function to create secure token\n     4.2. Store the recovery hash in the user's record\n         4.2.1. Associate hash with user's email address\n         4.2.2. Set expiration time for the recovery hash\n     4.3. Create recovery email\n         4.3.1. Generate recovery link containing the unique hash\n         4.3.2. Prepare email body with instructions and recovery link\n     4.4. Send recovery email to user's registered email address\n\n5. Response Generation\n   - Provide feedback to the user\n     5.1. Display confirmation message\n         5.1.1. Inform user that recovery instructions have been sent\n         5.1.2. Instruct user to check their email inbox\n     5.2. Provide support information\n         5.2.1. Include contact information if user doesn't receive email\n         5.2.2. Suggest checking spam folder",
    "databaseEntities": [
      "jforum_users",
      "jforum_sessions"
    ],
    "validationRules": [
      "Either username or email must be provided",
      "If email is provided, it must be in valid format",
      "User must exist in the system",
      "User account must be active to request password recovery"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "User": {
        "id": "number",
        "username": "string",
        "email": "string",
        "activationKey": "string"
      }
    }
  },
  {
    "featureName": "ProcessBasicAuthentication",
    "description": "Handles HTTP Basic Authentication for user login.",
    "inputValues": [
      "username-string-User",
      "password-string-User",
      "authorizationHeader-string-Request"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the following inputs:\n     1.1. Authorization header (mandatory) - Contains the Basic Authentication credentials\n     1.2. Username (system-generated from Authorization header)\n     1.3. Password (system-generated from Authorization header)\n\n2. Data Validation:\n   2.1. Validate Authorization Header:\n      2.1.1. Check if Authorization header exists\n      2.1.2. Verify header starts with 'Basic ' prefix\n      2.1.3. IF header is missing or invalid format, THEN proceed to standard login form\n   2.2. Decode Authorization Credentials:\n      2.2.1. Extract the base64-encoded portion of the Authorization header\n      2.2.2. Decode the base64 string to obtain username:password format\n      2.2.3. IF decoding fails, THEN return authentication error\n   2.3. Parse Credentials:\n      2.3.1. Split the decoded string at the colon character\n      2.3.2. Extract username portion (before colon)\n      2.3.3. Extract password portion (after colon)\n      2.3.4. IF colon separator not found, THEN return authentication error\n   2.4. Validate Credentials Format:\n      2.4.1. Verify username is not empty\n      2.4.2. Verify password is not empty\n      2.4.3. IF either credential is empty, THEN return authentication error\n\n3. Business Rule Processing:\n   3.1. Check Authentication Type:\n      3.1.1. Verify system is not configured for SSO-only authentication\n      3.1.2. IF system is SSO-only, THEN return authentication type error\n   3.2. Check Account Status:\n      3.2.1. Verify user account exists\n      3.2.2. Verify user account is active and not suspended\n      3.2.3. IF account doesn't exist or is inactive, THEN return invalid credentials error\n\n4. Core Operation Execution:\n   4.1. Authenticate User:\n      4.1.1. Validate username and password against stored credentials\n      4.1.2. IF credentials are invalid, THEN return authentication failure\n      4.1.3. IF credentials are valid, THEN proceed with login process\n   4.2. Create User Session:\n      4.2.1. Generate new user session\n      4.2.2. Remove any existing guest session for this connection\n      4.2.3. Populate session with user data\n      4.2.4. Set session last visit time\n      4.2.5. Store session in session repository\n   4.3. Handle Existing Sessions:\n      4.3.1. Check if user has an existing active session\n      4.3.2. IF existing session found, THEN store its data and remove it\n      4.3.3. Update last visit timestamp based on previous session if available\n   4.4. Load User Preferences:\n      4.4.1. Load user language preference\n      4.4.2. Load user security permissions\n\n5. Response Generation:\n   5.1. Generate Success Response:\n      5.1.1. Set authentication status as successful\n      5.1.2. Determine appropriate redirect location\n      5.1.3. Include user identification information\n   5.2. Generate Error Response:\n      5.2.1. IF authentication failed, THEN include error message\n      5.2.2. Provide option to retry authentication\n      5.2.3. Preserve return path if specified",
    "databaseEntities": [
      "jforum_users",
      "jforum_sessions",
      "jforum_user_groups"
    ],
    "validationRules": [
      "Authorization header must be present for Basic Authentication",
      "Authorization header must start with 'Basic ' prefix",
      "Authorization credentials must be valid base64 encoded string",
      "Decoded credentials must contain a colon separator",
      "Username must not be empty",
      "Password must not be empty",
      "User account must exist in the system",
      "User account must be active"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "User": {
        "id": "number",
        "username": "string",
        "password": "string",
        "email": "string",
        "active": "boolean",
        "lang": "string"
      },
      "UserSession": {
        "sessionId": "string",
        "userId": "number",
        "username": "string",
        "startTime": "date",
        "lastVisit": "date",
        "sessionTime": "number",
        "autoLogin": "boolean"
      },
      "Request": {
        "headers": {
          "Authorization": "string"
        }
      }
    }
  },
  {
    "featureName": "LostPassword",
    "description": "Allows users to recover their password when they have forgotten it.",
    "inputValues": [
      "username-string-User",
      "email-string-User",
      "hash-string-User",
      "newPassword-string-User"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect user identification information\n     1.1. Request either username OR email address (at least one must be provided)\n     1.2. System generates recovery hash (system-generated)\n     1.3. New password will be collected in a later step\n\n2. Data Validation:\n   2.1. Username/Email Validation\n      2.1.1. IF username is provided THEN verify it is not empty\n      2.1.2. IF email is provided THEN verify it is not empty\n      2.1.3. At least one of username or email must be provided\n      2.1.4. IF both are empty THEN display error message\n   2.2. Password Recovery Hash Validation (during recovery step)\n      2.2.1. Verify hash is not empty\n      2.2.2. Verify hash exists in the system\n      2.2.3. Verify hash is associated with the provided email\n   2.3. New Password Validation (during reset step)\n      2.3.1. Verify new password is not empty\n      2.3.2. Verify new password meets minimum security requirements\n\n3. Business Rule Processing:\n   3.1. User Existence Verification\n      3.1.1. IF email was provided THEN find associated username\n      3.1.2. IF username was provided THEN find user record\n      3.1.3. IF user cannot be found THEN display error message\n   3.2. Password Recovery Hash Generation\n      3.2.1. Create unique hash using user email, timestamp, system values, and random number\n      3.2.2. Store hash in user record for later verification\n   3.3. Password Reset Verification\n      3.3.1. Verify provided hash matches stored hash for user email\n      3.3.2. IF hash is invalid THEN display error message\n\n4. Core Operation Execution:\n   4.1. Password Recovery Request\n      4.1.1. Generate unique recovery hash for user\n      4.1.2. Store hash in user record\n      4.1.3. Send recovery email to user with password reset link containing hash\n      4.1.4. Display confirmation message to user\n   4.2. Password Reset\n      4.2.1. Validate recovery hash against stored value\n      4.2.2. IF hash is valid THEN encrypt new password\n      4.2.3. Update user record with new encrypted password\n      4.2.4. Clear recovery hash from user record\n      4.2.5. Display success message with login link\n\n5. Response Generation:\n   5.1. Password Recovery Request Response\n      5.1.1. IF user found THEN display confirmation message that email was sent\n      5.1.2. IF user not found THEN display error message about invalid username/email\n      5.1.3. Provide link to login page\n   5.2. Password Reset Response\n      5.2.1. IF password reset successful THEN display success message with login link\n      5.2.2. IF password reset failed THEN display error message about invalid data\n      5.2.3. Provide appropriate navigation options based on outcome",
    "databaseEntities": [
      "jforum_users"
    ],
    "validationRules": [
      "Either username or email must be provided",
      "User must exist in the system",
      "Recovery hash must be valid for the given email",
      "New password must not be empty"
    ],
    "dbSeedingOperations": [],
    "schema": {}
  },
  {
    "featureName": "PrepareLostPassword",
    "description": "Prepares password recovery by finding user and generating a recovery hash.",
    "inputValues": [
      "username-string-User",
      "email-string-User"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect username (string, optional) - User's login name\n   - Collect email (string, optional) - User's registered email address\n   - Note: At least one of username or email must be provided\n\n2. Data Validation:\n   - Check input parameters:\n     a. IF both username and email are empty THEN\n        - Return error indicating at least one field must be provided\n     b. IF email is provided THEN\n        - Validate email format is correct\n     c. IF username is provided THEN\n        - Validate username format is correct\n\n3. Business Rule Processing:\n   - Determine user lookup strategy:\n     a. IF email is provided and not empty THEN\n        - Find username associated with the provided email\n     b. IF username is now available (either directly provided or found via email) THEN\n        - Search for user by username\n        - IF multiple users found THEN\n           - Select the first matching user\n     c. IF no user found THEN\n        - Return null indicating recovery cannot proceed\n\n4. Core Operation Execution:\n   - Generate secure recovery hash:\n     a. Combine user email with current timestamp\n     b. Add system-defined hash sequence value\n     c. Add random number component\n     d. Create cryptographic hash of the combined string\n   - Store the generated hash in the database:\n     a. Associate hash with user's email address\n     b. Set expiration time if applicable\n   - Attach hash to user object for further processing\n\n5. Response Generation:\n   - IF user was found and hash was generated successfully THEN\n      - Return user object with attached recovery hash\n   - ELSE\n      - Return null to indicate failure",
    "databaseEntities": [
      "jforum_users"
    ],
    "validationRules": [
      "At least one of username or email must be provided",
      "Email must be in valid format if provided",
      "Username must exist in the system if provided directly",
      "Email must be associated with a user account if provided"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "User": {
        "type": "object",
        "properties": {
          "id": {
            "type": "number"
          },
          "username": {
            "type": "string"
          },
          "email": {
            "type": "string"
          },
          "activationKey": {
            "type": "string"
          }
        }
      }
    }
  },
  {
    "featureName": "LostPasswordSend",
    "description": "Sends password recovery email to user with recovery instructions.",
    "inputValues": [
      "username-string-User",
      "email-string-User"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the following inputs:\n     a. username (string, optional): The username of the account to recover\n     b. email (string, optional): The email address associated with the account to recover\n     - Note: At least one of username or email must be provided\n     - System will generate a unique recovery hash\n\n2. Data Validation:\n   - Validate inputs:\n     a. IF both username and email are empty THEN\n        - Return error message indicating at least one field must be provided\n     b. IF email is provided THEN\n        - Validate email format (must contain @ symbol and proper domain structure)\n     c. IF username is provided THEN\n        - Validate username exists in the system\n   - Error messages must be user-friendly and guide the user to correct the issue\n\n3. Business Rule Processing:\n   - Locate user account:\n     a. IF email is provided and username is empty THEN\n        - Look up username associated with the provided email\n     b. IF username is provided THEN\n        - Look up user record by username\n     c. IF no user is found THEN\n        - Return appropriate error message without revealing whether username or email exists\n   - Generate secure recovery hash:\n     a. Create a unique hash combining:\n        - User's email\n        - Current timestamp\n        - System-defined hash sequence\n        - Random number component\n     b. Store the generated hash in the user's record\n     c. Associate hash with user's email address\n\n4. Core Operation Execution:\n   - Prepare recovery email:\n     a. Create email with:\n        - Subject line for password recovery\n        - Greeting to the user by username\n        - Clear instructions for password recovery\n        - Recovery link containing the generated hash\n        - Expiration information for the recovery link\n        - Security recommendations\n     b. Send email to user's registered email address\n     c. IF email sending fails THEN\n        - Log the failure\n        - Provide appropriate error message\n\n5. Response Generation:\n   - Success response:\n     a. Display confirmation message that recovery email has been sent\n     b. Provide instructions to check email inbox and spam folder\n     c. Include link to login page for after recovery\n     d. Offer alternative contact method if email is not received\n   - Error response:\n     a. For security reasons, display generic message even if user not found\n     b. Provide guidance on alternative recovery methods\n     c. Offer contact information for support",
    "databaseEntities": [
      "jforum_users"
    ],
    "validationRules": [
      "At least one of username or email must be provided",
      "Email must be in valid format if provided",
      "Username must exist in the system if provided",
      "User account must be active to receive password recovery email"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "User": {
        "type": "object",
        "properties": {
          "id": {
            "type": "number"
          },
          "username": {
            "type": "string"
          },
          "email": {
            "type": "string"
          },
          "activationKey": {
            "type": "string"
          }
        }
      }
    }
  },
  {
    "featureName": "RecoverPassword",
    "description": "Displays the password recovery form for users with a valid hash.",
    "inputValues": [
      "hash-string-User",
      "email-string-User",
      "newPassword-string-User"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the recovery hash from the user request\n   - System prepares the password recovery form\n   \n2. Data Validation:\n   - Validate that the hash parameter exists in the request\n     * IF hash is missing or empty THEN display an error message\n     * IF hash is present THEN proceed to display recovery form\n   - Store the hash value for later use in the form submission\n   \n3. Business Rule Processing:\n   - Prepare the password recovery form interface\n   - Include fields for:\n     * Email address (to verify user identity)\n     * New password input\n     * Password confirmation input\n   - Include the recovery hash as a hidden field in the form\n   \n4. Core Operation Execution:\n   - Display the password recovery form to the user\n   - When user submits the form with new password:\n     * Validate the submitted hash against the email address\n     * IF hash validation fails THEN display an error message\n     * IF hash validation succeeds THEN:\n       - Encrypt the new password\n       - Update the user's password in the system\n       - Invalidate the used recovery hash\n       - Display a success message with login link\n   \n5. Response Generation:\n   - For initial form display:\n     * Show password recovery form with all required fields\n     * Include the recovery hash as a hidden value\n   - For form submission response:\n     * IF successful: Display confirmation message with login instructions\n     * IF failed: Display appropriate error message explaining the issue\n     * Provide navigation options for the user to retry or contact support",
    "databaseEntities": [
      "jforum_users"
    ],
    "validationRules": [
      "Recovery hash must be present in the request",
      "Email address must match the one associated with the recovery hash",
      "New password must not be empty",
      "New password must meet system password requirements",
      "Recovery hash must be valid and not expired"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "User": {
        "type": "object",
        "properties": {
          "email": {
            "type": "string",
            "description": "User's email address"
          },
          "hash": {
            "type": "string",
            "description": "Password recovery hash"
          },
          "newPassword": {
            "type": "string",
            "description": "User's new password"
          }
        },
        "required": [
          "email",
          "hash",
          "newPassword"
        ]
      }
    }
  },
  {
    "featureName": "RecoverPasswordValidate",
    "description": "Validates recovery hash and saves new user password.",
    "inputValues": [
      "recoverHash-string-User",
      "email-string-User",
      "newPassword-string-User"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the following required inputs:\n     a. recoverHash: A unique string identifier for the password recovery request\n     b. email: The user's email address\n     c. newPassword: The new password chosen by the user\n   - All fields are mandatory for this operation\n\n2. Data Validation:\n   a. Email Validation:\n      - Verify email is not empty\n      - Verify email follows standard email format\n      - Error message should indicate invalid email format if validation fails\n   b. Recovery Hash Validation:\n      - Verify recovery hash is not empty\n      - Verify hash is in the expected format\n      - Error message should indicate invalid recovery link if validation fails\n   c. Password Validation:\n      - Verify new password is not empty\n      - Verify password meets minimum length requirements\n      - Verify password meets complexity requirements (if applicable)\n      - Error message should indicate specific password requirements if validation fails\n\n3. Business Rule Processing:\n   a. Verify User Existence:\n      - Check if a user with the provided email exists in the system\n      - IF user does not exist, THEN:\n         i. Generate appropriate error message\n         ii. Abort the password recovery process\n   b. Validate Recovery Hash Association:\n      - Verify the recovery hash is associated with the provided email\n      - Verify the recovery hash has not expired\n      - IF hash is invalid or expired, THEN:\n         i. Generate error message indicating invalid or expired recovery link\n         ii. Abort the password recovery process\n\n4. Core Operation Execution:\n   a. Password Update:\n      - Process the new password (encrypt/hash it according to system requirements)\n      - Update the user's password in the system\n      - Clear any recovery hash information associated with the user\n      - IF password update fails, THEN:\n         i. Generate appropriate error message\n         ii. Maintain recovery hash validity for retry\n         iii. Abort the operation\n\n5. Response Generation:\n   a. Success Response:\n      - Generate success message confirming password has been changed\n      - Provide link to login page\n      - Clear any session data related to the recovery process\n   b. Error Response:\n      - Provide specific error message based on the validation or processing failure\n      - Maintain appropriate state for retry if applicable\n      - Provide guidance on next steps (retry, contact support, etc.)",
    "databaseEntities": [
      "jforum_users"
    ],
    "validationRules": [
      "Email must not be empty",
      "Email must be in valid format",
      "Recovery hash must not be empty",
      "Recovery hash must match the one stored for the user",
      "New password must not be empty",
      "New password must meet minimum length requirements",
      "User with provided email must exist in the system"
    ],
    "dbSeedingOperations": [],
    "schema": {}
  },
  {
    "featureName": "ListGroupUsers",
    "description": "Displays paginated list of users belonging to a specific group.",
    "inputValues": [
      "group_id-number-Group"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the group_id (mandatory) from the request\n   - System will determine pagination parameters:\n     - Current page number (derived from request)\n     - Users per page (loaded from system configuration)\n\n2. Data Validation:\n   - Validate group_id:\n     - Ensure group_id is provided\n     - Verify group_id is a valid integer\n     - Confirm group_id corresponds to an existing group\n     - IF validation fails, THEN display appropriate error message\n\n3. Business Rule Processing:\n   - Calculate pagination parameters:\n     - Determine total number of users in the specified group\n     - Calculate starting position based on current page\n     - Determine number of pages based on total users and users per page\n\n4. Core Operation Execution:\n   - Retrieve paginated list of users:\n     - Query users belonging to the specified group\n     - Apply pagination parameters (start position, users per page)\n     - Retrieve user details including username, registration date, and post count\n   - Prepare pagination navigation data:\n     - Calculate previous and next page links\n     - Generate page number links\n     - Set current page indicator\n\n5. Response Generation:\n   - Prepare display data:\n     - Format user list for display\n     - Include pagination controls\n     - Set page title and heading\n   - Generate view with:\n     - List of users with their details\n     - Pagination navigation\n     - Group information\n   - IF no users found in group, THEN display appropriate message",
    "databaseEntities": [
      "jforum_users",
      "jforum_groups",
      "jforum_user_groups"
    ],
    "validationRules": [
      "Group ID must be a valid integer",
      "Group ID must correspond to an existing group",
      "Pagination parameters must be valid"
    ],
    "dbSeedingOperations": [],
    "schema": {}
  },
  {
    "featureName": "SearchKarma",
    "description": "Displays paginated list of users with their karma information.",
    "inputValues": [
      "pageNumber-number-Pagination",
      "usersPerPage-number-Pagination"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect pageNumber (optional, defaults to 1)\n   - Collect usersPerPage (optional, uses system configuration value)\n   - System will generate pagination parameters based on these inputs\n\n2. Data Validation:\n   - Validate pageNumber:\n     * IF pageNumber is provided, THEN verify it is a positive integer\n     * IF pageNumber is not provided or invalid, THEN default to 1\n   - Validate usersPerPage:\n     * IF usersPerPage is provided, THEN verify it is a positive integer\n     * IF usersPerPage is not provided or invalid, THEN use system configuration value\n\n3. Business Rule Processing:\n   - Calculate pagination parameters:\n     * Determine start index based on pageNumber and usersPerPage\n     * Calculate total number of users in the system\n     * Determine total pages based on total users and usersPerPage\n   - Verify access permissions:\n     * Check if current user has permission to view karma information\n     * IF user lacks permission, THEN display appropriate error message\n\n4. Core Operation Execution:\n   - Retrieve total user count from the system\n   - Calculate pagination start index based on current page number\n   - Retrieve paginated list of users with their karma information:\n     * Fetch user records with associated karma data\n     * Sort users according to system default sorting (typically by username)\n     * Limit results based on pagination parameters\n   - Prepare pagination navigation data:\n     * Calculate previous page number (if applicable)\n     * Calculate next page number (if applicable)\n     * Generate list of available page numbers for navigation\n\n5. Response Generation:\n   - Prepare user list display:\n     * Format each user's information for display\n     * Include username, registration date, and karma score for each user\n   - Generate pagination controls:\n     * Include links to first, previous, next, and last pages as appropriate\n     * Display current page indicator\n   - Display the complete list with appropriate headings and formatting\n   - IF no users are found, THEN display appropriate message",
    "databaseEntities": [
      "jforum_users",
      "jforum_karma"
    ],
    "validationRules": [
      "Page number must be a positive integer",
      "Users per page must be a positive integer",
      "User must have permission to view karma information"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Pagination": {
        "type": "object",
        "properties": {
          "pageNumber": {
            "type": "number",
            "description": "Current page number"
          },
          "usersPerPage": {
            "type": "number",
            "description": "Number of users to display per page"
          }
        }
      }
    }
  },
  {
    "featureName": "ProcessAttachmentUploads",
    "description": "Validates and processes file attachments for forum posts with security and quota checks.",
    "inputValues": [
      "files-object-FileAttachment",
      "postId-number-Post",
      "forumId-number-Forum",
      "userId-number-User",
      "comments-object-AttachmentComment"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect file attachments from user submission\n   - Collect attachment comments for each file\n   - Retrieve post ID for attachment association\n   - Retrieve forum ID for permission checking\n   - Retrieve user ID from current session\n   - System generates current timestamp\n\n2. Data Validation:\n   - Validate permission access:\n     * Check if attachments are enabled for the specified forum\n     * Verify user has permission to upload attachments\n     * IF permissions are not valid, THEN abort processing\n   - Validate attachment count:\n     * Verify at least one file is being uploaded\n     * Check if total files exceed maximum allowed per post\n     * IF files exceed limit, THEN limit to maximum allowed\n   - Validate each file:\n     * Check for null characters in filenames for security\n     * Verify file extension is allowed based on system configuration\n     * Ensure file comment length does not exceed 254 characters\n     * Calculate total size of all attachments\n   - Validate quota limits:\n     * Retrieve quota limit for the user based on their group membership\n     * Check if total attachment size exceeds user's quota limit\n     * IF quota exceeded, THEN reject upload with appropriate message\n\n3. Business Rule Processing:\n   - Process file security:\n     * Extract file extension from each attachment\n     * Check extension against allowed/denied extension list\n     * Determine if extension is explicitly allowed, denied, or follows default rule\n     * IF extension is denied, THEN reject with appropriate message\n   - Process file metadata:\n     * Extract filename without path information\n     * Generate unique storage filename based on timestamp and user ID\n     * Create directory structure based on current date (year/month/day)\n     * Determine if thumbnail generation is required for image files\n\n4. Core Operation Execution:\n   - For each valid attachment:\n     * Create attachment record with user ID and post ID\n     * Store file metadata (size, comment, mimetype, filename)\n     * Save physical file to storage location\n     * IF file is an image type AND thumbnail generation is enabled, THEN:\n       - Generate thumbnail with configured dimensions\n       - Save thumbnail alongside original image\n   - Update post record to indicate it has attachments\n   - Store all attachment records in the database\n\n5. Response Generation:\n   - IF any validation errors occurred:\n     * Return appropriate error message indicating the specific validation failure\n     * Include details about file size limits, extension restrictions, or quota issues\n   - IF processing completed successfully:\n     * Return success indicator\n     * Include list of successfully processed attachments\n     * Provide attachment IDs for future reference",
    "databaseEntities": [
      "jforum_attachments",
      "jforum_posts",
      "jforum_users",
      "jforum_groups",
      "jforum_quota_limit",
      "jforum_extension_groups"
    ],
    "validationRules": [
      "User must have permission to upload attachments in the specified forum",
      "Number of attachments must not exceed maximum allowed per post",
      "File extensions must be in the allowed list and not in the denied list",
      "Filenames must not contain null characters",
      "Attachment comments must not exceed 254 characters",
      "Total attachment size must not exceed user's quota limit",
      "Attachment storage directories must exist or be created"
    ],
    "dbSeedingOperations": [
      "Ensure extension groups are defined with proper security settings",
      "Configure quota limits for user groups",
      "Set up allowed and denied file extensions"
    ],
    "schema": {
      "FileAttachment": {
        "name": "string",
        "size": "number",
        "contentType": "string",
        "content": "object"
      },
      "AttachmentComment": {
        "fileIndex": "number",
        "text": "string"
      }
    }
  },
  {
    "featureName": "InsertAttachmentsToPost",
    "description": "Saves uploaded attachments and associates them with forum posts.",
    "inputValues": [
      "postId-number-Post",
      "forumId-number-Forum",
      "files-object-FileUpload",
      "comments-object-AttachmentComment"
    ],
    "businessLogic": "1. Input Collection:\n   1.1. Collect the following inputs:\n       - Post ID (mandatory): Identifier of the post to attach files to\n       - Forum ID (mandatory): Identifier of the forum where the post exists\n       - Files (mandatory): One or more files to be attached\n       - Comments (optional): Description for each uploaded file\n   1.2. Determine the total number of files being uploaded\n       - IF total number of files is less than 1, THEN exit the process\n       - IF total number of files exceeds system maximum allowed per post, THEN limit to system maximum\n\n2. Data Validation:\n   2.1. Validate user permissions\n       - Check if attachments are enabled for the specified forum\n       - Check if user has permission to add attachments\n       - IF user does not have required permissions, THEN exit the process\n   2.2. Validate each file\n       - Check for null characters in filenames\n       - IF filename contains null characters, THEN reject the file and log security warning\n   2.3. Validate file extensions\n       - Extract file extension for each file\n       - Check if extension is in the allowed extensions list\n       - IF extension is not allowed, THEN throw bad extension error\n   2.4. Validate comments\n       - Check comment length for each file\n       - IF any comment exceeds 254 characters, THEN throw comment too long error\n   2.5. Validate total upload size\n       - Calculate total size of all files being uploaded\n       - Retrieve user's quota limit based on their group membership\n       - IF total size exceeds user's quota limit, THEN throw size too big error\n\n3. Business Rule Processing:\n   3.1. Process file information\n       - FOR each valid file:\n           - Create attachment record with user ID\n           - Create attachment info with file size, comment, and mimetype\n           - Extract filename without path\n           - Record upload timestamp\n           - Determine file extension information\n           - Generate unique storage filename\n   3.2. Check quota limits\n       - Determine user's quota limit based on group membership\n       - IF quota limit exists AND total upload size exceeds quota, THEN throw quota exceeded error\n\n4. Core Operation Execution:\n   4.1. Mark post as having attachments\n       - Update post record to indicate it has attachments\n   4.2. Save each attachment\n       - FOR each file to save:\n           - Associate attachment with post ID\n           - Determine storage path\n           - Save attachment record to database\n           - Save uploaded file to storage location\n   4.3. Process image thumbnails\n       - FOR each attachment that is an image (jpg, jpeg, gif, png):\n           - IF thumbnail creation is enabled, THEN:\n               - Create thumbnail of the image\n               - Save thumbnail with original filename plus '_thumb' suffix\n\n5. Response Generation:\n   5.1. Generate success response\n       - Return confirmation that attachments were successfully added to the post\n       - Include number of attachments processed\n   5.2. Generate error response (if applicable)\n       - Return specific error message based on validation failure\n       - Include guidance on resolving the issue (file size limits, allowed extensions, etc.)",
    "databaseEntities": [
      "jforum_attachments",
      "jforum_posts",
      "jforum_users",
      "jforum_groups",
      "jforum_quota_limit",
      "jforum_extension_groups"
    ],
    "validationRules": [
      "User must have permission to add attachments to the forum",
      "File extensions must be in the allowed list",
      "Filenames must not contain null characters",
      "Attachment comments must not exceed 254 characters",
      "Total upload size must not exceed user's quota limit",
      "Number of attachments must not exceed system maximum per post"
    ],
    "dbSeedingOperations": [
      "Ensure extension groups are defined with allowed file extensions",
      "Ensure quota limits are defined for user groups"
    ],
    "schema": {
      "FileUpload": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "description": "Original filename of the uploaded file"
          },
          "size": {
            "type": "number",
            "description": "Size of the file in bytes"
          },
          "contentType": {
            "type": "string",
            "description": "MIME type of the uploaded file"
          },
          "content": {
            "type": "object",
            "description": "Binary content of the uploaded file"
          }
        },
        "required": [
          "name",
          "size",
          "contentType",
          "content"
        ]
      },
      "AttachmentComment": {
        "type": "object",
        "properties": {
          "fileIndex": {
            "type": "number",
            "description": "Index of the file this comment belongs to"
          },
          "text": {
            "type": "string",
            "description": "Comment text for the attachment"
          }
        },
        "required": [
          "fileIndex",
          "text"
        ]
      }
    }
  },
  {
    "featureName": "CreateThumbnailImages",
    "description": "Generates thumbnail versions of image attachments for preview purposes.",
    "inputValues": [
      "imagePath-string-Attachment",
      "maxWidth-number-Configuration",
      "maxHeight-number-Configuration",
      "imageFormat-string-Configuration",
      "attachment-object-Attachment"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the following inputs:\n     - imagePath: Path to the original image file (mandatory)\n     - maxWidth: Maximum width for the thumbnail (mandatory)\n     - maxHeight: Maximum height for the thumbnail (mandatory)\n     - imageFormat: Format for the thumbnail image (mandatory)\n     - attachment: The attachment object containing metadata (mandatory)\n\n2. Data Validation:\n   - Validate image path:\n     - Check if the image path is not empty\n     - Verify the image file exists at the specified path\n     - Return error if file does not exist\n   - Validate image format:\n     - Ensure the image format is supported (jpg, jpeg, gif, png)\n     - Return error if format is not supported\n   - Validate dimensions:\n     - Ensure maxWidth and maxHeight are positive integers\n     - Ensure dimensions are within system limits\n     - Return error if dimensions are invalid\n   - Validate attachment object:\n     - Verify the attachment contains required metadata\n     - Check if the attachment is an image type\n     - Return error if attachment is not a valid image\n\n3. Business Rule Processing:\n   - Check if thumbnail generation is enabled in system settings\n     - IF thumbnail generation is disabled, THEN exit process\n   - Determine if the attachment should have a thumbnail:\n     - Check file extension (must be jpg, jpeg, gif, or png)\n     - Verify file size is within processable limits\n     - IF not eligible for thumbnail, THEN exit process\n   - Determine thumbnail filename:\n     - Generate thumbnail filename by appending \"_thumb\" to original filename\n     - Ensure the target directory exists and is writable\n     - Create directory structure if it doesn't exist\n\n4. Core Operation Execution:\n   - Load the original image file:\n     - Open the image file from the provided path\n     - Verify image data is valid and can be processed\n     - IF image cannot be loaded, THEN log error and exit\n   - Calculate thumbnail dimensions:\n     - Determine original image dimensions\n     - Calculate proportional dimensions that fit within maxWidth and maxHeight\n     - Preserve aspect ratio of the original image\n   - Generate the thumbnail:\n     - Resize the original image to the calculated dimensions\n     - Apply any necessary image quality settings\n     - IF resizing fails, THEN log error and exit\n   - Save the thumbnail:\n     - Write the thumbnail to the designated path\n     - Set appropriate file permissions\n     - IF saving fails, THEN log error and exit\n\n5. Response Generation:\n   - Success response:\n     - Return success status\n     - Include path to the generated thumbnail\n     - Include dimensions of the generated thumbnail\n   - Error response:\n     - Return error status\n     - Include specific error message\n     - Log detailed error information for troubleshooting\n     - Provide suggestions for resolving common issues",
    "databaseEntities": [
      "jforum_attachments",
      "jforum_extension_groups"
    ],
    "validationRules": [
      "Image file must exist at the specified path",
      "Image format must be one of: jpg, jpeg, gif, png",
      "Maximum width must be a positive integer",
      "Maximum height must be a positive integer",
      "Thumbnail generation must be enabled in system settings",
      "Target directory must be writable",
      "Original image must be valid and processable"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Attachment": {
        "type": "object",
        "properties": {
          "id": {
            "type": "number",
            "description": "Unique identifier for the attachment"
          },
          "postId": {
            "type": "number",
            "description": "ID of the post this attachment belongs to"
          },
          "userId": {
            "type": "number",
            "description": "ID of the user who uploaded the attachment"
          },
          "info": {
            "type": "object",
            "properties": {
              "physicalFilename": {
                "type": "string",
                "description": "The name of the file on the server"
              },
              "realFilename": {
                "type": "string",
                "description": "The original name of the uploaded file"
              },
              "comment": {
                "type": "string",
                "description": "User comment about the attachment"
              },
              "mimetype": {
                "type": "string",
                "description": "MIME type of the attachment"
              },
              "filesize": {
                "type": "number",
                "description": "Size of the file in bytes"
              },
              "uploadTimeInMillis": {
                "type": "number",
                "description": "Upload timestamp in milliseconds"
              },
              "extension": {
                "type": "object",
                "description": "Information about the file extension"
              }
            }
          }
        }
      }
    }
  },
  {
    "featureName": "EditPostAttachments",
    "description": "Updates or removes attachments from existing forum posts.",
    "inputValues": [
      "postId-number-Post",
      "forumId-number-Forum",
      "attachmentsToDelete-string-Attachment",
      "attachmentsToEdit-object-AttachmentEdit"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect postId (mandatory): Numeric identifier of the post being modified\n   - Collect forumId (mandatory): Numeric identifier of the forum containing the post\n   - Collect attachmentsToDelete (optional): Comma-separated list of attachment IDs to remove\n   - Collect attachmentsToEdit (optional): List of attachment objects with updated information\n     - Each attachment edit contains:\n       - attachmentId: Numeric identifier of the attachment\n       - comment: New comment text for the attachment\n\n2. Data Validation:\n   - Validate postId:\n     - Must be a positive integer\n     - Must reference an existing post\n     - Error if invalid: \"Invalid post identifier provided\"\n   - Validate forumId:\n     - Must be a positive integer\n     - Must reference an existing forum\n     - Error if invalid: \"Invalid forum identifier provided\"\n   - Validate attachmentsToDelete:\n     - Each ID must be a positive integer\n     - Each ID must belong to an attachment in the specified post\n     - Error if invalid: \"One or more attachment IDs are invalid\"\n   - Validate attachmentsToEdit:\n     - Each attachmentId must be a positive integer and exist in the system\n     - Each attachmentId must belong to an attachment in the specified post\n     - Comments must not exceed 254 characters in length\n     - Error if invalid: \"One or more attachment edits contain invalid data\"\n\n3. Business Rule Processing:\n   - Check user permissions:\n     - Verify user has permission to edit attachments in the specified forum\n     - IF user does not have attachment edit permission THEN\n       - Return error: \"You do not have permission to edit attachments in this forum\"\n   - Verify post exists and belongs to the specified forum\n     - IF post does not exist THEN\n       - Return error: \"The specified post does not exist\"\n     - IF post does not belong to the specified forum THEN\n       - Return error: \"The post does not belong to the specified forum\"\n   - Verify user has rights to edit the post attachments:\n     - IF user is not the post author AND user is not a moderator THEN\n       - Return error: \"You do not have permission to edit attachments for this post\"\n\n4. Core Operation Execution:\n   - Process attachment deletions:\n     - FOR EACH attachment ID in attachmentsToDelete:\n       - Retrieve the attachment details from the database\n       - Remove the attachment record from the database\n       - Delete the physical attachment file from the storage system\n       - IF attachment has a thumbnail image THEN\n         - Delete the thumbnail file from the storage system\n   - Process attachment updates:\n     - FOR EACH attachment in attachmentsToEdit:\n       - IF attachment ID is not in the attachmentsToDelete list THEN\n         - Retrieve the attachment from the database\n         - Update the attachment comment with the new value\n         - Save the updated attachment to the database\n   - Update post attachment status:\n     - Count remaining attachments for the post\n     - Update post record to indicate whether it has attachments\n\n5. Response Generation:\n   - IF all operations completed successfully THEN\n     - Return success response with:\n       - Message: \"Attachments updated successfully\"\n       - Updated list of attachments for the post\n       - Count of deleted attachments\n       - Count of updated attachments\n   - IF any operation failed THEN\n     - Return error response with:\n       - Error message describing the failure\n       - Any partial success information (e.g., \"2 of 3 attachments were updated\")\n       - Guidance for resolving the issue",
    "databaseEntities": [
      "jforum_posts",
      "jforum_attachments",
      "jforum_forums",
      "jforum_users",
      "jforum_groups",
      "jforum_extension_groups",
      "jforum_quota_limit"
    ],
    "validationRules": [
      "Post ID must be a positive integer and reference an existing post",
      "Forum ID must be a positive integer and reference an existing forum",
      "User must have permission to edit attachments in the specified forum",
      "User must be the post author or a moderator to edit post attachments",
      "Attachment IDs must belong to the specified post",
      "Attachment comments must not exceed 254 characters",
      "Post must exist and belong to the specified forum"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "AttachmentEdit": {
        "type": "object",
        "properties": {
          "attachmentId": {
            "type": "number",
            "description": "Unique identifier of the attachment to edit"
          },
          "comment": {
            "type": "string",
            "description": "Updated comment for the attachment",
            "maxLength": 254
          }
        },
        "required": [
          "attachmentId",
          "comment"
        ]
      }
    }
  },
  {
    "featureName": "DeletePostAttachments",
    "description": "Removes all attachments associated with a forum post.",
    "inputValues": [
      "postId-number-Post",
      "forumId-number-Forum"
    ],
    "businessLogic": "1. Input Collection\n   - Collect the following inputs:\n     1.1. postId (mandatory): The unique identifier of the post containing attachments\n     1.2. forumId (mandatory): The identifier of the forum where the post exists\n     1.3. System will use current user session information\n\n2. Data Validation\n   2.1. Validate Post Existence\n       - Verify the post with the provided postId exists in the system\n       - IF post does not exist, THEN\n         - Generate an error message indicating invalid post\n         - Terminate the operation\n   2.2. Validate Forum Existence\n       - Verify the forum with the provided forumId exists in the system\n       - IF forum does not exist, THEN\n         - Generate an error message indicating invalid forum\n         - Terminate the operation\n   2.3. Validate User Permissions\n       - Check if the current user has permission to delete attachments in this forum\n       - IF user lacks necessary permissions, THEN\n         - Generate an access denied error message\n         - Terminate the operation\n\n3. Business Rule Processing\n   3.1. Check Attachment Existence\n       - Retrieve all attachments associated with the specified post\n       - IF no attachments exist, THEN\n         - Log that no attachments were found for deletion\n         - Skip to Response Generation with appropriate message\n   3.2. Verify Post Ownership or Moderation Rights\n       - Check if current user is either the post owner or has moderation rights\n       - IF user is neither post owner nor moderator, THEN\n         - Generate an unauthorized access error\n         - Terminate the operation\n\n4. Core Operation Execution\n   4.1. Prepare Attachment List for Deletion\n       - Create a list of all attachment IDs associated with the post\n       - For each attachment in the post:\n         - Add the attachment ID to the deletion list\n   4.2. Delete Physical Files\n       - For each attachment in the deletion list:\n         4.2.1. Retrieve the attachment details including physical filename\n         4.2.2. Construct the full file path using the system's attachment storage directory\n         4.2.3. Delete the physical file from the storage location\n         4.2.4. Check if a thumbnail exists for the attachment\n         4.2.5. IF thumbnail exists, THEN delete the thumbnail file\n   4.3. Remove Database Records\n       - For each attachment in the deletion list:\n         4.3.1. Remove the attachment record from the database\n         4.3.2. Log the successful deletion of the attachment\n   4.4. Update Post Status\n       - Update the post record to indicate it no longer has attachments\n       - Set the 'hasAttachments' flag to false\n\n5. Response Generation\n   5.1. Success Response\n       - Generate a success message indicating all attachments were successfully deleted\n       - Include the count of attachments that were removed\n       - Return success status to the caller\n   5.2. Error Response\n       - IF any errors occurred during the deletion process, THEN\n         - Generate appropriate error messages detailing what failed\n         - Include information about any attachments that could not be deleted\n         - Return error status to the caller",
    "databaseEntities": [
      "jforum_posts",
      "jforum_attachments",
      "jforum_forums"
    ],
    "validationRules": [
      "User must have permission to delete attachments in the specified forum",
      "Post must exist in the system",
      "Forum must exist in the system",
      "User must be either the post owner or have moderation rights",
      "Attachments must belong to the specified post"
    ],
    "dbSeedingOperations": [],
    "schema": {}
  },
  {
    "featureName": "CheckAttachmentQuota",
    "description": "Validates if uploaded attachments exceed the user's quota limits.",
    "inputValues": [
      "userId-number-User",
      "uploadedFiles-object-FileCollection",
      "forumId-number-Forum"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect userId (mandatory): The identifier of the user uploading attachments\n   - Collect uploadedFiles (mandatory): Collection of files being uploaded\n      * Each file must contain: name, size, content type, and binary content\n      * Optional comment for each file (limited to 254 characters)\n   - Collect forumId (mandatory): The identifier of the forum where attachments will be posted\n\n2. Data Validation:\n   - Validate user permissions:\n      * Check if attachments are enabled for the specified forum\n      * Verify user has permission to upload attachments\n      * IF permissions are not valid, THEN abort process and return error message\n   - Validate file count:\n      * Ensure number of files does not exceed system-defined maximum per post\n      * IF too many files, THEN limit to maximum allowed\n   - Validate each file:\n      * Ensure filename does not contain null characters (security check)\n      * Verify file extension is allowed based on system configuration\n      * Check comment length does not exceed 254 characters\n      * IF any validation fails, THEN abort process and return appropriate error message\n\n3. Business Rule Processing:\n   - Calculate total size of all attachments being uploaded\n   - Retrieve user's quota limit:\n      * Identify all groups the user belongs to\n      * Find the highest quota limit among all user's groups\n      * IF no specific quota found, THEN use system default quota\n   - Check quota compliance:\n      * Compare total upload size against user's quota limit\n      * IF total size exceeds quota, THEN abort process and return quota exceeded error\n\n4. Core Operation Execution:\n   - For each valid file:\n      * Generate unique storage filename based on date, time, and user information\n      * Create directory structure if needed (year/month/day folders)\n      * Prepare attachment metadata including:\n         > Original filename\n         > Physical storage location\n         > File size\n         > MIME type\n         > Upload timestamp\n         > User-provided comment\n      * Determine if thumbnail generation is needed for image files\n   - Return validation success with prepared attachment information\n\n5. Response Generation:\n   - Success response:\n      * List of validated attachments ready for storage\n      * Confirmation that quota limits are satisfied\n   - Error response options:\n      * Permission denied: User cannot upload attachments\n      * Invalid file type: File extension not allowed\n      * Comment too long: Attachment comment exceeds character limit\n      * Quota exceeded: Detailed message showing limit and current usage\n      * Security violation: Malformed filenames or other security issues",
    "databaseEntities": [
      "jforum_users",
      "jforum_groups",
      "jforum_attachments",
      "jforum_quota_limit",
      "jforum_extension_groups"
    ],
    "validationRules": [
      "User must have permission to upload attachments in the specified forum",
      "Number of attachments must not exceed system-defined maximum per post",
      "File extensions must be allowed according to system configuration",
      "Attachment comments must not exceed 254 characters",
      "Filenames must not contain null characters (security check)",
      "Total attachment size must not exceed user's quota limit",
      "User must belong to at least one group with defined quota limits"
    ],
    "dbSeedingOperations": [
      "Ensure quota limits are defined for user groups",
      "Configure allowed file extensions in the system",
      "Set up maximum attachments per post system parameter"
    ],
    "schema": {
      "FileCollection": {
        "type": "array",
        "items": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string",
              "description": "Original filename of the attachment"
            },
            "size": {
              "type": "number",
              "description": "Size of the file in bytes"
            },
            "contentType": {
              "type": "string",
              "description": "MIME type of the file"
            },
            "content": {
              "type": "object",
              "description": "Binary content of the file"
            },
            "comment": {
              "type": "string",
              "description": "Optional user comment about the attachment",
              "maxLength": 254
            }
          },
          "required": [
            "name",
            "size",
            "contentType",
            "content"
          ]
        }
      }
    }
  },
  {
    "featureName": "CheckUnreadPosts",
    "description": "Checks if a forum has unread messages based on user tracking and last visit time.",
    "inputValues": [
      "forum-object-Forum",
      "tracking-object-Map",
      "lastVisit-number-UserSession"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the forum object containing forum information\n   - Collect the tracking map containing topic read timestamps\n   - Collect the lastVisit timestamp representing user's last visit time\n   - Determine if the user is logged in\n\n2. Data Validation:\n   - Verify forum object is not null\n     * IF forum is null THEN return without processing\n   - Check if forum contains last post information\n     * IF last post information is null THEN mark forum as having no unread posts and return\n   - Validate tracking map if provided\n     * IF tracking map is provided THEN verify it contains valid timestamp entries\n   - Ensure lastVisit timestamp is valid\n     * IF lastVisit is negative THEN set to default value of 0\n\n3. Business Rule Processing:\n   - Extract last post information from the forum\n     * Get the topic ID of the last post\n     * Get the timestamp of the last post\n   - Determine user's read status for the forum\n     * IF user is not logged in THEN mark forum as having no unread posts\n     * IF user is logged in THEN proceed with unread status check\n   - Check if the forum should be marked as containing unread posts\n     * IF tracking map contains the topic ID of the last post THEN\n       - Compare the last post timestamp with the read timestamp from tracking\n       - IF last post timestamp is greater than read timestamp THEN mark forum as unread\n       - ELSE mark forum as read\n     * ELSE\n       - Compare the last post timestamp with the user's last visit timestamp\n       - IF last post timestamp is greater than last visit timestamp THEN mark forum as unread\n       - ELSE mark forum as read\n\n4. Core Operation Execution:\n   - Update the forum's unread status flag based on the comparison results\n     * Set forum.unread to true if unread posts exist\n     * Set forum.unread to false if all posts have been read\n   - Store the updated forum status for display purposes\n     * Update the forum object with the new unread status\n\n5. Response Generation:\n   - Return the updated forum object with correct unread status\n   - Ensure the forum object contains all necessary information for display\n   - Provide visual indication of unread status for user interface rendering",
    "databaseEntities": [
      "jforum_forums",
      "jforum_topics",
      "jforum_posts",
      "jforum_sessions",
      "jforum_users"
    ],
    "validationRules": [
      "Forum object must not be null",
      "Last post information must be available to determine unread status",
      "User tracking map must contain valid timestamp entries",
      "Last visit timestamp must be a valid positive number",
      "Topic ID must be a valid integer value"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Forum": {
        "type": "object",
        "properties": {
          "id": {
            "type": "number"
          },
          "name": {
            "type": "string"
          },
          "description": {
            "type": "string"
          },
          "lastPostInfo": {
            "type": "object",
            "properties": {
              "topicId": {
                "type": "number"
              },
              "postTimeMillis": {
                "type": "number"
              }
            }
          },
          "unread": {
            "type": "boolean"
          }
        }
      },
      "Map": {
        "type": "object",
        "description": "A collection of topic IDs mapped to read timestamps"
      }
    }
  },
  {
    "featureName": "GetAllCategoriesAndForums",
    "description": "Retrieves all forums available to the user with optional unread post checking.",
    "inputValues": [
      "userSession-object-UserSession",
      "anonymousUserId-number-User",
      "tracking-object-TopicTracking",
      "checkUnreadPosts-boolean-Forum"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect user session information (optional)\n   - Determine if unread post checking is required\n   - Gather topic tracking data if available\n   - Set anonymous user ID for permission checking\n\n2. Data Validation:\n   - Validate user session status:\n     * IF user session is provided, extract user ID and last visit timestamp\n     * IF user session is not provided, use anonymous user ID and current time\n   - Validate tracking data format if provided\n   - Determine if unread post checking should be performed:\n     * Only check unread posts if user is logged in (not anonymous)\n     * Skip unread checking if explicitly set to false\n\n3. Business Rule Processing:\n   - Retrieve category access permissions for the current user\n   - Filter categories based on user's access rights\n   - For each accessible category:\n     * Retrieve associated forums\n     * Filter forums based on user's access permissions\n     * IF checkUnreadPosts is true:\n       > For each forum, determine if it contains unread posts\n       > Compare last post timestamp with user's last visit time\n       > Mark forums with unread content accordingly\n\n4. Core Operation Execution:\n   - Create result collection for categories\n   - For each accessible category:\n     * Create category object with basic information\n     * Populate category with accessible forums\n     * For each forum in the category:\n       > Include forum metadata (name, description)\n       > Include forum statistics (total topics, posts)\n       > IF checkUnreadPosts is true:\n         - Check last post information\n         - Compare with user's tracking data\n         - Mark forum as read/unread based on comparison\n     * Add complete category with forums to result collection\n\n5. Response Generation:\n   - Return hierarchical structure of categories and forums\n   - Each category contains:\n     * Category ID and name\n     * List of accessible forums\n   - Each forum contains:\n     * Forum ID, name, and description\n     * Forum statistics\n     * Unread status flag (if requested)\n     * Last post information (if available)",
    "databaseEntities": [
      "jforum_categories",
      "jforum_forums",
      "jforum_topics",
      "jforum_posts",
      "jforum_users",
      "jforum_sessions"
    ],
    "validationRules": [
      "User must have permission to view requested categories",
      "User must have permission to view forums within categories",
      "Anonymous users cannot check for unread posts",
      "Last visit timestamp must be valid for unread post checking",
      "Topic tracking data must be properly formatted if provided"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "UserSession": {
        "userId": "number",
        "lastVisit": "date",
        "username": "string"
      },
      "TopicTracking": {
        "type": "object",
        "properties": {
          "topicId": "number",
          "lastReadTime": "number"
        }
      },
      "Category": {
        "id": "number",
        "name": "string",
        "order": "number",
        "forums": "array"
      },
      "Forum": {
        "id": "number",
        "name": "string",
        "description": "string",
        "categoryId": "number",
        "totalTopics": "number",
        "totalPosts": "number",
        "unread": "boolean",
        "lastPostInfo": "object"
      }
    }
  },
  {
    "featureName": "FillPollFromRequest",
    "description": "Creates a new Poll object from HTTP request parameters including options and poll duration.",
    "inputValues": [
      "poll_label-string-Poll",
      "poll_option_count-number-Poll",
      "poll_option_*-string-PollOption",
      "poll_length-number-Poll"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the following inputs from the request:\n     a. poll_label (string): The title or description of the poll\n     b. poll_option_count (number): The number of poll options available\n     c. poll_option_* (string array): Multiple option text values, where * is the option index\n     d. poll_length (number): The duration for which the poll will remain active\n   - Note: poll_label is mandatory, other fields are optional\n\n2. Data Validation:\n   - Validate poll_label:\n     a. IF poll_label is null OR empty THEN\n        i. Return null (no poll will be created)\n     b. ELSE continue processing\n   - Validate poll options:\n     a. Each option must be trimmed of leading/trailing spaces\n     b. Empty options after trimming should be ignored\n     c. At least one valid option must exist for a valid poll\n   - Validate poll_length:\n     a. IF provided, must be convertible to a valid integer\n     b. IF not provided, system default duration will apply\n\n3. Business Rule Processing:\n   - Check system constraints:\n     a. Verify the user has permission to create polls\n     b. Ensure the poll complies with forum rules and settings\n   - Process poll options:\n     a. Count the number of valid options after filtering\n     b. Ensure the number of options does not exceed system limits\n     c. Verify option text lengths are within acceptable limits\n\n4. Core Operation Execution:\n   - Create a new Poll object:\n     a. Set the poll label with the validated poll_label value\n     b. Set the poll start time to the current date/time\n     c. IF poll_length is provided and valid THEN\n        i. Set the poll duration to the specified value\n     d. Process each poll option:\n        i. FOR each index from 0 to poll_option_count\n           1. Retrieve the option text for the current index\n           2. IF option exists and is not empty after trimming THEN\n              a. Create a new PollOption object\n              b. Set the option ID to the current index\n              c. Set the option text to the trimmed value\n              d. Add the option to the Poll object\n\n5. Response Generation:\n   - Return the fully constructed Poll object with:\n     a. Poll label\n     b. Start time\n     c. Duration (if specified)\n     d. Collection of valid poll options\n   - IF no valid poll could be created (no label or no valid options) THEN\n     a. Return null to indicate poll creation failure",
    "databaseEntities": [
      "jforum_topics",
      "jforum_posts"
    ],
    "validationRules": [
      "Poll label must not be empty",
      "At least one valid poll option must exist",
      "Poll options must not be empty after trimming",
      "Poll length must be a valid integer if provided"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Poll": {
        "type": "object",
        "properties": {
          "label": {
            "type": "string",
            "description": "The title or description of the poll"
          },
          "startTime": {
            "type": "date",
            "description": "The date and time when the poll starts"
          },
          "length": {
            "type": "number",
            "description": "The duration for which the poll will remain active"
          },
          "options": {
            "type": "array",
            "items": {
              "$ref": "#/PollOption"
            },
            "description": "Collection of poll options"
          }
        }
      },
      "PollOption": {
        "type": "object",
        "properties": {
          "id": {
            "type": "number",
            "description": "The identifier for the poll option"
          },
          "text": {
            "type": "string",
            "description": "The text content of the poll option"
          }
        }
      }
    }
  },
  {
    "featureName": "PreparePostForDisplay",
    "description": "Formats post text for display by handling HTML, BBCode, and safety processing.",
    "inputValues": [
      "post-object-Post"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the Post object that needs to be prepared for display\n   - Required fields: text content of the post\n   - System settings: HTML enabled flag, BBCode enabled flag, Smilies enabled flag\n\n2. Data Validation:\n   - Check if post text is null\n     - IF post text is null THEN\n       - Return the post without modifications\n     - END IF\n   - Verify post object has all required attributes accessible\n\n3. Business Rule Processing:\n   - Create a working copy of the post text for manipulation\n   - Check HTML permissions\n     - IF HTML is not enabled for this post THEN\n       - Convert all HTML special characters to their safe equivalents\n       - Replace < with &lt;\n       - Replace > with &gt;\n     - END IF\n   - Process newlines\n     - Replace all newline characters with HTML break tags\n   - Apply safety processing\n     - Run text through safety processor to remove potentially harmful content\n\n4. Core Operation Execution:\n   - Process special formatting blocks\n     - Identify if the post contains code blocks\n     - IF code blocks are present THEN\n       - Process text outside code blocks normally\n       - Process code blocks with special formatting:\n         - Preserve code formatting and syntax\n         - Apply syntax highlighting if language is specified\n         - Ensure code content is displayed securely\n     - ELSE\n       - Process entire text with standard formatting\n     - END IF\n   - Apply BBCode formatting\n     - IF BBCode is enabled for this post THEN\n       - Process all BBCode tags (except code tags which were handled separately)\n       - Convert BBCode formatting to appropriate HTML\n     - END IF\n   - Process smilies\n     - IF smilies are enabled for this post THEN\n       - Replace smilie codes with their corresponding image representations\n     - END IF\n   - Apply required BBCode processing regardless of settings\n   - Perform final safety check on all HTML attributes\n\n5. Response Generation:\n   - Update the post object with the processed text\n   - IF code blocks were processed THEN\n     - Set indicator that the post contains code blocks\n   - END IF\n   - Return the updated post object with display-ready text",
    "databaseEntities": [
      "jforum_posts",
      "jforum_posts_text",
      "jforum_smilies"
    ],
    "validationRules": [
      "Post text must be processed according to HTML permission settings",
      "BBCode must be processed only if BBCode is enabled for the post",
      "Smilies must be processed only if smilies are enabled for the post",
      "Code blocks must maintain their formatting and be processed separately",
      "All HTML content must be made safe to prevent security vulnerabilities",
      "Newlines must be converted to HTML break tags for proper display"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Post": {
        "type": "object",
        "properties": {
          "text": {
            "type": "string",
            "description": "The content of the post"
          },
          "isHtmlEnabled": {
            "type": "boolean",
            "description": "Flag indicating if HTML is allowed in the post"
          },
          "isBbCodeEnabled": {
            "type": "boolean",
            "description": "Flag indicating if BBCode is allowed in the post"
          },
          "isSmiliesEnabled": {
            "type": "boolean",
            "description": "Flag indicating if smilies should be processed in the post"
          }
        }
      }
    }
  },
  {
    "featureName": "ProcessTextWithCodeBlocks",
    "description": "Processes post text with special handling for code blocks and syntax highlighting.",
    "inputValues": [
      "post-object-Post"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect post object containing:\n     a. Text content (mandatory)\n     b. HTML enabled flag (boolean)\n     c. BBCode enabled flag (boolean)\n     d. Smilies enabled flag (boolean)\n\n2. Data Validation:\n   - Validate post text content:\n     a. IF post text is null THEN\n        i. Return the post without processing\n     b. ELSE\n        i. Continue with text processing\n\n3. Business Rule Processing:\n   - Process HTML safety:\n     a. IF HTML is not enabled THEN\n        i. Replace all '<' characters with '&lt;'\n        ii. Replace all '>' characters with '&gt;'\n     b. Replace all newline characters with HTML break tags\n     c. Apply safe HTML processing to prevent security issues\n\n4. Core Operation Execution:\n   - Code Block Detection and Processing:\n     a. Search for code block markers in the text\n     b. IF no code blocks are found THEN\n        i. Process the entire text normally with BBCode and smilies as configured\n     c. ELSE IF BBCode is enabled THEN\n        i. Set code block flag to true for template context\n        ii. Process text in segments:\n           1. For each segment before a code block:\n              - Apply normal text processing (BBCode, smilies)\n           2. For each code block segment:\n              - Identify language specification if present\n              - Restore newlines from HTML breaks\n              - Escape HTML-like tags\n              - Apply syntax highlighting formatting\n           3. Process any remaining text after the last code block\n\n   - Normal Text Processing:\n     a. IF smilies are enabled THEN\n        i. Replace smilie codes with corresponding image references\n     b. IF BBCode is enabled THEN\n        i. Process all non-code BBCode tags according to registered patterns\n     c. Apply required BBCode processing regardless of settings\n\n5. Response Generation:\n   - Return the processed post object with:\n     a. Formatted text with all processing applied\n     b. Code blocks properly formatted with syntax highlighting\n     c. Template context updated with code block presence flag if applicable",
    "databaseEntities": [
      "jforum_posts",
      "jforum_posts_text",
      "jforum_smilies"
    ],
    "validationRules": [
      "Post text may be null, in which case no processing occurs",
      "Code blocks must be properly formatted with [code] or [code=language] tags",
      "Code blocks must have matching closing [/code] tags",
      "HTML safety must be enforced based on user permissions"
    ],
    "dbSeedingOperations": [
      "Ensure smilies are properly loaded in the system",
      "Ensure BBCode definitions are properly registered in the system"
    ],
    "schema": {
      "Post": {
        "text": "string",
        "htmlEnabled": "boolean",
        "bbCodeEnabled": "boolean",
        "smiliesEnabled": "boolean",
        "userId": "number",
        "userIp": "string",
        "subject": "string",
        "signatureEnabled": "boolean",
        "time": "date"
      }
    }
  },
  {
    "featureName": "ParseCode",
    "description": "Parses code blocks with syntax highlighting and proper formatting.",
    "inputValues": [
      "post-object-Post",
      "bbCodeEnabled-boolean-Post",
      "smiliesEnabled-boolean-Post",
      "htmlEnabled-boolean-Post"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect Post object containing text content\n   - Determine if BBCode is enabled for the post\n   - Determine if smilies are enabled for the post\n   - Determine if HTML is enabled for the post\n\n2. Data Validation:\n   - Check if post text is null\n     - IF post text is null, THEN return post without processing\n   - Validate that post object contains all required properties\n     - Ensure text content is available for processing\n     - Verify formatting flags (BBCode, smilies, HTML) are properly set\n\n3. Business Rule Processing:\n   - Process HTML safety measures\n     - IF HTML is not enabled, THEN convert < and > characters to &lt; and &gt;\n     - Replace newline characters with HTML break tags\n     - Apply safe HTML processing to prevent security issues\n   - Identify code blocks in the content\n     - Search for [code] or [code=language] tags in the text\n     - Determine if special code block processing is needed\n\n4. Core Operation Execution:\n   - Process text content based on formatting rules\n     - IF no code blocks are found, THEN:\n       - Process the entire text with standard formatting rules\n       - Apply BBCode formatting if enabled\n       - Process smilies if enabled\n     - IF code blocks are found and BBCode is enabled, THEN:\n       - Split content into code and non-code segments\n       - For each non-code segment:\n         - Apply standard text formatting rules\n         - Process BBCode tags (except code tags)\n         - Process smilies if enabled\n       - For each code segment:\n         - Identify the programming language if specified\n         - Convert newlines to proper format\n         - Escape HTML characters\n         - Apply syntax highlighting formatting\n         - Preserve indentation and spacing\n       - Reassemble the content in the correct order\n     - Apply any always-required BBCode processing\n     - Set a flag indicating code blocks were found\n\n5. Response Generation:\n   - Return the processed post with formatted text\n   - Include information about whether code blocks were processed\n   - Ensure all formatting is properly applied and preserved\n   - Maintain the integrity of code blocks with syntax highlighting",
    "databaseEntities": [
      "jforum_posts",
      "jforum_posts_text"
    ],
    "validationRules": [
      "Post text must be properly checked for null before processing",
      "HTML special characters must be escaped when HTML is not enabled",
      "Code blocks must be properly identified with [code] or [code=language] tags",
      "Code content must preserve proper formatting and indentation",
      "BBCode tags must be processed according to their defined patterns",
      "Smilies must be replaced with their corresponding images when enabled"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Post": {
        "type": "object",
        "properties": {
          "text": {
            "type": "string",
            "description": "The content of the post including any formatting codes"
          },
          "subject": {
            "type": "string",
            "description": "The title or subject of the post"
          },
          "bbCodeEnabled": {
            "type": "boolean",
            "description": "Flag indicating if BBCode formatting is enabled for this post"
          },
          "htmlEnabled": {
            "type": "boolean",
            "description": "Flag indicating if HTML is allowed in this post"
          },
          "smiliesEnabled": {
            "type": "boolean",
            "description": "Flag indicating if smilies should be processed in this post"
          },
          "signatureEnabled": {
            "type": "boolean",
            "description": "Flag indicating if user signature should be attached to this post"
          },
          "userId": {
            "type": "integer",
            "description": "ID of the user who created the post"
          },
          "userIp": {
            "type": "string",
            "description": "IP address of the user who created the post"
          },
          "time": {
            "type": "string",
            "format": "date-time",
            "description": "Timestamp when the post was created"
          },
          "canEdit": {
            "type": "boolean",
            "description": "Flag indicating if the current user can edit this post"
          }
        },
        "required": [
          "text"
        ]
      }
    }
  },
  {
    "featureName": "ProcessSmilies",
    "description": "Replaces smilie codes with their corresponding image URLs in post text.",
    "inputValues": [
      "text-string-Post",
      "smilies-object-SmiliesList"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect post text content (text-string-Post)\n   - Retrieve list of available smilies (smilies-object-SmiliesList)\n   - Check if smilies are enabled for the post\n\n2. Data Validation:\n   - Verify that the post text is not null or empty\n     * IF text is null or empty THEN return the original text without processing\n   - Verify that smilies list is available and not empty\n     * IF smilies list is empty THEN return the original text without processing\n   - Confirm smilies processing is enabled for the current post\n     * IF smilies are disabled for this post THEN return the original text without processing\n\n3. Business Rule Processing:\n   - Convert the text string to a modifiable text buffer\n   - Prepare to track position information to prevent infinite loops\n   - Set up a counter to prevent potential infinite processing loops\n   - Establish a reasonable maximum iteration limit (e.g., 300 iterations)\n\n4. Core Operation Execution:\n   - FOR each smilie in the smilies list:\n     * Find the first occurrence position of the smilie code in the text\n     * WHILE a smilie code is found AND counter is below safety limit:\n       > Replace the smilie code with its corresponding image URL\n       > Update the position to find the next occurrence of the smilie code\n       > Increment the safety counter\n   - Handle any special cases where smilie codes might be part of other content\n   - Ensure proper spacing and formatting is maintained around replaced smilies\n\n5. Response Generation:\n   - Convert the modified text buffer back to a string\n   - Return the processed text with all smilie codes replaced by their image URLs\n   - Ensure the text maintains its original formatting except for the replaced smilies",
    "databaseEntities": [
      "jforum_smilies",
      "jforum_posts"
    ],
    "validationRules": [
      "Post text must not be null when processing smilies",
      "Smilies must be enabled for the post to process smilies",
      "Smilie codes must be replaced with their corresponding image URLs",
      "Processing must have a safety limit to prevent infinite loops"
    ],
    "dbSeedingOperations": [
      "Ensure the jforum_smilies table contains standard emoticons with their codes and image URLs"
    ],
    "schema": {
      "SmiliesList": {
        "type": "array",
        "items": {
          "type": "object",
          "properties": {
            "code": {
              "type": "string",
              "description": "The text code representing the smilie (e.g., ':)', ':-)', ':-(', etc.)"
            },
            "url": {
              "type": "string",
              "description": "The URL to the image that represents the smilie"
            }
          },
          "required": [
            "code",
            "url"
          ]
        }
      }
    }
  },
  {
    "featureName": "FillPostFromRequest",
    "description": "Creates or updates post objects from HTTP request parameters.",
    "inputValues": [
      "subject-string-Post",
      "message-string-Post",
      "disable_bbcode-boolean-Post",
      "disable_smilies-boolean-Post",
      "attach_sig-boolean-Post",
      "disable_html-boolean-Post",
      "forum_id-number-Forum",
      "post-object-Post"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the following inputs from the HTTP request:\n     a. subject (string): The post subject/title\n     b. message (string): The main content of the post\n     c. disable_bbcode (boolean): Whether BBCode is disabled for this post\n     d. disable_smilies (boolean): Whether smilies are disabled for this post\n     e. attach_sig (boolean): Whether to attach user signature to the post\n     f. disable_html (boolean): Whether HTML is disabled for this post\n     g. forum_id (number): The ID of the forum where the post belongs\n     h. post (object, optional): Existing Post object for edit operations\n   - System will determine if this is a new post creation or an edit operation based on the presence of a post object\n\n2. Data Validation:\n   - Validate subject:\n     a. Check if subject is provided\n     b. Ensure subject follows forum rules for length and content\n   - Validate message:\n     a. Check if message is not empty\n     b. Ensure message follows forum rules for length and content\n   - Validate forum_id:\n     a. Ensure forum_id is a valid number\n     b. Verify the forum exists in the system\n   - IF any validation fails, THEN:\n     a. Generate appropriate error message\n     b. Return to the post form with error details\n\n3. Business Rule Processing:\n   - Determine post formatting settings:\n     a. Set BBCode enabled status to TRUE if disable_bbcode parameter is not present\n     b. Set Smilies enabled status to TRUE if disable_smilies parameter is not present\n     c. Set Signature enabled status to TRUE if attach_sig parameter is present\n   - Determine HTML permissions:\n     a. Check if current user has HTML permission for the specified forum\n     b. Set HTML enabled status to TRUE if user has permission AND disable_html parameter is not present\n   - IF this is a new post (not an edit), THEN:\n     a. Record the user's IP address\n     b. Set the user ID from the current session\n     c. Set the current timestamp as post creation time\n\n4. Core Operation Execution:\n   - Create or update Post object:\n     a. Set the subject field with the provided subject value\n     b. Set BBCode enabled flag based on previous determination\n     c. Set Smilies enabled flag based on previous determination\n     d. Set Signature enabled flag based on previous determination\n     e. Set HTML enabled flag based on previous determination\n   - Process the message content:\n     a. IF HTML is enabled, THEN:\n        i. Apply safety filtering to the message to prevent XSS attacks\n     b. ELSE:\n        i. Use the message as-is without HTML filtering\n     c. Set the processed message to the post object\n   - IF this is a new post, THEN:\n     a. Set the user's IP address to the post\n     b. Set the user ID to the post\n     c. Set the current timestamp to the post\n   - Return the fully populated Post object\n\n5. Response Generation:\n   - Return the populated Post object for further processing\n   - IF any errors occurred during processing, THEN:\n     a. Include error details with the response\n     b. Indicate which fields had validation issues\n   - IF successful, THEN:\n     a. Return the complete Post object ready for database persistence\n     b. Include any formatting flags that were set during processing",
    "databaseEntities": [
      "jforum_posts",
      "jforum_posts_text",
      "jforum_forums",
      "jforum_users",
      "jforum_sessions"
    ],
    "validationRules": [
      "Post subject must not be empty",
      "Post message must not be empty",
      "Forum ID must be valid",
      "User must be logged in to create or edit a post",
      "HTML usage must be permitted by forum settings and user permissions",
      "Post content must comply with forum safety rules"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Post": {
        "type": "object",
        "properties": {
          "id": {
            "type": "number",
            "description": "Unique identifier for the post"
          },
          "subject": {
            "type": "string",
            "description": "Post title or subject"
          },
          "text": {
            "type": "string",
            "description": "Post content or message"
          },
          "userId": {
            "type": "number",
            "description": "ID of the user who created the post"
          },
          "topicId": {
            "type": "number",
            "description": "ID of the topic this post belongs to"
          },
          "forumId": {
            "type": "number",
            "description": "ID of the forum this post belongs to"
          },
          "time": {
            "type": "date",
            "description": "Timestamp when the post was created"
          },
          "userIp": {
            "type": "string",
            "description": "IP address of the user who created the post"
          },
          "bbCodeEnabled": {
            "type": "boolean",
            "description": "Whether BBCode formatting is enabled for this post"
          },
          "htmlEnabled": {
            "type": "boolean",
            "description": "Whether HTML is enabled for this post"
          },
          "smiliesEnabled": {
            "type": "boolean",
            "description": "Whether smilies are enabled for this post"
          },
          "signatureEnabled": {
            "type": "boolean",
            "description": "Whether user signature is attached to this post"
          }
        }
      }
    }
  },
  {
    "featureName": "CheckPostEditPermission",
    "description": "Determines if the current user has permission to edit a specific post.",
    "inputValues": [
      "post-object-Post",
      "currentUser-object-User"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the post object containing post details including userId\n   - Obtain current user information from the session\n   - Determine if the user is logged in\n\n2. Data Validation:\n   - Verify post object is valid and contains required information\n     - Check that post has a valid userId\n     - Ensure post exists in the system\n   - Validate current user session\n     - Confirm user session is active\n     - Verify user authentication status\n\n3. Business Rule Processing:\n   - Check user authorization level\n     - IF user is not logged in THEN\n       - Return false (no permission)\n     - ELSE\n       - Continue permission evaluation\n   - Evaluate ownership condition\n     - IF post creator (userId) matches current user's ID THEN\n       - Mark as potential permission grant (ownership condition met)\n     - ELSE\n       - Ownership condition not met, proceed to moderation check\n   - Check moderation privileges\n     - Verify if current user has post moderation rights\n     - IF user has moderation privileges THEN\n       - Mark as potential permission grant (moderation condition met)\n     - ELSE\n       - Moderation condition not met\n\n4. Core Operation Execution:\n   - Determine final permission status\n     - IF ownership condition OR moderation condition is met THEN\n       - Grant edit permission\n     - ELSE\n       - Deny edit permission\n   - Apply any time-based restrictions\n     - Check if post editing timeframe has expired (if applicable)\n     - Adjust permission accordingly\n\n5. Response Generation:\n   - Return the permission result (boolean)\n     - True: User can edit the post\n     - False: User cannot edit the post\n   - Include reason code for permission denial if needed",
    "databaseEntities": [
      "jforum_users",
      "jforum_posts",
      "jforum_user_groups",
      "jforum_groups"
    ],
    "validationRules": [
      "User must be logged in to edit any post",
      "User can edit their own posts",
      "Users with moderation privileges can edit any post",
      "Post must exist in the system",
      "User session must be valid"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Post": {
        "type": "object",
        "properties": {
          "id": {
            "type": "number",
            "description": "Unique identifier for the post"
          },
          "userId": {
            "type": "number",
            "description": "ID of the user who created the post"
          },
          "text": {
            "type": "string",
            "description": "Content of the post"
          },
          "subject": {
            "type": "string",
            "description": "Subject/title of the post"
          },
          "time": {
            "type": "date",
            "description": "When the post was created"
          },
          "canEdit": {
            "type": "boolean",
            "description": "Flag indicating if post can be edited"
          }
        }
      },
      "User": {
        "type": "object",
        "properties": {
          "id": {
            "type": "number",
            "description": "Unique identifier for the user"
          },
          "username": {
            "type": "string",
            "description": "User's login name"
          },
          "isLogged": {
            "type": "boolean",
            "description": "Whether the user is currently logged in"
          }
        }
      }
    }
  },
  {
    "featureName": "RetrieveTopicPosts",
    "description": "Retrieves and prepares posts for a topic with pagination and edit permissions.",
    "inputValues": [
      "topicId-number-Topic",
      "start-number-Pagination",
      "count-number-Pagination",
      "userId-number-User",
      "canEdit-boolean-Permission"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the following inputs:\n     a. topicId (mandatory): Unique identifier for the topic\n     b. start (mandatory): Starting position for pagination\n     c. count (mandatory): Number of posts to retrieve\n     d. userId (mandatory): Current user's identifier\n     e. canEdit (mandatory): Flag indicating if user has general edit permission\n\n2. Data Validation:\n   - Validate topicId:\n     a. Ensure topicId is a positive integer\n     b. Verify topic exists in the system\n     c. IF topic does not exist, THEN return error message\n   - Validate pagination parameters:\n     a. Ensure start is a non-negative integer\n     b. Ensure count is a positive integer\n     c. IF parameters are invalid, THEN use default values\n   - Validate userId:\n     a. Ensure userId is a valid user in the system\n     b. IF userId is invalid, THEN use anonymous user ID\n\n3. Business Rule Processing:\n   - Determine caching strategy:\n     a. Check if post caching is enabled in system configuration\n     b. IF caching is enabled, THEN prepare to retrieve posts from cache\n     c. ELSE prepare to retrieve posts directly from data storage\n   - Determine anonymous user identifier:\n     a. Retrieve anonymous user ID from system configuration\n     b. Store for later permission comparisons\n\n4. Core Operation Execution:\n   - Retrieve posts:\n     a. IF post caching is enabled:\n        i. Retrieve posts from post repository with pagination\n        ii. Set needPrepare flag to false\n     b. ELSE:\n        i. Retrieve posts directly from data access object with pagination\n        ii. Set needPrepare flag to true\n   - Process each post:\n     a. FOR EACH post in retrieved posts:\n        i. IF needPrepare is true, THEN use post as is\n        ii. ELSE create a new post object from the cached post\n        iii. Determine edit permission for this specific post:\n           - IF user has general edit permission OR\n           - (post creator is not anonymous AND post creator matches current user)\n           - THEN grant edit permission for this post\n        iv. IF needPrepare is true, THEN prepare post for display:\n           - Process HTML content based on post settings\n           - Process BBCode if enabled\n           - Process smilies if enabled\n           - Format code blocks if present\n        v. Add processed post to result list\n\n5. Response Generation:\n   - Return the processed post list containing:\n     a. Post content properly formatted for display\n     b. Edit permissions for each post\n     c. All post metadata (author, timestamp, etc.)\n   - IF an error occurred during processing:\n     a. Return appropriate error message\n     b. Include details about the nature of the error",
    "databaseEntities": [
      "jforum_topics",
      "jforum_posts",
      "jforum_posts_text",
      "jforum_users"
    ],
    "validationRules": [
      "Topic ID must be a valid positive integer",
      "Topic must exist in the system",
      "Pagination start parameter must be a non-negative integer",
      "Pagination count parameter must be a positive integer",
      "User ID must correspond to a valid user in the system"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Post": {
        "type": "object",
        "properties": {
          "id": {
            "type": "number"
          },
          "topicId": {
            "type": "number"
          },
          "userId": {
            "type": "number"
          },
          "subject": {
            "type": "string"
          },
          "text": {
            "type": "string"
          },
          "time": {
            "type": "date"
          },
          "bbCodeEnabled": {
            "type": "boolean"
          },
          "htmlEnabled": {
            "type": "boolean"
          },
          "smiliesEnabled": {
            "type": "boolean"
          },
          "signatureEnabled": {
            "type": "boolean"
          },
          "userIp": {
            "type": "string"
          },
          "canEdit": {
            "type": "boolean"
          }
        }
      },
      "Topic": {
        "type": "object",
        "properties": {
          "id": {
            "type": "number"
          },
          "forumId": {
            "type": "number"
          },
          "title": {
            "type": "string"
          },
          "lastPostId": {
            "type": "number"
          },
          "postCount": {
            "type": "number"
          }
        }
      },
      "Pagination": {
        "type": "object",
        "properties": {
          "start": {
            "type": "number"
          },
          "count": {
            "type": "number"
          }
        }
      },
      "User": {
        "type": "object",
        "properties": {
          "id": {
            "type": "number"
          },
          "username": {
            "type": "string"
          }
        }
      },
      "Permission": {
        "type": "object",
        "properties": {
          "canEdit": {
            "type": "boolean"
          }
        }
      }
    }
  },
  {
    "featureName": "SetupTopicListingContext",
    "description": "Configures template context with topic types, statuses, and moderation permissions for topic listing pages.",
    "inputValues": [
      "userSession-object-UserSession",
      "securityRepository-object-SecurityRepository"
    ],
    "businessLogic": "1. Input Collection:\n   - Retrieve current template context\n   - Obtain user session information\n   - Identify user permissions\n   \n2. Data Validation:\n   - Verify template context is available\n   - Confirm user session is valid\n   - Ensure security repository contains necessary permission data\n   \n3. Business Rule Processing:\n   - Determine user's moderation capabilities\n     3.1. Check if user has general moderation access\n     3.2. Check if user can remove posts\n     3.3. Check if user can move topics\n     3.4. Check if user can lock or unlock topics\n   - Verify system configuration settings\n     3.5. Determine if RSS functionality is enabled\n   \n4. Core Operation Execution:\n   - Add topic type constants to template context\n     4.1. Add announcement topic type\n     4.2. Add sticky topic type\n     4.3. Add normal topic type\n   - Add topic status constants to template context\n     4.4. Add locked status\n     4.5. Add unlocked status\n   - Add moderation permission flags to template context\n     4.6. Set general moderator flag\n     4.7. Set post removal permission flag\n     4.8. Set topic movement permission flag\n     4.9. Set topic lock/unlock permission flag\n   - Add system configuration flags\n     4.10. Set RSS availability flag\n   \n5. Response Generation:\n   - Return updated template context with all necessary values\n   - Make context available for use in topic listing views",
    "databaseEntities": [
      "jforum_users",
      "jforum_topics",
      "jforum_forums",
      "jforum_sessions"
    ],
    "validationRules": [
      "Template context must be available",
      "User session must be valid",
      "Security repository must contain user permissions",
      "Topic type constants must be correctly defined",
      "Topic status constants must be correctly defined"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "UserSession": {
        "type": "object",
        "properties": {
          "userId": {
            "type": "integer",
            "description": "Unique identifier for the user"
          },
          "lastVisit": {
            "type": "object",
            "description": "Timestamp of user's last visit"
          }
        }
      },
      "SecurityRepository": {
        "type": "object",
        "properties": {
          "permissions": {
            "type": "object",
            "description": "Collection of user permissions"
          }
        }
      }
    }
  },
  {
    "featureName": "CheckTopicAccessibility",
    "description": "Verifies if the current user has permission to view a specific topic.",
    "inputValues": [
      "forumId-number-Forum",
      "userSession-object-UserSession"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect forumId (mandatory): The numeric identifier of the forum containing the topic\n   - Retrieve userSession (system-generated): The current user's session information\n\n2. Data Validation:\n   - Validate forumId:\n     2.1. Check if forumId is a valid positive integer\n     2.2. Verify forumId exists in the system\n     2.3. If validation fails, prepare error message indicating invalid forum identifier\n\n3. Business Rule Processing:\n   - Retrieve forum information:\n     3.1. Fetch forum details using the provided forumId\n     3.2. IF forum is not found:\n          3.2.1. Set access status to denied\n          3.2.2. Prepare access denied message\n          3.2.3. Return false (not accessible)\n     3.3. Retrieve the categoryId associated with the forum\n     3.4. Check category accessibility:\n          3.4.1. Verify if the user has permission to access the category\n          3.4.2. IF category is not accessible:\n                 3.4.2.1. Set access status to denied\n                 3.4.2.2. Prepare access denied message\n                 3.4.2.3. Return false (not accessible)\n\n4. Core Operation Execution:\n   - Determine final accessibility status:\n     4.1. IF both forum exists AND category is accessible:\n          4.1.1. Set access status to granted\n          4.1.2. Return true (accessible)\n     4.2. ELSE:\n          4.2.1. Set access status to denied\n          4.2.2. Return false (not accessible)\n\n5. Response Generation:\n   - Generate appropriate response:\n     5.1. IF access is granted:\n          5.1.1. Return success response with accessibility status set to true\n     5.2. ELSE:\n          5.2.1. Return error response with access denied message\n          5.2.2. Include reason for denial (forum not found or category not accessible)",
    "databaseEntities": [
      "jforum_forums",
      "jforum_categories",
      "jforum_user_groups",
      "jforum_groups"
    ],
    "validationRules": [
      "Forum ID must be a valid positive integer",
      "Forum must exist in the system",
      "User must have permission to access the category containing the forum",
      "Category must be accessible to the user"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "UserSession": {
        "type": "object",
        "properties": {
          "userId": {
            "type": "number",
            "description": "The unique identifier of the user"
          },
          "lastVisit": {
            "type": "object",
            "description": "The timestamp of the user's last visit"
          },
          "permissions": {
            "type": "object",
            "description": "The user's permission settings"
          }
        }
      }
    }
  },
  {
    "featureName": "NotifySubscribedUsers",
    "description": "Sends email notifications to users watching a topic when a new post is added.",
    "inputValues": [
      "topic-object-Topic",
      "post-object-Post"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the Topic object containing topic details\n   - Collect the Post object containing the new post details\n   - System retrieves notification configuration setting\n\n2. Data Validation:\n   - Verify Topic object contains valid topic ID\n     * IF topic ID is invalid or null THEN abort notification process\n     * Generate error: \"Invalid topic information\"\n   - Verify Post object contains required content\n     * IF post content is empty THEN abort notification process\n     * Generate error: \"Cannot notify users of empty post\"\n   - Check if notifications are enabled in system settings\n     * IF notifications are disabled THEN exit process without error\n\n3. Business Rule Processing:\n   - Check if the topic has any subscribed users\n     * Query database for users watching this topic\n     * IF no users are subscribed THEN exit process (no notifications needed)\n   - Verify user permissions for each subscriber\n     * FOR EACH subscribed user:\n       * Check if user still has access to the forum containing this topic\n       * IF user lacks access THEN remove user from notification list\n\n4. Core Operation Execution:\n   - Prepare notification content\n     * Create email subject line including topic title\n     * Format email body with:\n       * Topic information (title, forum)\n       * Post content summary\n       * Author information\n       * Link to view the complete post\n   - Create notification task\n     * Package all notification data into a task object\n     * Add all recipient users to the task\n   - Submit notification task to execution system\n     * Pass task to background processing system\n     * Ensure task execution doesn't block main thread\n\n5. Response Generation:\n   - Record notification attempt in system logs\n     * Log number of notifications queued\n     * Log timestamp of notification process\n   - Return success status\n     * IF notification task was successfully queued THEN return success\n     * IF any errors occurred THEN return appropriate error message",
    "databaseEntities": [
      "jforum_users",
      "jforum_topics",
      "jforum_posts",
      "jforum_forums"
    ],
    "validationRules": [
      "Notifications must be enabled in system settings",
      "Topic must exist and be valid",
      "Post must contain content",
      "Users must be subscribed to the topic to receive notifications",
      "Users must have access to the forum containing the topic"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Topic": {
        "id": "number",
        "forumId": "number",
        "title": "string",
        "lastPostId": "number",
        "lastPostDate": "date"
      },
      "Post": {
        "id": "number",
        "topicId": "number",
        "userId": "number",
        "content": "string",
        "postDate": "date"
      }
    }
  },
  {
    "featureName": "UpdateBoardStatus",
    "description": "Updates forum statistics and cache after new post creation.",
    "inputValues": [
      "topic-object-Topic",
      "lastPostId-number-Post",
      "firstPost-boolean-Post",
      "topicDao-object-TopicDAO",
      "forumDao-object-ForumDAO"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the following inputs:\n     a. Topic object containing topic details (required)\n     b. Last post ID as a number (required)\n     c. Boolean flag indicating if this is the first post in the topic (required)\n     d. Topic data access object for database operations (required)\n     e. Forum data access object for database operations (required)\n\n2. Data Validation:\n   - Validate Topic object:\n     a. Verify Topic object is not null\n     b. Ensure Topic ID is valid (positive integer)\n     c. Ensure Forum ID within Topic is valid (positive integer)\n   - Validate Last Post ID:\n     a. Verify Last Post ID is a positive integer\n   - Validate Data Access Objects:\n     a. Ensure Topic DAO is properly initialized\n     b. Ensure Forum DAO is properly initialized\n   - IF any validation fails, THEN:\n     a. Generate appropriate error message\n     b. Abort the operation\n\n3. Business Rule Processing:\n   - Check system state:\n     a. Verify the topic exists in the system\n     b. Verify the forum exists in the system\n     c. Ensure the user has appropriate permissions to update board status\n   - Verify data consistency:\n     a. Confirm the topic belongs to the specified forum\n     b. Ensure the last post ID corresponds to an actual post\n   - IF any business rule fails, THEN:\n     a. Log the error with detailed information\n     b. Generate appropriate error message\n     c. Abort the operation\n\n4. Core Operation Execution:\n   - Update Topic Information:\n     a. Set the last post ID for the topic\n     b. Update the topic in the database\n   - Update Forum Information:\n     a. Set the last post ID for the forum\n     b. IF this is the first post in the topic, THEN:\n        i. Increment the total topics count for the forum by 1\n     c. ELSE:\n        i. Increment the total replies count for the topic\n   - Update Topic Statistics:\n     a. Increment the total views count for the topic\n   - Update Cache:\n     a. Add the topic to the topic repository cache\n     b. Push the topic to the top of the recent topics list\n     c. Update the forum repository total message count\n   - IF any operation fails, THEN:\n     a. Attempt to rollback changes where possible\n     b. Log the error with detailed information\n     c. Generate appropriate error message\n\n5. Response Generation:\n   - Generate Success Response:\n     a. Confirm all updates were completed successfully\n     b. Return updated topic and forum statistics\n   - IF operation failed, THEN:\n     a. Generate detailed error response with failure reason\n     b. Include suggestions for resolving the issue",
    "databaseEntities": [
      "jforum_topics",
      "jforum_forums",
      "jforum_posts"
    ],
    "validationRules": [
      "Topic object must not be null",
      "Topic ID must be a positive integer",
      "Forum ID must be a positive integer",
      "Last Post ID must be a positive integer",
      "Topic must exist in the system",
      "Forum must exist in the system",
      "Topic must belong to the specified forum",
      "Data access objects must be properly initialized"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Topic": {
        "id": "number",
        "forumId": "number",
        "lastPostId": "number",
        "totalReplies": "number",
        "totalViews": "number"
      },
      "TopicDAO": {
        "update": "function",
        "incrementTotalReplies": "function",
        "incrementTotalViews": "function"
      },
      "ForumDAO": {
        "setLastPost": "function",
        "incrementTotalTopics": "function"
      }
    }
  },
  {
    "featureName": "SaveUploadedFile",
    "description": "Saves an uploaded file to the specified location on the server.",
    "inputValues": [
      "fileItem-object-FileItem",
      "targetFilename-string-String"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the file item to be saved (mandatory)\n   - Collect the target filename with complete path (mandatory)\n   - System will determine file extension from the original filename\n\n2. Data Validation:\n   - Validate file item exists\n     * IF file item is null THEN return error \"No file provided\"\n     * IF file item contains no data THEN return error \"Empty file provided\"\n   - Validate target filename\n     * IF target filename is empty THEN return error \"No target location specified\"\n     * IF target filename is invalid THEN return error \"Invalid target location\"\n   - Validate file extension\n     * Extract extension from original filename\n     * IF no extension found THEN use empty string as extension\n\n3. Business Rule Processing:\n   - Check storage location availability\n     * IF target directory does not exist THEN return error \"Target directory not found\"\n     * IF target directory is not writable THEN return error \"Permission denied for target directory\"\n   - Check storage capacity\n     * IF insufficient space available THEN return error \"Insufficient storage space\"\n   - Check for existing file\n     * IF file already exists at target location AND overwrite not allowed THEN return error \"File already exists\"\n\n4. Core Operation Execution:\n   - Prepare file streams\n     * Create input stream from the uploaded file item\n     * Create output stream to the target filename\n   - Transfer file data\n     * Read data from input stream in chunks\n     * Write data to output stream\n     * Continue until all data is transferred\n   - Handle potential errors\n     * IF I/O error occurs during transfer THEN\n       > Close all open streams if possible\n       > Delete partially written file if possible\n       > Return error \"File transfer failed\"\n\n5. Response Generation:\n   - Clean up resources\n     * Flush output stream to ensure all data is written\n     * Close all open streams\n   - Generate success response\n     * Return success status\n     * Include saved file information (name, size, path)\n   - IF any errors occurred during the process THEN\n     * Return appropriate error message\n     * Include error details for troubleshooting",
    "databaseEntities": [
      "jforum_attachments"
    ],
    "validationRules": [
      "File item must not be null",
      "Target filename must not be empty",
      "Target directory must exist and be writable",
      "Sufficient storage space must be available"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "FileItem": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "description": "Original name of the uploaded file"
          },
          "inputStream": {
            "type": "object",
            "description": "Stream containing the file data"
          },
          "size": {
            "type": "number",
            "description": "Size of the uploaded file in bytes"
          }
        },
        "required": [
          "name",
          "inputStream"
        ]
      }
    }
  },
  {
    "featureName": "GetFileExtension",
    "description": "Extracts and returns the file extension from an uploaded file.",
    "inputValues": [
      "uploadedFile-object-FileItem"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the uploaded file object (FileItem)\n   - Check if the file object is not null\n   - Verify the file has a name property\n\n2. Data Validation:\n   - Validate that the uploaded file object exists\n     - IF file object is null THEN return error message \"No file provided\"\n   - Validate that the file has a name\n     - IF file name is empty THEN return error message \"File has no name\"\n   - Validate that the file name contains an extension\n     - IF file name does not contain a period (.) THEN return error message \"File has no extension\"\n\n3. Business Rule Processing:\n   - Check if extension has already been extracted\n     - IF extension is already stored and not empty THEN return the stored extension\n   - Determine the position of the last period in the file name\n     - Find the last occurrence of period (.) character in the file name\n     - IF no period is found THEN return error message \"Invalid file name format\"\n\n4. Core Operation Execution:\n   - Extract the extension from the file name\n     - Get the substring of the file name starting from the position after the last period\n     - Store the extracted extension for future reference\n   - Normalize the extension if needed\n     - Convert extension to lowercase for consistency (optional)\n     - Remove any trailing whitespace or special characters (optional)\n\n5. Response Generation:\n   - Return the extracted file extension\n   - IF extraction was successful THEN return the extension string\n   - IF any errors occurred during extraction THEN return appropriate error message",
    "databaseEntities": [
      "jforum_attachments",
      "jforum_extension_groups"
    ],
    "validationRules": [
      "Uploaded file must not be null",
      "File name must not be empty",
      "File name must contain at least one period character",
      "Extension must be extractable from the file name"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "FileItem": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "description": "The name of the uploaded file"
          },
          "inputStream": {
            "type": "object",
            "description": "Stream containing the file data"
          }
        },
        "required": [
          "name"
        ]
      }
    }
  },
  {
    "featureName": "HandleAvatarUpload",
    "description": "Processes avatar image uploads with resizing, format conversion, and validation against size limits.",
    "inputValues": [
      "avatarFile-object-AvatarImage",
      "userId-number-User",
      "avatarUrl-string-User"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the following inputs:\n     a. Avatar file (optional): User-uploaded image file\n     b. Avatar URL (optional): External URL to an image\n     c. User ID (mandatory): Identifier of the user updating avatar\n     d. Avatar deletion flag (optional): Indicates if avatar should be removed\n     e. System configuration parameters (system-generated):\n        i. Maximum avatar width\n        ii. Maximum avatar height\n        iii. Allowed file formats\n        iv. External URL permission flag\n\n2. Data Validation:\n   a. Avatar Source Validation:\n      - IF avatar deletion flag is set THEN\n        i. Skip other avatar validations\n      - ELSE IF both avatar file and avatar URL are provided THEN\n        i. Return error indicating only one avatar source is allowed\n      - ELSE IF neither avatar file nor avatar URL are provided THEN\n        i. Skip remaining validations (no avatar change requested)\n   \n   b. File Upload Validation (when avatar file is provided):\n      - Validate file format is one of the allowed types (jpg, jpeg, gif, png)\n        i. IF format is not supported THEN return error message\n      - Validate file can be processed as an image\n        i. IF file cannot be read as an image THEN return error message\n   \n   c. External URL Validation (when avatar URL is provided):\n      - Validate system allows external avatar URLs\n        i. IF external URLs not allowed THEN return error message\n      - Validate URL starts with \"http://\"\n        i. IF URL doesn't start with \"http://\" THEN return error message\n      - Validate URL points to an accessible image\n        i. IF URL doesn't point to a readable image THEN return error message\n\n3. Business Rule Processing:\n   a. Image Dimension Validation:\n      - FOR the provided avatar (file or URL):\n        i. Load the image and determine its dimensions\n        ii. IF width exceeds maximum allowed width OR height exceeds maximum allowed height THEN\n           - Return error indicating avatar dimensions are too large\n   \n   b. File Format Conversion Rules:\n      - IF image format is GIF THEN\n        i. Mark for conversion to PNG format\n      - IF image format is not supported for storage THEN\n        i. Return error indicating unsupported format\n\n4. Core Operation Execution:\n   a. Avatar Deletion Processing:\n      - IF avatar deletion flag is set THEN\n        i. Locate the current avatar file in storage\n        ii. Delete the file from the storage system\n        iii. Set user's avatar reference to null\n        iv. Skip remaining processing steps\n   \n   b. Avatar File Processing:\n      - IF avatar file is provided THEN\n        i. Generate a unique filename based on user ID\n        ii. Save the uploaded file to a temporary location\n        iii. Resize the image to fit within maximum dimensions while maintaining aspect ratio\n        iv. Convert the image format if necessary (e.g., GIF to PNG)\n        v. Save the processed image to the final avatar storage location\n        vi. Delete the temporary file\n        vii. Update user's avatar reference to the new filename\n   \n   c. Avatar URL Processing:\n      - IF avatar URL is provided THEN\n        i. Verify the image at the URL fits within maximum dimensions\n        ii. Update user's avatar reference to the validated URL\n\n5. Response Generation:\n   a. Success Response:\n      - Return success status\n      - Include the updated avatar reference (filename or URL)\n   \n   b. Error Response:\n      - Return failure status\n      - Include specific error message describing the validation or processing failure\n      - Include guidance on allowed avatar parameters (formats, dimensions)",
    "databaseEntities": [
      "jforum_users"
    ],
    "validationRules": [
      "Avatar file must be in jpg, jpeg, gif, or png format",
      "Avatar dimensions must not exceed maximum allowed width and height",
      "External avatar URL must start with 'http://'",
      "External avatar URL must point to an accessible image",
      "External avatar URL is only allowed if system configuration permits",
      "Only one avatar source (file or URL) can be provided at a time"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "AvatarImage": {
        "type": "object",
        "properties": {
          "content": {
            "type": "binary",
            "description": "Binary content of the uploaded image file"
          },
          "filename": {
            "type": "string",
            "description": "Original filename of the uploaded image"
          },
          "contentType": {
            "type": "string",
            "description": "MIME type of the uploaded image"
          },
          "size": {
            "type": "number",
            "description": "Size of the uploaded file in bytes"
          }
        }
      }
    }
  },
  {
    "featureName": "ContextToPagination",
    "description": "Prepares user context for data pagination with page counts and navigation variables.",
    "inputValues": [
      "start-number-Pagination",
      "totalRecords-number-Pagination",
      "recordsPerPage-number-Pagination"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the following required inputs:\n     a. start (number): The starting record index (zero-based)\n     b. totalRecords (number): The total number of records available\n     c. recordsPerPage (number): The number of records to display per page\n\n2. Data Validation:\n   - Validate start parameter:\n     a. IF start is negative THEN\n        i. Set start to 0\n     b. ENDIF\n   - Validate totalRecords parameter:\n     a. IF totalRecords is negative THEN\n        i. Set totalRecords to 0\n     b. ENDIF\n   - Validate recordsPerPage parameter:\n     a. IF recordsPerPage is less than or equal to 0 THEN\n        i. Set recordsPerPage to a default value (e.g., 10)\n     b. ENDIF\n\n3. Business Rule Processing:\n   - Calculate pagination variables:\n     a. Calculate total number of pages:\n        i. totalPages = CEILING(totalRecords / recordsPerPage)\n     b. Calculate current page number:\n        i. thisPage = CEILING((start + 1) / recordsPerPage)\n     c. Ensure calculated values are valid:\n        i. IF totalPages is less than 1 THEN\n           1. Set totalPages to 1\n        ii. ENDIF\n        iii. IF thisPage is greater than totalPages THEN\n           1. Set thisPage to totalPages\n        iv. ENDIF\n        v. IF thisPage is less than 1 THEN\n           1. Set thisPage to 1\n        vi. ENDIF\n\n4. Core Operation Execution:\n   - Prepare context variables for pagination:\n     a. Set totalPages variable in context\n     b. Set recordsPerPage variable in context\n     c. Set totalRecords variable in context\n     d. Set thisPage variable in context\n     e. Set start variable in context\n\n5. Response Generation:\n   - Return the updated context with all pagination variables:\n     a. totalPages: The total number of pages available\n     b. recordsPerPage: The number of records shown per page\n     c. totalRecords: The total number of records found\n     d. thisPage: The current page being shown\n     e. start: The starting record index",
    "databaseEntities": [],
    "validationRules": [
      "Start parameter must be a non-negative integer",
      "Total records must be a non-negative integer",
      "Records per page must be a positive integer"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Pagination": {
        "type": "object",
        "properties": {
          "start": {
            "type": "number",
            "description": "Starting record index (zero-based)"
          },
          "totalRecords": {
            "type": "number",
            "description": "Total number of records available"
          },
          "recordsPerPage": {
            "type": "number",
            "description": "Number of records to display per page"
          }
        },
        "required": [
          "start",
          "totalRecords",
          "recordsPerPage"
        ]
      }
    }
  },
  {
    "featureName": "ContextToLogin",
    "description": "Prepares template context for login page with return path handling and SSO redirect support.",
    "inputValues": [
      "returnPath-string-ReturnPath"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the following inputs:\n     a. returnPath (string, optional): The path to return to after login\n     b. authType (string, system-generated): Authentication type from system configuration\n     c. ssoRedirect (string, system-generated): SSO redirect URL from system configuration\n\n2. Data Validation:\n   - Validate returnPath:\n     a. IF returnPath is not provided THEN\n        i. Get current request URI\n        ii. Get current query string\n        iii. IF query string exists THEN\n             - Set returnPath = URI + \"?\" + query string\n        iv. ELSE\n             - Set returnPath = URI\n     b. No specific format validation required for returnPath\n\n3. Business Rule Processing:\n   - Check authentication configuration:\n     a. Retrieve authentication type from system configuration\n     b. IF authentication type is SSO THEN\n        i. Check if SSO redirect URL is configured\n        ii. IF SSO redirect URL is configured THEN\n            - Validate SSO redirect URL format:\n              * Verify URL has a proper scheme (must be absolute URL)\n              * IF URL is not absolute THEN\n                  - Generate error indicating SSO redirect URL should start with a scheme\n\n4. Core Operation Execution:\n   - Set up template context:\n     a. Add returnPath to template context for use in login form\n     b. IF authentication type is SSO AND SSO redirect URL is configured THEN\n        i. Encode the forum base URL + returnPath using UTF-8\n        ii. Prepare the complete redirect URL:\n            - IF SSO redirect URL contains '?' THEN\n                * Append '&returnUrl=' + encoded return path\n            - ELSE\n                * Append '?returnUrl=' + encoded return path\n        iii. Set up system redirect to the complete SSO URL\n\n5. Response Generation:\n   - Return the template key for the login page\n   - IF SSO redirect is configured THEN\n     a. System will perform redirect to SSO provider\n   - ELSE\n     a. System will display the login form template\n     b. The login form will include the returnPath for post-login navigation",
    "databaseEntities": [
      "jforum_users",
      "jforum_sessions"
    ],
    "validationRules": [
      "SSO redirect URL must be an absolute URL with a scheme if SSO authentication is enabled",
      "Return path must be properly captured from current request if not explicitly provided"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "ReturnPath": {
        "type": "string",
        "description": "The URL path to return to after successful login"
      }
    }
  },
  {
    "featureName": "GetStartPage",
    "description": "Determines the initial page number for record pagination from request parameters.",
    "inputValues": [
      "requestParameter-string-Request"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the 'start' parameter from the request\n   - This parameter is optional and represents the starting record index for pagination\n\n2. Data Validation:\n   - Check if the 'start' parameter exists in the request\n     - IF parameter is empty or not present\n       - Set start value to 0 (default to first page)\n     - ELSE\n       - Parse the string value to an integer\n       - IF parsed value is less than 0\n         - Set start value to 0 (ensure non-negative value)\n       - ELSE\n         - Use the parsed value as is\n\n3. Business Rule Processing:\n   - No additional business rules to process\n   - The start value represents the index of the first record to display in pagination\n\n4. Core Operation Execution:\n   - Return the validated start value\n   - This value will be used by the calling function to determine which records to fetch\n\n5. Response Generation:\n   - Return the calculated start page value as an integer\n   - This value represents the starting point for record retrieval in a paginated list",
    "databaseEntities": [],
    "validationRules": [
      "Start parameter must be a valid integer if provided",
      "Start parameter must be non-negative",
      "If start parameter is missing or invalid, default to 0"
    ],
    "dbSeedingOperations": [],
    "schema": {}
  },
  {
    "featureName": "GetForumLink",
    "description": "Retrieves the forum base URL with trailing slash for consistent linking.",
    "inputValues": [
      "forumLink-string-System"
    ],
    "businessLogic": "1. Input Collection:\n   - Retrieve the forum link configuration value from the system\n   - This value represents the base URL of the forum\n\n2. Data Validation:\n   - Check if the forum link value exists\n     - IF forum link is null or empty THEN\n       - Return an error indicating the forum link configuration is missing\n     - END IF\n\n3. Business Rule Processing:\n   - Examine the forum link to ensure it ends with a trailing slash\n     - IF the last character of the forum link is not a forward slash ('/') THEN\n       - The link needs to be modified to include the trailing slash\n     - ELSE\n       - The link already has the proper format\n     - END IF\n\n4. Core Operation Execution:\n   - IF the forum link does not end with a trailing slash THEN\n     - Append a forward slash character ('/') to the end of the forum link\n   - END IF\n   - Store the properly formatted forum link for return\n\n5. Response Generation:\n   - Return the formatted forum link with trailing slash\n   - The returned link can now be used as a base URL for constructing complete forum URLs",
    "databaseEntities": [],
    "validationRules": [
      "Forum link configuration value must exist in the system",
      "Returned forum link must always end with a trailing slash character ('/')"
    ],
    "dbSeedingOperations": [],
    "schema": {}
  },
  {
    "featureName": "ToUtf8String",
    "description": "Converts strings to UTF-8 encoded format for proper character handling.",
    "inputValues": [
      "inputString-string-String"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the input string to be converted to UTF-8 format\n     1.1. Verify the input string is not null\n     1.2. If null, return an empty string\n\n2. Data Validation:\n   - Validate the input string\n     2.1. Check if the input string is empty\n        2.1.1. IF string is empty, THEN return the empty string as is\n     2.2. Verify the string contains characters that need encoding\n        2.2.1. IF string contains only ASCII characters (0-127), optimization may be possible\n\n3. Business Rule Processing:\n   - Prepare for character-by-character processing\n     3.1. Initialize a string buffer to hold the result\n     3.2. Determine the encoding strategy based on system settings\n        3.2.1. Verify UTF-8 encoding is supported by the system\n        3.2.2. IF encoding is not supported, prepare fallback mechanism\n\n4. Core Operation Execution:\n   - Process each character in the input string\n     4.1. FOR each character in the input string:\n        4.1.1. Examine the character value\n           4.1.1.1. IF character is in ASCII range (0-255):\n              - Add the character directly to the result buffer\n           4.1.1.2. ELSE (character is outside ASCII range):\n              - Convert the character to UTF-8 bytes\n              - FOR each byte in the UTF-8 representation:\n                 - Convert byte to hexadecimal representation\n                 - Prefix with '%' symbol\n                 - Ensure hexadecimal values are uppercase\n                 - Append to the result buffer\n     4.2. Handle any conversion exceptions\n        4.2.1. IF exception occurs during byte conversion:\n           - Log the error\n           - Continue processing with empty byte array\n\n5. Response Generation:\n   - Prepare the final UTF-8 encoded string\n     5.1. Convert the string buffer to a string\n     5.2. Verify the resulting string is properly formatted\n     5.3. Return the UTF-8 encoded string",
    "databaseEntities": [],
    "validationRules": [
      "Input string must not be null",
      "Character conversion must handle both ASCII (0-255) and non-ASCII characters",
      "Non-ASCII characters must be properly encoded as UTF-8 byte sequences",
      "Each byte in UTF-8 sequences must be represented as a percent-encoded uppercase hexadecimal value"
    ],
    "dbSeedingOperations": [],
    "schema": {}
  },
  {
    "featureName": "FormatDate",
    "description": "Formats dates using system-defined date/time pattern from configuration.",
    "inputValues": [
      "date-date-Date"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the date input (date-date-Date) to be formatted\n   - System will retrieve the date/time format pattern from system configuration\n\n2. Data Validation:\n   - Validate that the input date is not null\n     * IF date is null THEN\n       - Return an appropriate error message\n       - Exit the process\n   - Validate that the system configuration contains a valid date/time format pattern\n     * IF date/time format pattern is missing or invalid THEN\n       - Use a default date/time format pattern\n       - Log a warning about using default pattern\n\n3. Business Rule Processing:\n   - Check if the system is configured to use a specific locale for date formatting\n     * IF specific locale is configured THEN\n       - Retrieve locale settings from system configuration\n     * ELSE\n       - Use system default locale\n   - Determine if any special formatting rules apply based on system settings\n     * IF special formatting rules exist THEN\n       - Apply these rules to the formatting process\n\n4. Core Operation Execution:\n   - Create a date formatter using the retrieved date/time pattern\n   - Apply the formatter to the input date\n   - Convert the formatted date to a string representation\n   - IF formatting operation fails THEN\n     * Log the error\n     * Return a system-defined error message\n     * Consider falling back to a simpler date format\n\n5. Response Generation:\n   - Return the formatted date string\n   - IF debugging is enabled THEN\n     * Include additional information about the format pattern used\n   - Ensure consistent encoding of the returned string",
    "databaseEntities": [],
    "validationRules": [
      "Input date must not be null",
      "System configuration must contain a valid date/time format pattern",
      "Date formatter must be able to process the given date"
    ],
    "dbSeedingOperations": [],
    "schema": {}
  },
  {
    "featureName": "EscapeHtml",
    "description": "Escapes HTML special characters to prevent security vulnerabilities.",
    "inputValues": [
      "content-string-TextContent"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the text content to be processed (content-string-TextContent)\n   - This field is mandatory\n   - No default values are provided\n\n2. Data Validation:\n   - Validate the input content\n     - Check if the content is not null\n     - IF content is null THEN\n       - Return an empty string\n     - END IF\n     - Check if the content is a valid string\n     - IF content is not a valid string THEN\n       - Generate an error message indicating invalid input format\n     - END IF\n\n3. Business Rule Processing:\n   - Determine which special characters need to be escaped\n     - Identify HTML sensitive characters (< and >)\n     - Prepare replacement mappings:\n       - < should be replaced with &lt;\n       - > should be replaced with &gt;\n\n4. Core Operation Execution:\n   - Create a buffer to hold the processed content\n     - Convert the input string to a string buffer for manipulation\n   - Process the content character by character\n     - Scan through the entire content\n     - Replace each occurrence of < with &lt;\n     - Replace each occurrence of > with &gt;\n   - Compile the final escaped string\n     - Convert the buffer back to a string\n\n5. Response Generation:\n   - Return the escaped HTML string\n   - IF any errors occurred during processing THEN\n     - Return appropriate error information\n   - ELSE\n     - Return the successfully escaped content\n   - END IF",
    "databaseEntities": [],
    "validationRules": [
      "Input content must not be null",
      "Input content must be a valid string",
      "All < characters must be replaced with &lt;",
      "All > characters must be replaced with &gt;"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "TextContent": {
        "type": "object",
        "properties": {
          "content": {
            "type": "string",
            "description": "The text content that may contain HTML special characters"
          }
        },
        "required": [
          "content"
        ]
      }
    }
  },
  {
    "featureName": "ReplaceAll",
    "description": "Performs string replacement operations for content transformation.",
    "inputValues": [
      "content-string-TextContent",
      "searchPattern-string-Pattern",
      "replacementValue-string-Replacement"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the following inputs:\n     a. content (string, mandatory): The original text content to be processed\n     b. searchPattern (string, mandatory): The pattern to search for in the content\n     c. replacementValue (string, mandatory): The value to replace the pattern with\n\n2. Data Validation:\n   - Validate content input:\n     a. IF content is null or empty THEN\n        i. Generate error message: \"Content cannot be empty\"\n        ii. Abort operation and return error\n   - Validate searchPattern input:\n     a. IF searchPattern is null or empty THEN\n        i. Generate error message: \"Search pattern cannot be empty\"\n        ii. Abort operation and return error\n   - Validate replacementValue input:\n     a. IF replacementValue is null THEN\n        i. Set replacementValue to an empty string\n        ii. Log warning about null replacement being converted to empty string\n\n3. Business Rule Processing:\n   - Check for special handling requirements:\n     a. IF content contains binary or non-text data THEN\n        i. Generate warning about potential data corruption\n        ii. Proceed with caution or abort based on configuration settings\n     b. IF searchPattern appears extremely frequently in content THEN\n        i. Evaluate performance implications\n        ii. Consider chunking the operation for large content\n     c. IF content size exceeds system-defined threshold THEN\n        i. Evaluate memory requirements\n        ii. Consider streaming approach for replacement\n\n4. Core Operation Execution:\n   - Initialize a buffer to hold the modified content\n     a. Create a new string buffer with the original content\n   - Perform the replacement operation:\n     a. Find the first occurrence of searchPattern in the buffer\n     b. WHILE an occurrence is found DO\n        i. Replace the current occurrence with replacementValue\n        ii. Find the next occurrence of searchPattern in the buffer\n   - Handle any exceptions during replacement:\n     a. IF an exception occurs during replacement THEN\n        i. Log the error details\n        ii. Abort operation and return error with details\n\n5. Response Generation:\n   - Prepare the response with the transformed content:\n     a. Convert the buffer to a string\n     b. Include the following in the response:\n        i. The transformed content\n        ii. Number of replacements made\n        iii. Original content length\n        iv. New content length\n   - Return success response with the transformed content",
    "databaseEntities": [],
    "validationRules": [
      "Content must not be null or empty",
      "Search pattern must not be null or empty",
      "Replacement value must be initialized (default to empty string if null)"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "TextContent": {
        "type": "object",
        "properties": {
          "originalText": {
            "type": "string",
            "description": "The original text content before transformation"
          },
          "transformedText": {
            "type": "string",
            "description": "The text content after transformation"
          },
          "replacementCount": {
            "type": "integer",
            "description": "Number of replacements performed"
          }
        }
      }
    }
  },
  {
    "featureName": "PrepareUserSignature",
    "description": "Formats user signatures for display with proper HTML formatting and security.",
    "inputValues": [
      "user-object-User"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect user object that contains signature data\n     1.1. Verify user object is not null\n     1.2. Check if signature field exists within the user object\n\n2. Data Validation:\n   - Validate signature content\n     2.1. IF signature is null THEN\n         2.1.1. Skip processing and return\n     2.2. Check signature length\n         2.2.1. IF signature exceeds maximum allowed length THEN\n             2.2.1.1. Truncate signature to maximum allowed length\n\n3. Business Rule Processing:\n   - Apply signature formatting rules\n     3.1. Check system settings for signature formatting options\n     3.2. Determine which formatting features are enabled\n         3.2.1. Check if HTML is allowed in signatures\n         3.2.2. Check if BBCode is allowed in signatures\n         3.2.3. Check if image embedding is allowed in signatures\n\n4. Core Operation Execution:\n   - Format signature for display\n     4.1. Create a buffer to hold the formatted signature\n     4.2. Replace newline characters with HTML line breaks\n         4.2.1. Find all occurrences of '\\n' in the signature\n         4.2.2. Replace each occurrence with '<br />'\n     4.3. Apply security measures to prevent XSS attacks\n         4.3.1. Escape HTML special characters\n             4.3.1.1. Replace '<' with '&lt;'\n             4.3.1.2. Replace '>' with '&gt;'\n     4.4. Process allowed formatting tags\n         4.4.1. IF HTML is allowed THEN\n             4.4.1.1. Process allowed HTML tags\n         4.4.2. IF BBCode is allowed THEN\n             4.4.2.1. Convert BBCode to corresponding HTML\n     4.5. Update the user object with the formatted signature\n\n5. Response Generation:\n   - Return updated user object\n     5.1. Ensure the user object now contains properly formatted signature\n     5.2. IF any errors occurred during processing THEN\n         5.2.1. Log the error details\n         5.2.2. Return user object with original unformatted signature",
    "databaseEntities": [
      "jforum_users"
    ],
    "validationRules": [
      "User object must not be null",
      "Signature must be properly escaped to prevent XSS attacks",
      "HTML formatting must follow system configuration rules",
      "Line breaks must be converted to HTML break tags",
      "Signature must maintain content integrity after formatting"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "User": {
        "type": "object",
        "properties": {
          "id": {
            "type": "number"
          },
          "username": {
            "type": "string"
          },
          "signature": {
            "type": "string",
            "description": "User's forum signature that may contain text formatting"
          }
        },
        "required": [
          "id",
          "username"
        ]
      }
    }
  },
  {
    "featureName": "WelcomeInstallation",
    "description": "Prepares installation welcome page with configuration parameters from session.",
    "inputValues": [
      "language-string-UserSession",
      "database-string-SystemConfiguration",
      "dbHost-string-DatabaseConfiguration",
      "dbUser-string-DatabaseConfiguration",
      "dbName-string-DatabaseConfiguration",
      "dbPort-string-DatabaseConfiguration",
      "dbPassword-string-DatabaseConfiguration",
      "dbEncoding-string-DatabaseConfiguration",
      "dbEncodingOther-string-DatabaseConfiguration",
      "usePool-string-DatabaseConfiguration",
      "forumLink-string-SystemConfiguration",
      "siteLink-string-SystemConfiguration",
      "adminPassword-string-UserConfiguration",
      "dbdatasource-string-DatabaseConfiguration",
      "db_connection_type-string-DatabaseConfiguration"
    ],
    "businessLogic": "1. Input Collection:\n   - Retrieve configuration parameters from request and session\n     1.1. Collect primary configuration parameters from request\n        - Language preference\n        - Database type selection\n        - Database connection details (host, port, user, name, password)\n        - Database encoding settings (encoding, encoding_other)\n        - Connection pool usage flag\n        - System URLs (forum link, site link)\n        - Administrator password\n        - Data source configuration\n        - Database connection type\n     1.2. Apply default values for missing parameters\n        - Default database host to \"localhost\" if not provided\n        - Default encoding to \"utf-8\" if not provided\n        - Default forum link to \"http://localhost\" if not provided\n        - Default database name to \"jforum\" if not provided\n        - For HSQLDB database type, default user to \"sa\" if not provided\n\n2. Data Validation:\n   2.1. Parameter Format Validation\n      - Ensure all parameters have appropriate formats\n      - Validate URL formats for forum and site links\n      - Validate database connection parameters\n   2.2. System Environment Validation\n      - Check if the system can write to configuration directories\n      - Determine if file permissions are adequate for installation\n      - Verify system requirements are met\n\n3. Business Rule Processing:\n   3.1. Session Management\n      - Store all configuration parameters in session for persistence\n      - Initialize installation state tracking in session\n      - Clear any previous installation progress indicators\n   3.2. Context Preparation\n      - Add all configuration parameters to rendering context\n      - Add system capability flags to context (e.g., write permissions)\n      - Set module action identifier for template processing\n\n4. Core Operation Execution:\n   4.1. Template Selection\n      - Set appropriate installation information check template\n   4.2. Context Population\n      - Add all configuration parameters to rendering context\n        - Language setting\n        - Database configuration (type, host, user, name, port)\n        - Connection settings (password, encoding, pool usage)\n        - System URLs (forum link, site link)\n        - Administrator credentials\n        - Data source configuration\n      - Add installation state flags to context\n        - Set configureDatabase flag to null\n        - Set createTables flag to null\n        - Set importTablesData flag to null\n      - Add system capability indicators\n        - Add canWriteToWebInf flag based on file system check\n\n5. Response Generation:\n   5.1. Prepare Installation Check Page\n      - Format all configuration parameters for display\n      - Show system capability status\n      - Highlight any potential issues or warnings\n   5.2. Return Installation Check Page\n      - Return fully populated page with all configuration parameters\n      - Provide options to proceed with installation or modify settings\n      - Show next steps in the installation process",
    "databaseEntities": [
      "jforum_users",
      "jforum_groups",
      "jforum_topics",
      "jforum_posts",
      "jforum_forums"
    ],
    "validationRules": [
      "Language code must exist in the system",
      "All required configuration parameters must be present in session",
      "Database host must be provided or defaulted to localhost",
      "Database encoding must be provided or defaulted to utf-8",
      "Forum link must be provided or defaulted to http://localhost",
      "Database name must be provided or defaulted to jforum",
      "For HSQLDB database type, user must be provided or defaulted to sa"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "UserSession": {
        "type": "object",
        "properties": {
          "language": {
            "type": "string",
            "description": "User preferred language code"
          }
        }
      },
      "DatabaseConfiguration": {
        "type": "object",
        "properties": {
          "dbType": {
            "type": "string",
            "description": "Database type (e.g., mysql, postgresql)"
          },
          "dbHost": {
            "type": "string",
            "description": "Database server hostname"
          },
          "dbUser": {
            "type": "string",
            "description": "Database username"
          },
          "dbName": {
            "type": "string",
            "description": "Database name"
          },
          "dbPort": {
            "type": "string",
            "description": "Database server port"
          },
          "dbPassword": {
            "type": "string",
            "description": "Database password"
          },
          "dbEncoding": {
            "type": "string",
            "description": "Database character encoding"
          },
          "dbEncodingOther": {
            "type": "string",
            "description": "Custom database character encoding"
          },
          "usePool": {
            "type": "string",
            "description": "Whether to use connection pooling"
          },
          "dbdatasource": {
            "type": "string",
            "description": "JNDI datasource name if applicable"
          },
          "db_connection_type": {
            "type": "string",
            "description": "Type of database connection to use"
          }
        }
      },
      "SystemConfiguration": {
        "type": "object",
        "properties": {
          "forumLink": {
            "type": "string",
            "description": "URL to the forum"
          },
          "siteLink": {
            "type": "string",
            "description": "URL to the main site"
          },
          "database": {
            "type": "string",
            "description": "Database type selection"
          }
        }
      },
      "UserConfiguration": {
        "type": "object",
        "properties": {
          "adminPassword": {
            "type": "string",
            "description": "Administrator password for system access"
          }
        }
      }
    }
  },
  {
    "featureName": "CheckLanguage",
    "description": "Validates and sets user language preference for installation process.",
    "inputValues": [
      "languageParameter-string-Language",
      "userLocale-object-Locale"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect language parameter from request (optional)\n   - Collect user's locale from request (system-generated)\n\n2. Data Validation:\n   - Check if language parameter exists in request\n     - IF language parameter is null THEN\n       - Extract language from user's locale\n       - Format as \"language_country\" code\n   - Verify language exists in system\n     - IF language does not exist in system THEN\n       - Return without changing language\n       - Keep default language\n\n3. Business Rule Processing:\n   - Verify language resource files are available\n   - Check if language is supported for installation\n   - Ensure language code follows proper format (language_COUNTRY)\n\n4. Core Operation Execution:\n   - Load language resources for selected language\n   - Create new user session\n   - Set language preference in user session\n   - Add user session to session management system\n   - Store language selection in both session and context\n\n5. Response Generation:\n   - Return success status\n   - Make selected language available for installation process\n   - Ensure all subsequent installation steps use selected language\n   - Display installation interface in selected language",
    "databaseEntities": [
      "jforum_users"
    ],
    "validationRules": [
      "Language code must exist in the system",
      "Language code must follow the format 'language_COUNTRY'",
      "Language resources must be available for the selected language"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Locale": {
        "language": "string",
        "country": "string"
      }
    }
  },
  {
    "featureName": "DoInstall",
    "description": "Executes the forum installation process including database setup and configuration.",
    "inputValues": [
      "language-string-System",
      "database-string-System",
      "dbHost-string-System",
      "dbUser-string-System",
      "dbName-string-System",
      "dbPort-string-System",
      "dbPassword-string-System",
      "dbEncoding-string-System",
      "usePool-string-System",
      "forumLink-string-System",
      "siteLink-string-System",
      "dbdatasource-string-System"
    ],
    "businessLogic": "1. Input Collection:\n   - Retrieve installation configuration parameters from the session:\n     - language: The language setting for the forum\n     - database: The database type (e.g., postgresql, oracle)\n     - dbHost: Database server hostname\n     - dbUser: Database username\n     - dbName: Database name\n     - dbPort: Database port number\n     - dbPassword: Database password\n     - dbEncoding: Database character encoding\n     - usePool: Whether to use connection pooling\n     - forumLink: URL to the forum\n     - siteLink: URL to the main site\n     - dbdatasource: Database datasource name if applicable\n\n2. Data Validation:\n   - Check for writable directory permissions:\n     - Verify that configuration directories are writable\n     - IF directories are not writable, THEN\n       - Set error message about insufficient permissions\n       - Abort installation process\n       - Return error status\n   - Validate database connection parameters:\n     - Ensure all required database fields are provided\n     - Verify database type is supported\n     - Check that database credentials are valid\n\n3. Business Rule Processing:\n   - Remove any existing user configuration:\n     - Delete previous installation configuration files if they exist\n     - Prepare system for fresh installation\n   - Configure database connection:\n     - IF database configuration hasn't been completed, THEN\n       - Establish database connection using provided parameters\n       - IF connection fails, THEN\n         - Set error message about database connection failure\n         - Abort installation process\n         - Return error status\n     - Mark database configuration as completed\n\n4. Core Operation Execution:\n   - Create database tables:\n     - IF tables creation hasn't been completed, THEN\n       - For database types like PostgreSQL or Oracle:\n         - Drop existing tables if present\n       - Parse database structure file based on selected database type\n       - Execute table creation SQL statements\n       - IF any statement fails, THEN\n         - Roll back transaction\n         - Set error message about table creation failure\n         - Abort installation process\n         - Return error status\n     - Mark table creation as completed\n   - Import initial data:\n     - IF data import hasn't been completed, THEN\n       - Parse database data dump file\n       - Execute data insertion SQL statements\n       - IF any statement fails, THEN\n         - Roll back transaction\n         - Set error message about data import failure\n         - Abort installation process\n         - Return error status\n     - Mark data import as completed\n   - Update administrator password:\n     - Set secure password for administrator account\n     - IF password update fails, THEN\n       - Roll back transaction\n       - Set error message about admin password update failure\n       - Abort installation process\n       - Return error status\n   - Store support project message\n   - Configure system settings:\n     - Generate and set user hash sequence\n     - Set forum and site links\n     - Set default language\n     - Mark system as installed\n     - Save installation configuration\n   - Fix modules mapping:\n     - Remove installation module from active modules\n     - Update modules configuration file\n\n5. Response Generation:\n   - IF installation completed successfully, THEN\n     - Redirect to installation finished page\n     - Display success message with link to forum\n     - Provide instructions for next steps\n   - ELSE\n     - Display appropriate error message\n     - Provide troubleshooting information",
    "databaseEntities": [
      "jforum_users",
      "jforum_groups",
      "jforum_categories",
      "jforum_forums",
      "jforum_topics",
      "jforum_posts",
      "jforum_posts_text",
      "jforum_attachments",
      "jforum_privmsgs",
      "jforum_privmsgs_text",
      "jforum_moderator_groups",
      "jforum_user_groups",
      "jforum_sessions",
      "jforum_smilies",
      "jforum_words",
      "jforum_karma",
      "jforum_bookmarks",
      "jforum_quota_limit",
      "jforum_extension_groups"
    ],
    "validationRules": [
      "Configuration directory must be writable",
      "Database connection parameters must be valid",
      "Database type must be supported",
      "Database connection must be established successfully",
      "All required database tables must be created successfully",
      "Initial data must be imported successfully",
      "Administrator password must be updated successfully"
    ],
    "dbSeedingOperations": [
      "Import initial forum data from database dump file",
      "Create default administrator account",
      "Create default forum categories and groups",
      "Create default system settings"
    ],
    "schema": {}
  },
  {
    "featureName": "ConfigureDatabase",
    "description": "Sets up database connection based on user configuration parameters.",
    "inputValues": [
      "database-string-Database",
      "dbHost-string-Database",
      "dbUser-string-Database",
      "dbName-string-Database",
      "dbPort-string-Database",
      "dbPassword-string-Database",
      "dbEncoding-string-Database",
      "usePool-boolean-Database",
      "dbdatasource-string-Database",
      "adminPassword-string-User",
      "db_connection_type-string-Database"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect database configuration parameters:\n     1.1. Retrieve database type (required)\n     1.2. Retrieve database host address (required)\n     1.3. Retrieve database username (required)\n     1.4. Retrieve database name (required)\n     1.5. Retrieve database port (optional, system will use default if not provided)\n     1.6. Retrieve database password (required)\n     1.7. Retrieve database character encoding (optional)\n     1.8. Determine if connection pooling should be used (optional, default is false)\n     1.9. Retrieve data source name if applicable (optional)\n     1.10. Retrieve connection type (JDBC or datasource)\n     1.11. Retrieve administrator password for system setup\n\n2. Data Validation:\n   - Validate all database configuration parameters:\n     2.1. Verify database type is supported by the system\n        IF database type is not supported THEN\n          Display error message indicating unsupported database type\n          Return to configuration form\n        END IF\n     2.2. Verify database host is not empty\n        IF database host is empty THEN\n          Display error message for missing host\n          Return to configuration form\n        END IF\n     2.3. Verify database name is not empty\n        IF database name is empty THEN\n          Display error message for missing database name\n          Return to configuration form\n        END IF\n     2.4. Verify database username is not empty\n        IF database username is empty THEN\n          Display error message for missing username\n          Return to configuration form\n        END IF\n     2.5. Verify port number is valid if provided\n        IF port is provided AND port is not a valid number THEN\n          Display error message for invalid port\n          Return to configuration form\n        END IF\n     2.6. Verify administrator password is not empty\n        IF administrator password is empty THEN\n          Display error message for missing admin password\n          Return to configuration form\n        END IF\n\n3. Business Rule Processing:\n   - Process connection configuration based on user selections:\n     3.1. Determine connection type based on user preferences\n        IF connection type is JDBC THEN\n          IF usePool is true AND database is not hsqldb THEN\n            Set connection implementation to pooled connection\n          ELSE\n            Set connection implementation to simple connection\n          END IF\n        ELSE\n          Set connection implementation to datasource connection\n        END IF\n     3.2. Verify system has write permissions to configuration directories\n        IF system cannot write to configuration directory THEN\n          Display error message about insufficient permissions\n          Return to configuration form\n        END IF\n        IF system cannot write to search index directory THEN\n          Display error message about insufficient permissions\n          Return to configuration form\n        END IF\n\n4. Core Operation Execution:\n   - Establish and configure database connection:\n     4.1. Load database-specific properties file based on selected database type\n     4.2. Process port configuration\n        IF port is provided THEN\n          Update connection string to include port\n        ELSE\n          Remove port placeholder from connection string\n        END IF\n     4.3. Update database properties with user-provided values\n        4.3.1. Set database host\n        4.3.2. Set database username\n        4.3.3. Set database password\n        4.3.4. Set database name\n        4.3.5. Set database encoding\n        4.3.6. Set database port\n        4.3.7. Set database driver name\n     4.4. Save updated properties to configuration file\n     4.5. Update system settings with new database configuration\n     4.6. Save installation configuration\n     4.7. Attempt to establish database connection\n        IF connection fails THEN\n          Log connection failure details\n          Display error message about connection failure\n          Return to configuration form with error details\n        END IF\n     4.8. For PostgreSQL or Oracle databases\n        4.8.1. Execute table drop statements if needed\n     4.9. Execute database structure creation statements\n        FOR EACH SQL statement in database structure file\n          4.9.1. Execute statement\n          IF statement execution fails THEN\n            Log execution failure\n            Display error message with failed statement\n            Return to configuration form with error details\n          END IF\n        END FOR\n     4.10. Update administrator password\n        4.10.1. Hash the provided admin password\n        4.10.2. Update admin user record in database\n        IF password update fails THEN\n          Log update failure\n          Display error message about password update failure\n          Return to configuration form with error details\n        END IF\n\n5. Response Generation:\n   - Provide feedback on database configuration status:\n     5.1. IF all operations completed successfully THEN\n       5.1.1. Mark database configuration as completed\n       5.1.2. Display success message\n       5.1.3. Enable next installation step\n     5.2. ELSE\n       5.2.1. Display detailed error information\n       5.2.2. Provide troubleshooting suggestions\n       5.2.3. Allow user to modify configuration and retry",
    "databaseEntities": [
      "Database",
      "Configuration",
      "jforum_users"
    ],
    "validationRules": [
      "Database type must be supported by the system",
      "Database host must not be empty",
      "Database name must not be empty",
      "Database username must not be empty",
      "Database port must be a valid number if provided",
      "System must have write permissions to configuration directory",
      "System must have write permissions to search index directory",
      "Administrator password must not be empty"
    ],
    "dbSeedingOperations": [
      "Execute database structure creation SQL statements from the appropriate database type file",
      "Update the Admin user password with the provided password"
    ],
    "schema": {
      "Database": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "description": "Type of database (e.g., mysql, postgresql, oracle)"
          },
          "host": {
            "type": "string",
            "description": "Database server hostname or IP address"
          },
          "name": {
            "type": "string",
            "description": "Name of the database to connect to"
          },
          "user": {
            "type": "string",
            "description": "Username for database authentication"
          },
          "password": {
            "type": "string",
            "description": "Password for database authentication"
          },
          "port": {
            "type": "string",
            "description": "Port number for database connection"
          },
          "encoding": {
            "type": "string",
            "description": "Character encoding for database connection"
          },
          "usePool": {
            "type": "boolean",
            "description": "Whether to use connection pooling"
          },
          "datasource": {
            "type": "string",
            "description": "Name of datasource if applicable"
          },
          "connectionType": {
            "type": "string",
            "description": "Type of connection (JDBC or datasource)"
          }
        },
        "required": [
          "type",
          "host",
          "name",
          "user",
          "password"
        ]
      },
      "Configuration": {
        "type": "object",
        "properties": {
          "connectionType": {
            "type": "string",
            "description": "Type of connection (simple, pooled, datasource)"
          },
          "configPath": {
            "type": "string",
            "description": "Path to configuration files"
          },
          "status": {
            "type": "string",
            "description": "Status of database configuration"
          }
        }
      },
      "User": {
        "type": "object",
        "properties": {
          "username": {
            "type": "string",
            "description": "User's login name"
          },
          "password": {
            "type": "string",
            "description": "User's password (stored as hash)"
          }
        }
      }
    }
  },
  {
    "featureName": "CreateTables",
    "description": "Creates database tables required for forum functionality.",
    "inputValues": [
      "database-string-Database",
      "configDir-string-Configuration"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect database type (string) from session\n   - Collect configuration directory path (string) from system settings\n   - Both inputs are mandatory for table creation\n\n2. Data Validation:\n   - Validate database type:\n     * Check if database type is supported\n     * Verify that the database type string is not empty\n     * Ensure database type matches available configuration files\n   - Validate configuration directory:\n     * Verify the directory exists\n     * Ensure the directory contains required database structure files\n     * Check read permissions for the database structure files\n   - IF any validation fails, THEN generate appropriate error message\n\n3. Business Rule Processing:\n   - Check if tables already exist in the database\n   - Determine if special handling is needed for specific database types:\n     * IF database type is PostgreSQL or Oracle, THEN prepare for table dropping\n     * For other database types, proceed with standard creation\n   - Verify database connection status\n   - Set appropriate transaction settings\n\n4. Core Operation Execution:\n   - Parse database structure file based on database type\n     * Load SQL statements from the appropriate structure file\n     * Process each statement into executable format\n   - Execute table creation statements:\n     * FOR each SQL statement in the parsed file:\n       > Skip empty or invalid statements\n       > Execute the statement against the database\n       > IF execution fails, THEN record error and stop processing\n     * END FOR\n   - Handle transaction management:\n     * IF any statement fails, THEN rollback all changes\n     * IF all statements succeed, THEN commit changes\n   - Update system state to reflect successful table creation\n\n5. Response Generation:\n   - IF table creation succeeds:\n     * Generate success response\n     * Update session to mark table creation as completed\n     * Prepare system for next installation step\n   - IF table creation fails:\n     * Generate detailed error message with specific failure point\n     * Include exception details for troubleshooting\n     * Provide guidance on potential resolution steps",
    "databaseEntities": [
      "jforum_users",
      "jforum_groups",
      "jforum_categories",
      "jforum_forums",
      "jforum_topics",
      "jforum_posts",
      "jforum_posts_text",
      "jforum_attachments",
      "jforum_privmsgs",
      "jforum_privmsgs_text",
      "jforum_moderator_groups",
      "jforum_user_groups",
      "jforum_sessions",
      "jforum_smilies",
      "jforum_words",
      "jforum_karma",
      "jforum_bookmarks",
      "jforum_quota_limit",
      "jforum_extension_groups"
    ],
    "validationRules": [
      "Database type must be supported by the system",
      "Database structure file must exist for the selected database type",
      "Configuration directory must be accessible",
      "Database connection must be active",
      "User must have sufficient permissions to create tables in the database"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Database": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "description": "The type of database (e.g., postgresql, oracle, mysql)"
          },
          "connection": {
            "type": "object",
            "description": "Database connection information"
          }
        }
      },
      "Configuration": {
        "type": "object",
        "properties": {
          "path": {
            "type": "string",
            "description": "Path to configuration directory"
          },
          "files": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "List of configuration files"
          }
        }
      }
    }
  },
  {
    "featureName": "ImportTablesData",
    "description": "Populates database tables with initial required data.",
    "inputValues": [
      "connection-object-Connection",
      "database-string-Database"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect database connection object (connection-object-Connection)\n   - Retrieve database type from session (database-string-Database)\n   - System will use configuration directory path for locating SQL files\n\n2. Data Validation:\n   - Validate database connection is active and valid\n     * IF connection is null or closed THEN return error\n   - Validate database type is supported\n     * IF database type is not recognized THEN return error\n   - Validate SQL dump file exists\n     * IF file path [config_dir]/database/[database_type]/[database_type]_data_dump.sql does not exist THEN return error\n\n3. Business Rule Processing:\n   - Check if tables are ready to receive data\n     * IF tables have not been created THEN return error\n   - Set up transaction environment\n     * Store current auto-commit state\n     * Set auto-commit to false for transaction control\n\n4. Core Operation Execution:\n   - Parse SQL dump file into executable statements\n     * Read file from [config_dir]/database/[database_type]/[database_type]_data_dump.sql\n     * Split file content into individual SQL statements\n   - Execute each SQL statement in sequence\n     * FOR EACH statement in parsed statements:\n       * Skip empty statements\n       * Trim whitespace from statement\n       * Create database statement object\n       * IF statement starts with \"UPDATE\" or \"INSERT\" or \"SET\" THEN\n         * Execute as update statement\n       * ELSE IF statement starts with \"SELECT\" THEN\n         * Execute as query statement\n       * ELSE\n         * Throw invalid query exception\n       * Close statement object\n     * IF any statement execution fails THEN\n       * Roll back transaction\n       * Log error details\n       * Store exception message in context\n       * Return failure status\n   - Restore original auto-commit setting\n   - Return success status\n\n5. Response Generation:\n   - IF operation completed successfully THEN\n     * Mark \"importTablesData\" as \"passed\" in session\n     * Return true to indicate successful import\n   - ELSE\n     * Set error message in context\n     * Return false to indicate import failure",
    "databaseEntities": [
      "jforum_users",
      "jforum_groups",
      "jforum_categories",
      "jforum_forums",
      "jforum_topics",
      "jforum_posts",
      "jforum_posts_text",
      "jforum_attachments",
      "jforum_privmsgs",
      "jforum_privmsgs_text",
      "jforum_moderator_groups",
      "jforum_user_groups",
      "jforum_sessions",
      "jforum_smilies",
      "jforum_words",
      "jforum_karma",
      "jforum_bookmarks",
      "jforum_quota_limit",
      "jforum_extension_groups"
    ],
    "validationRules": [
      "Database connection must be active and valid",
      "Database type must be supported by the system",
      "SQL dump file must exist in the expected location",
      "Tables must be created before importing data",
      "All SQL statements must be valid and executable"
    ],
    "dbSeedingOperations": [
      "Execute all SQL statements from database-specific data dump file"
    ],
    "schema": {
      "Connection": {
        "type": "object",
        "properties": {
          "autoCommit": {
            "type": "boolean",
            "description": "Auto-commit setting for the connection"
          },
          "closed": {
            "type": "boolean",
            "description": "Indicates if connection is closed"
          }
        },
        "methods": {
          "setAutoCommit": {
            "description": "Sets the auto-commit mode"
          },
          "getAutoCommit": {
            "description": "Gets the current auto-commit mode"
          },
          "createStatement": {
            "description": "Creates a statement object for executing SQL"
          },
          "rollback": {
            "description": "Rolls back the current transaction"
          },
          "commit": {
            "description": "Commits the current transaction"
          }
        }
      }
    }
  },
  {
    "featureName": "UpdateAdminPassword",
    "description": "Sets the administrator password during system installation.",
    "inputValues": [
      "adminPassword-string-User",
      "confirmPassword-string-User"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the following inputs:\n     1.1. adminPassword (mandatory): The new administrator password\n     1.2. confirmPassword (mandatory): Confirmation of the administrator password\n\n2. Data Validation:\n   2.1. Validate adminPassword:\n      2.1.1. Check if adminPassword is not empty\n      2.1.2. Check if adminPassword meets minimum length requirements\n      2.1.3. Check if adminPassword meets complexity requirements (contains letters, numbers, special characters)\n      2.1.4. IF validation fails, THEN display appropriate error message\n   2.2. Validate confirmPassword:\n      2.2.1. Check if confirmPassword matches adminPassword\n      2.2.2. IF passwords don't match, THEN display error message\n\n3. Business Rule Processing:\n   3.1. Verify system installation state:\n      3.1.1. Check if system is in installation mode\n      3.1.2. IF not in installation mode, THEN display error message and abort operation\n   3.2. Verify database connection:\n      3.2.1. Check if database connection is established\n      3.2.2. IF connection is not available, THEN display error message and abort operation\n   3.3. Verify write permissions:\n      3.3.1. Check if the system has write permissions to required directories\n      3.3.2. IF write permissions are not available, THEN display error message and abort operation\n\n4. Core Operation Execution:\n   4.1. Hash the password:\n      4.1.1. Generate a secure hash of the adminPassword\n      4.1.2. IF hashing fails, THEN display error message and abort operation\n   4.2. Update administrator account:\n      4.2.1. Locate the administrator account in the system (username 'Admin')\n      4.2.2. Update the password field with the hashed password\n      4.2.3. IF update fails, THEN rollback changes and display error message\n   4.3. Commit changes:\n      4.3.1. Commit the password update to the database\n      4.3.2. IF commit fails, THEN rollback changes and display error message\n\n5. Response Generation:\n   5.1. Generate success response:\n      5.1.1. Create confirmation message that password was updated successfully\n      5.1.2. Include information about next steps in the installation process\n   5.2. Handle error scenarios:\n      5.2.1. For validation errors, provide specific guidance on fixing the input\n      5.2.2. For system errors, provide troubleshooting information\n      5.2.3. Include support contact information for unresolved issues",
    "databaseEntities": [
      "jforum_users"
    ],
    "validationRules": [
      "Administrator password must not be empty",
      "Administrator password must meet minimum length requirements",
      "Administrator password must meet complexity requirements",
      "Confirmation password must match the administrator password",
      "System must be in installation mode",
      "Database connection must be established",
      "System must have write permissions to required directories"
    ],
    "dbSeedingOperations": [],
    "schema": {}
  },
  {
    "featureName": "FinishInstallation",
    "description": "Completes installation process and prepares system for first use.",
    "inputValues": [
      "language-string-SystemConfig",
      "database-string-DatabaseConfig",
      "dbHost-string-DatabaseConfig",
      "dbUser-string-DatabaseConfig",
      "dbName-string-DatabaseConfig",
      "dbPort-string-DatabaseConfig",
      "dbPassword-string-DatabaseConfig",
      "dbEncoding-string-DatabaseConfig",
      "usePool-boolean-DatabaseConfig",
      "forumLink-string-SystemConfig",
      "siteLink-string-SystemConfig",
      "dbdatasource-string-DatabaseConfig"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect all installation configuration parameters:\n     a. System configuration parameters (language, forumLink, siteLink)\n     b. Database configuration parameters (database type, host, user, name, port, password, encoding)\n     c. Connection pool settings (usePool, dbdatasource)\n   - All parameters should be previously collected and stored in session\n\n2. Data Validation:\n   - Validate system directory permissions:\n     a. Check if configuration directories are writable\n     b. IF directories are not writable THEN\n        i. Display error message\n        ii. Halt installation process\n     c. ELSE continue with installation\n   - Validate database configuration:\n     a. Verify database connection parameters are valid\n     b. IF database connection fails THEN\n        i. Display database error message\n        ii. Halt installation process\n     c. ELSE mark database configuration as passed\n\n3. Business Rule Processing:\n   - Process database setup:\n     a. IF tables creation has not been completed THEN\n        i. Create database tables\n        ii. IF table creation fails THEN\n           - Display table creation error message\n           - Rollback changes\n           - Halt installation process\n        iii. ELSE mark table creation as passed\n     b. IF data import has not been completed THEN\n        i. Import initial data into tables\n        ii. IF data import fails THEN\n           - Display data import error message\n           - Rollback changes\n           - Halt installation process\n        iii. ELSE mark data import as passed\n     c. Update administrator password\n        i. IF password update fails THEN\n           - Display admin update error message\n           - Rollback changes\n           - Halt installation process\n     d. Store support project information\n\n4. Core Operation Execution:\n   - Configure system settings:\n     a. Remove temporary user configuration files\n     b. Fix modules mapping:\n        i. Remove installation module from active modules\n        ii. Save updated module configuration\n     c. Set system global parameters:\n        i. Generate and set security hash sequence\n        ii. Set forum and site links\n        iii. Set default language\n        iv. Mark system as installed\n     d. Save installation configuration\n     e. Restart system globals\n\n5. Response Generation:\n   - Prepare completion response:\n     a. Set template to installation finished view\n     b. Include forum link in context\n     c. Include language setting in context\n     d. Include success message and next steps\n   - Clean up session data:\n     a. Remove installation session data\n     b. Prepare system for first use",
    "databaseEntities": [
      "jforum_users",
      "jforum_groups",
      "jforum_categories",
      "jforum_forums",
      "jforum_topics",
      "jforum_posts",
      "jforum_posts_text",
      "jforum_attachments",
      "jforum_privmsgs",
      "jforum_privmsgs_text",
      "jforum_moderator_groups",
      "jforum_user_groups",
      "jforum_sessions",
      "jforum_smilies",
      "jforum_words",
      "jforum_karma",
      "jforum_bookmarks",
      "jforum_quota_limit",
      "jforum_extension_groups"
    ],
    "validationRules": [
      "Configuration directories must be writable",
      "Database connection must be established successfully",
      "Database tables must be created without errors",
      "Initial data must be imported without errors",
      "Administrator password must be updated successfully",
      "System global parameters must be configured properly",
      "Installation configuration must be saved successfully"
    ],
    "dbSeedingOperations": [
      "Import initial data from database-specific SQL dump file",
      "Create administrator account with updated password",
      "Store support project information"
    ],
    "schema": {
      "SystemConfig": {
        "language": "string",
        "forumLink": "string",
        "siteLink": "string"
      },
      "DatabaseConfig": {
        "database": "string",
        "dbHost": "string",
        "dbUser": "string",
        "dbName": "string",
        "dbPort": "string",
        "dbPassword": "string",
        "dbEncoding": "string",
        "usePool": "boolean",
        "dbdatasource": "string"
      }
    }
  },
  {
    "featureName": "ConfigureSystemGlobals",
    "description": "Sets system-wide configuration parameters after successful installation.",
    "inputValues": [
      "dbPassword-string-SystemConfig",
      "forumLink-string-SystemConfig",
      "siteLink-string-SystemConfig",
      "language-string-SystemConfig"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the following configuration parameters:\n     - dbPassword (mandatory): Database password used for generating hash sequence\n     - forumLink (mandatory): URL link to the forum\n     - siteLink (mandatory): URL link to the main site\n     - language (mandatory): Default language setting for the system\n\n2. Data Validation:\n   - Validate forumLink:\n     - Must be a properly formatted URL\n     - Must not be empty\n     - IF invalid, THEN display error message and request correction\n   - Validate siteLink:\n     - Must be a properly formatted URL\n     - Must not be empty\n     - IF invalid, THEN display error message and request correction\n   - Validate language:\n     - Must be a supported language code\n     - IF language code doesn't exist in the system, THEN use default language\n\n3. Business Rule Processing:\n   - Check if system is in proper state for configuration:\n     - Verify installation process has completed database setup\n     - Verify required files are accessible and writable\n     - IF any prerequisite checks fail, THEN abort configuration process and display appropriate error\n\n4. Core Operation Execution:\n   - Generate unique hash sequence:\n     - Create a cryptographic hash using database password and current timestamp\n     - Store hash sequence in system configuration\n   - Set system configuration values:\n     - Set forum link URL in system configuration\n     - Set homepage link URL in system configuration\n     - Set default language in system configuration\n     - Set installation status to \"true\"\n   - Save configuration changes to persistent storage:\n     - Write all configuration values to system configuration files\n     - Ensure all values are properly formatted and escaped\n     - IF writing fails, THEN display error message and suggest manual configuration\n   - Restart system globals:\n     - Reload configuration from storage\n     - Apply new settings to running system\n\n5. Response Generation:\n   - IF configuration completes successfully:\n     - Display success message to user\n     - Provide link to access the newly configured system\n     - Include instructions for any additional steps if needed\n   - IF configuration fails:\n     - Display detailed error message\n     - Provide troubleshooting information\n     - Suggest alternative configuration methods",
    "databaseEntities": [
      "jforum_users",
      "jforum_groups",
      "jforum_categories",
      "jforum_forums",
      "jforum_topics",
      "jforum_posts",
      "jforum_posts_text",
      "jforum_sessions"
    ],
    "validationRules": [
      "Forum link must be a valid URL",
      "Site link must be a valid URL",
      "Language code must be supported by the system",
      "Database password must be available for hash generation",
      "Configuration files must be writable"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "SystemConfig": {
        "type": "object",
        "properties": {
          "dbPassword": {
            "type": "string",
            "description": "Database password used for generating hash sequence"
          },
          "forumLink": {
            "type": "string",
            "description": "URL link to the forum"
          },
          "siteLink": {
            "type": "string",
            "description": "URL link to the main site"
          },
          "language": {
            "type": "string",
            "description": "Default language setting for the system"
          }
        },
        "required": [
          "dbPassword",
          "forumLink",
          "siteLink",
          "language"
        ]
      }
    }
  },
  {
    "featureName": "FixModulesMapping",
    "description": "Updates module mappings to disable installer after successful installation.",
    "inputValues": [],
    "businessLogic": "1. Input Collection:\n   - No user inputs required as this is a system operation\n   - System-generated input: modules mapping file path from system configuration\n\n2. Data Validation:\n   - Verify modules mapping file exists\n   - Verify modules mapping file is writable\n   - Verify system has proper permissions to modify the file\n   - IF any validation fails, log warning message and exit process\n\n3. Business Rule Processing:\n   - Check if installation process has completed successfully\n   - Verify that the 'install' module entry exists in the mapping file\n   - IF 'install' module entry doesn't exist, no action needed\n\n4. Core Operation Execution:\n   - Load current modules mapping configuration from file\n   - Check if the 'install' module entry exists in the configuration\n   - IF 'install' module entry exists:\n     a. Remove the 'install' module entry from the configuration\n     b. Save updated configuration back to the modules mapping file\n     c. Reload modules mapping in the system configuration\n   - Set session attribute to indicate mapping has been fixed\n\n5. Response Generation:\n   - IF operation completes successfully:\n     a. Log success message\n     b. Set session attribute 'mappingFixed' to 'true'\n   - IF operation fails:\n     a. Log warning message with error details\n     b. Continue with remaining installation steps",
    "databaseEntities": [],
    "validationRules": [
      "Modules mapping file must exist",
      "Modules mapping file must be writable",
      "System must have proper permissions to modify the file"
    ],
    "dbSeedingOperations": [],
    "schema": {}
  },
  {
    "featureName": "ExecuteDatabaseStructureCreation",
    "description": "Creates database tables by executing SQL statements from structure files.",
    "inputValues": [
      "dbType-string-Database",
      "connection-object-Connection",
      "configDirectory-string-System"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect database type (dbType) from system configuration\n   - Obtain active database connection (connection)\n   - Determine configuration directory path (configDirectory)\n   - All inputs are mandatory for operation\n\n2. Data Validation:\n   - Validate database type:\n     * Verify dbType is not null or empty\n     * Confirm dbType is a supported database type\n     * Generate error if database type is invalid\n   - Validate connection:\n     * Verify connection is active and not null\n     * Check connection has proper access rights\n     * Generate error if connection is invalid\n   - Validate configuration directory:\n     * Verify configDirectory path exists\n     * Confirm system has read access to the directory\n     * Generate error if directory is inaccessible\n\n3. Business Rule Processing:\n   - Check for special database handling requirements:\n     * IF dbType is \"postgresql\" OR dbType is \"oracle\" THEN\n       - Execute special table dropping procedure\n     * END IF\n   - Verify structure file existence:\n     * Construct path to database structure file: configDirectory + \"/database/\" + dbType + \"/\" + dbType + \"_db_struct.sql\"\n     * Confirm file exists and is readable\n     * Generate error if structure file cannot be found\n   - Check for write permissions:\n     * Verify system can write to required directories\n     * Generate error if write permissions are inadequate\n\n4. Core Operation Execution:\n   - Prepare database connection:\n     * Store current auto-commit state\n     * Set auto-commit to false for transaction control\n   - Parse database structure file:\n     * Read SQL statements from structure file\n     * Split file content into individual SQL statements\n   - Execute SQL statements:\n     * FOR EACH statement in parsed statements:\n       - Skip if statement is empty or null\n       - Create new statement object\n       - Execute the SQL statement\n       - IF execution fails THEN\n         - Log error details\n         - Store exception message\n         - Break execution loop\n         - Set operation status to failure\n       - END IF\n     * END FOR\n   - Restore connection state:\n     * Reset auto-commit to original state\n   - Handle any exceptions during process:\n     * Log exception details\n     * Wrap and propagate as system exception\n\n5. Response Generation:\n   - Generate success response:\n     * Return boolean status indicating success or failure\n     * Include details of executed operations\n   - Generate error response:\n     * Include specific error messages for troubleshooting\n     * Provide guidance on resolving structure creation issues\n     * Include details about which statement failed if applicable",
    "databaseEntities": [
      "jforum_users",
      "jforum_groups",
      "jforum_categories",
      "jforum_forums",
      "jforum_topics",
      "jforum_posts",
      "jforum_posts_text",
      "jforum_attachments",
      "jforum_privmsgs",
      "jforum_privmsgs_text",
      "jforum_moderator_groups",
      "jforum_user_groups",
      "jforum_sessions",
      "jforum_smilies",
      "jforum_words",
      "jforum_karma",
      "jforum_bookmarks",
      "jforum_quota_limit",
      "jforum_extension_groups"
    ],
    "validationRules": [
      "Database type must be a supported value",
      "Database connection must be active and valid",
      "Configuration directory must exist and be accessible",
      "Structure file must exist for the specified database type",
      "System must have write permissions to required directories",
      "SQL statements must be valid for the target database"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Connection": {
        "type": "object",
        "properties": {
          "autoCommit": {
            "type": "boolean",
            "description": "Auto-commit state of the connection"
          },
          "status": {
            "type": "boolean",
            "description": "Connection status"
          }
        }
      }
    }
  },
  {
    "featureName": "DropOracleOrPostgreSQLTables",
    "description": "Removes existing database tables for Oracle or PostgreSQL database types.",
    "inputValues": [
      "dbType-string-Database",
      "connection-object-DatabaseConnection"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect database type (dbType) - mandatory string input\n   - Obtain database connection (connection) - mandatory system-provided object\n\n2. Data Validation:\n   - Validate database type:\n     a. Check if dbType is not null or empty\n     b. Verify dbType equals either \"oracle\" or \"postgresql\"\n     c. If validation fails, generate appropriate error message\n   - Validate database connection:\n     a. Verify connection object is valid and active\n     b. Check if connection has proper permissions to execute DROP statements\n     c. If validation fails, generate appropriate error message with connection details\n\n3. Business Rule Processing:\n   - Check system state:\n     a. Verify system is in maintenance mode or installation process\n     b. Ensure no active users are connected to the system\n     c. IF system is not in appropriate state THEN\n        i. Generate warning about potential data loss\n        ii. Request confirmation before proceeding\n   - Verify database structure file exists:\n     a. Locate drop tables SQL file for the specified database type\n     b. Verify file is readable\n     c. IF file not found or not readable THEN\n        i. Log error message\n        ii. Abort operation\n\n4. Core Operation Execution:\n   - Prepare database connection:\n     a. Store current auto-commit setting\n     b. Set auto-commit to false to allow transaction control\n   - Process SQL statements:\n     a. Read drop table statements from configuration file\n     b. FOR EACH SQL statement in the file:\n        i. Skip empty or comment-only statements\n        ii. Execute the drop table statement\n        iii. IF execution fails THEN\n            1. Log error but continue with next statement (non-fatal errors)\n            2. Record failed statement for reporting\n   - Restore connection settings:\n     a. Restore original auto-commit setting\n     b. Ensure all resources are properly closed\n\n5. Response Generation:\n   - Generate success response:\n     a. Include count of successfully dropped tables\n     b. Include list of any tables that could not be dropped\n   - Generate error response if operation failed completely:\n     a. Include specific error details\n     b. Provide guidance on manual resolution steps\n   - Log operation completion status",
    "databaseEntities": [
      "jforum_users",
      "jforum_groups",
      "jforum_categories",
      "jforum_forums",
      "jforum_topics",
      "jforum_posts",
      "jforum_posts_text",
      "jforum_attachments",
      "jforum_privmsgs",
      "jforum_privmsgs_text",
      "jforum_moderator_groups",
      "jforum_user_groups",
      "jforum_sessions",
      "jforum_smilies",
      "jforum_words",
      "jforum_karma",
      "jforum_bookmarks",
      "jforum_quota_limit",
      "jforum_extension_groups"
    ],
    "validationRules": [
      "Database type must be either 'oracle' or 'postgresql'",
      "Database connection must be valid and active",
      "System must be in maintenance mode or installation process",
      "Drop tables SQL file must exist and be readable",
      "User must have sufficient database permissions to drop tables"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "DatabaseConnection": {
        "type": "object",
        "properties": {
          "autoCommit": {
            "type": "boolean",
            "description": "Current auto-commit setting of the connection"
          },
          "closed": {
            "type": "boolean",
            "description": "Indicates if the connection is closed"
          }
        }
      }
    }
  },
  {
    "featureName": "CheckForWritableDirectories",
    "description": "Validates write permissions for WebInf and Lucene index directories.",
    "inputValues": [
      "webInfDirectory-string-Directory",
      "luceneIndexDirectory-string-Directory"
    ],
    "businessLogic": "1. Input Collection\n   - Collect the following inputs:\n     a. webInfDirectory (mandatory): Path to the WebInf directory\n     b. luceneIndexDirectory (mandatory): Path to the Lucene index directory\n     c. configDirectory (system-generated): Path to the configuration directory\n\n2. Data Validation\n   - Validate directory paths:\n     a. Check if webInfDirectory path is not empty\n        - IF empty THEN generate error message \"WebInf directory path cannot be empty\"\n     b. Check if luceneIndexDirectory path is not empty\n        - IF empty THEN generate error message \"Lucene index directory path cannot be empty\"\n\n3. Business Rule Processing\n   - Verify system state requirements:\n     a. Check if the system has access to the file system\n        - IF no access THEN generate error message \"System cannot access file system\"\n     b. Check if the current user has sufficient permissions to perform file operations\n        - IF insufficient permissions THEN generate error message \"Insufficient user permissions for file operations\"\n\n4. Core Operation Execution\n   - Check WebInf directory write permissions:\n     a. Locate the modulesMapping.properties file in the WebInf directory\n        - IF file not found THEN generate error message \"modulesMapping.properties file not found in WebInf directory\"\n     b. Attempt to verify write permissions on the file\n        - IF not writable THEN set canWriteToWebInf flag to FALSE\n        - ELSE set canWriteToWebInf flag to TRUE\n   - Check Lucene index directory write permissions:\n     a. Check if the Lucene index directory exists\n        - IF directory does not exist THEN\n          i. Attempt to create the directory\n          ii. IF directory creation fails THEN set canWriteToLuceneIndex flag to FALSE\n          iii. ELSE set canWriteToLuceneIndex flag to TRUE\n        - ELSE\n          i. Attempt to verify write permissions on the directory\n          ii. IF not writable THEN set canWriteToLuceneIndex flag to FALSE\n          iii. ELSE set canWriteToLuceneIndex flag to TRUE\n   - Evaluate overall directory write permissions:\n     a. IF canWriteToWebInf is FALSE OR canWriteToLuceneIndex is FALSE THEN\n        i. Set writePermissionsValid flag to FALSE\n        ii. IF canWriteToWebInf is FALSE THEN prepare WebInf error message\n        iii. ELSE IF canWriteToLuceneIndex is FALSE THEN prepare Lucene index error message\n     b. ELSE set writePermissionsValid flag to TRUE\n\n5. Response Generation\n   - Generate appropriate response based on validation results:\n     a. IF writePermissionsValid is TRUE THEN\n        i. Return success response with message \"All required directories have write permissions\"\n     b. ELSE\n        i. Return error response with specific error message about which directory lacks write permissions\n        ii. Include suggestion to check file system permissions\n        iii. Provide option to retry the operation after fixing permissions",
    "databaseEntities": [],
    "validationRules": [
      "WebInf directory must have write permissions",
      "Lucene index directory must have write permissions or be creatable",
      "modulesMapping.properties file must exist in WebInf directory",
      "System must have access to the file system",
      "User must have sufficient permissions to perform file operations"
    ],
    "dbSeedingOperations": [],
    "schema": {}
  },
  {
    "featureName": "ConfigureJDBCConnection",
    "description": "Sets up database connection properties based on user configuration.",
    "inputValues": [
      "dbUser-string-DatabaseConfig",
      "dbPassword-string-DatabaseConfig",
      "dbName-string-DatabaseConfig",
      "dbHost-string-DatabaseConfig",
      "database-string-DatabaseConfig",
      "dbEncoding-string-DatabaseConfig",
      "dbPort-string-DatabaseConfig",
      "db_connection_type-string-ConnectionConfig",
      "usePool-string-ConnectionConfig",
      "dbdatasource-string-ConnectionConfig",
      "adminPassword-string-AdminConfig"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect database configuration parameters:\n     1.1. Retrieve username for database access\n     1.2. Retrieve password for database access\n     1.3. Retrieve database name\n     1.4. Retrieve database host address\n     1.5. Retrieve database type (e.g., postgresql, oracle)\n     1.6. Retrieve database character encoding\n     1.7. Retrieve database port number\n     1.8. Retrieve connection type (JDBC or Datasource)\n     1.9. Retrieve connection pooling preference (yes/no)\n     1.10. Retrieve datasource name (if applicable)\n     1.11. Retrieve administrator password for system access\n\n2. Data Validation:\n   2.1. Validate directory permissions:\n     2.1.1. Check if configuration directory is writable\n       IF not writable THEN\n         Display error message about missing write permissions\n         Set error flag and halt process\n       END IF\n     2.1.2. Check if index directory exists and is writable\n       IF directory doesn't exist THEN\n         Attempt to create directory\n       END IF\n       IF directory is not writable THEN\n         Display error message about missing write permissions\n         Set error flag and halt process\n       END IF\n   2.2. Validate database connection parameters:\n     2.2.1. Ensure database type is supported\n     2.2.2. Ensure host information is provided\n     2.2.3. Ensure database name is provided\n     2.2.4. Validate port number format if provided\n\n3. Business Rule Processing:\n   3.1. Determine connection implementation type:\n     3.1.1. IF connection type is JDBC THEN\n       IF use connection pooling is enabled AND database is not HSQLDB THEN\n         Set implementation to pooled connection\n       ELSE\n         Set implementation to simple connection\n       END IF\n       Configure JDBC connection with provided parameters\n     3.1.2. ELSE (connection type is Datasource)\n       Set implementation to datasource connection\n       Configure datasource name parameter\n     END IF\n   3.2. Process database port configuration:\n     3.2.1. IF port is provided THEN\n       Ensure port is included in connection string\n     3.2.2. ELSE\n       Remove port reference from connection string if present\n     END IF\n\n4. Core Operation Execution:\n   4.1. Load database type-specific properties:\n     4.1.1. Locate properties file for selected database type\n     4.1.2. Load existing configuration properties\n     4.1.3. Update port configuration in connection string\n   4.2. Update database configuration properties:\n     4.2.1. Set database host property\n     4.2.2. Set database username property\n     4.2.3. Set database password property\n     4.2.4. Set database name property\n     4.2.5. Set database encoding property\n     4.2.6. Set database port property\n     4.2.7. Set database driver name property\n   4.3. Save updated configuration:\n     4.3.1. Write updated properties to database configuration file\n     4.3.2. Update system configuration with new properties\n     4.3.3. Save installation configuration\n     4.3.4. Restart system configuration\n   4.4. Establish database connection:\n     4.4.1. Initialize appropriate connection handler based on implementation type\n     4.4.2. Attempt to establish connection to database\n     4.4.3. IF connection fails THEN\n       Log error details\n       Store exception message for display\n       Set error flag\n     END IF\n   4.5. Update administrator password:\n     4.5.1. Prepare SQL statement to update admin user\n     4.5.2. Encrypt provided admin password\n     4.5.3. Execute update operation\n     4.5.4. IF update fails THEN\n       Log error details\n       Store exception message for display\n       Set error flag\n     END IF\n\n5. Response Generation:\n   5.1. IF any errors occurred during configuration THEN\n     5.1.1. Prepare error response with detailed message\n     5.1.2. Include exception details if available\n     5.1.3. Provide guidance on resolving the issue\n   5.2. ELSE\n     5.2.1. Prepare success response\n     5.2.2. Include confirmation of database connection\n     5.2.3. Include confirmation of admin password update\n     5.2.4. Provide next steps for system usage\n   5.3. Return appropriate response to user",
    "databaseEntities": [
      "jforum_users"
    ],
    "validationRules": [
      "Configuration directory must have write permissions",
      "Index directory must exist and have write permissions",
      "Database connection parameters must be valid",
      "Database type must be supported",
      "Administrator password must be provided for update",
      "Connection must be successfully established with provided parameters"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "DatabaseConfig": {
        "type": "object",
        "properties": {
          "dbUser": {
            "type": "string",
            "description": "Database username"
          },
          "dbPassword": {
            "type": "string",
            "description": "Database password"
          },
          "dbName": {
            "type": "string",
            "description": "Database name"
          },
          "dbHost": {
            "type": "string",
            "description": "Database host address"
          },
          "database": {
            "type": "string",
            "description": "Database type"
          },
          "dbEncoding": {
            "type": "string",
            "description": "Database character encoding"
          },
          "dbPort": {
            "type": "string",
            "description": "Database port number"
          }
        }
      },
      "ConnectionConfig": {
        "type": "object",
        "properties": {
          "db_connection_type": {
            "type": "string",
            "description": "Type of connection (JDBC or Datasource)"
          },
          "usePool": {
            "type": "string",
            "description": "Whether to use connection pooling"
          },
          "dbdatasource": {
            "type": "string",
            "description": "Datasource name if using datasource connection"
          }
        }
      },
      "AdminConfig": {
        "type": "object",
        "properties": {
          "adminPassword": {
            "type": "string",
            "description": "Administrator password"
          }
        }
      }
    }
  },
  {
    "featureName": "CheckInstallationInformation",
    "description": "Validates and stores installation parameters for forum setup including database and forum configuration.",
    "inputValues": [
      "language-string-Installation",
      "database-string-Installation",
      "dbHost-string-Installation",
      "dbPort-string-Installation",
      "dbUser-string-Installation",
      "dbName-string-Installation",
      "dbPassword-string-Installation",
      "dbEncoding-string-Installation",
      "dbEncodingOther-string-Installation",
      "usePool-string-Installation",
      "forumLink-string-Installation",
      "siteLink-string-Installation",
      "adminPassword-string-Installation",
      "dbdatasource-string-Installation",
      "db_connection_type-string-Installation"
    ],
    "businessLogic": "1. Input Collection\n   - Collect installation configuration parameters from the user\n     1.1. Gather language preference for the forum\n     1.2. Collect database configuration information:\n          - Database type (e.g., MySQL, PostgreSQL)\n          - Database host address\n          - Database port number\n          - Database user name\n          - Database name\n          - Database password\n          - Database character encoding\n          - Alternative encoding if needed\n     1.3. Collect connection pool preference (whether to use connection pooling)\n     1.4. Gather forum configuration information:\n          - Forum URL link\n          - Site URL link\n          - Administrator password\n          - Database datasource name (if applicable)\n          - Database connection type\n\n2. Data Validation\n   - Validate all input parameters for correctness and completeness\n     2.1. Check if required fields are provided\n          - IF any mandatory field is empty, apply default values where appropriate:\n            - Set default database host to \"localhost\" if not provided\n            - Set default character encoding to \"utf-8\" if not specified\n            - Set default forum link to \"http://localhost\" if not provided\n            - Set default database name to \"jforum\" if not provided\n            - IF database type is \"hsqldb\" AND user name is empty, set default user to \"sa\"\n     2.2. Validate format of provided URLs\n          - Ensure forum link and site link have proper URL format\n     2.3. Validate database connection parameters\n          - Ensure port number is numeric if provided\n          - Ensure database name follows naming conventions\n\n3. Business Rule Processing\n   - Process business rules related to installation configuration\n     3.1. Check system environment compatibility\n          - Verify if the application has write permissions to configuration directories\n          - Store write permission status for later use in the installation process\n     3.2. Determine installation steps based on configuration\n          - Reset configuration flags for database setup steps\n          - Prepare for subsequent installation phases\n\n4. Core Operation Execution\n   - Store validated configuration in the system\n     4.1. Save all validated parameters to session context\n          - Store language preference\n          - Store database configuration (type, host, port, user, name, password, encoding)\n          - Store connection pooling preference\n          - Store forum and site URLs\n          - Store administrator password\n          - Store database connection details\n     4.2. Save all validated parameters to view context\n          - Make all configuration parameters available for the view template\n          - Add write permission status to view context\n     4.3. Reset installation progress flags\n          - Clear database configuration status\n          - Clear table creation status\n          - Clear data import status\n\n5. Response Generation\n   - Prepare response for the user\n     5.1. Set appropriate template for displaying configuration summary\n     5.2. Include all configuration parameters in the view\n     5.3. Include system status information (e.g., write permissions)\n     5.4. Prepare navigation information for next installation steps\n     5.5. Return the prepared view with configuration summary",
    "databaseEntities": [
      "jforum_users",
      "jforum_topics",
      "jforum_posts",
      "jforum_forums"
    ],
    "validationRules": [
      "Database host defaults to 'localhost' if not provided",
      "Database encoding defaults to 'utf-8' if not provided",
      "Forum link defaults to 'http://localhost' if not provided",
      "Database name defaults to 'jforum' if not provided",
      "Database user defaults to 'sa' if database is 'hsqldb' and no user is provided",
      "System must have write permissions to configuration directories"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Installation": {
        "type": "object",
        "properties": {
          "language": {
            "type": "string",
            "description": "Preferred language for the forum"
          },
          "database": {
            "type": "string",
            "description": "Database type selection"
          },
          "dbHost": {
            "type": "string",
            "description": "Database server hostname"
          },
          "dbPort": {
            "type": "string",
            "description": "Database server port"
          },
          "dbUser": {
            "type": "string",
            "description": "Database username"
          },
          "dbName": {
            "type": "string",
            "description": "Database name"
          },
          "dbPassword": {
            "type": "string",
            "description": "Database password"
          },
          "dbEncoding": {
            "type": "string",
            "description": "Database character encoding"
          },
          "dbEncodingOther": {
            "type": "string",
            "description": "Alternative database encoding"
          },
          "usePool": {
            "type": "string",
            "description": "Whether to use connection pooling"
          },
          "forumLink": {
            "type": "string",
            "description": "URL for the forum"
          },
          "siteLink": {
            "type": "string",
            "description": "URL for the main site"
          },
          "adminPassword": {
            "type": "string",
            "description": "Administrator password"
          },
          "dbdatasource": {
            "type": "string",
            "description": "Database datasource name"
          },
          "db_connection_type": {
            "type": "string",
            "description": "Type of database connection"
          }
        }
      }
    }
  },
  {
    "featureName": "StoreSupportProjectMessage",
    "description": "Creates a support announcement topic in the forum with information about contributing to JForum.",
    "inputValues": [
      "connection-object-Connection"
    ],
    "businessLogic": "1. Input Collection\n   - Collect database connection object\n   - System will use predefined message content about supporting JForum\n   - System will use predefined user ID (2) for posting the announcement\n   - System will use predefined forum ID (1) for posting the announcement\n\n2. Data Validation\n   - Validate that the database connection is active and valid\n     - IF connection is null or closed THEN\n       - Generate error message indicating invalid connection\n       - Terminate process\n     - END IF\n   - Validate that the system can access required database entities\n     - IF unable to access forum tables THEN\n       - Generate error message indicating database access issue\n       - Terminate process\n     - END IF\n\n3. Business Rule Processing\n   - Prepare system environment for announcement creation\n     - Load authentication configuration\n     - Load data access implementation\n     - Load system queries\n     - Temporarily disable search indexing\n     - Set up execution context with provided connection\n   - Verify user permissions\n     - Ensure the system has sufficient privileges to create announcement\n     - IF permissions insufficient THEN\n       - Log permission error\n       - Terminate process\n     - END IF\n\n4. Core Operation Execution\n   - Create new announcement topic\n     - Set topic type as announcement\n     - Set topic title to \"Support JForum - Please read\"\n     - Set posting user ID to administrator (ID: 2)\n     - Set topic forum ID to main forum (ID: 1)\n     - Set posting timestamp to current date/time\n     - Save topic to database\n   - Create new post within the topic\n     - Set post subject to match topic title\n     - Set post timestamp to match topic timestamp\n     - Set user ID to administrator (ID: 2)\n     - Set post text to predefined support message content\n     - Set forum ID to match topic forum ID\n     - Enable smilies, HTML, and BBCode formatting\n     - Set user IP address\n     - Set topic ID to the newly created topic's ID\n     - Save post to database\n   - Update topic with post references\n     - Set topic's first post ID to the newly created post's ID\n     - Set topic's last post ID to the newly created post's ID\n     - Update topic in database\n   - Update forum statistics\n     - Increment total topics count for the forum\n     - Set forum's last post ID to the newly created post's ID\n\n5. Response Generation\n   - Restore system environment\n     - Re-enable search indexing\n     - Clear database connection from execution context\n   - Return operation status\n     - IF all operations completed successfully THEN\n       - Return success status\n     - ELSE\n       - Return error status with details of failure\n     - END IF",
    "databaseEntities": [
      "jforum_users",
      "jforum_topics",
      "jforum_posts",
      "jforum_posts_text",
      "jforum_forums"
    ],
    "validationRules": [
      "Database connection must be active and valid",
      "System must have access to required database entities",
      "User ID 2 must exist in the system",
      "Forum ID 1 must exist in the system"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Connection": {
        "type": "object",
        "description": "Database connection object used to interact with the forum database"
      }
    }
  },
  {
    "featureName": "ParseDatabaseDumpFile",
    "description": "Parses SQL dump files by reading and filtering statements, removing comments and empty lines.",
    "inputValues": [
      "filePath-string-File"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the file path (filePath-string) to the SQL dump file that needs to be parsed\n   - Verify the file path is not empty or null\n   - Ensure the file exists in the specified location\n\n2. Data Validation:\n   - Validate that the provided file path is not empty\n     * IF file path is empty or null THEN\n       * Generate an error message indicating a valid file path is required\n       * Abort processing and return error\n   - Validate that the file exists at the specified location\n     * IF file does not exist THEN\n       * Generate an error message indicating the file could not be found\n       * Abort processing and return error\n   - Validate that the file is readable\n     * IF file is not readable THEN\n       * Generate an error message indicating permission issues\n       * Abort processing and return error\n\n3. Business Rule Processing:\n   - Initialize an empty collection to store valid SQL statements\n   - Prepare file reading resources\n     * Create a file reader for the specified file path\n     * Create a buffered reader to efficiently read the file line by line\n\n4. Core Operation Execution:\n   - Read the file line by line\n     * WHILE there are more lines to read DO\n       * Read the next line from the file\n       * Trim whitespace from the beginning and end of the line\n       * IF line is empty THEN\n         * Skip to the next line\n       * Check the first character of the line\n         * IF first character is '-' or '#' (indicating a comment) THEN\n           * Skip to the next line\n       * Check if the line ends with a semicolon\n         * IF line ends with semicolon THEN\n           * Remove the semicolon from the end of the line\n       * Add the processed line to the collection of valid SQL statements\n     * END WHILE\n   - Close all file reading resources\n     * Ensure the buffered reader is properly closed\n     * Handle any exceptions that occur during file closing\n\n5. Response Generation:\n   - Return the collection of valid SQL statements\n   - IF any errors occurred during processing THEN\n     * Return appropriate error information\n     * Include details about the nature of the error (file not found, permission issues, etc.)\n   - IF processing completed successfully THEN\n     * Return the collection of valid SQL statements\n     * Include the count of statements processed",
    "databaseEntities": [],
    "validationRules": [
      "File path must not be empty",
      "File must exist at the specified location",
      "File must be readable",
      "Empty lines in the file must be skipped",
      "Lines starting with '-' or '#' (comments) must be skipped",
      "Semicolons at the end of statements must be removed"
    ],
    "dbSeedingOperations": [],
    "schema": {}
  },
  {
    "featureName": "ParseDatabaseStructureFile",
    "description": "Parses database structure files to extract SQL statements for database setup.",
    "inputValues": [
      "filename-string-File"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the database structure file path (filename) as a string\n   - The filename must point to an existing file containing SQL statements\n   - The file is expected to contain database creation statements\n\n2. Data Validation:\n   - Validate that the filename is not empty\n     * IF filename is empty or null THEN\n       - Return an error indicating a valid filename is required\n     * END IF\n   - Validate that the file exists and is readable\n     * IF file does not exist THEN\n       - Return an error indicating the file cannot be found\n     * END IF\n     * IF file is not readable THEN\n       - Return an error indicating permission issues\n     * END IF\n\n3. Business Rule Processing:\n   - Initialize an empty list to store extracted SQL statements\n   - Define recognized SQL command patterns that should be extracted:\n     * CREATE INDEX\n     * CREATE TABLE\n     * CREATE SEQUENCE\n     * DROP TABLE\n     * IF EXISTS\n     * DROP SEQUENCE\n     * DROP INDEX\n   - Set the statement delimiter character (typically semicolon)\n   - Verify the file format is compatible with the parser\n     * IF file format is incompatible THEN\n       - Return an error indicating format issues\n     * END IF\n\n4. Core Operation Execution:\n   - Open the specified file for reading\n   - Initialize a buffer to accumulate multi-line statements\n   - FOR each line in the file DO\n     * Skip empty lines\n     * Skip comment lines (starting with '-' or '#')\n     * IF currently processing a multi-line statement THEN\n       - Append the current line to the buffer\n       - IF line contains the delimiter character THEN\n         * Remove the delimiter from the buffer\n         * Add the complete statement to the result list\n         * Reset the processing flag\n       * END IF\n     * ELSE\n       - FOR each recognized SQL command pattern DO\n         * IF the current line contains this pattern THEN\n           - Clear the buffer\n           - IF line contains the delimiter character THEN\n             * Clean the line by removing the delimiter\n             * Add the statement to the result list\n           * ELSE\n             * Add the line to the buffer\n             * Set the processing flag to true\n           * END IF\n           - Break the pattern checking loop\n         * END IF\n       * END FOR\n     * END IF\n   * END FOR\n   - Close the file\n   - IF any error occurs during processing THEN\n     * Handle the exception appropriately\n     * Ensure file resources are properly released\n   * END IF\n\n5. Response Generation:\n   - Return the list of extracted SQL statements\n   - IF the extraction was successful THEN\n     * Return the complete list of valid SQL statements\n   * ELSE\n     * Return appropriate error information\n     * Include details about which part of the process failed\n   * END IF",
    "databaseEntities": [
      "jforum_users",
      "jforum_groups",
      "jforum_categories",
      "jforum_forums",
      "jforum_topics",
      "jforum_posts",
      "jforum_posts_text",
      "jforum_attachments",
      "jforum_privmsgs",
      "jforum_privmsgs_text",
      "jforum_moderator_groups",
      "jforum_user_groups",
      "jforum_sessions",
      "jforum_smilies",
      "jforum_words",
      "jforum_karma",
      "jforum_bookmarks",
      "jforum_quota_limit",
      "jforum_extension_groups"
    ],
    "validationRules": [
      "Filename must not be empty",
      "File must exist and be readable",
      "File must contain valid SQL statements",
      "SQL statements must follow expected format with proper delimiters",
      "Comments in the file must start with '-' or '#'"
    ],
    "dbSeedingOperations": [],
    "schema": {}
  },
  {
    "featureName": "ImportPhpbbToJforum",
    "description": "Migrates data from phpBB to JForum including users, posts, private messages, and forum structure.",
    "inputValues": [
      "baseDirectory-string-System",
      "sourceDatabase-object-PhpbbDatabase",
      "targetDatabase-object-JforumDatabase"
    ],
    "businessLogic": "1. Input Collection\n   - Collect base directory path for configuration files\n   - Obtain connection details for source phpBB database\n   - Obtain connection details for target JForum database\n   - Determine text formatting conversion rules\n\n2. Data Validation\n   - Verify base directory exists and contains required configuration files\n     - IF configuration files are missing THEN display error and exit\n   - Validate database connection parameters for both source and target\n     - IF connection parameters are invalid THEN display error and exit\n   - Verify source database contains valid phpBB data structure\n     - IF required phpBB tables are missing THEN display error and exit\n   - Check if target JForum database is properly initialized\n     - IF JForum tables are not properly set up THEN display error and exit\n\n3. Business Rule Processing\n   - Initialize system configuration from properties files\n   - Establish database connections to both source and target databases\n   - Prepare text conversion rules for formatting compatibility\n   - Verify sufficient disk space and memory for migration process\n   - Check user permissions for database operations\n\n4. Core Operation Execution\n   - Clean Target Tables\n     - Remove existing data from all target tables to prevent conflicts\n     - Preserve system configuration data if needed\n   - Import Users\n     - Retrieve all users from phpBB database\n     - Transform user data to match JForum structure\n     - Insert transformed user records into JForum database\n     - Preserve user credentials, profiles, and preferences\n   - Import Forum Structure\n     - Migrate categories hierarchy\n     - Migrate forums within categories\n     - Preserve forum settings and permissions\n   - Import Private Messages\n     - Retrieve private message data from phpBB\n     - Transform message content using text conversion rules\n     - Insert messages into JForum private messaging system\n     - Preserve sender/recipient relationships\n   - Import Posts and Topics\n     - Retrieve all posts and topics from phpBB\n     - Transform post content using text conversion rules\n     - Maintain topic-post relationships\n     - Preserve posting dates, edit information, and author details\n   - Setup Permissions\n     - Configure user group permissions\n     - Set administrator access rights\n     - Establish moderation capabilities\n     - Ensure proper access control for all imported content\n\n5. Response Generation\n   - Generate detailed migration statistics\n     - Number of users migrated\n     - Number of forums and categories migrated\n     - Number of topics and posts migrated\n     - Number of private messages migrated\n   - Report any errors or warnings encountered during migration\n   - Provide verification steps to confirm successful migration\n   - Display completion message with summary of migration results",
    "databaseEntities": [
      "jforum_users",
      "jforum_groups",
      "jforum_categories",
      "jforum_forums",
      "jforum_topics",
      "jforum_posts",
      "jforum_posts_text",
      "jforum_privmsgs",
      "jforum_privmsgs_text",
      "jforum_user_groups"
    ],
    "validationRules": [
      "Base directory must exist and contain required configuration files",
      "Database connection parameters must be valid for both source and target",
      "Source database must contain valid phpBB data structure",
      "Target database must be properly initialized with JForum schema",
      "User must have sufficient permissions to read from source and write to target databases",
      "System must have sufficient resources (memory and disk space) for migration"
    ],
    "dbSeedingOperations": [
      "Create anonymous user in JForum if not present",
      "Set up administrator group and permissions",
      "Configure default forum settings"
    ],
    "schema": {
      "PhpbbDatabase": {
        "type": "object",
        "properties": {
          "connectionString": {
            "type": "string",
            "description": "Database connection string for phpBB"
          },
          "tablePrefix": {
            "type": "string",
            "description": "Prefix used for phpBB database tables"
          }
        }
      },
      "JforumDatabase": {
        "type": "object",
        "properties": {
          "connectionString": {
            "type": "string",
            "description": "Database connection string for JForum"
          }
        }
      }
    }
  },
  {
    "featureName": "ImportPhpbbUsers",
    "description": "Imports user accounts from phpBB to JForum with all profile data and settings.",
    "inputValues": [
      "sourceDatabase-string-Database",
      "targetDatabase-string-Database",
      "tablePrefix-string-Configuration",
      "baseDirectory-string-FileSystem"
    ],
    "businessLogic": "1. Input Collection\n   - Collect source phpBB database connection details\n   - Collect target JForum database connection details\n   - Collect phpBB table prefix configuration\n   - Collect base directory path for configuration files\n   - All inputs are mandatory for the import process\n\n2. Data Validation\n   - Validate source database connection parameters\n     * Ensure database connection string is properly formatted\n     * Verify database credentials are valid\n     * Check if the source database contains required phpBB tables\n   - Validate target database connection parameters\n     * Ensure database connection string is properly formatted\n     * Verify database credentials are valid\n     * Check if the target database contains required JForum tables\n   - Validate table prefix\n     * Ensure the table prefix matches the phpBB installation\n   - Validate base directory path\n     * Verify the directory exists\n     * Check if required configuration files are present\n   - Display appropriate error messages for any validation failures\n\n3. Business Rule Processing\n   - Initialize system configuration\n     * Load global system settings\n     * Load database query templates\n     * Configure text conversion rules for formatting\n   - Verify system readiness\n     * Check if target system is prepared for data import\n     * Verify no conflicts exist in the target system\n   - Establish database connections\n     * Connect to source phpBB database\n     * Connect to target JForum database\n   - IF any connection fails THEN\n     * Display connection error message\n     * Abort the import process\n\n4. Core Operation Execution\n   - Clean target tables\n     * Remove existing data from all relevant JForum tables\n     * Reset any sequences or auto-increment counters\n   - Import user accounts\n     * Retrieve all users from phpBB database\n     * For EACH user record:\n       * Extract user profile information\n       * Convert user signature using text formatting rules\n       * Insert user record into JForum database\n   - Import forum structure\n     * Import categories\n     * Import forums\n     * Import topic information\n   - Import user content\n     * Import private messages\n       * Retrieve private message text\n       * Apply text formatting conversions\n       * Store in JForum format\n     * Import posts\n       * Calculate total post count\n       * Process posts in batches\n       * Convert post text formatting\n       * Store in JForum format\n   - Configure permissions\n     * Set up user groups\n     * Configure administrator permissions\n     * Set default user permissions\n   - IF any import operation fails THEN\n     * Log detailed error information\n     * Continue with next import operation when possible\n\n5. Response Generation\n   - Generate import summary\n     * Total number of users imported\n     * Total number of posts processed\n     * Total number of private messages imported\n     * List of any errors encountered\n   - Display completion status\n     * Show success message if import completed\n     * Show partial completion message if some operations failed\n     * Provide recommendations for post-import verification",
    "databaseEntities": [
      "jforum_users",
      "jforum_groups",
      "jforum_categories",
      "jforum_forums",
      "jforum_topics",
      "jforum_posts",
      "jforum_posts_text",
      "jforum_privmsgs",
      "jforum_privmsgs_text",
      "jforum_user_groups"
    ],
    "validationRules": [
      "Source database connection must be valid",
      "Target database connection must be valid",
      "Base directory must exist and contain required configuration files",
      "phpBB table prefix must match the actual prefix in the source database",
      "Target JForum database tables must exist",
      "User IDs must be preserved during migration",
      "Text formatting must be converted from phpBB to JForum format",
      "All user profile fields must be mapped correctly between systems"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "User": {
        "properties": {
          "user_id": {
            "type": "integer"
          },
          "username": {
            "type": "string"
          },
          "user_password": {
            "type": "string"
          },
          "user_email": {
            "type": "string"
          },
          "user_regdate": {
            "type": "string"
          },
          "user_level": {
            "type": "string"
          },
          "user_posts": {
            "type": "string"
          },
          "user_timezone": {
            "type": "string"
          },
          "user_avatar": {
            "type": "string"
          },
          "user_sig": {
            "type": "string"
          },
          "user_website": {
            "type": "string"
          }
        }
      },
      "Database": {
        "properties": {
          "connectionString": {
            "type": "string"
          },
          "username": {
            "type": "string"
          },
          "password": {
            "type": "string"
          },
          "driver": {
            "type": "string"
          }
        }
      },
      "Configuration": {
        "properties": {
          "value": {
            "type": "string"
          }
        }
      },
      "FileSystem": {
        "properties": {
          "path": {
            "type": "string"
          }
        }
      }
    }
  },
  {
    "featureName": "ImportPosts",
    "description": "Transfers forum posts from phpBB to JForum with text formatting conversion.",
    "inputValues": [
      "baseDirectory-string-Configuration",
      "sourceDatabase-object-DatabaseConnection",
      "targetDatabase-object-DatabaseConnection",
      "formattingRules-object-TextFormatting"
    ],
    "businessLogic": "1. Input Collection\n   - Collect the base directory path for configuration files\n   - Obtain connection details for source phpBB database\n   - Obtain connection details for target JForum database\n   - Gather text formatting conversion rules\n\n2. Data Validation\n   - Validate base directory exists and contains required configuration files\n     - IF base directory is invalid THEN display error message and halt process\n   - Verify source database connection parameters\n     - IF source database connection fails THEN display connection error and halt process\n   - Verify target database connection parameters\n     - IF target database connection fails THEN display connection error and halt process\n   - Validate text formatting conversion rules are properly defined\n     - IF formatting rules are incomplete THEN use default conversion settings\n\n3. Business Rule Processing\n   - Initialize system configuration from properties files\n     - Load global system settings\n     - Load database query definitions\n   - Verify target database tables are ready for import\n     - Check table structure compatibility\n     - Ensure proper character encoding support for text conversion\n   - Calculate total number of posts to be imported\n     - IF total posts count is zero THEN notify user and skip post import process\n\n4. Core Operation Execution\n   - Clean target database tables to prepare for import\n     - Remove existing data from all relevant tables\n   - Import user accounts\n     - Transfer user profiles, credentials, and preferences\n     - Preserve user relationships and permissions\n   - Import forum structure\n     - Transfer categories, forums, and topic definitions\n     - Maintain hierarchical relationships\n   - Import private messages\n     - Transfer message content with text formatting conversion\n     - Preserve sender/recipient relationships\n   - Import forum posts\n     - Process posts in batches to optimize memory usage\n     - Apply text formatting conversion rules to post content\n     - Convert BBCode tags to JForum compatible format\n     - Preserve post relationships (topics, replies, etc.)\n     - Display progress indicators during lengthy import process\n   - Set up permissions\n     - Configure user group permissions\n     - Set administrative access rights\n\n5. Response Generation\n   - Generate summary of import operation\n     - Total number of users imported\n     - Total number of forums and categories imported\n     - Total number of topics imported\n     - Total number of posts imported\n     - Total number of private messages imported\n   - Report any errors or warnings encountered during import\n     - List any posts that couldn't be properly converted\n     - Identify any missing relationships or data integrity issues\n   - Provide next steps for post-import verification\n     - Instructions for validating the imported data\n     - Guidance for any manual adjustments needed",
    "databaseEntities": [
      "jforum_users",
      "jforum_groups",
      "jforum_categories",
      "jforum_forums",
      "jforum_topics",
      "jforum_posts",
      "jforum_posts_text",
      "jforum_privmsgs",
      "jforum_privmsgs_text",
      "jforum_user_groups"
    ],
    "validationRules": [
      "Base directory must contain valid configuration files",
      "Source database connection must be valid",
      "Target database connection must be valid",
      "Text formatting rules must be properly defined",
      "User IDs must be preserved during import",
      "Post relationships must maintain referential integrity",
      "Text formatting must be converted according to defined rules",
      "All posts must be associated with valid topics",
      "All topics must be associated with valid forums",
      "User permissions must be properly configured after import"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "DatabaseConnection": {
        "type": "object",
        "properties": {
          "driverClass": {
            "type": "string",
            "description": "Database driver class name"
          },
          "connectionUrl": {
            "type": "string",
            "description": "Database connection URL"
          },
          "username": {
            "type": "string",
            "description": "Database username"
          },
          "password": {
            "type": "string",
            "description": "Database password"
          }
        },
        "required": [
          "driverClass",
          "connectionUrl"
        ]
      },
      "TextFormatting": {
        "type": "object",
        "properties": {
          "conversionRules": {
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "sourcePattern": {
                  "type": "string",
                  "description": "Regular expression pattern to match"
                },
                "targetReplacement": {
                  "type": "string",
                  "description": "Replacement pattern"
                }
              },
              "required": [
                "sourcePattern",
                "targetReplacement"
              ]
            }
          }
        },
        "required": [
          "conversionRules"
        ]
      }
    }
  },
  {
    "featureName": "ImportPrivateMessages",
    "description": "Migrates private messages between users from phpBB to JForum.",
    "inputValues": [
      "sourceDatabase-object-PhpBBDatabase",
      "targetDatabase-object-JForumDatabase",
      "configurationSettings-object-MigrationConfig"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect source database connection details (required)\n   - Collect target database connection details (required)\n   - Collect configuration settings (required)\n     - Table prefix for source database (required)\n     - Text formatting rules for message conversion (required)\n     - Batch size for processing messages (optional, default: 50)\n\n2. Data Validation:\n   - Validate source database connection\n     - Check if connection can be established\n     - Verify required tables exist in source database\n     - IF connection fails or tables missing, THEN display error and exit\n   - Validate target database connection\n     - Check if connection can be established\n     - Verify required tables exist in target database\n     - IF connection fails or tables missing, THEN display error and exit\n   - Validate configuration settings\n     - Ensure table prefix is valid\n     - Verify text formatting rules are properly defined\n     - IF configuration is invalid, THEN display error and exit\n\n3. Business Rule Processing:\n   - Check system state\n     - Verify target database is prepared for import\n     - Ensure no conflicts exist with existing message IDs\n   - Verify dependencies\n     - Confirm user accounts have been migrated first\n     - Ensure user IDs match between systems\n     - IF user migration is incomplete, THEN display warning and confirm continuation\n   - Prepare text conversion rules\n     - Load formatting patterns for BBCode conversion\n     - Initialize text processing engine\n\n4. Core Operation Execution:\n   - Initialize progress tracking\n     - Count total private messages to be migrated\n     - Set up progress reporting mechanism\n   - Process private message records\n     - Retrieve messages from source database in batches\n     - FOR EACH message:\n       - Extract message ID, sender ID, recipient ID, and metadata\n       - Convert message text using formatting rules\n       - Map sender and recipient IDs to target system\n       - Insert message header into target message table\n       - Insert converted message content into message text table\n       - Update progress indicator\n     - END FOR\n   - Verify message integrity\n     - Count messages in target system\n     - Compare with source count\n     - IF counts don't match, THEN log discrepancy\n   - Update user message counters\n     - FOR EACH user with messages:\n       - Count new and unread messages\n       - Update user record with message counts\n     - END FOR\n\n5. Response Generation:\n   - Generate migration summary\n     - Total messages processed\n     - Success count\n     - Failure count with reasons\n     - Processing time\n   - Provide next steps\n     - Suggest verification process\n     - Recommend user notification about migrated messages\n   - Return completion status\n     - Success or failure indication\n     - Detailed log reference for troubleshooting if needed",
    "databaseEntities": [
      "jforum_users",
      "jforum_privmsgs",
      "jforum_privmsgs_text"
    ],
    "validationRules": [
      "Source database must be accessible and contain valid phpBB tables",
      "Target database must be accessible and contain valid JForum tables",
      "User accounts must be migrated before private messages",
      "Message text must be properly converted from phpBB format to JForum format",
      "All message relationships between users must be preserved",
      "Message read/unread status must be maintained",
      "User message counters must be updated after migration"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "PhpBBDatabase": {
        "type": "object",
        "properties": {
          "connectionString": {
            "type": "string",
            "description": "Database connection string for phpBB database"
          },
          "tablePrefix": {
            "type": "string",
            "description": "Prefix used for phpBB tables"
          },
          "credentials": {
            "type": "object",
            "properties": {
              "username": {
                "type": "string"
              },
              "password": {
                "type": "string"
              }
            }
          }
        }
      },
      "JForumDatabase": {
        "type": "object",
        "properties": {
          "connectionString": {
            "type": "string",
            "description": "Database connection string for JForum database"
          },
          "credentials": {
            "type": "object",
            "properties": {
              "username": {
                "type": "string"
              },
              "password": {
                "type": "string"
              }
            }
          }
        }
      },
      "MigrationConfig": {
        "type": "object",
        "properties": {
          "batchSize": {
            "type": "number",
            "description": "Number of messages to process in each batch"
          },
          "textFormatRules": {
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "pattern": {
                  "type": "string"
                },
                "replacement": {
                  "type": "string"
                }
              }
            }
          }
        }
      }
    }
  },
  {
    "featureName": "ImportForumStructure",
    "description": "Transfers categories, forums, topics and related forum structure data.",
    "inputValues": [
      "baseDirectory-string-SystemConfig",
      "sourceConnection-object-DatabaseConnection",
      "targetConnection-object-DatabaseConnection",
      "importOptions-object-ImportOptions"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect baseDirectory (string): Path to the base directory containing configuration files\n   - Collect sourceConnection (object): Connection details for the source forum database\n   - Collect targetConnection (object): Connection details for the target forum database\n   - Collect importOptions (object): Configuration options for the import process\n     - Include options for selecting which elements to import (users, posts, messages, etc.)\n     - Include formatting options for text conversion\n\n2. Data Validation:\n   - Validate baseDirectory:\n     - Check if the directory exists\n     - Verify required configuration files are present\n     - IF validation fails, THEN display appropriate error message and exit\n   - Validate source connection:\n     - Test connection to source database\n     - Verify required tables exist in source database\n     - IF connection fails, THEN display connection error and exit\n   - Validate target connection:\n     - Test connection to target database\n     - Verify required tables exist in target database\n     - IF connection fails, THEN display connection error and exit\n   - Validate import options:\n     - Check that selected import options are valid\n     - Verify any custom formatting rules are properly formatted\n     - IF validation fails, THEN display appropriate error message and exit\n\n3. Business Rule Processing:\n   - Check system resources:\n     - Verify sufficient memory for the operation\n     - Estimate required disk space for the import\n     - IF resources insufficient, THEN warn user and confirm continuation\n   - Check target database state:\n     - Verify if target database already contains data\n     - IF data exists, THEN prompt for confirmation to clean/overwrite\n     - Check for data integrity constraints that might affect import\n   - Prepare text conversion rules:\n     - Load text formatting conversion rules\n     - Compile regular expressions for text transformations\n     - Validate all conversion patterns are valid\n\n4. Core Operation Execution:\n   - Initialize system:\n     - Load configuration settings\n     - Establish database connections\n     - Prepare statement templates\n   - Clean target tables:\n     - Remove existing data from all target tables\n     - Reset auto-increment counters if applicable\n     - Log cleaning operations\n   - Import user data:\n     - Transfer user profiles and credentials\n     - Maintain user IDs where possible\n     - Convert user signatures using text conversion rules\n     - Log progress of user import\n   - Import forum structure:\n     - Transfer categories maintaining hierarchy\n     - Transfer forums with proper category associations\n     - Transfer forum permissions and settings\n     - Log progress of structure import\n   - Import topics and posts:\n     - Count total posts to provide progress updates\n     - Transfer topics with metadata\n     - Transfer posts with proper topic associations\n     - Convert post text using text conversion rules\n     - Log progress at regular intervals\n   - Import private messages:\n     - Transfer message headers and metadata\n     - Convert message text using text conversion rules\n     - Maintain sender/recipient relationships\n     - Log progress of message import\n   - Import supplementary data:\n     - Transfer user groups and memberships\n     - Transfer moderation assignments\n     - Transfer ban lists and restrictions\n     - Transfer voting and poll data\n     - Log completion of each supplementary data type\n   - Setup permissions:\n     - Configure default permission groups\n     - Assign users to appropriate groups\n     - Set administrative permissions\n     - Verify permission integrity\n\n5. Response Generation:\n   - Generate import summary:\n     - Total number of users imported\n     - Total number of categories and forums imported\n     - Total number of topics and posts imported\n     - Total number of private messages imported\n     - List of any items that failed to import\n   - Generate warnings:\n     - Identify any data inconsistencies found\n     - List any formatting issues encountered\n     - Highlight permissions that may need manual review\n   - Provide next steps:\n     - Suggest verification procedures\n     - Recommend backup of the newly imported data\n     - Suggest manual review of administrative settings",
    "databaseEntities": [
      "jforum_users",
      "jforum_groups",
      "jforum_categories",
      "jforum_forums",
      "jforum_topics",
      "jforum_posts",
      "jforum_posts_text",
      "jforum_privmsgs",
      "jforum_privmsgs_text",
      "jforum_user_groups",
      "jforum_moderator_groups",
      "jforum_smilies",
      "jforum_words"
    ],
    "validationRules": [
      "Base directory must exist and contain required configuration files",
      "Source database connection must be valid and accessible",
      "Target database connection must be valid and accessible",
      "Source database must contain required forum structure tables",
      "Target database tables must be compatible with the import structure",
      "Text conversion rules must be properly formatted",
      "User IDs must be preserved during import to maintain relationships",
      "Post text must be converted according to formatting rules",
      "Category and forum hierarchies must be maintained",
      "Topic and post relationships must be preserved",
      "User group assignments must be correctly transferred",
      "Administrative permissions must be properly configured after import"
    ],
    "dbSeedingOperations": [
      "Create default administrative user group",
      "Assign administrative roles to appropriate users",
      "Set up anonymous user account",
      "Configure default permission settings"
    ],
    "schema": {
      "DatabaseConnection": {
        "type": "object",
        "properties": {
          "driverClass": {
            "type": "string",
            "description": "Database driver class name"
          },
          "url": {
            "type": "string",
            "description": "Database connection URL"
          },
          "username": {
            "type": "string",
            "description": "Database username"
          },
          "password": {
            "type": "string",
            "description": "Database password"
          },
          "tablePrefix": {
            "type": "string",
            "description": "Prefix used for database tables"
          }
        },
        "required": [
          "driverClass",
          "url",
          "username",
          "password"
        ]
      },
      "ImportOptions": {
        "type": "object",
        "properties": {
          "importUsers": {
            "type": "boolean",
            "description": "Whether to import user data"
          },
          "importCategories": {
            "type": "boolean",
            "description": "Whether to import categories"
          },
          "importForums": {
            "type": "boolean",
            "description": "Whether to import forums"
          },
          "importTopics": {
            "type": "boolean",
            "description": "Whether to import topics"
          },
          "importPosts": {
            "type": "boolean",
            "description": "Whether to import posts"
          },
          "importPrivateMessages": {
            "type": "boolean",
            "description": "Whether to import private messages"
          },
          "cleanTargetTables": {
            "type": "boolean",
            "description": "Whether to clean target tables before import"
          },
          "textConversionRules": {
            "type": "array",
            "description": "Rules for converting text formatting",
            "items": {
              "type": "object",
              "properties": {
                "pattern": {
                  "type": "string",
                  "description": "Regular expression pattern to match"
                },
                "replacement": {
                  "type": "string",
                  "description": "Replacement text"
                }
              }
            }
          }
        }
      }
    }
  },
  {
    "featureName": "SetupPermissions",
    "description": "Configures user permissions and group relationships in the JForum system.",
    "inputValues": [
      "groupId-number-Group",
      "adminUsers-object-AdminUsers"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect groupId (mandatory): The identifier of the admin group\n   - Collect adminUsers (mandatory): List of users to be assigned admin permissions\n   - System will use existing database connection\n\n2. Data Validation:\n   - Validate groupId:\n      * Verify groupId is a positive integer\n      * Check if groupId exists in the groups table\n      * If validation fails, generate appropriate error message\n   - Validate adminUsers:\n      * Verify adminUsers list is not empty\n      * Verify each user ID in the list is valid\n      * Check if all users exist in the users table\n      * If validation fails, generate appropriate error message\n   - Validate system state:\n      * Verify database connection is active\n      * If connection is not available, generate connection error\n\n3. Business Rule Processing:\n   - Check if admin group exists:\n      * Query the groups table to find the admin group\n      * If admin group doesn't exist, create it with appropriate permissions\n   - Check if admin role exists:\n      * Query the roles table to find the admin role\n      * If admin role doesn't exist, create it with appropriate permissions\n   - Verify user-group relationships:\n      * Check if users are already assigned to admin group\n      * Identify which users need new group assignments\n\n4. Core Operation Execution:\n   - Retrieve maximum group ID:\n      * Query the database to get the highest existing group ID\n      * Store this value for reference\n   - Assign admin users to admin group:\n      * For each admin user:\n         > Create user-group relationship record\n         > Link user ID with admin group ID\n         > Set appropriate permission flags\n   - Update permission settings:\n      * Set forum access permissions for admin group\n      * Set moderation permissions for admin group\n      * Set system administration permissions for admin group\n   - If any operation fails:\n      * Roll back all changes made in this transaction\n      * Log the specific failure point and reason\n\n5. Response Generation:\n   - On success:\n      * Generate confirmation message with number of users assigned\n      * Include summary of permissions configured\n      * Return success status code\n   - On failure:\n      * Generate detailed error message\n      * Include specific validation or processing failure\n      * Provide guidance for resolving the issue\n      * Return appropriate error status code",
    "databaseEntities": [
      "jforum_users",
      "jforum_groups",
      "jforum_user_groups"
    ],
    "validationRules": [
      "Group ID must be a positive integer",
      "Admin group must exist in the system",
      "Admin users list must not be empty",
      "All admin users must exist in the users table",
      "Database connection must be active",
      "Each user can only be assigned to the admin group once"
    ],
    "dbSeedingOperations": [
      "Create admin group if it doesn't exist",
      "Create admin role if it doesn't exist"
    ],
    "schema": {
      "AdminUsers": {
        "type": "object",
        "properties": {
          "userIds": {
            "type": "array",
            "items": {
              "type": "number",
              "description": "User ID to be assigned admin permissions"
            }
          }
        },
        "required": [
          "userIds"
        ]
      }
    }
  },
  {
    "featureName": "CleanTables",
    "description": "Prepares JForum database by cleaning target tables before migration.",
    "inputValues": [
      "databaseConnection-object-Connection",
      "tableNames-object-TableList"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect database connection information\n     1.1. Verify database connection is active\n     1.2. Confirm user has proper database permissions\n   - Identify target tables for cleaning\n     1.3. Determine which tables need to be cleaned\n     1.4. Verify tables exist in the database\n\n2. Data Validation:\n   - Validate database connection\n     2.1. Check if connection is valid and open\n     2.2. Verify connection has write permissions\n     2.3. IF connection is invalid or closed, THEN generate connection error\n   - Validate table list\n     2.4. Verify each table in the list exists in the database\n     2.5. Check if tables are accessible with current permissions\n     2.6. IF any table doesn't exist, THEN generate table not found error\n     2.7. IF tables are not accessible, THEN generate access denied error\n\n3. Business Rule Processing:\n   - Verify system state for cleaning operation\n     3.1. Check if system is in maintenance mode\n     3.2. Verify no active user sessions are present\n     3.3. IF system is not in maintenance mode, THEN warn about potential user impact\n   - Validate dependencies between tables\n     3.4. Identify tables with foreign key relationships\n     3.5. Determine proper cleaning order based on dependencies\n     3.6. IF dependencies exist, THEN establish proper cleaning sequence\n\n4. Core Operation Execution:\n   - Prepare cleaning statements\n     4.1. Generate cleaning statements for each table\n     4.2. Order statements based on dependency requirements\n   - Execute table cleaning\n     4.3. Begin transaction if supported\n     4.4. FOR EACH table in the cleaning sequence:\n        4.4.1. Execute cleaning statement\n        4.4.2. Log cleaning operation\n        4.4.3. IF cleaning fails, THEN record error and continue\n     4.5. Commit transaction if all operations successful\n     4.6. IF any operation fails, THEN rollback transaction if possible\n   - Verify cleaning results\n     4.7. Check that tables are empty\n     4.8. Record any tables that failed to clean properly\n\n5. Response Generation:\n   - Generate cleaning operation summary\n     5.1. Count total tables processed\n     5.2. List successfully cleaned tables\n     5.3. List tables with cleaning errors\n   - Provide next steps information\n     5.4. Indicate system is ready for data migration\n     5.5. Suggest verification steps if needed\n     5.6. IF any errors occurred, THEN provide troubleshooting guidance",
    "databaseEntities": [
      "jforum_users",
      "jforum_groups",
      "jforum_categories",
      "jforum_forums",
      "jforum_topics",
      "jforum_posts",
      "jforum_posts_text",
      "jforum_privmsgs",
      "jforum_privmsgs_text",
      "jforum_user_groups",
      "jforum_banlist",
      "jforum_ranks",
      "jforum_smilies",
      "jforum_topics_watch",
      "jforum_vote_desc",
      "jforum_vote_results",
      "jforum_vote_voters"
    ],
    "validationRules": [
      "Database connection must be valid and active",
      "User must have DELETE permissions on target tables",
      "All specified tables must exist in the database",
      "System should be in maintenance mode during cleaning",
      "Tables must be cleaned in proper dependency order",
      "Transaction must be used when supported by database"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Connection": {
        "type": "object",
        "properties": {
          "url": {
            "type": "string",
            "description": "Database connection URL"
          },
          "credentials": {
            "type": "object",
            "properties": {
              "username": {
                "type": "string"
              },
              "password": {
                "type": "string"
              }
            }
          }
        }
      },
      "TableList": {
        "type": "object",
        "properties": {
          "tables": {
            "type": "array",
            "items": {
              "type": "string",
              "description": "Name of table to be cleaned"
            }
          },
          "cleaningOrder": {
            "type": "array",
            "items": {
              "type": "string",
              "description": "Table names in dependency order"
            }
          }
        }
      }
    }
  },
  {
    "featureName": "FormatPostContent",
    "description": "Converts phpBB formatting codes to JForum compatible markup using regex patterns.",
    "inputValues": [
      "postText-string-Post",
      "regexPatterns-object-RegexPatternSet"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect postText (string): The original text with phpBB formatting\n   - Collect regexPatterns (object): Set of regex patterns and replacements\n     - Each pattern consists of a search regex and a replacement string\n     - Patterns are organized in pairs for different formatting elements (bold, italic, etc.)\n\n2. Data Validation:\n   - Validate postText:\n     - IF postText is null THEN\n       - Set postText to empty string\n     - ENDIF\n   - Validate regexPatterns:\n     - Ensure regexPatterns contains valid pattern pairs\n     - Each pair must have a search pattern and replacement pattern\n     - IF regexPatterns is empty or invalid THEN\n       - Return original postText without modifications\n     - ENDIF\n\n3. Business Rule Processing:\n   - Check system configuration for additional formatting rules\n   - Determine if any special formatting should be preserved\n   - Identify any formatting codes that should be ignored\n\n4. Core Operation Execution:\n   - Initialize formattedText variable with the original postText\n   - FOR EACH pattern pair in regexPatterns:\n     - Extract search pattern from the pair\n     - Extract replacement pattern from the pair\n     - Apply regex replacement to formattedText:\n       - Replace all occurrences of search pattern with replacement pattern\n     - Update formattedText with the result\n   - END FOR\n   - Process special formatting cases:\n     - Handle nested formatting tags\n     - Process quote blocks with usernames\n     - Format code blocks with proper syntax\n     - Process list items and bullet points\n     - Handle image tags and links\n     - Process text size and color attributes\n\n5. Response Generation:\n   - Return the fully formatted text with all phpBB codes converted to JForum format\n   - IF any formatting errors occurred THEN\n     - Log the specific formatting issues\n     - Return best-effort formatted text\n   - ENDIF",
    "databaseEntities": [
      "jforum_posts_text",
      "jforum_privmsgs_text",
      "jforum_users"
    ],
    "validationRules": [
      "Post text must be properly processed even if null or empty",
      "All phpBB formatting codes must be correctly converted to JForum format",
      "Nested formatting tags must be properly handled",
      "User signatures must maintain proper formatting after conversion",
      "Private message text must maintain proper formatting after conversion"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "RegexPatternSet": {
        "type": "object",
        "properties": {
          "patterns": {
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "searchPattern": {
                  "type": "string",
                  "description": "Regular expression pattern to search for"
                },
                "replacementPattern": {
                  "type": "string",
                  "description": "String to replace matched content with"
                }
              },
              "required": [
                "searchPattern",
                "replacementPattern"
              ]
            }
          }
        },
        "required": [
          "patterns"
        ]
      }
    }
  },
  {
    "featureName": "MigratePHPBBToJForum",
    "description": "Migrates data from PHPBB forum system to JForum database with automatic connection management.",
    "inputValues": [
      "baseDirectory-string-Configuration"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the base directory path as a string input\n   - This input is mandatory and must be provided by the user\n   - No default values are provided\n\n2. Data Validation:\n   - Validate base directory input:\n     a. Check if the base directory path is provided\n     b. IF base directory path is not provided THEN\n        i. Display usage instructions to the user\n        ii. Terminate the migration process\n     c. Check if the base directory exists and is accessible\n     d. IF base directory is not accessible THEN\n        i. Display error message indicating the directory cannot be accessed\n        ii. Terminate the migration process\n\n3. Business Rule Processing:\n   - Initialize the migration environment:\n     a. Set up configuration based on the provided base directory\n     b. Verify database connection parameters are available\n     c. Check if source PHPBB database is accessible\n     d. Check if target JForum database is accessible\n     e. IF any connection verification fails THEN\n        i. Display specific error message about connection issue\n        ii. Terminate the migration process\n\n4. Core Operation Execution:\n   - Establish database connections:\n     a. Open primary connection to databases with auto-commit enabled\n     b. Open secondary connection to databases with auto-commit enabled\n     c. IF connections cannot be established THEN\n        i. Display error message about connection failure\n        ii. Terminate the migration process\n   - Record start time for performance measurement\n   - Execute migration process:\n     a. Migrate user accounts from PHPBB to JForum\n     b. Migrate user groups and permissions\n     c. Migrate categories and forums structure\n     d. Migrate topics and their metadata\n     e. Migrate posts and their content\n     f. Migrate private messages\n     g. Migrate attachments if applicable\n     h. Migrate additional data (bookmarks, karma, etc.)\n     i. FOR each migration step:\n        i. Read data from source PHPBB tables\n        ii. Transform data to match JForum structure\n        iii. Write transformed data to JForum tables\n        iv. Log progress of current step\n     j. IF any migration step fails THEN\n        i. Log specific error information\n        ii. Continue with next migration step\n   - Record end time and calculate total migration duration\n\n5. Response Generation:\n   - Generate migration summary:\n     a. Display completion message to user\n     b. Show total migration time in seconds\n     c. List any warnings or non-critical errors encountered\n   - Clean up resources:\n     a. Close all database connections\n     b. Release any temporary resources used during migration\n   - IF migration completed successfully THEN\n     a. Display success message with next steps for JForum setup\n   - ELSE\n     a. Display partial completion message with troubleshooting guidance",
    "databaseEntities": [
      "jforum_users",
      "jforum_groups",
      "jforum_categories",
      "jforum_forums",
      "jforum_topics",
      "jforum_posts",
      "jforum_posts_text",
      "jforum_attachments",
      "jforum_privmsgs",
      "jforum_privmsgs_text",
      "jforum_moderator_groups",
      "jforum_user_groups",
      "jforum_sessions",
      "jforum_smilies",
      "jforum_words",
      "jforum_karma",
      "jforum_bookmarks",
      "jforum_quota_limit",
      "jforum_extension_groups"
    ],
    "validationRules": [
      "Base directory path must not be empty",
      "Base directory must exist and be accessible",
      "Configuration files must be present in the base directory",
      "Database connection parameters must be valid",
      "Source PHPBB database must be accessible",
      "Target JForum database must be accessible",
      "User must have appropriate database permissions for reading and writing"
    ],
    "dbSeedingOperations": [],
    "schema": {}
  },
  {
    "featureName": "LoadEnvironment",
    "description": "Initializes the system environment by loading configuration files and setting up global settings.",
    "inputValues": [
      "configPath-string-ConfigurationPath",
      "rootDirectory-string-DirectoryPath"
    ],
    "businessLogic": "1. Input Collection:\n   - rootDirectory: mandatory string representing the base directory path\n   - configPath: mandatory string representing the path to configuration files\n   - applicationPath: system-generated based on rootDirectory\n   - installationConfigPath: system-generated based on configuration settings\n\n2. Data Validation:\n   - Validate rootDirectory:\n     * Check if directory exists\n     * Verify read permissions are available\n     * IF directory does not exist or is not readable THEN\n       > Generate error message: \"Invalid root directory path\"\n       > Terminate process\n   - Validate configPath:\n     * Check if configuration file exists at the specified path\n     * Verify file is readable\n     * IF configuration file does not exist or is not readable THEN\n       > Generate error message: \"Configuration file not found or not accessible\"\n       > Terminate process\n\n3. Business Rule Processing:\n   - Determine application root directory:\n     * IF rootDirectory is not explicitly provided THEN\n       > Detect current execution context location\n       > Calculate root directory based on execution context\n     * Set application path based on root directory\n   - Check for installation configuration:\n     * Determine path to installation configuration file\n     * Check if installation configuration file exists\n     * IF installation configuration exists THEN\n       > Mark system as installed\n     * ELSE\n       > Mark system as not fully installed\n\n4. Core Operation Execution:\n   - Initialize global system settings:\n     * Load default configuration from primary configuration file\n     * Set base application paths in the system\n     * IF installation configuration exists THEN\n       > Load additional settings from installation configuration\n       > Override default settings with installation-specific values\n   - Configure template engine:\n     * Create template engine configuration\n     * Set template directory path based on application path\n     * Set template update parameters\n     * Register template configuration with execution context\n   - Load internationalization resources:\n     * Identify available language files\n     * Load default language resources\n     * IF custom language is specified in configuration THEN\n       > Load custom language resources\n   - Initialize system components:\n     * Set up logging framework\n     * Initialize cache mechanisms\n     * Prepare execution context\n\n5. Response Generation:\n   - Success response:\n     * Return initialization status indicator\n     * Provide summary of loaded configuration files\n     * Include information about system readiness\n   - Error response:\n     * Detailed error message indicating failure point\n     * Suggested troubleshooting steps\n     * System state information for diagnosis",
    "databaseEntities": [],
    "validationRules": [
      "Root directory must exist and be accessible",
      "Configuration file must exist and be readable",
      "Template directory must exist within application path",
      "Required configuration keys must be present in configuration files",
      "Installation configuration file must be checked for existence"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "ConfigurationPath": {
        "type": "string",
        "description": "Path to the system configuration file"
      },
      "DirectoryPath": {
        "type": "string",
        "description": "Path to a directory in the file system"
      }
    }
  },
  {
    "featureName": "InitDatabaseImplementation",
    "description": "Sets up database connectivity by loading drivers, queries, and initializing the data access layer.",
    "inputValues": [
      "configPath-string-SystemConfiguration",
      "databaseDriverConfig-string-DatabaseConfig"
    ],
    "businessLogic": "1. Input Collection:\n   - configPath: Path to the system configuration file (mandatory)\n   - databaseDriverConfig: Database driver configuration identifier (mandatory)\n   - systemGlobals: System configuration object (system-generated)\n\n2. Data Validation:\n   - Validate configPath:\n     2.1. Check if configPath is not empty\n     2.2. Verify the configuration file exists at the specified path\n     2.3. IF file does not exist, THEN generate error: \"Configuration file not found\"\n   - Validate databaseDriverConfig:\n     2.4. Check if databaseDriverConfig is not empty\n     2.5. Verify the driver configuration identifier is valid\n     2.6. IF identifier is invalid, THEN generate error: \"Invalid database driver configuration\"\n\n3. Business Rule Processing:\n   - Verify system initialization status:\n     3.1. Check if the system has been partially initialized\n     3.2. IF already fully initialized, THEN generate warning: \"Database already initialized\"\n   - Check database configuration availability:\n     3.3. Verify that all required database configuration parameters are available\n     3.4. IF any required parameter is missing, THEN generate error: \"Incomplete database configuration\"\n\n4. Core Operation Execution:\n   - Load database driver configuration:\n     4.1. Load additional configuration defaults from the database driver configuration file\n     4.2. IF loading fails, THEN generate error: \"Failed to load database driver configuration\"\n   - Load SQL queries:\n     4.3. Load generic SQL queries from the configured path\n     4.4. Load driver-specific SQL queries from the configured path\n     4.5. IF loading of any query file fails, THEN generate error: \"Failed to load SQL queries\"\n   - Initialize data access driver:\n     4.6. Get the configured data access driver class name\n     4.7. Load the driver class\n     4.8. Create a new instance of the driver\n     4.9. Initialize the data access layer with the driver instance\n     4.10. IF any step fails, THEN generate error: \"Failed to initialize data access driver\"\n   - Establish database connection:\n     4.11. Create database connection instance\n     4.12. Initialize the database connection\n     4.13. Verify connection is established successfully\n     4.14. IF connection fails, THEN generate error: \"Failed to establish database connection\"\n\n5. Response Generation:\n   - Success response:\n     5.1. Generate success message with connection details\n     5.2. Include database type and version information\n     5.3. Include driver information\n   - Error response:\n     5.4. Include detailed error message\n     5.5. Provide troubleshooting suggestions based on error type\n     5.6. Include support contact information",
    "databaseEntities": [
      "jforum_users",
      "jforum_groups",
      "jforum_categories",
      "jforum_forums",
      "jforum_topics",
      "jforum_posts",
      "jforum_posts_text",
      "jforum_attachments",
      "jforum_privmsgs",
      "jforum_privmsgs_text",
      "jforum_moderator_groups",
      "jforum_user_groups",
      "jforum_sessions",
      "jforum_smilies",
      "jforum_words",
      "jforum_karma",
      "jforum_bookmarks",
      "jforum_quota_limit",
      "jforum_extension_groups"
    ],
    "validationRules": [
      "Configuration file path must not be empty",
      "Configuration file must exist at the specified path",
      "Database driver configuration identifier must not be empty",
      "Database driver configuration must be valid",
      "Required database configuration parameters must be available",
      "SQL query files must be accessible",
      "Data access driver class must be loadable",
      "Database connection must be established successfully"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "SystemConfiguration": {
        "type": "object",
        "properties": {
          "configPath": {
            "type": "string",
            "description": "Path to the system configuration file"
          },
          "applicationPath": {
            "type": "string",
            "description": "Path to the application root directory"
          }
        }
      },
      "DatabaseConfig": {
        "type": "object",
        "properties": {
          "driverClass": {
            "type": "string",
            "description": "Database driver class name"
          },
          "connectionUrl": {
            "type": "string",
            "description": "Database connection URL"
          },
          "queryFilePath": {
            "type": "string",
            "description": "Path to SQL query files"
          }
        }
      }
    }
  },
  {
    "featureName": "GetRootDir",
    "description": "Retrieves the application's root directory path for configuration and resource loading.",
    "inputValues": [],
    "businessLogic": "1. Root Directory Path Determination\n   1.1. IF root directory path is not already cached\n       1.1.1. Get the current class's resource path using the class loader\n       1.1.2. Extract the base path by removing the test-specific portion\n       1.1.3. Store the calculated path in the cache for future use\n   1.2. ELSE use the cached root directory path\n   1.3. Return the root directory path\n\n2. Data Validation\n   2.1. Verify the returned path is not null\n   2.2. Verify the returned path is a valid directory path\n   2.3. IF validation fails\n       2.3.1. Generate appropriate error message\n       2.3.2. Return error status\n\n3. Business Rule Processing\n   3.1. Check if the returned path has proper access permissions\n   3.2. Verify the path contains expected application structure\n   3.3. IF any business rule fails\n       3.3.1. Log the validation failure\n       3.3.2. Return error status\n\n4. Core Operation Execution\n   4.1. Format the path according to system requirements\n   4.2. Ensure path uses correct directory separators for the current operating system\n   4.3. Return the properly formatted root directory path\n\n5. Response Generation\n   5.1. Return the validated and formatted root directory path\n   5.2. IF any errors occurred during processing\n       5.2.1. Include error details in the response\n       5.2.2. Provide guidance on resolving path issues",
    "databaseEntities": [],
    "validationRules": [
      "Root directory path must not be null",
      "Root directory path must be a valid directory",
      "Root directory path must have read permissions",
      "Root directory path must contain expected application structure"
    ],
    "dbSeedingOperations": [],
    "schema": {}
  },
  {
    "featureName": "ListPOPMessages",
    "description": "Retrieves email messages from a POP server.",
    "inputValues": [
      "serverSettings-object-POPServerSettings"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect serverSettings (mandatory) containing POP server connection details\n     1.1. Server hostname (mandatory)\n     1.2. Port number (mandatory)\n     1.3. Username (mandatory)\n     1.4. Password (mandatory)\n     1.5. Use SSL connection flag (optional, default: false)\n     1.6. Connection timeout in seconds (optional, default: 60)\n\n2. Data Validation:\n   - Validate server connection parameters\n     2.1. Verify hostname is not empty\n         IF hostname is empty THEN\n             Return error: \"Server hostname cannot be empty\"\n     2.2. Verify port number is valid\n         IF port number is not between 1 and 65535 THEN\n             Return error: \"Invalid port number\"\n     2.3. Verify username is not empty\n         IF username is empty THEN\n             Return error: \"Username cannot be empty\"\n     2.4. Verify password is not empty\n         IF password is empty THEN\n             Return error: \"Password cannot be empty\"\n     2.5. Verify timeout value is reasonable\n         IF timeout is less than 5 or greater than 300 seconds THEN\n             Return error: \"Timeout must be between 5 and 300 seconds\"\n\n3. Business Rule Processing:\n   - Prepare for server connection\n     3.1. Check system readiness for external connections\n         IF system is in maintenance mode THEN\n             Return error: \"System is in maintenance mode. Try again later.\"\n     3.2. Verify maximum connection limits\n         IF current active connections exceed system limit THEN\n             Return error: \"Maximum connection limit reached. Try again later.\"\n     3.3. Check user permissions\n         IF current user does not have permission to access mail features THEN\n             Return error: \"Insufficient permissions to access mail server\"\n\n4. Core Operation Execution:\n   - Connect to POP server and retrieve messages\n     4.1. Establish connection to POP server\n         4.1.1. Initialize connection using server settings\n         4.1.2. Apply timeout settings\n         4.1.3. Apply SSL settings if enabled\n     4.2. Authenticate with server\n         4.2.1. Send username to server\n         4.2.2. Send password to server\n         4.2.3. Verify authentication success\n             IF authentication fails THEN\n                 Return error: \"Authentication failed. Check username and password.\"\n     4.3. Retrieve message list\n         4.3.1. Request message headers from server\n         4.3.2. Create message objects for each email\n         4.3.3. Store message metadata (subject, sender, date, size)\n     4.4. Close connection to POP server\n         4.4.1. Send logout command\n         4.4.2. Release connection resources\n\n5. Response Generation:\n   - Prepare message list for display\n     5.1. Format message data for presentation\n         5.1.1. Extract relevant fields (From, Subject, Date, Size)\n         5.1.2. Sort messages by date (newest first)\n     5.2. Generate success response\n         5.2.1. Include total message count\n         5.2.2. Include formatted message list\n         5.2.3. Include connection statistics (time taken)\n     5.3. Handle empty mailbox case\n         IF no messages found THEN\n             Return success with empty list and notification: \"No messages found\"\n     5.4. Return formatted message list to caller",
    "databaseEntities": [
      "jforum_privmsgs",
      "jforum_privmsgs_text",
      "jforum_users"
    ],
    "validationRules": [
      "Server hostname must not be empty",
      "Port number must be between 1 and 65535",
      "Username must not be empty",
      "Password must not be empty",
      "Connection timeout must be between 5 and 300 seconds",
      "User must have permission to access mail features"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "POPServerSettings": {
        "type": "object",
        "properties": {
          "hostname": {
            "type": "string",
            "description": "POP server hostname"
          },
          "port": {
            "type": "number",
            "description": "POP server port number"
          },
          "username": {
            "type": "string",
            "description": "Authentication username"
          },
          "password": {
            "type": "string",
            "description": "Authentication password"
          },
          "useSSL": {
            "type": "boolean",
            "description": "Whether to use SSL for connection"
          },
          "timeout": {
            "type": "number",
            "description": "Connection timeout in seconds"
          }
        },
        "required": [
          "hostname",
          "port",
          "username",
          "password"
        ]
      }
    }
  },
  {
    "featureName": "OpenPOPConnection",
    "description": "Establishes a connection to a POP3 mail server with optional SSL support.",
    "inputValues": [
      "mailIntegration-object-MailIntegration"
    ],
    "businessLogic": "1. Input Collection:\n   1.1. Collect the MailIntegration object containing:\n       - popHost (mandatory): Server hostname\n       - popPort (mandatory): Server port number\n       - popUsername (mandatory): Username for authentication\n       - popPassword (mandatory): Password for authentication\n       - isSSL (mandatory): Boolean flag indicating whether to use SSL\n\n2. Data Validation:\n   2.1. Validate MailIntegration object:\n       - Check if mailIntegration object is not null\n       - Verify popHost is not empty and has valid hostname format\n       - Ensure popPort is a positive integer within valid port range (1-65535)\n       - Confirm popUsername is not empty\n       - Verify popPassword is provided\n       - Validate isSSL is a boolean value\n   2.2. If any validation fails:\n       - Generate appropriate error message\n       - Abort connection process\n\n3. Business Rule Processing:\n   3.1. Check system state:\n       - Verify no existing connection is active\n       - If connection exists, close it before proceeding\n   3.2. Determine connection protocol:\n       - IF isSSL is TRUE, THEN use secure protocol (pop3s)\n       - ELSE use standard protocol (pop3)\n\n4. Core Operation Execution:\n   4.1. Establish mail session:\n       - Create new mail session with default properties\n   4.2. Connect to mail server:\n       - Initialize store using appropriate protocol (pop3 or pop3s)\n       - Connect to server using provided credentials (host, port, username, password)\n       - IF connection fails, THEN generate connection error\n   4.3. Access mail folder:\n       - Attempt to open the INBOX folder in READ_WRITE mode\n       - IF folder cannot be accessed, THEN generate folder access error\n\n5. Response Generation:\n   5.1. Success response:\n       - Return confirmation that connection has been established\n       - Make connection available for subsequent mail operations\n   5.2. Error response:\n       - Provide detailed error information if connection failed\n       - Include troubleshooting suggestions based on error type",
    "databaseEntities": [],
    "validationRules": [
      "MailIntegration object must not be null",
      "POP host must be a valid hostname or IP address",
      "POP port must be a valid port number (1-65535)",
      "POP username must not be empty",
      "POP password must not be empty",
      "SSL flag must be a boolean value"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "MailIntegration": {
        "type": "object",
        "properties": {
          "popHost": {
            "type": "string",
            "description": "POP3 server hostname or IP address"
          },
          "popPort": {
            "type": "number",
            "description": "POP3 server port number"
          },
          "popUsername": {
            "type": "string",
            "description": "Username for POP3 authentication"
          },
          "popPassword": {
            "type": "string",
            "description": "Password for POP3 authentication"
          },
          "isSSL": {
            "type": "boolean",
            "description": "Flag indicating whether to use SSL for connection"
          }
        },
        "required": [
          "popHost",
          "popPort",
          "popUsername",
          "popPassword",
          "isSSL"
        ]
      }
    }
  },
  {
    "featureName": "ClosePOPConnection",
    "description": "Closes an active connection to a POP email server.",
    "inputValues": [],
    "businessLogic": "1. Input Collection:\n   - No explicit inputs required for this operation\n   - System will use the current connection state information\n   - Connection must be previously established via openConnection method\n\n2. Data Validation:\n   - Validate connection state:\n     a. Verify the connection is in an active state\n        - IF connection is not active THEN\n          - Generate error: \"Cannot close an inactive connection\"\n          - Exit process\n     b. Verify the folder object is valid\n        - IF folder is null THEN\n          - Log warning: \"Attempting to close connection with null folder\"\n     c. Verify the store object is valid\n        - IF store is null THEN\n          - Log warning: \"Attempting to close connection with null store\"\n\n3. Business Rule Processing:\n   - Check if any pending operations need to be completed before closing\n     a. IF there are unsaved changes THEN\n        - Determine if changes should be committed or discarded\n        - IF changes should be committed THEN\n          - Process pending changes\n        - ELSE\n          - Discard pending changes\n   - Verify system resources can be properly released\n     a. Check if any locks are held on the connection\n        - IF locks exist THEN\n          - Attempt to release locks\n          - IF locks cannot be released THEN\n            - Log warning: \"Closing connection with active locks\"\n\n4. Core Operation Execution:\n   - Release message resources\n     a. IF messages have been retrieved THEN\n        - Release message references\n        - Clear message cache\n   - Close the folder connection\n     a. IF folder is not null THEN\n        - Attempt to close the folder\n        - Handle any errors during folder closure\n          - IF error occurs THEN\n            - Log error: \"Error closing folder: [error details]\"\n   - Close the store connection\n     a. IF store is not null THEN\n        - Attempt to close the store\n        - Handle any errors during store closure\n          - IF error occurs THEN\n            - Log error: \"Error closing store: [error details]\"\n   - Release any system resources associated with the connection\n     a. Clear any cached credentials\n     b. Release network resources\n\n5. Response Generation:\n   - Generate appropriate response\n     a. IF all operations completed successfully THEN\n        - Return success status: \"Connection closed successfully\"\n     b. IF any errors occurred THEN\n        - Return error status with details\n        - Include information about partial completion if applicable",
    "databaseEntities": [
      "MailIntegration"
    ],
    "validationRules": [
      "Connection must be in active state before closing",
      "Store object must be valid",
      "Folder object must be valid"
    ],
    "dbSeedingOperations": [],
    "schema": {}
  },
  {
    "featureName": "MatchBanlistEntries",
    "description": "Validates if banlist entries match based on user ID, email, or IP address patterns.",
    "inputValues": [
      "userId-number-Banlist",
      "email-string-Banlist",
      "ip-string-Banlist",
      "targetEntry-object-Banlist"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the following inputs:\n     - userId (number, mandatory if email and ip are not provided)\n     - email (string, mandatory if userId and ip are not provided)\n     - ip (string, mandatory if userId and email are not provided)\n     - targetEntry (object, mandatory): The banlist entry to compare against\n\n2. Data Validation:\n   - Validate userId:\n     - IF userId is provided THEN\n       - ENSURE userId is a positive integer\n       - IF invalid THEN return validation error\n   - Validate email:\n     - IF email is provided THEN\n       - ENSURE email is in valid format\n       - IF invalid THEN return validation error\n   - Validate IP address:\n     - IF ip is provided THEN\n       - ENSURE ip follows valid IP format or contains wildcards (*)\n       - IF invalid THEN return validation error\n   - Validate targetEntry:\n     - ENSURE targetEntry contains at least one of: userId, email, or ip\n     - IF invalid THEN return validation error\n   - ENSURE at least one matching criterion (userId, email, or ip) is provided\n     - IF no criteria provided THEN return validation error\n\n3. Business Rule Processing:\n   - Determine match type priority:\n     - IF userId is provided in both source and target THEN\n       - Set comparison type to \"userId\"\n     - ELSE IF email is provided in both source and target THEN\n       - Set comparison type to \"email\"\n     - ELSE IF ip is provided in both source and target THEN\n       - Set comparison type to \"ip\"\n     - ELSE\n       - Set match result to FALSE\n       - Skip to Response Generation\n\n4. Core Operation Execution:\n   - Execute matching based on determined type:\n     - IF comparison type is \"userId\" THEN\n       - Compare source userId with target userId\n       - IF values are equal THEN\n         - Set match result to TRUE\n       - ELSE\n         - Set match result to FALSE\n     - ELSE IF comparison type is \"email\" THEN\n       - Compare source email with target email (case-insensitive)\n       - IF values are equal THEN\n         - Set match result to TRUE\n       - ELSE\n         - Set match result to FALSE\n     - ELSE IF comparison type is \"ip\" THEN\n       - IF source ip contains wildcards (*) THEN\n         - Split both IPs into segments\n         - IF segment counts don't match THEN\n           - Set match result to FALSE\n         - ELSE\n           - FOR EACH segment in source ip\n             - IF segment is wildcard (*) THEN\n               - Continue to next segment\n             - ELSE IF segment matches corresponding target segment THEN\n               - Continue to next segment\n             - ELSE\n               - Set match result to FALSE\n               - Break loop\n           - IF all segments processed successfully THEN\n             - Set match result to TRUE\n       - ELSE\n         - Compare source ip with target ip directly\n         - IF values are equal THEN\n           - Set match result to TRUE\n         - ELSE\n           - Set match result to FALSE\n\n5. Response Generation:\n   - Return the match result:\n     - IF match result is TRUE THEN\n       - Return success response with match details\n     - ELSE\n       - Return negative match response",
    "databaseEntities": [
      "jforum_users"
    ],
    "validationRules": [
      "At least one of userId, email, or IP must be provided",
      "User ID must be a positive integer if provided",
      "Email must be in valid format if provided",
      "IP address must be in valid format or contain wildcards (*)",
      "IP address segments must match in count when comparing with wildcards",
      "Target entry must contain at least one matching criterion field"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Banlist": {
        "type": "object",
        "properties": {
          "userId": {
            "type": "number",
            "description": "User ID to match"
          },
          "email": {
            "type": "string",
            "description": "Email address to match"
          },
          "ip": {
            "type": "string",
            "description": "IP address to match, may contain wildcards (*)"
          }
        }
      }
    }
  },
  {
    "featureName": "DetectPollChanges",
    "description": "Identifies differences between two poll instances including label changes and option modifications.",
    "inputValues": [
      "originalPoll-object-Poll",
      "updatedPoll-object-Poll"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect originalPoll (mandatory): The original poll instance\n   - Collect updatedPoll (mandatory): The updated poll instance with potential changes\n\n2. Data Validation:\n   - Validate originalPoll:\n     * Verify originalPoll is not null\n     * Verify originalPoll has a valid label\n     * Verify originalPoll has at least one option\n   - Validate updatedPoll:\n     * Verify updatedPoll is not null\n     * Verify updatedPoll has a valid label\n     * Verify updatedPoll has at least one option\n\n3. Business Rule Processing:\n   - Initialize change tracking containers:\n     * Create empty list for changed options\n     * Create empty list for deleted options\n     * Create empty list for new options\n     * Set label change status to false\n   - Check for label changes:\n     * IF originalPoll label does not match updatedPoll label THEN\n       > Set label change status to true\n   - Process option changes:\n     * Create map of original options by ID for efficient lookup\n     * FOR EACH option in updatedPoll:\n       > IF option exists in originalPoll (by ID) THEN\n         * IF option text has changed THEN\n           - Add to changed options list\n       > ELSE\n         * Add to new options list\n     * FOR EACH option in originalPoll:\n       > IF option does not exist in updatedPoll (by ID) THEN\n         * Add to deleted options list\n\n4. Core Operation Execution:\n   - Determine if any changes exist:\n     * IF label has changed OR any options list is not empty THEN\n       > Set hasChanges flag to true\n     * ELSE\n       > Set hasChanges flag to false\n   - Organize change information:\n     * Compile all changes into a structured format\n     * Ensure options in each category (changed, new, deleted) maintain their original properties\n\n5. Response Generation:\n   - Create response with the following information:\n     * hasChanges: Boolean indicating if any changes were detected\n     * labelChanged: Boolean indicating if the poll label changed\n     * changedOptions: List of options that were modified\n     * newOptions: List of options that were added\n     * deletedOptions: List of options that were removed\n   - Return the compiled change information",
    "databaseEntities": [
      "jforum_topics"
    ],
    "validationRules": [
      "Both original and updated polls must not be null",
      "Both polls must have valid labels",
      "Both polls must have at least one option",
      "Poll options must have unique IDs within each poll",
      "Option text changes are detected by comparing the text while maintaining the same ID"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Poll": {
        "type": "object",
        "properties": {
          "id": {
            "type": "number",
            "description": "Unique identifier for the poll"
          },
          "label": {
            "type": "string",
            "description": "The question or title of the poll"
          },
          "options": {
            "type": "array",
            "items": {
              "$ref": "#/PollOption"
            },
            "description": "List of available options for the poll"
          }
        }
      },
      "PollOption": {
        "type": "object",
        "properties": {
          "id": {
            "type": "number",
            "description": "Unique identifier for the poll option"
          },
          "text": {
            "type": "string",
            "description": "The text content of the poll option"
          },
          "voteCount": {
            "type": "number",
            "description": "Number of votes received for this option"
          }
        }
      }
    }
  },
  {
    "featureName": "TrackChangedPollOptions",
    "description": "Tracks poll options that have been modified between poll versions.",
    "inputValues": [
      "originalPoll-object-Poll",
      "updatedPoll-object-Poll"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect originalPoll (mandatory): The original poll object with its options\n   - Collect updatedPoll (mandatory): The updated poll object with its options\n\n2. Data Validation:\n   - Validate originalPoll:\n     a. Verify originalPoll is not null\n     b. Verify originalPoll has a label\n     c. Generate error if validation fails\n   - Validate updatedPoll:\n     a. Verify updatedPoll is not null\n     b. Verify updatedPoll has a label\n     c. Generate error if validation fails\n\n3. Business Rule Processing:\n   - Initialize tracking containers:\n     a. Create empty list for changed options\n     b. Create empty list for new options\n     c. Create empty list for deleted options\n   - Compare poll labels:\n     a. IF originalPoll.label != updatedPoll.label THEN\n        i. Mark that changes exist\n\n4. Core Operation Execution:\n   - Process option changes:\n     a. FOR EACH option in updatedPoll:\n        i. Find matching option in originalPoll by ID\n        ii. IF matching option found THEN\n            1. IF option text has changed THEN\n               a. Add to changed options list\n        iii. ELSE\n            1. Add to new options list\n     b. FOR EACH option in originalPoll:\n        i. Find matching option in updatedPoll by ID\n        ii. IF no matching option found THEN\n            1. Add to deleted options list\n     c. Determine if any changes exist:\n        i. IF any of these conditions are true THEN mark changes exist:\n           1. Label changed\n           2. Changed options list is not empty\n           3. New options list is not empty\n           4. Deleted options list is not empty\n\n5. Response Generation:\n   - Prepare change tracking result:\n     a. Include status indicating if changes exist\n     b. Include list of changed options\n     c. Include list of new options\n     d. Include list of deleted options\n   - Return the complete change tracking result",
    "databaseEntities": [
      "jforum_topics"
    ],
    "validationRules": [
      "Original poll must not be null",
      "Updated poll must not be null",
      "Poll options must have unique IDs within each poll",
      "Poll must have a label"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Poll": {
        "type": "object",
        "properties": {
          "id": {
            "type": "number"
          },
          "label": {
            "type": "string"
          },
          "options": {
            "type": "array",
            "items": {
              "$ref": "#/PollOption"
            }
          }
        }
      },
      "PollOption": {
        "type": "object",
        "properties": {
          "id": {
            "type": "number"
          },
          "text": {
            "type": "string"
          },
          "voteCount": {
            "type": "number"
          }
        }
      },
      "PollChanges": {
        "type": "object",
        "properties": {
          "hasChanges": {
            "type": "boolean"
          },
          "changedOptions": {
            "type": "array",
            "items": {
              "$ref": "#/PollOption"
            }
          },
          "newOptions": {
            "type": "array",
            "items": {
              "$ref": "#/PollOption"
            }
          },
          "deletedOptions": {
            "type": "array",
            "items": {
              "$ref": "#/PollOption"
            }
          }
        }
      }
    }
  },
  {
    "featureName": "TrackNewPollOptions",
    "description": "Identifies new poll options added in an updated poll.",
    "inputValues": [
      "originalPoll-object-Poll",
      "updatedPoll-object-Poll"
    ],
    "businessLogic": "1. Input Collection\n   - Collect the original poll (originalPoll) with its options\n   - Collect the updated poll (updatedPoll) with its options\n   - Both polls must contain:\n     * Label (text identifier for the poll)\n     * Options list (collection of poll options)\n   - Each poll option must contain:\n     * ID (unique identifier)\n     * Text (description of the option)\n     * Vote count\n\n2. Data Validation\n   - Validate originalPoll is not null\n     * IF originalPoll is null THEN return error \"Original poll cannot be null\"\n   - Validate updatedPoll is not null\n     * IF updatedPoll is null THEN return error \"Updated poll cannot be null\"\n   - Validate originalPoll has valid options collection\n     * IF originalPoll options collection is null THEN initialize empty collection\n   - Validate updatedPoll has valid options collection\n     * IF updatedPoll options collection is null THEN initialize empty collection\n\n3. Business Rule Processing\n   - Compare poll labels\n     * IF originalPoll.label != updatedPoll.label THEN mark label as changed\n   - Initialize collections for tracking changes:\n     * newOptions (options in updatedPoll not in originalPoll)\n     * deletedOptions (options in originalPoll not in updatedPoll)\n     * changedOptions (options in both polls but with different text)\n\n4. Core Operation Execution\n   - Identify new poll options\n     * FOR EACH option in updatedPoll:\n       * IF option ID does not exist in originalPoll THEN\n         * Add option to newOptions collection\n   - Identify deleted poll options\n     * FOR EACH option in originalPoll:\n       * IF option ID does not exist in updatedPoll THEN\n         * Add option to deletedOptions collection\n   - Identify changed poll options\n     * FOR EACH option in updatedPoll:\n       * IF option ID exists in originalPoll THEN\n         * IF option text differs from corresponding option in originalPoll THEN\n           * Add option to changedOptions collection\n   - Determine if any changes exist\n     * IF label changed OR newOptions not empty OR deletedOptions not empty OR changedOptions not empty THEN\n       * Set hasChanges flag to true\n     * ELSE\n       * Set hasChanges flag to false\n\n5. Response Generation\n   - Create response containing:\n     * hasChanges flag indicating if any changes were detected\n     * Collection of new options added to the poll\n     * Collection of options deleted from the poll\n     * Collection of options whose text was modified\n     * Whether the poll label was changed\n   - Return the complete change tracking information",
    "databaseEntities": [
      "jforum_topics"
    ],
    "validationRules": [
      "Original poll must not be null",
      "Updated poll must not be null",
      "Poll options must have unique IDs",
      "Each poll option must have an ID, text, and vote count"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Poll": {
        "type": "object",
        "properties": {
          "label": {
            "type": "string",
            "description": "Text identifier for the poll"
          },
          "options": {
            "type": "array",
            "items": {
              "$ref": "#/PollOption"
            },
            "description": "Collection of options for the poll"
          }
        }
      },
      "PollOption": {
        "type": "object",
        "properties": {
          "id": {
            "type": "integer",
            "description": "Unique identifier for the poll option"
          },
          "text": {
            "type": "string",
            "description": "Description text for the poll option"
          },
          "voteCount": {
            "type": "integer",
            "description": "Number of votes received for this option"
          }
        }
      },
      "PollChanges": {
        "type": "object",
        "properties": {
          "hasChanges": {
            "type": "boolean",
            "description": "Flag indicating if any changes were detected"
          },
          "newOptions": {
            "type": "array",
            "items": {
              "$ref": "#/PollOption"
            },
            "description": "Collection of new options added to the poll"
          },
          "deletedOptions": {
            "type": "array",
            "items": {
              "$ref": "#/PollOption"
            },
            "description": "Collection of options deleted from the poll"
          },
          "changedOptions": {
            "type": "array",
            "items": {
              "$ref": "#/PollOption"
            },
            "description": "Collection of options whose text was modified"
          },
          "labelChanged": {
            "type": "boolean",
            "description": "Flag indicating if the poll label was changed"
          }
        }
      }
    }
  },
  {
    "featureName": "TrackDeletedPollOptions",
    "description": "Identifies poll options that have been removed in an updated poll.",
    "inputValues": [
      "originalPoll-object-Poll",
      "updatedPoll-object-Poll"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect originalPoll (mandatory): The original poll object before updates\n   - Collect updatedPoll (mandatory): The updated poll object with potential changes\n\n2. Data Validation:\n   - Validate originalPoll:\n     a. Verify originalPoll is not null\n     b. Ensure originalPoll has a valid label\n     c. Check that originalPoll contains at least one poll option\n   - Validate updatedPoll:\n     a. Verify updatedPoll is not null\n     b. Ensure updatedPoll has a valid label\n\n3. Business Rule Processing:\n   - Initialize tracking containers:\n     a. Create container for deleted options\n     b. Create container for new options\n     c. Create container for changed options\n   - Determine if poll label has changed:\n     a. Compare originalPoll.label with updatedPoll.label\n     b. Flag label change if different\n\n4. Core Operation Execution:\n   - Compare poll options between original and updated polls:\n     a. FOR each option in originalPoll:\n        i. Search for matching option by ID in updatedPoll\n        ii. IF matching option not found:\n            - Add to deleted options container\n        iii. ELSE IF matching option found but text changed:\n            - Add to changed options container\n     b. FOR each option in updatedPoll:\n        i. Search for matching option by ID in originalPoll\n        ii. IF matching option not found:\n            - Add to new options container\n   - Determine overall change status:\n     a. IF any of these conditions are true, mark as having changes:\n        i. Poll label changed\n        ii. Deleted options container is not empty\n        iii. New options container is not empty\n        iv. Changed options container is not empty\n\n5. Response Generation:\n   - Compile poll changes result:\n     a. Include flag indicating whether changes were detected\n     b. Include list of deleted poll options\n     c. Include list of new poll options\n     d. Include list of changed poll options\n   - Return compiled poll changes result",
    "databaseEntities": [
      "jforum_topics"
    ],
    "validationRules": [
      "Original poll must not be null",
      "Updated poll must not be null",
      "Poll options must have unique IDs",
      "Poll must have a valid label"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Poll": {
        "type": "object",
        "properties": {
          "id": {
            "type": "number",
            "description": "Unique identifier for the poll"
          },
          "label": {
            "type": "string",
            "description": "The title or question of the poll"
          },
          "options": {
            "type": "array",
            "items": {
              "$ref": "#/PollOption"
            },
            "description": "List of available options for the poll"
          }
        }
      },
      "PollOption": {
        "type": "object",
        "properties": {
          "id": {
            "type": "number",
            "description": "Unique identifier for the poll option"
          },
          "text": {
            "type": "string",
            "description": "The text of the poll option"
          },
          "voteCount": {
            "type": "number",
            "description": "Number of votes for this option"
          }
        }
      }
    }
  },
  {
    "featureName": "ManageHttpSessionAttributes",
    "description": "Provides session attribute management with get, set and remove operations.",
    "inputValues": [
      "attributeName-string-SessionAttribute",
      "attributeValue-object-AttributeValue"
    ],
    "businessLogic": "1. Input Collection:\n   - attributeName (string, mandatory): The name identifier for the session attribute\n   - attributeValue (object, optional for get/remove operations): The value to be stored in the session\n   - operationType (string, mandatory): Type of operation to perform (GET, SET, REMOVE)\n\n2. Data Validation:\n   - Validate attributeName:\n     a. Check if attributeName is not null or empty\n     b. Verify attributeName is a valid string format\n     c. Return error if validation fails: \"Attribute name must be provided\"\n   - Validate operationType:\n     a. Verify operationType is one of the allowed values: GET, SET, REMOVE\n     b. Return error if validation fails: \"Invalid operation type specified\"\n   - For SET operation:\n     a. Verify attributeValue is provided\n     b. Return error if validation fails: \"Attribute value must be provided for SET operation\"\n\n3. Business Rule Processing:\n   - Verify session exists and is valid:\n     a. Check if the current session is active and not expired\n     b. IF session is invalid or expired THEN\n        i. Return error: \"Invalid or expired session\"\n     c. ELSE continue processing\n   - Check access permissions:\n     a. Verify current user has permission to access/modify the requested attribute\n     b. IF permission check fails THEN\n        i. Return error: \"Insufficient permissions to access this attribute\"\n     c. ELSE continue processing\n\n4. Core Operation Execution:\n   - SWITCH based on operationType:\n     a. CASE GET:\n        i. Retrieve the attribute value from the session using attributeName\n        ii. IF attribute does not exist THEN\n            - Return null or appropriate default value\n        iii. ELSE return the retrieved attribute value\n     b. CASE SET:\n        i. Store the attributeValue in the session with attributeName as key\n        ii. IF previous value existed THEN\n            - Overwrite the previous value\n        iii. Return confirmation of successful operation\n     c. CASE REMOVE:\n        i. Remove the attribute identified by attributeName from the session\n        ii. IF attribute did not exist THEN\n            - Return notification that no attribute was removed\n        iii. ELSE return confirmation of successful removal\n\n5. Response Generation:\n   - For successful operations:\n     a. GET: Return the retrieved attribute value or null if not found\n     b. SET: Return confirmation message \"Attribute successfully set\"\n     c. REMOVE: Return confirmation message \"Attribute successfully removed\"\n   - For failed operations:\n     a. Include specific error message describing the failure reason\n     b. Include error code for programmatic handling\n     c. Include suggestions for resolving the issue where applicable",
    "databaseEntities": [
      "jforum_sessions"
    ],
    "validationRules": [
      "Attribute name must not be null or empty",
      "Operation type must be one of: GET, SET, REMOVE",
      "For SET operations, attribute value must be provided",
      "Session must be valid and not expired",
      "User must have permission to access the requested attribute"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "AttributeValue": {
        "type": "object",
        "description": "Represents any type of value that can be stored in a session",
        "properties": {
          "type": {
            "type": "string",
            "description": "The data type of the stored value"
          },
          "value": {
            "type": "object",
            "description": "The actual value being stored"
          }
        }
      },
      "SessionAttribute": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "description": "Name of the session attribute"
          },
          "value": {
            "type": "object",
            "description": "Value of the session attribute"
          },
          "creationTime": {
            "type": "number",
            "description": "Timestamp when the attribute was created"
          },
          "lastAccessedTime": {
            "type": "number",
            "description": "Timestamp when the attribute was last accessed"
          }
        }
      }
    }
  },
  {
    "featureName": "GetSessionIdentification",
    "description": "Retrieves session identification information including ID and creation details.",
    "inputValues": [
      "sessionRequest-object-SessionRequest"
    ],
    "businessLogic": "1. Input Collection:\n   1.1. Collect session request information:\n       - sessionRequest (mandatory): Contains the request for session identification\n       - System will determine if this is an existing or new session request\n\n2. Data Validation:\n   2.1. Validate session request:\n       - Verify the session request is properly formatted\n       - Check if session request contains required authentication parameters\n       - IF session request is invalid THEN prepare error response\n   2.2. Validate session existence:\n       - Check if the requested session exists in the system\n       - IF session does not exist THEN prepare new session creation parameters\n\n3. Business Rule Processing:\n   3.1. Check session access permissions:\n       - Verify the requester has appropriate permissions to access the session\n       - IF requester lacks permissions THEN deny access and log attempt\n   3.2. Check session status:\n       - Verify if session is active or expired\n       - IF session is expired THEN prepare session renewal process\n       - IF session is active THEN proceed with identification retrieval\n\n4. Core Operation Execution:\n   4.1. Retrieve session identification data:\n       - Extract session ID from the session store\n       - Retrieve session creation timestamp\n       - Collect session last accessed time\n       - Gather session maximum inactive interval\n       - Determine if session is new\n   4.2. Format session identification data:\n       - Organize retrieved data into structured format\n       - Include all relevant session metadata\n       - Prepare response with complete session identification\n\n5. Response Generation:\n   5.1. Generate success response:\n       - Include session ID\n       - Include creation time\n       - Include last accessed time\n       - Include session status (new or existing)\n       - Include maximum inactive interval\n   5.2. Handle error scenarios:\n       - IF session retrieval failed THEN include error details\n       - IF session expired THEN include expiration information\n       - Include guidance for session renewal if applicable",
    "databaseEntities": [
      "jforum_sessions"
    ],
    "validationRules": [
      "Session request must contain valid authentication parameters",
      "Requester must have appropriate permissions to access session information",
      "Session ID must be valid and exist in the system for existing sessions",
      "Session must not be expired unless renewal is requested"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "SessionRequest": {
        "type": "object",
        "properties": {
          "requestType": {
            "type": "string",
            "description": "Type of session request (new, existing)"
          },
          "authenticationParameters": {
            "type": "object",
            "description": "Parameters used for authentication"
          },
          "sessionId": {
            "type": "string",
            "description": "Optional session ID for existing sessions"
          }
        },
        "required": [
          "requestType",
          "authenticationParameters"
        ]
      }
    }
  },
  {
    "featureName": "TestSummaryScheduler",
    "description": "Tests the functionality of the summary scheduler and its frequency for sending post summaries to users.",
    "inputValues": [
      "timeRange-object-DateRange",
      "recipients-object-RecipientsList"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect timeRange (DateRange object) with startDate and endDate\n   - Collect recipients (RecipientsList object) containing user information\n   - System will use current date as endDate if not provided\n   - System will calculate startDate as 7 days before endDate if not provided\n\n2. Data Validation:\n   - Validate timeRange:\n      * Ensure startDate is before endDate\n      * Ensure startDate is not null\n      * Ensure endDate is not null or use current date\n      * IF any validation fails, THEN display appropriate error message\n   - Validate recipients:\n      * Ensure recipients list is accessible\n      * IF recipients list cannot be accessed, THEN display error message\n      * IF recipients list is empty, THEN display notification\n\n3. Business Rule Processing:\n   - Verify scheduler configuration:\n      * Check if scheduler is properly configured\n      * Verify frequency settings for summary delivery\n      * Ensure scheduler has necessary permissions to run\n      * IF configuration is invalid, THEN display configuration error\n   - Verify system resources:\n      * Check if email service is available\n      * Ensure database connection is active\n      * IF any required resource is unavailable, THEN abort operation and log error\n\n4. Core Operation Execution:\n   - Initialize summary scheduler:\n      * Set up scheduler with configured frequency\n      * Start the scheduler job\n      * Monitor for any initialization errors\n      * IF initialization fails, THEN log error and abort operation\n   - Retrieve posts within time range:\n      * Query posts created between startDate and endDate\n      * Filter posts based on user preferences if applicable\n      * Sort posts by relevance or chronological order\n      * IF no posts found, THEN prepare empty summary notification\n   - Generate summary content:\n      * Format post information (subject, author, date, content excerpt)\n      * Group posts by categories or forums if applicable\n      * Create personalized content for each recipient\n      * IF content generation fails, THEN log error and continue with next recipient\n   - Send summary emails:\n      * For each recipient in the list:\n         > Prepare personalized email with summary content\n         > Send email to recipient\n         > Track delivery status\n      * IF sending fails for any recipient, THEN log error and continue with next recipient\n\n5. Response Generation:\n   - Prepare execution summary:\n      * Count of posts included in summary\n      * Count of recipients processed\n      * Count of successful email deliveries\n      * Count of failed email deliveries\n   - Generate test results:\n      * Scheduler initialization status\n      * Post retrieval status\n      * Email sending status\n      * Overall test status (success/failure)\n   - Log detailed results:\n      * Record timing information\n      * Document any errors or exceptions\n      * Store metrics for performance analysis",
    "databaseEntities": [
      "jforum_users",
      "jforum_posts",
      "jforum_posts_text",
      "jforum_topics",
      "jforum_forums"
    ],
    "validationRules": [
      "Start date must be before end date",
      "Time range must not exceed system-defined maximum period",
      "Recipients list must be accessible",
      "Email service must be available for sending summaries",
      "Scheduler must be properly configured",
      "Summary frequency must match configured settings"
    ],
    "dbSeedingOperations": [
      "Ensure test users exist with valid email addresses",
      "Create test posts within the specified time range",
      "Configure test summary preferences for users"
    ],
    "schema": {
      "DateRange": {
        "startDate": "date",
        "endDate": "date"
      },
      "RecipientsList": {
        "users": [
          {
            "userId": "number",
            "email": "string",
            "username": "string",
            "preferences": {
              "summaryEnabled": "boolean",
              "summaryFrequency": "string"
            }
          }
        ]
      }
    }
  },
  {
    "featureName": "TestLoadRecipients",
    "description": "Tests loading of summary email recipients from the system.",
    "inputValues": [],
    "businessLogic": "1. Input Collection:\n   - No user inputs required for this feature\n   - System will use current application state and database\n\n2. Data Validation:\n   - Verify database connection is available\n     - IF database connection fails, THEN display error message and abort operation\n   - Verify summary recipient data exists in the system\n     - IF no recipient data exists, THEN log warning but continue process\n\n3. Business Rule Processing:\n   - Initialize the summary model component\n     - Create new instance of summary model\n     - Prepare model for recipient retrieval\n   - Verify user permissions and system configuration\n     - Check if summary email functionality is enabled in system settings\n     - Verify current user has permission to access recipient information\n     - IF permissions are insufficient, THEN abort operation and display error\n\n4. Core Operation Execution:\n   - Retrieve recipient list from the system\n     - Query the database for all users who have subscribed to summary emails\n     - Collect email addresses and user preferences for each recipient\n     - Format recipient data in appropriate structure for display\n   - Process recipient information\n     - Count total number of recipients found\n     - Log recipient retrieval operation completion\n     - Display recipient information for verification purposes\n   - Verify recipient list integrity\n     - Check that recipient list contains at least one entry\n     - Validate email format for each recipient\n     - IF recipient list is empty, THEN log warning message\n\n5. Response Generation:\n   - Display recipient information\n     - For each recipient, output relevant information to console or log\n     - Show total count of recipients found\n   - Verify operation success\n     - Assert that recipient list contains at least one entry\n     - IF assertion passes, THEN mark test as successful\n     - IF assertion fails, THEN mark test as failed and log error",
    "databaseEntities": [
      "jforum_users",
      "jforum_user_groups",
      "jforum_groups"
    ],
    "validationRules": [
      "Database connection must be available",
      "Summary email functionality must be enabled in system settings",
      "User must have permission to access recipient information",
      "Recipient list must contain at least one entry",
      "Each recipient must have a valid email address"
    ],
    "dbSeedingOperations": [
      "Ensure at least one user with summary email subscription exists in jforum_users"
    ],
    "schema": {}
  },
  {
    "featureName": "TestSendMails",
    "description": "Tests sending summary emails to recipients with posts from a specified time period.",
    "inputValues": [
      "recipients-object-RecipientList",
      "startDate-date-Date",
      "endDate-date-Date"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the following inputs:\n     a. recipients: List of email addresses to receive the summary (mandatory)\n     b. startDate: Beginning date for post collection period (mandatory)\n     c. endDate: Ending date for post collection period (mandatory, defaults to current date if not provided)\n\n2. Data Validation:\n   - Validate recipient list:\n     a. IF recipient list is empty or null THEN\n        i. Generate error message \"Recipient list cannot be empty\"\n        ii. Halt process and return error\n     b. FOR EACH recipient in the list:\n        i. Validate email format\n        ii. IF email format is invalid THEN mark recipient as invalid\n   - Validate date range:\n     a. IF startDate is after endDate THEN\n        i. Generate error message \"Start date must be before end date\"\n        ii. Halt process and return error\n     b. IF startDate is null THEN\n        i. Generate error message \"Start date is required\"\n        ii. Halt process and return error\n     c. IF endDate is null THEN\n        i. Set endDate to current system date\n\n3. Business Rule Processing:\n   - Check system state:\n     a. Verify email service is available\n     b. IF email service is unavailable THEN\n        i. Log error \"Email service unavailable\"\n        ii. Halt process and return error\n   - Check post availability:\n     a. Query post repository for posts between startDate and endDate\n     b. IF no posts found THEN\n        i. Log message \"No posts found in the specified date range\"\n        ii. Proceed with empty post list\n\n4. Core Operation Execution:\n   - Retrieve posts for the summary:\n     a. Query database for all posts created between startDate and endDate\n     b. Sort posts by date (newest first)\n     c. Group posts by forum or topic as needed\n   - Generate summary content:\n     a. Create email subject line with date range information\n     b. Format email body with post information including:\n        i. Post titles\n        ii. Post authors\n        iii. Post dates\n        iv. Brief content excerpts\n   - Send emails to recipients:\n     a. FOR EACH valid recipient:\n        i. Create personalized email with the summary content\n        ii. Send email to recipient\n        iii. Track delivery status\n     b. IF any email fails to send THEN\n        i. Log the failure with recipient information\n        ii. Continue with next recipient\n\n5. Response Generation:\n   - Generate success report:\n     a. Count of emails successfully sent\n     b. Count of posts included in summary\n     c. Date range of the summary\n   - Generate error report if applicable:\n     a. List of recipients with failed deliveries\n     b. Specific error messages for each failure\n   - Return complete status report",
    "databaseEntities": [
      "jforum_users",
      "jforum_posts",
      "jforum_posts_text",
      "jforum_topics",
      "jforum_forums"
    ],
    "validationRules": [
      "Recipient list must not be empty",
      "Each recipient email must be in valid format",
      "Start date must be before end date",
      "Start date is required",
      "Email service must be available"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "RecipientList": {
        "type": "array",
        "items": {
          "type": "string",
          "format": "email",
          "description": "Email address of a recipient"
        }
      }
    }
  },
  {
    "featureName": "ListPostsByDateRange",
    "description": "Retrieves posts from a specific date range for summary generation.",
    "inputValues": [
      "startDate-date-Post",
      "endDate-date-Post"
    ],
    "businessLogic": "1. Input Collection:\n   1.1. Collect startDate (mandatory) - The beginning date of the range to search for posts\n   1.2. Collect endDate (mandatory) - The ending date of the range to search for posts\n   1.3. System will use current date as default for endDate if not provided\n\n2. Data Validation:\n   2.1. Validate startDate:\n       2.1.1. IF startDate is null or empty THEN\n           2.1.1.1. Generate error message: \"Start date is required\"\n           2.1.1.2. Return validation error\n       2.1.2. IF startDate is not in valid date format THEN\n           2.1.2.1. Generate error message: \"Start date must be a valid date\"\n           2.1.2.2. Return validation error\n   2.2. Validate endDate:\n       2.2.1. IF endDate is null or empty THEN\n           2.2.1.1. Set endDate to current system date\n       2.2.2. IF endDate is not in valid date format THEN\n           2.2.2.1. Generate error message: \"End date must be a valid date\"\n           2.2.2.2. Return validation error\n   2.3. Validate date range:\n       2.3.1. IF startDate is after endDate THEN\n           2.3.1.1. Generate error message: \"Start date cannot be after end date\"\n           2.3.1.2. Return validation error\n\n3. Business Rule Processing:\n   3.1. Check system state:\n       3.1.1. Verify database connection is available\n       3.1.2. IF database connection is unavailable THEN\n           3.1.2.1. Generate error message: \"Database service unavailable\"\n           3.1.2.2. Return system error\n   3.2. Check access permissions:\n       3.2.1. Verify user has permission to view posts\n       3.2.2. IF user lacks permission THEN\n           3.2.2.1. Generate error message: \"Insufficient permissions to view posts\"\n           3.2.2.2. Return access denied error\n\n4. Core Operation Execution:\n   4.1. Initialize empty collection for storing posts\n   4.2. Query database for posts:\n       4.2.1. Search for all posts with creation date between startDate and endDate (inclusive)\n       4.2.2. Sort posts by date in descending order (newest first)\n   4.3. Process retrieved posts:\n       4.3.1. FOR EACH post in query results DO\n           4.3.1.1. Extract post details (subject, content, author, creation date)\n           4.3.1.2. Add post to collection\n       4.3.2. END FOR\n\n5. Response Generation:\n   5.1. IF posts collection is empty THEN\n       5.1.1. Return success response with message: \"No posts found in the specified date range\"\n   5.2. ELSE\n       5.2.1. Return success response with:\n           5.2.1.1. Collection of posts\n           5.2.1.2. Total count of posts found\n           5.2.1.3. Date range used for the search",
    "databaseEntities": [
      "jforum_posts",
      "jforum_posts_text",
      "jforum_users",
      "jforum_topics"
    ],
    "validationRules": [
      "Start date must be provided",
      "End date must be provided or defaults to current date",
      "Start date must be before or equal to end date",
      "Both dates must be valid date formats",
      "User must have permission to view posts"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Post": {
        "type": "object",
        "properties": {
          "id": {
            "type": "number"
          },
          "subject": {
            "type": "string"
          },
          "text": {
            "type": "string"
          },
          "creationDate": {
            "type": "date"
          },
          "userId": {
            "type": "number"
          },
          "topicId": {
            "type": "number"
          }
        },
        "required": [
          "id",
          "subject",
          "text",
          "creationDate",
          "userId",
          "topicId"
        ]
      }
    }
  },
  {
    "featureName": "URLNormalization",
    "description": "Normalizes URLs by replacing spaces, removing special characters, and enforcing character limits.",
    "inputValues": [
      "inputString-string-Text",
      "characterLimit-number-Configuration",
      "friendlyMode-boolean-Configuration"
    ],
    "businessLogic": "1. Input Collection:\n   - Collect the following inputs:\n     - inputString (string, mandatory): The text to be normalized\n     - characterLimit (number, optional): Maximum length for the normalized string, defaults to system-defined limit\n     - friendlyMode (boolean, optional): Determines how the character limit is applied, defaults to true\n\n2. Data Validation:\n   - Validate inputString:\n     - IF inputString is null or empty THEN\n       - Return empty string\n     - END IF\n   - Validate characterLimit:\n     - IF characterLimit is provided THEN\n       - Ensure characterLimit is a positive integer\n       - IF characterLimit is negative or zero THEN\n         - Use system default limit\n       - END IF\n     - ELSE\n       - Use system default limit\n     - END IF\n\n3. Business Rule Processing:\n   - Determine normalization rules based on system configuration:\n     - Space replacement character (default: underscore)\n     - Characters to be removed (special characters, parentheses, etc.)\n     - Word separators to be replaced\n     - Case transformation rules (if any)\n\n4. Core Operation Execution:\n   - Process the input string according to normalization rules:\n     - Replace all spaces with the designated replacement character\n     - Remove all special characters (!, @, #, $, %, ^, &, *, etc.)\n     - Remove parentheses and their contents or replace with appropriate text\n     - Replace plus signs with the designated replacement character\n     - Apply any additional character transformations\n   - Apply character limit:\n     - IF friendlyMode is true THEN\n       - Trim at the last complete word within the character limit\n       - Ensure no partial words remain at the end of the string\n     - ELSE\n       - Trim exactly at the character limit regardless of word boundaries\n     - END IF\n   - Perform final cleanup:\n     - Remove any trailing special characters or separators\n     - Ensure consistent formatting\n\n5. Response Generation:\n   - Return the normalized string\n   - IF normalization process encountered issues THEN\n     - Log warnings about potential information loss\n   - END IF",
    "databaseEntities": [],
    "validationRules": [
      "Input string must not be null",
      "Character limit must be a positive integer if provided",
      "Normalized string must not contain spaces",
      "Normalized string must not contain special characters",
      "Normalized string must respect the character limit",
      "In friendly mode, string must be trimmed at word boundaries"
    ],
    "dbSeedingOperations": [],
    "schema": {
      "Text": {
        "type": "object",
        "properties": {
          "content": {
            "type": "string",
            "description": "The text content to be normalized"
          }
        }
      },
      "Configuration": {
        "type": "object",
        "properties": {
          "limit": {
            "type": "number",
            "description": "Maximum character length for normalized strings"
          },
          "friendly": {
            "type": "boolean",
            "description": "Whether to use word-boundary-aware trimming"
          }
        }
      }
    }
  }
]